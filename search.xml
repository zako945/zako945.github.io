<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>33. Search in Rotated Sorted Array</title>
      <link href="/post/search-in-rotated-sorted-array/"/>
      <url>/post/search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">https://leetcode.cn/problems/search-in-rotated-sorted-array/</a></strong></p><p><strong>題意</strong>: 有一整數 array <code>nums</code> 按升序排列, 其中的值<strong>互不相同</strong>。</p><p>給一<strong>旋轉後</strong>的 array <code>nums</code> 和一整數 <code>target</code>, 如果 <code>nums</code> 中存在 <code>target</code>, 則返回其 index; 否則, 返回 <code>-1</code>。</p><p>請設計 $O(log(n))$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/oxWfuYg.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 將 <code>nums</code> 從中間分開成左右兩部分的時候, 一定有一部分是有序的。</strong></p><p><strong>e.g. <code>nums = [4,5,6,7,0,1,2]</code>, 從 <code>6</code> 切割, 可分成 <code>[4,5,6]</code> 和 <code>[7,0,1,2]</code> 兩個部分, 其中左邊 <code>[4,5,6]</code> 是有序的</strong></p><p>因此我們可以在 Binary Search 時查看當前 <code>mid</code> 分割的兩個部分 <code>[left, mid]</code> 和 <code>[mid + 1, right]</code> 中哪個是有序的, 藉此來縮小左邊界 or 右邊界。</p><ul><li>若 <code>target == nums[mid]</code>, 則直接返回 <code>mid</code></li><li>若 <code>[left, mid]</code> 是有序的, 且 <code>target</code> 界於 <strong><code>[nums[left], nums[mid])</code></strong> 間, 則縮小搜索範圍為 <code>[left, mid - 1]</code>; 否則, 縮小搜索範圍為 <code>[mid + 1, right]</code></li><li>若 <code>[mid + 1, right]</code> 是有序的, 且 <code>target</code> 界於 <strong><code>(nums[mid], nums[right]]</code></strong> 間, 則縮小搜索範圍為 <code>[mid + 1, right]</code>; 否則, 縮小搜索範圍為 <code>[left, mid - 1]</code></li></ul><p>當 <code>[left, mid]</code> 區間恰好只有一個元素時, 也滿足左半邊已排序的定義</p><p>e.g. <code>nums = [3, 1]</code>, <code>target = 1</code></p><ul><li><code>left = 0</code>, <code>right = 1</code>, <code>mid = 0</code> ➔ <code>[left, mid]</code> 區間恰好只有一個元素, 使得 <code>nums[left] == nums[mid]</code>, 這時 <code>target</code> 應跟左半邊中的元素比較, 然後才縮小邊界</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 這種特殊的 Binary Search 建議搜到就返回</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左半邊是被排序過的, e.g. [4,5,6,7,0,1,2], mid = 7</span></span><br><span class="line">            <span class="comment">// nums[left] == nums[mid] 也滿足左半邊是排序的定義（有可能 left == mid）</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 因為 target != nums[mid], 故用 &lt; 即可</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右半邊是被排序過的, e.g. [7,0,1,2,4,5,6], mid = 2</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>981. Time Based Key-Value Store</title>
      <link href="/post/time-based-key-value-store/"/>
      <url>/post/time-based-key-value-store/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/time-based-key-value-store/">https://leetcode.cn/problems/time-based-key-value-store/</a></strong></p><p><strong>題意：</strong>設計一個基於時間的 key-value 的資料結構, 它可以在不同 timestamp 儲存對應同一個 key 的多個值, 並針對特定 timestamp 得到相對應的 key 的 value。</p><p>實作 <code>TimeMap</code> class：</p><ul><li><code>TimeMap()</code> : 初始化 instance</li><li><code>void set(String key, String value, int timestamp)</code> : 儲存 <code>key</code>、 <code>value</code>, 以及 <code>timestamp</code>。</li><li><code>String get(String key, int timestamp)</code> :<ul><li>返回 <code>timestamp_prev</code> 對應的 value, 其中 <code>timestamp_prev &lt;= timestamp</code></li><li>如果存在多個值, 則返回對應<strong>最大</strong>的 <code>timestamp_prev</code> 的 value。</li><li>如果不存在, 則返回 <code>&quot;&quot;</code>。</li></ul></li></ul><p><strong>注意:</strong> <code>set(key, value, timestamp)</code> 中的 <code>timestamp</code> 都是嚴格遞增的。</p></blockquote><p><img src="https://i.imgur.com/9V7VWMN.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：題目的意思如下圖, <code>key</code> 裡面會儲存 <code>values</code>, 而 <code>values</code> 裡面可以有多個 <code>&#123;value, timestmap&#125;</code> pair。由於 <code>values</code> 裡面的 <code>timestamp</code> 都是嚴格遞增的(已排序), 所以我們可直接使用 Binary Search</strong></p></blockquote><p><img src="https://i.imgur.com/PdkaQmt.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeMap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeMap</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(string key, string value, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        m[key].<span class="built_in">emplace_back</span>(pair&lt;string, <span class="type">int</span>&gt;&#123;value, timestamp&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(string key, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">find</span>(key) == m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = m[key].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m[key][mid].second &gt; timestamp) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left 為 &gt; timestamp 的位置, 故 left - 1 為 &lt;= timestamp 的位置</span></span><br><span class="line">        <span class="keyword">return</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span>) ? m[key][left - <span class="number">1</span>].first : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt;&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search, 其中 <code>n</code> 為 <code>m[key]</code> 的長度</li><li><strong>space：</strong>$O(n)$ ➔ 其中 <code>n</code> 為 <code>set()</code> 的次數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/post/add-two-numbers/"/>
      <url>/post/add-two-numbers/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></strong></p><p><strong>題意</strong>：給兩個<strong>非空</strong> linked list 表示兩個非負整數, 每位數字都是按照<strong>逆序</strong>（e.g. 個位數在前, 十位數在後）儲存的, 且每一個 node 只能存一位數字。請將兩數相加, 並以相同型式返回和的 linked list。</p><p>除了數字 0 以外, 其他數字都不會以 0 作為開頭。</p></blockquote><p><img src="https://i.imgur.com/ICc2d6B.png"></p><p><img src="https://i.imgur.com/9nnmNaL.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution</strong>：</h2><blockquote><p><strong>想法：用 dummy 記住新的 linked list 開頭, tail 用來更新新的 linked list 之尾端。除此之外, 還要考慮進位(carry bit)和以下特殊情況</strong>：</p><ul><li><p><strong>兩個整數長度不一（e.g. <code>123</code> + <code>4567</code>）</strong><br>➔ 當 <code>node</code> 為 <code>NULL</code> 時, 把 <code>node-&gt;val</code> 設為 <code>0</code></p></li><li><p><strong>進位導致輸出比原本最長整數還長（e.g. <code>1</code> + <code>99</code> &#x3D; <code>100</code>）</strong><br>➔ loop 終止條件須判斷 carry bit 是否為 0</p><p>  <img src="https://i.imgur.com/atRCQf4.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *tail = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 ptr, 若 ptr 為 null, 則不能用 ptr-&gt;next, 而是直接設成 null</span></span><br><span class="line">            l1 = l1 ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(max(m,n))$ ➔ while loop 終止是取決最長的 linked list 長度</li><li><strong>space：</strong>$O(max(m,n))$ ➔ 新的 linked list 長度取決於最長的 linked list 長度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138. Copy List with Random Pointer</title>
      <link href="/post/copy-list-with-random-pointer/"/>
      <url>/post/copy-list-with-random-pointer/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></strong></p><p><strong>題意：</strong>給一長度為 <code>n</code> 的 linked list, 每個節點包含一個額外增加的隨機 pointer <code>random</code>, 該 pointer 可以指向 linked list 中的任何節點 or 空節點。</p><p>建構該 linked list 的 deep copy, 它由 <code>n</code> 個新節點組成, 其中每個新節點的值都設為其對應的 <code>node.val</code>。</p><p>新節點的 <code>next</code> 和 <code>random</code> 也都應指向新 linked list 中的其他節點, 使原 linked list 和新 linked list 能夠表示成相同的 linked list。</p><p>e.g. 如果原 linked list 中有 <code>X</code> 和 <code>Y</code> 兩個節點, 其中 <code>X.random --&gt; Y</code>。則新 linked list 中對應的兩個節點 <code>x</code> 和 <code>y</code>, 同樣有 <code>x.random --&gt; y</code>。</p><p>返回新 linked list 的 <code>head</code>。</p></blockquote><p><img src="https://i.imgur.com/pfPzZ9u.png"></p><p><img src="https://i.imgur.com/a0gJl5X.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table, 先遍歷原 linked list, 並在遍歷的同時不斷創建新節點, 將 <code>原節點</code> 作為 <code>key</code>、<code>新節點</code> 作為 <code>value</code> 放入 hash table 中。最後, 再遍歷一次原 linked list, 並設置新 linked list 的 <code>next</code> 和 <code>random</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        Node *cur = head;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; oldToNew; <span class="comment">// &#123;old, new&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            oldToNew[cur] = newNode;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            oldToNew[cur]-&gt;next = oldToNew[cur-&gt;next];</span><br><span class="line">            oldToNew[cur]-&gt;random = oldToNew[cur-&gt;random];</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldToNew[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list</li><li><strong>space：</strong>$O(n)$ ➔ <code>oldToNew</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：分成三個步驟</strong></p><ul><li>根據遍歷到的原節點來創建對應的新節點, 並把每個新節點放在原節點後面<br>e.g. <code>1 -&gt; 1&#39; -&gt; 2 -&gt; 2&#39; -&gt; 3 -&gt; 3&#39;</code></li><li>設置新節點的 <code>random</code><br>➔ 新節點的 <code>random</code> 為原節點的 <code>random-&gt;next</code> (原 <code>random</code> 對應的新節點)</li><li>將兩個 linked list 分開</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根據遍歷到的原節點來創建對應的新節點, 並把每個新節點放在原節點後面</span></span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            newNode-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            cur = newNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 設置新節點的 random</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="comment">// 不用判斷 cur-&gt;next 是否為 null, 是因為 cur 為原 linked list 的節點</span></span><br><span class="line">            <span class="comment">// cur-&gt;next 為對應的新節點, 在 cur != null 的前提下, cur-&gt;next 必不為 null</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;random) &#123;</span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將兩個 linked list 分開</span></span><br><span class="line">        cur = head;</span><br><span class="line">        Node *dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>), *tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            tail-&gt;next = cur-&gt;next; <span class="comment">// 將新節點加到新 linked list</span></span><br><span class="line">            tail = tail-&gt;next; <span class="comment">// 更新 tail</span></span><br><span class="line">            cur-&gt;next = tail-&gt;next; <span class="comment">// 將 cur 指向下一個原 linked list 的 node</span></span><br><span class="line">            cur = cur-&gt;next; <span class="comment">// 將 cur 更新成下一個原 linked list 的 node</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要 copy 的 node, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>287. Find the Duplicate Number</title>
      <link href="/post/find-the-duplicate-number/"/>
      <url>/post/find-the-duplicate-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-the-duplicate-number/">https://leetcode.cn/problems/find-the-duplicate-number/</a></strong></p><p><strong>題意</strong>：給一有 <code>n + 1</code> 個數的 array <code>nums</code>, 每個元素值皆在 <code>[1, n]</code>, 剛好<strong>只有一數字重複</strong>, 求重複的數字。</p><p><strong>注意</strong>：只能使用 $O(1)$ space, 且<strong>不能改變</strong> <code>nums</code></p><p><strong>進階</strong>：設計 $O(n)$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/GNc82JD.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1</strong>：</h2><blockquote><p><strong>想法：利用 Binary Search, 先在 <code>[1, n]</code> 中找中點 <code>mid</code>, 然後判斷整個 <code>nums</code> 中 <code>≤ mid</code> 的元素個數 <code>cnt</code>。若 <code>cnt &gt; mid</code> 代表有重複, 則往左繼續找</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不要考慮 nums, 只需要考慮數字都在 1 到 n 之間</span><br><span class="line">nums = [1,3,4,2,2] 此時數字在 1 到 4 之間</span><br><span class="line"></span><br><span class="line">mid = (1 + 4) / 2 = 2, nums 中 ≤ 2 的有3個(1,2,2), 1到2中肯定有重複, 往左搜尋 ➔ right = 2</span><br><span class="line">mid = (1 + 2) / 2 = 1, nums 中 ≤ 1 的有1個(1), 2到2中肯定有重複, 往右搜尋</span><br><span class="line">➔ left = 2, left &lt; right 不成立</span><br><span class="line">➔ 所以重複的數是 2</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; mid) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$<ul><li>$O(log(n))$<strong>：</strong>Binary Search, while loop 得做 $O(log(n))$ 次</li><li>$O(n)$<strong>：</strong>while loop 每迭代一次, for loop 都得遍歷 <code>nums</code></li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：將此問題轉換成 linked list cyle, 利用 slow &amp; fast pointers 找出 cycle 的起點, 可參考 142. Linked List Cycle II</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [1,3,4,2,2]</span><br><span class="line"></span><br><span class="line">第一個 0 代表從 idx = 0 開始</span><br><span class="line">下一個移動到 nums[0] = 1</span><br><span class="line">下一個移動到 nums[1] = 3, 依此類推</span><br><span class="line">因為有重複數, 代表會有兩個數指向同一個數 e.g. nums[3] 和 nums[4] 都指向 nums[2] = 4</span><br><span class="line">0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2, cycle: 2-&gt;4-&gt;2</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/65xJ87D.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 slow 和 fast 相遇的點</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 cycle 的起點</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146. LRU Cache</title>
      <link href="/post/lru-cache/"/>
      <url>/post/lru-cache/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a></strong></p><p><strong>題意：</strong>設計並實現一個滿足 <strong>LRU（Least Recently Used）</strong>的資料結構。</p><p><strong>實現 <code>LRUCache</code> class：</strong></p><ul><li><code>LRUCache(int capacity)</code>：以 <code>capacity</code> 初始化 LRU cache 的大小。</li><li><code>int get(int key)</code>：若 <code>key</code> 存在於 cache 中, 則返回其對應的 <code>val</code>, 否則返回 <code>1</code>。</li><li><code>void put(int key, int value)</code>：<ul><li>若 <code>key</code> 已經存在, 則變更其 <code>value</code></li><li>若不存在, 則將該組 <code>key-value</code> insert 到 cache 中</li><li>若 insert 操作導致 pair 數量超過 <code>capacity</code>, 則移除最久未使用的 <code>key-value</code> pair</li></ul></li></ul><p><strong>注意：</strong><code>get()</code> 和 <code>put()</code> 必須是 $O(1)$ time</p></blockquote><p><img src="https://i.imgur.com/xxJOpVQ.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution</strong>：</h2><blockquote><p><strong>想法：利用 hash table + list, 其中 <code>cache</code> 用來存放所有的 <code>key</code>, 用來記錄哪個 <code>key</code> 最近被使用、最久沒被使用。用 list 而非 forward_list 的原因是：「當 <code>get()</code> 訪問的是處於中間位置的節點時, 可以直接獲取其前一個節點和後一個節點, 從而省去了遍歷整個 linked list的時間」。若用 forward_list, 要獲取前一個節點和後一個節點必須從 linked list 的 head 開始遍歷</strong></p><ul><li><code>cache.begin()</code> : 最久未用的 key</li><li><code>--cache.end()</code> : 最近使用的 key</li></ul><p><strong>而 <code>key2val</code> 和 <code>key2iter</code> 分別存放 <code>key</code> 所對應到的 <code>val</code> 和 <code>iterator</code></strong></p><ul><li><strong><code>get(key)</code> :</strong><ul><li>若 <code>key</code> 已在 <code>cache</code> 中, 則將其放到 <code>cache</code> 尾部</li><li>若 <code>key</code> 不在 <code>cache</code> 中, 則返回 <code>1</code></li></ul></li><li><strong><code>put(key, value)</code> :</strong><ul><li>若 <code>key</code> 已在 <code>cache</code> 中, 則更新其對應的 val</li><li>若 <code>key</code> 不在 <code>cache</code> 中, 則要新增該 key。若 <code>capacity</code> 已滿, 則要移除 <code>cache.begin()</code></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        capacity_ = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若 cache 已存在該 key, 則將其放到 cache 尾部</span></span><br><span class="line">        <span class="keyword">if</span> (key2val.<span class="built_in">find</span>(key) != key2val.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = key2val[key];</span><br><span class="line">            <span class="keyword">auto</span> it = key2iter[key];</span><br><span class="line">            cache.<span class="built_in">erase</span>(it);</span><br><span class="line">            cache.<span class="built_in">push_back</span>(key);</span><br><span class="line">            key2iter[key] = --cache.<span class="built_in">end</span>();</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// key not found</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cache 已存在該 key, 則更新其對應的 val</span></span><br><span class="line">        <span class="comment">// 直接調用 get(key), 若存在 key, 則 get 會將其放到 cache 尾端, 然後更新 val 即可</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(key) != <span class="number">-1</span>) &#123;</span><br><span class="line">            key2val[key] = value;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// key 已存在, 因此 put 後 size 不變, 不會超過 cap, 所以直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache 不存在該 key, 則要新增該 key</span></span><br><span class="line">        <span class="comment">// 若 cache 已滿, 則要先移除 cache.begin()</span></span><br><span class="line">        <span class="keyword">if</span> (key2val.<span class="built_in">size</span>() == capacity_) &#123;</span><br><span class="line">            <span class="type">int</span> keyDel = *cache.<span class="built_in">begin</span>();</span><br><span class="line">            cache.<span class="built_in">erase</span>(cache.<span class="built_in">begin</span>());</span><br><span class="line">            key2val.<span class="built_in">erase</span>(keyDel);</span><br><span class="line">            key2iter.<span class="built_in">erase</span>(keyDel);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cache.<span class="built_in">push_back</span>(key);</span><br><span class="line">        key2val[key] = value;</span><br><span class="line">        key2iter[key] = --cache.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity_;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; cache; <span class="comment">// 存放 &quot;key&quot; 的 list</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; key2val; <span class="comment">// &#123;key, val&#125;</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;::iterator&gt; key2iter; <span class="comment">// &#123;key, iterator&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$</li><li><strong>space：</strong>$O(capacity)$ ➔ <code>cache</code>, <code>key2val</code>, <code>key2iter</code> 的元素個數不超過 <code>capacity</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>235. Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="/post/lowest-common-ancestor-of-a-binary-search-tree/"/>
      <url>/post/lowest-common-ancestor-of-a-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></strong></p><p><strong>題意：</strong>給一 BT 和兩個節點 <code>p</code>, <code>q</code>, 求兩節點之<strong>最低共同祖先(LCA)</strong></p></blockquote><p><img src="https://i.imgur.com/aMLdW4p.png"></p><p><img src="https://i.imgur.com/wS3XAZv.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS 和 BST 的性質, 找到一 node 滿足 <code>node.val</code> 介於 <code>p</code>、<code>q</code> 之間</strong></p><ul><li><code>p-&gt;val ≤ node.val ≤ q-&gt;val</code> 或</li><li><code>q-&gt;val ≤ node.val ≤ p-&gt;val</code></li></ul><p><strong>BST 性質:</strong></p><ul><li><code>root</code> 左子樹中所有 <code>node.val</code> 皆小於 <code>root.val</code></li><li><code>root</code> 右子樹中所有 <code>node.val</code> 皆大於 <code>root.val</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123; <span class="comment">// 當前 root 太小</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123; <span class="comment">// 當前 root 太大</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 當前 root-&gt;val 介於 p、q 之間, 故返回 root</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, 遞迴深度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>143. Reorder List</title>
      <link href="/post/reorder-list/"/>
      <url>/post/reorder-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reorder-list/">https://leetcode.cn/problems/reorder-list/</a></strong></p><p><strong>題意：</strong>給一單向 linked list 的起始節點 <code>head</code>, 該 linked list 可表示為</p><p><code>L0 → L1 → … → Ln - 1 → Ln</code></p><p>將其重新排序為</p><p><code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code></p><p>不能只是單純改變節點內部的值, 必須進行實際的節點交換。</p></blockquote><p><img src="https://i.imgur.com/HgeYnkh.png"></p><p><img src="https://i.imgur.com/IblLtsI.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：分成以下步驟</strong></p><ul><li><strong>找到 linked list 的中點, 按照 <a href="https://zako945.github.io/post/linked-list-cycle/">141. Linked List Cycle</a> 的方法</strong><ul><li>奇數時, <code>mid</code> 指向中點</li><li>偶數時, <code>mid</code> 指向右中點</li><li>因此, 最一開始要先讓 <code>fast</code> 先走一步, 這樣不管是奇偶數, <code>mid</code> 都會指向左中點</li></ul></li><li><strong>重要：截斷兩個 list ➔ <code>mid-&gt;next = nullptr</code>（容易忘記這步）</strong></li><li><strong>reverse 右半部分 <code>Ln → Ln - 1 → Ln - 2 → ...</code></strong></li><li><strong>merge 左半和右半</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *mid = <span class="built_in">get_mid</span>(head); <span class="comment">// 得到第一個中點</span></span><br><span class="line">        ListNode *right = mid-&gt;next; <span class="comment">// 得到右半部分</span></span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// **重要** 截斷兩個 list</span></span><br><span class="line">        right = <span class="built_in">reverse</span>(right); <span class="comment">// reverse 右半部分</span></span><br><span class="line">        <span class="built_in">merge</span>(head, right); <span class="comment">// merge 左半和右半</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// // 找到中點; 若為偶數, 則返回第一個中點</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">get_mid</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先讓 fast 先走一步, 這樣偶數時, slow 才會是第一個中點</span></span><br><span class="line">        ListNode *slow = head, *fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *tail = head;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (tail) &#123;</span><br><span class="line">            nxt = tail-&gt;next;</span><br><span class="line">            tail-&gt;next = prev;</span><br><span class="line">            prev = tail;</span><br><span class="line">            tail = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="comment">// 先儲存各自的 next</span></span><br><span class="line">            ListNode *n1 = l1-&gt;next;</span><br><span class="line">            ListNode *n2 = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// l1 下一個指向當前的 l2, 然後 l2 下一個指向 n1</span></span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 各自前進到下一個</span></span><br><span class="line">            l1 = n1;</span><br><span class="line">            l2 = n2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/post/remove-nth-node-from-end-of-list/"/>
      <url>/post/remove-nth-node-from-end-of-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></strong></p><p><strong>題意：</strong>給一 linked list, 請刪除倒數第 <code>n</code> 個 node, 並返回 linked list 的 head。</p><p><strong>進階：</strong>試著用一次掃描就完成。</p></blockquote><p><img src="https://i.imgur.com/o9Lnn8T.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 slow &amp; fast pointers, 用 <code>dummy</code> 是因為有可能第一個 node 被刪, 所以需要有 ptr 指著第一個 node 的前一個 node。首先 <code>fast</code> 先從 head 走 <code>n</code> 步（讓 <code>fast</code> 領先）, 然後 <code>slow</code> 才從 <code>dummy</code> 開始往前走, 直到 <code>fast</code> 變成 <code>NULL</code></strong></p><ul><li><strong>為什麼 <code>fast</code> 是初始化為 <code>head</code>, 而 <code>slow</code> 初始化為 <code>dummy</code> ?</strong><br>因為若 <code>fast</code> 和 <code>slow</code> 都初始化為 <code>head</code>, 則當 <code>fast</code> 為 <code>NULL</code> 時, <code>slow</code> 恰好在倒數第 <code>n</code> 個 node(因為 <code>fast</code> 領先 <code>n</code> 步), 但是我們是要<strong>刪除</strong>倒數第 <code>n</code> 個 node, <strong>要取得的是倒數第 <code>n</code> 個 node 的前一個節點</strong>(倒數第 <code>n + 1</code> 的 node), 故讓 slow 在初始化時就慢 <code>fast</code> 一步, 讓 <code>fast</code> 領先 <code>n + 1</code> 步, 這樣 <code>slow</code> 最後才會是倒數第 <code>n + 1</code> 的 node</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *slow = dummy, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(L)$ ➔ 遍歷 linked list, 其中 <code>L</code> 為 linked list 的長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/post/trapping-rain-water/"/>
      <url>/post/trapping-rain-water/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></strong></p><p><strong>題意：</strong>給 <code>n</code> 個非負整數, 代表每個寬度為 <code>1</code> 的柱子之高度圖, 計算按此排列的柱子, 在下雨後能接多少雨水。</p></blockquote><p><img src="https://i.imgur.com/YA2gsx4.png" alt="Untitled"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用暴力法, 我們計算每個 col 所能接住的水量, 因此對於每個 <code>i</code> 我們要在 <code>height[0 ~ i]</code> 和 <code>height[i ~ (n - 1)]</code> 中分別找出最大值 <code>leftMax</code> 和 <code>rightMax</code>, 則該 col 所能接住的水量 &#x3D; <code>min(leftMax, rightMax) - height[i]</code></strong></p><p><img src="https://i.imgur.com/uRPc5KE.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = height.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> leftMax = *<span class="built_in">max_element</span>(it, it + i + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> rightMax = *<span class="built_in">max_element</span>(it + i, it + n);</span><br><span class="line">            res += <span class="built_in">min</span>(leftMax, rightMax) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 每計算一次需找出 <code>leftMax</code> 和 <code>rightMax</code>, 此過程需 $O(n)$, 總共要計算 <code>n</code> 次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 概念同 Solution 1, 只是我們用兩個 array <code>leftMax</code> 和 <code>rightMax</code> 來記錄, 其中 <code>leftMax[i]</code> 和 <code>rightMax[i]</code> 分別代表 <code>height[0 ~ i]</code> 和 <code>height[(n - 1) ~ i]</code> 之最大值</strong></p><ul><li>由左往右遍歷 <code>height</code> 得到每一個 <code>leftMax[i]</code></li><li>由右往左遍歷 <code>height</code> 得到每一個 <code>rightMax[i]</code></li><li>最後計算每個 col 所能接住的雨水</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(n, height.front())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(n, height.back())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            leftMax[i] = <span class="built_in">max</span>(height[i], leftMax[i - <span class="number">1</span>]);</span><br><span class="line">            rightMax[n - <span class="number">1</span> - i] = <span class="built_in">max</span>(height[n - <span class="number">1</span> - i], rightMax[n - i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res += <span class="built_in">min</span>(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>leftMax</code>, <code>rightMax</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers, 改進 Solution 2, 因為 <code>leftMax[i]</code> 和 <code>rightMax[i]</code> 只會用到一次, 然後就再也不會用到了, 因此我們用一個變數記住即可。我們定義以下變數：</strong></p><ul><li><code>leftMax</code>：左邊的最大值, 它是由左往右遍歷得到的</li><li><code>rightMax</code>：右邊的最大值, 它是由右往左遍歷得到的</li><li><code>left</code>：由左往右處理的當前 idx</li><li><code>right</code>：由右往左處理的當前 idx</li></ul><p><strong>我們有以下定理可使用：</strong></p><ul><li><p><strong>定理一</strong>：在 <code>idx = i</code> 時能接住的水量是取決於左右兩邊的最大值中<strong>較小</strong>的那一個</p></li><li><p><strong>定理二</strong>：</p><ul><li>當我們由左往右處理到 <code>left</code> 時, 左邊的最大值 <code>leftMax</code> 對它而言是可信的, 但 <code>rightMax</code> 對它而言是不可信的</li><li>當我們由右往左處理到 <code>right</code> 時, 右邊的最大值 <code>rightMax</code> 對它而言是可信的, 但 <code>leftMax</code> 對它而言是不可信的</li></ul><p>  <img src="https://i.imgur.com/qwYcmK4.png" alt="Untitled"></p></li></ul><p><strong>由上述定理, 我們可以得到：</strong></p><ul><li>對於 <code>left</code> 而言, 它左邊最大值一定是 <code>leftMax</code>, 就算 <code>右邊實際最大值 ≥ rightMax</code>, 只要 <code>leftMax &lt; rightMax</code> 成立, 就能知道 <code>left</code> 能接住多少水(<strong>定理一</strong>), 無論右邊將來是否會出現更大的 <code>rightMax</code>, 都不會影響到這個結果。反之, <code>right</code> 也是同樣道理。</li></ul><p><strong>while loop 的條件為何是 <code>left &lt;= right</code>, 而非 <code>left &lt; right</code> ?</strong></p><p>因為是先計算當前 ptr, 再移動 ptr 的</p><p>e.g. <code>height = [1, 0, 3]</code></p><ul><li>一開始 <code>leftMax(0) &lt; rightMax(0)</code> 不成立, 故處理 <code>right</code> ➔ 得 <code>rightMax = 3</code>, <code>res = 0</code>, <code>right = 1</code></li><li><code>leftMax(0) &lt; rightMax(3)</code> 成立, 故處理 <code>left</code> ➔ 得 <code>leftMax = 1</code>, <code>res = 0</code>, <code>left = 1</code></li><li>此時, <code>left = 1 = right</code>, 若 while loop 條件為 <code>left &lt; right</code>, 則無法計算到 <code>idx = 1</code> 位置的水量</li><li><code>leftMax(1) &lt; rightMax(3)</code>成立, 故處理 <code>left</code> ➔ 得 <code>leftMax = 1</code>, <code>res = 1</code>, <code>left = 2</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                leftMax = <span class="built_in">max</span>(leftMax, height[left]); <span class="comment">// 得到左邊最大值(含自身)</span></span><br><span class="line">                res += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightMax = <span class="built_in">max</span>(rightMax, height[right]); <span class="comment">// 得到右邊最大值(含自身)</span></span><br><span class="line">                res += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>height</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>739. Daily Temperatures</title>
      <link href="/post/daily-temperatures/"/>
      <url>/post/daily-temperatures/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></strong></p><p><strong>題意:</strong> 給一整數 array <code>temperatures</code> 代表每天的溫度。請返回 array <code>res</code>, 其中 <code>res[i]</code> 是指對於第 <code>i</code> 天, 下一個更高溫度是出現在幾天後。如果氣溫在這之後都不會升高, 則該位置用 <code>0</code> 來代替。</p></blockquote><p><img src="https://i.imgur.com/NEFqBSZ.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack, 使用 Monotonic（遞減） Stack <code>stk</code> 紀錄 <code>&#123;temperature, idx&#125;</code>, 一旦當前溫度 <code>temperatures[i]</code> 比 <code>stk.top().first</code> 還高, 則不斷將 <code>stk.top()</code> 取出, 並計算 <code>res[idx]</code>, 直到 <code>stk.top().first &gt; temperatures[i]</code> 才把 <code>temperatures[i]</code> push 到 <code>stk</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 若最後 stk 不為空, 則剩餘元素的 res[idx] 皆為 0</span></span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; stk; <span class="comment">// &#123;temperature, idx&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 一旦當前溫度 &gt; top, 則不斷將 top 給 pop 掉, 並計算 res[idx]</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; stk.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [temperature, idx] = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                res[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">emplace</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&#123;temperatures[i], i&#125;); <span class="comment">// push 當前元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>853. Car Fleet</title>
      <link href="/post/car-fleet/"/>
      <url>/post/car-fleet/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/car-fleet/">https://leetcode.cn/problems/car-fleet/</a></strong></p><p><strong>題意:</strong> 在一條單行道上, 有 <code>n</code> 輛車開往同一目的地, 目的地是幾英里外的 <code>target</code>。</p><p>給兩個整數 array <code>position</code>、<code>speed</code>, 其中 <code>position[i]</code> 是第 <code>i</code> 輛車的位置, <code>speed[i]</code> 是第 <code>i</code> 輛車的時速(英里&#x2F;小時)。</p><p>一輛車永遠不會超過前面的另一輛車, 但它可以追上去, 並與前車<strong>以相同的速度</strong>緊接著行駛。此時, 我們可忽略這兩輛車之間的距離, 也就是說, 它們被假定處於相同的位置。</p><p><strong>車隊</strong>是一些由行駛在相同位置、具有相同速度的車組成的非空集合。注意, 一輛車也可以是一個車隊。</p><p>即便一輛車在目的地才趕上了一個車隊, 它們仍然會被視作是同一個車隊。</p><p>返回到達目的地的<strong>車隊數量</strong>。</p></blockquote><p><img src="https://i.imgur.com/A0EImP6.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Monotonic（遞減） Stack, 先使用 map 根據 <code>position[i]</code> 「由小到大」排序, 然後依序取出, 並計算 <code>position[i]</code> 到 <code>target</code> 所需的時間。如果當前所需的時間 <code>time ≥ stk.top()</code>, 則代表兩車會合併為一個車隊, 因為離 <code>target</code> 較遠的那輛車所需的時間 <code>stk.top()</code> 較短, 但是道路為單向且不能超車。所以最後抵達 <code>target</code> 的時間會受制於 <code>time</code>。所以一旦 <code>time ≥ stk.top()</code> 就要 <code>stk.pop()</code>, 將兩輛車合併為一個車隊（受限於當前 <code>time</code> 的車隊）, 直到 <code>stk.top() &gt; time</code>, 才能將 <code>time</code> push 到 <code>stk</code> 中。最後, <code>stk</code> 中的元素個數即為車隊數量。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">carFleet</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; position, vector&lt;<span class="type">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ps;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; position.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ps[position[i]] = speed[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">float</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [pos, spd] : ps) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">float</span> time = <span class="built_in">float</span>(target - pos) / spd;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; time &gt;= stk.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">emplace</span>(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>74. Search a 2D Matrix</title>
      <link href="/post/search-a-2d-matrix/"/>
      <url>/post/search-a-2d-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></strong></p><p><strong>題意</strong>: 設計一高效演算法來搜索 <code>m x n</code> matrix 中是否存在整數 <code>target</code>, matrix 滿足以下特性:</p><ul><li>每列的元素由左到右按升序排列</li><li>每列的第一個元素 &gt; 前一列的最後一個元素</li></ul></blockquote><p><img src="https://i.imgur.com/1iXww8t.png"></p><p><img src="https://i.imgur.com/PJveiV8.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, <code>matrix</code> 其實就是 1D 已排序的 array, 只是改成用 2D array 表達而已, 故將 <code>matrix</code> 看成 1D array, 然後還原回 2D array 座標來做 Binary Search</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matrix[mid / n][mid % n] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left &lt; m * n &amp;&amp; matrix[left / n][left % n] == target) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(mn))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>875. Koko Eating Bananas</title>
      <link href="/post/koko-eating-bananas/"/>
      <url>/post/koko-eating-bananas/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/koko-eating-bananas/">https://leetcode.cn/problems/koko-eating-bananas/</a></strong></p><p><strong>題意:</strong> Koko 喜歡吃香蕉。這里有 <code>n</code> 堆香蕉, 第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警衛已經離開了, 並且將在 <code>h</code> 小時後回來。</p><p>Koko 可以決定她吃香蕉的速度 <code>k</code> （單位：根 &#x2F; 小時）。每個小時, 她將會選擇其中一堆的香蕉, 並從中吃掉 <code>k</code> 根。如果這堆香蕉少於 <code>k</code> 根, 她將吃掉這堆所有的香蕉, 然後這一小時內都不會再吃更多的香蕉。  </p><p>Koko 喜歡慢慢吃, 但仍然想在警衛回來前吃掉所有的香蕉。</p><p>返回她可以在 <code>h</code> 小時內吃掉所有香蕉的最小速度 <code>k</code>, 其中 <code>k</code> 為整數。</p></blockquote><p><img src="https://i.imgur.com/8vBcc5O.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 其中 <code>k</code> 的區間為 <code>[1,  max(piles)]</code>, 因為 Koko 吃掉該堆所有的香蕉後, 這一小時內都不會再吃更多的香蕉, 所以 <code>k</code> 取到 <code>max(piles)</code> 即可。此外, <code>left</code> 不能為 <code>0</code>, 否則 <code>mid</code> 有可能為 <code>0</code>, 這會導致計算 <code>time += ceil(1.0 * pile / mid)</code> 時發生錯誤</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = *<span class="built_in">max_element</span>(piles.<span class="built_in">begin</span>(), piles.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// speed</span></span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> cost = <span class="number">0</span>; <span class="comment">// 加總有可能會 overflow, 故取 long</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; pile : piles) &#123;</span><br><span class="line">                cost += <span class="built_in">ceil</span>(<span class="number">1.0</span> * pile / mid); <span class="comment">// 先轉成 float 再運算, 最後取 ceiling</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cost &lt;= h) &#123; <span class="comment">// 速度過快, 往左區間繼續搜尋</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(m))$ ➔ 其中 <code>n</code> 為 <code>piles</code> 的長度, <code>m</code> 為 <code>piles</code> 中的最大值<ul><li>$O(log(m))$ : Binary Search 的次數</li><li>$O(n \cdot log(m))$ : 每一次 Binary Search 皆須 $O(n)$, 因為計算出 mid 後, 皆須遍歷 <code>piles</code></li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>153. Find Minimum in Rotated Sorted Array</title>
      <link href="/post/find-minimum-in-rotated-sorted-array/"/>
      <url>/post/find-minimum-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/</a></strong></p><p><strong>題意</strong>: 給一長度為 <code>n</code> 的 array, 已照升序排列, 經過 1 到 <code>n</code> 次旋轉後得到 input array。</p><p>e.g. <code>nums = [0,1,2,4,5,6,7]</code> 經過變化後可得到:</p><ul><li>若旋轉 <code>4</code> 次, 可得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋轉 <code>7</code> 次, 可得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>給一元素互不相同的 array <code>nums</code>, 已照升序排列, 並進行多次旋轉, 返回 <code>nums</code> 中最小的元素。</p><p><strong>注意</strong>: 請設計 $O(log(n))$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/gSIGk6B.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 根據比較左、中、右三個位置的值來縮小左邊界 or 右邊界, 有以下幾種情況：</strong></p><ul><li><strong>(左 &lt; 中) 且 (中 &lt; 右)</strong>, e.g. <code>[1,2,3,4,5]</code>。代表<strong>沒有旋轉</strong> ➔ min 在左半邊, 故縮小<strong>右</strong>邊界。</li><li><strong>(左 &gt; 中) 且 (中 &lt; 右)</strong>, e.g. <code>[5,1,2,3,4]</code>。代表<strong>有旋轉</strong> ➔ min 在左半邊, 故縮小<strong>右</strong>邊界</li><li><strong>(左 &lt; 中) 且 (中 &gt; 右)</strong>, e.g. <code>[2,3,4,5,1]</code>。代表<strong>有旋轉</strong> ➔ min 在右半邊, 故縮小<strong>左</strong>邊界</li><li><strong>(左 &gt; 中) 且 (中 &gt; 右)</strong>, e.g. <code>[5,4,3,2,1]</code>。單調遞減, 本題不可能出現此種情形, 因為遞增的 array 再怎麼轉也不可能變遞減的</li></ul><p>分析前面三種可能的情況, 我們選擇比較<strong>中、右</strong></p><p>➔ 因為這樣可將情況 1、2 是視作一類（中 &lt; 右, 縮小右邊界）, 而情況 3 視作另一類（中 &gt; 右, 縮小左邊界）</p><p><img src="https://i.imgur.com/uuP4Hbh.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>]; <span class="comment">// 初始值設 array 的第一個元素</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            res = <span class="built_in">min</span>(res, nums[mid]); <span class="comment">// 更新最小值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>637. Average of Levels in Binary Tree</title>
      <link href="/post/average-of-levels-in-binary-tree/"/>
      <url>/post/average-of-levels-in-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 Binary Tree(BT), 計算每一層的平均值。</p></blockquote><p><img src="https://i.imgur.com/I7IRJWJ.png" alt="Untitled"></p><p><img src="https://i.imgur.com/cZP2nAa.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於樹的高度, worse case 為 skew tree, tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/post/3sum/"/>
      <url>/post/3sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 返回 <code>nums</code> 是否存在 <code>[nums[i], nums[j], nums[k]]</code>, 使得 <code>nums[i] + nums[j] + nums[k] == 0</code>, 其中 <code>i != j</code>, <code>i != k</code> 且 <code>j != k</code>。</p><p><strong>注意：</strong>答案中不可包含重複的 tuple。</p></blockquote><p><img src="https://i.imgur.com/yeEmHb3.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers</strong></p><ul><li><p>首先, 將 <code>nums</code> 由小到大做<strong>排序</strong></p><ul><li>用來避免取重複的 tuple, 並可使用 two pointer 來移動 ptr</li></ul></li><li><p>用 <code>i</code> 遍歷 <code>index = [0, n - 3]</code>, 得到 <code>nums[i]</code></p><ul><li>為了避免第一次取到與上一輪相同的元素，我們需要在這裡進行一次判斷並跳過</li><li>使用 Two pointer <code>left = i + 1</code>, <code>right = n - 1</code> 尋找滿足條件的 pair</li><li>若 <code>sum &lt; 0</code> : 則 <code>left + 1</code></li><li>若 <code>sum &gt; 0</code> : 則 <code>right - 1</code></li><li>若 <code>sum == 0</code> : 則將 tuple 加入到 <code>res</code> 中，由於還要檢查剩餘的元素中是否有滿足條件的。因此在加入 tuple 後，<code>left</code> 和 <code>right</code> 都需要跳過與當前元素相同的值</li></ul></li><li><p>注意：答案中不可包含重複的 tuple</p><ul><li>對於第一個元素，我們在判斷時已經確保不會與上一輪相同</li><li>對於第二和第三個元素，在加入 <code>res</code> 後，我們繼續遍歷剩餘元素時，需要判斷是否與上一個元素相同，如果相同則跳過</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// skip duplicates for the second element</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// skip duplicates for the third element</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// move pointers to the next elements with different values</span></span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ $O(n \cdot log(n))$ + $O(n^2)$<ul><li>$O(n \cdot log(n))$ : 排序 <code>nums</code></li><li>$O(n^2)$ : for loop 需 $O(n)$, 其中每一個元素用 two ptr 遍歷剩餘元素需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮 output array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>844. Backspace String Compare</title>
      <link href="/post/backspace-string-compare/"/>
      <url>/post/backspace-string-compare/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/backspace-string-compare/">https://leetcode.cn/problems/backspace-string-compare/</a></strong></p><p><strong>題意：</strong>給兩個 string <code>s</code>, <code>t</code>, 其中的 <code>#</code> 代表 <code>退格(backspace)字元</code>, 求兩字串是否相等。</p></blockquote><p><img src="https://i.imgur.com/DvHelFY.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 two pointers, 其中 <code>slowindex</code> 負責 in-place 記錄新的 string, 而 <code>fastindex</code> 負責遍歷整個 string</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(s) == <span class="built_in">build</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">string <span class="title">build</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> slowindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fastindex = <span class="number">0</span>; fastindex &lt; s.<span class="built_in">size</span>(); ++fastindex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[fastindex] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                slowindex = <span class="built_in">max</span>(<span class="number">0</span>, --slowindex);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s[slowindex++] = s[fastindex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(<span class="number">0</span>, slowindex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code>, 其中 m 為 <code>s</code> 之長度, <code>n</code> 為 <code>t</code> 之長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110. Balanced Binary Tree</title>
      <link href="/post/balanced-binary-tree/"/>
      <url>/post/balanced-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 判斷它是否 <strong>height-balanced</strong>。</p><p><strong>height-balanced 的定義：</strong>BT 中每個 node 的左、右子樹的高度差不超過 1。</p></blockquote><p><img src="https://i.imgur.com/iNX9uVN.png" alt="Untitled"></p><p><img src="https://i.imgur.com/jCJucay.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 如果當前 node 的左、右子樹的高度差不超過 1, 且左、右子樹皆為 height-balanced, 則返回 true</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span></span><br><span class="line">            &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 BT 中所有 node</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case : BT 為 skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link href="/post/best-time-to-buy-and-sell-stock/"/>
      <url>/post/best-time-to-buy-and-sell-stock/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></strong></p><p><strong>題意：</strong>給一 array <code>prices</code>, 從左到右分別是每天的股票價格, 求如何買賣可以獲得最大的利潤。</p><p><strong>注意：</strong>買入的天數必須在賣出的天數之前。</p></blockquote><p><img src="https://i.imgur.com/oGeonr9.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 紀錄前 <code>i - 1</code> 天的最大利潤、最小價格, 然後計算第 <code>i</code> 天的利潤並比較</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 紀錄前 (i - 1) 天的最大利潤</span></span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>];<span class="comment">// 紀錄前 (i - 1) 天的最小價格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - minPrice);</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>prices</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>704. Binary Search</title>
      <link href="/post/binary-search/"/>
      <url>/post/binary-search/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></strong></p><p><strong>題意：</strong>給一已排序的整數 array <code>nums</code>, 用 binary search 找出 <code>nums</code> 中是否存在 <code>target</code>。若存在, 則返回該元素的 idx；否則, 返回 <code>-1</code>。</p></blockquote><p><img src="https://i.imgur.com/ZzNPVSo.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 找到 left 為第一個 <code>≥ target</code> 的數。若 <code>left</code> 越界 or <code>nums[left] != target</code>, 則代表 <code>target</code> 不存在於 <code>nums</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 當 nums 中所有的元素都比 target 小 (target 不存在), left 會越界 (left = n)</span></span><br><span class="line">        <span class="comment">// 所以在存取 nums[left] 前, 要先判斷 left 是否越界, 否則存取會出錯</span></span><br><span class="line">        <span class="keyword">return</span> (left &lt; n &amp;&amp; nums[left] == target) ? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70. Climbing Stairs</title>
      <link href="/post/climbing-stairs/"/>
      <url>/post/climbing-stairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></strong></p><p><strong>題意：</strong>今天有 <code>n</code> 階樓梯要爬, 每一次你可以選擇要爬 1階 or 2階, 求總共有幾種不同的爬法。</p></blockquote><p><img src="https://i.imgur.com/345Jp3i.png" alt="Untitled"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用遞迴求解</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>time complexity 證明：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(n) = <span class="built_in">T</span>(n - <span class="number">1</span>) + <span class="built_in">T</span>(n - <span class="number">2</span>) + c</span><br><span class="line">     &lt;= <span class="number">2</span>T(n - <span class="number">1</span>) + c, 取 upper bound <span class="built_in">T</span>(n - <span class="number">2</span>) &lt;= <span class="built_in">T</span>(n - <span class="number">1</span>)</span><br><span class="line">      = <span class="number">2</span>*(<span class="number">2</span>T(n - <span class="number">2</span>) + <span class="number">1</span>) + (<span class="number">1</span> * c)</span><br><span class="line">      = <span class="number">4</span>T(n - <span class="number">2</span>) + (<span class="number">2</span> * c)</span><br><span class="line">      = <span class="number">8</span>T(n - <span class="number">3</span>) + (<span class="number">3</span> * c)</span><br><span class="line">      = <span class="number">2</span>^k * <span class="built_in">T</span>(n - k) + (<span class="number">2</span>^k * c)</span><br><span class="line"></span><br><span class="line">令 k = n , <span class="built_in">T</span>(<span class="number">0</span>) = <span class="number">1</span></span><br><span class="line"><span class="built_in">T</span>(n) &lt;= <span class="number">2</span>^n * <span class="built_in">T</span>(<span class="number">0</span>) + (<span class="number">2</span>^n * c)</span><br><span class="line">      = <span class="number">2</span>^n * (<span class="number">1</span> + c)</span><br></pre></td></tr></table></figure><ul><li><p><strong>time：</strong>$O(2^n)$</p></li><li><p><strong>space：</strong>$O(n)$ ➔ 受限於 tree 的深度, 下圖中可以看到 F(6) 的深度 &#x3D; 6 - 1 &#x3D; n - 1</p><p>  <img src="https://i.imgur.com/vaRiYvD.png" alt="Untitled"></p><p>  <strong>遞迴缺點：重複計算</strong>, e.g. 上圖中可看到 F(3) 被重複呼叫好幾次</p></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 紀錄 0, 1, 2, …, n 階的方法數, 用空間換取時間, 避免重複計算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, <code>dp[i] = dp[i - 1] + dp[i - 2]</code> 中 <code>dp[i]</code> 只會用到前兩步的方法數, 也就是說只需紀錄 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> 就好, 根本不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">1</span>; <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="type">int</span> two = <span class="number">1</span>; <span class="comment">// dp[i - 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> cur = one + two; <span class="comment">// dp[i]</span></span><br><span class="line">            two = one;</span><br><span class="line">            one = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/post/container-with-most-water/"/>
      <url>/post/container-with-most-water/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/container-with-most-water/">https://leetcode.cn/problems/container-with-most-water/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>height</code> 和一整數 <code>n</code>。有 <code>n</code> 條線其高度為 <code>height[i]</code>, 找出其中的兩條線，使得它們與 x 軸組成的容器可以容納最多的水。</p></blockquote><p><img src="https://i.imgur.com/9XQIlRp.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers</strong></p><ul><li>當前 area &#x3D; 兩條線中<strong>較短</strong>的高度 * 彼此間的距離</li><li><strong>移動較短</strong>那端的 ptr, 盡量保留較長的線</li></ul><p><strong>為何是移動較短那端的 ptr？</strong> 因為 area 是用<strong>下限</strong>計算的, 我們希望下限越高越好, 但是下限會受限於上限 ➔ 因此我們採取的策略為<strong>「維持上限、提升下限」</strong></p><p>e.g. <code>height = [1, 3, 5, 7]</code></p><ul><li><p>最一開始 <code>left = 0</code>, <code>right = 3</code> ➔ <code>nums[left] = 1</code>, <code>nums[right] = 7</code><br>此時 <code>area = min(1, 7) * (3 - 0) = 1 * 3 = 3</code></p><ul><li><p><strong>若移動 right</strong> : <code>left = 0</code>, <code>right = 2</code> ➔ <code>nums[left] = 1</code>, <code>nums[right] = 5</code><br>  此時 <code>area = min(1, 5) * (2 - 0) = 1 * 2 = 2</code> 反而更小了</p></li><li><p><strong>若移動 left</strong> : <code>left = 1</code>, <code>right = 3</code> ➔ <code>nums[left] = 3</code>, <code>nums[right] = 7</code><br>  此時 <code>area = min(3, 7) * (3 - 1) = 3 * 2 = 6</code></p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)  &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> area = <span class="built_in">min</span>(height[left], height[right]) * (right - left);</span><br><span class="line">            res = <span class="built_in">max</span>(res, area);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>height</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>217. Contains Duplicate</title>
      <link href="/post/contains-duplicate/"/>
      <url>/post/contains-duplicate/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/contains-duplicate/">https://leetcode.cn/problems/contains-duplicate/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 判斷當中是否有重複數字。</p></blockquote><p><img src="https://i.imgur.com/Er5lLKp.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先排序, 再用 loop 兩兩比較 <code>nums[i - 1]</code> 和 <code>nums[i]</code> 是否相等</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ sorting 後 data 仍儲存在 <code>nums</code> 中, 不需要額外空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 hash table 紀錄出現過的元素</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(num) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>s</code> 長度不超過 <code>n</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：比較 <code>nums</code> 和 <code>set(nums)</code> 長度是否相等, 若不相等代表有重複</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() != <span class="built_in">set</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()).<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 將 <code>nums</code> 轉成 <code>set(nums)</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>set(nums)</code> 長度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022. Convert 1D Array Into 2D Array</title>
      <link href="/post/convert-1d-array-into-2d-array/"/>
      <url>/post/convert-1d-array-into-2d-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/convert-1d-array-into-2d-array/">https://leetcode.cn/problems/convert-1d-array-into-2d-array/</a></strong></p><p><strong>題意：</strong>將 1d array <code>original</code> 轉成 <code>m</code> 列 <code>n</code> 行的 2d array。</p></blockquote><p><img src="https://i.imgur.com/Ys9chvQ.png" alt="Untitled"></p><p><img src="https://i.imgur.com/DMHTmAS.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：每次塞 <code>1 x n</code> 的 vector</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">construct2DArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; original, <span class="type">int</span> m, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m * n != original.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i += n)</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(original.<span class="built_in">begin</span>() + i, original.<span class="built_in">begin</span>() + i + n));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>original</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>338. Counting Bits</title>
      <link href="/post/counting-bits/"/>
      <url>/post/counting-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/counting-bits/">https://leetcode.cn/problems/counting-bits/</a></strong></p><p><strong>題意：</strong>給一整數 <code>n</code>, 對於 <code>0 ≤ i ≤ n</code> 中的每個 <code>i</code>, 計算其在二進制中 <code>1</code> 的個數, 返回一個長度為 <code>n + 1</code> 的 array 作為答案。</p></blockquote><p><img src="https://i.imgur.com/xLkiXO6.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：判斷 <code>i</code> 最靠右的 bit 是否為 <code>1</code>。若是的話, 則 <code>cnt++</code>, 每次判斷完後就將 <code>i</code> 右移一位, 直到 <code>i = 0</code>（沒有 1-bit）為止</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> val = i; val &gt; <span class="number">0</span>; val &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> rightmost = val &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(rightmost == <span class="number">1</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ $n * O(log(n))$<ul><li>$O(log(n))$ : <code>n</code> 右移 <code>1</code> 位等價 <code>n</code> 除以 <code>2</code>, 令 <code>k</code> 為右移次數, $\dfrac{n}{2^k} &#x3D; 1$ ➔ $k &#x3D; log(n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要返回的 array, 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 因為透過觀察發現：</strong></p><p><strong>1. 前一數（偶數）的 1 之個數 + 1, 因為偶數最右邊的 bit 必為 0, 奇數多的就是最右邊的 bit</strong></p><ul><li>e.g. 3 &#x3D; 011, 2 &#x3D; 010 ➔ 故 3 的 1 之個數 &#x3D; 2 的 1 之個數 + 1</li></ul><p><strong>2. 偶數的 1 之個數 &#x3D; （該數 &#x2F; 2） 的 1 之個數, 因為偶數最右邊的 bit 必為 0, 所以偶數往右移一位, 該數的 1 之個數並不會減少</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            dp[i] = (i &amp; <span class="number">1</span>) ? dp[i - <span class="number">1</span>] + <span class="number">1</span> : dp[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $n * O(1)$<ul><li><code>dp[i]</code> 都是去存取先前已計算過的 <code>dp[i-1]</code> 或 <code>dp[i &gt;&gt; 1]</code>, 故每一次計算 <code>dp[i]</code> 故只需花 $O(1)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>543. Diameter of Binary Tree</title>
      <link href="/post/diameter-of-binary-tree/"/>
      <url>/post/diameter-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求任兩點的 path 之最大長度。</p><ul><li>最大長度<strong>：</strong>最長 path 上的 <code>edge</code> 數</li></ul></blockquote><p><img src="https://i.imgur.com/NkrA6am.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, LP(node) 返回以 <code>node</code> 為 root 的 subtree 之最長路徑, 只有當前 node 可以同時使用左子樹和右子樹（由左至右分別是 1, 2, 1）, 也就是計算 <code>res</code> 時可用, 但返回時只能 return 單邊路徑。由於 path 不一定要經過 root, 因此可用 global 變數 <code>res</code> 來記錄最長 path 之長度</strong></p><p><img src="https://i.imgur.com/48fZdOl.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">LP</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LP</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">LP</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">LP</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        res = <span class="built_in">max</span>(res, left + right); <span class="comment">// 只有當前 root 可以同時使用左子樹和右子樹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right); <span class="comment">// 每個 node 都看成是轉折點, 只能返回單邊路徑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case：skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>271. Encode and Decode Strings</title>
      <link href="/post/encode-and-decode-strings/"/>
      <url>/post/encode-and-decode-strings/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/encode-and-decode-strings/">https://leetcode.cn/problems/encode-and-decode-strings/</a></strong></p><p><strong>題意：</strong>給一 string list <code>strs</code>, 請設計一演算法, 讓 encode 後的 string 可以透過網路高效傳輸, 並透過 decode 還原回原本的 string list。</p><p><strong>注意：</strong></p><ul><li>string 可能會包含所有的 ASCII char, 所以你設計的演算法要能處理任何可能出現的 char</li><li>請勿使用 <code>class member</code>、<code>global variable</code>、<code>static variable</code> 來儲存額外的狀態</li></ul></blockquote><p><img src="https://i.imgur.com/ftVLgXk.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：不能只在兩個 string 間只用一個分隔符 (delimiter) 隔開, 因為也有可能 input 中恰好有該分隔符組成的 string</strong></p><p>e.g. <code>delimiter = &#39;#&#39;</code>, <code>strs = [&#39;1&#39;, &#39;2#3&#39;]</code></p><p>這樣會得到錯誤的答案 <code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</code>, 而非 <code>[&#39;1&#39;, &#39;2#3&#39;]</code></p><p><strong>因此, 要額外紀錄每個 string 的長度：</strong></p><ul><li>Encode 時, 在每個 string <code>s</code> 前面加上長度 <code>s.size()</code> 和分割符 <code>#</code></li><li>Decode 時, 首先找出 idx <code>i</code> 往後的第一個 <code>#</code>, 假設其 idx 為 <code>j</code>, 則 <code>s[i, j)</code> 轉成 int 後即為 <code>s</code> 的長度。從 <code>j + 1</code> 往後(含)取 <code>s[i, j)</code> 個 char 即可得到當前的 <code>s</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a list of strings to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : strs) &#123;</span><br><span class="line">            ss &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;#&#x27;</span> &lt;&lt; s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a single string to a list of strings.</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">decode</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (s[j] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(i, j - i));</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(j + <span class="number">1</span>, len)); <span class="comment">// push 當前的 string</span></span><br><span class="line">            i = j + <span class="number">1</span> + len; <span class="comment">// 更新下一次開始的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><strong>encode：</strong>$O(n)$ ➔ <code>n</code> 為 <code>strs</code> 中所有 string 的總長度</li><li><strong>decode：</strong>$O(n)$ ➔ <code>n</code> 為 <code>s</code> 的長度</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 皆需要 $O(n)$ 來儲存原先所有的 string</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link href="/post/evaluate-reverse-polish-notation/"/>
      <url>/post/evaluate-reverse-polish-notation/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></strong></p><p><strong>題意：</strong>給一 postorder, 返回 inorder 的運算結果。</p><p>保證 postorder 運算式皆為有效的, 不會有除數為 <code>0</code> 的情況。</p></blockquote><p><img src="https://i.imgur.com/Fib7hlW.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack, 一旦當前 <code>token</code> 為數字, 則 push 到 stack 中; 否則, 取出 stack 中最上面的兩個 top 元素出來做運算, 並把運算結果 push 到 stack 中。重複以上步驟, 最後 stack 會剩下一個元素, 也就是最終的運算結果</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; token : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(token))</span><br><span class="line">                stk.<span class="built_in">emplace</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 注意順序</span></span><br><span class="line">                <span class="type">int</span> n2 = <span class="built_in">get_topNum</span>();</span><br><span class="line">                <span class="type">int</span> n1 = <span class="built_in">get_topNum</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span>(token[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 + n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 - n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(<span class="built_in">long</span>(n1) * <span class="built_in">long</span>(n2));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 / n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isdigit</span><span class="params">(string&amp; token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_topNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop, 其中 <code>n</code> 為 <code>token</code> 的個數</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>448. Find All Numbers Disappeared in an Array</title>
      <link href="/post/find-all-numbers-disappeared-in-an-array/"/>
      <url>/post/find-all-numbers-disappeared-in-an-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/</a></strong></p><p><strong>題意：</strong>原本有一包含 <code>[1, n]</code> 總共 <code>n</code> 個數的 array, 今給一個 <code>n</code> 個數的 array (含重複數) <code>nums</code>, 找出所有缺失的數。</p></blockquote><p><img src="https://i.imgur.com/uWoILtq.png" alt="Untitled"></p><hr><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將數字設為 負數 來標記我們看到的數字的 index, 然後遍歷 <code>nums</code> 元素, 若 <code>nums[i] &gt; 0</code>, 代表數字 <code>i + 1</code> 沒出現過</strong></p><p>e.g. <code>[1, 2, 2]</code> ➔ <code>[-1, -2, 2]</code>, 其中 <code>nums[0]</code> 紀錄數字 1 是否出現</p><p>因為數字 1 有出現, 所以 <code>nums[0]</code> 被設為負數, 依此類推</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 將數字設為負數來標記我們看到的數字的index</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除返回的 array, 且缺失 idx 都儲存在 <code>nums</code> 中, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>744. Find Smallest Letter Greater Than Target</title>
      <link href="/post/find-smallest-letter-greater-than-target/"/>
      <url>/post/find-smallest-letter-greater-than-target/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/">https://leetcode.cn/problems/find-smallest-letter-greater-than-target/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> char array <code>letters</code>, 在其中找到比 <code>target</code> 大的最小 char。</p><p><strong>注意：</strong><code>letters</code> 是循環的</p><ul><li>e.g. <code>target == &#39;z&#39;</code> 且 <code>letters == [&#39;a&#39;, &#39;b&#39;]</code>, 則返回 <code>&#39;a&#39;</code></li></ul></blockquote><p><img src="https://i.imgur.com/8BY6pKe.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 binary search</strong></p><ul><li><code>letters[mid] &gt; target</code> 時, 往左查找, 看是否有比 <code>mid</code> 更小的</li><li><code>letters[mid] &lt;= target</code> 時, 往右查找</li></ul><p>最後記得檢查是否 <code>&gt; target</code>, 如果不滿足(代表 <code>letters</code> 中沒有 <code>&gt; target</code> 的 char), 則返回 <code>letters[0]</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; letters, <span class="type">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = letters.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 避免 overflow</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &gt; target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[left] &gt; target ? letters[left] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. Generate Parentheses</title>
      <link href="/post/generate-parentheses/"/>
      <url>/post/generate-parentheses/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/generate-parentheses/">https://leetcode.cn/problems/generate-parentheses/</a></strong></p><p><strong>題意：</strong>數字 <code>n</code> 代表生成括號的對數, 生成所有可能的且<strong>有效的</strong>括號組合。</p></blockquote><p><img src="https://i.imgur.com/3fkGh4I.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p><ul><li><p>當 <code>左括號個數 &lt; n</code> 時, 可以加入左括號</p></li><li><p>當 <code>右括號個數 &lt; 左括號個數</code> 時, 可以加入右括號</p><p>  <img src="https://i.imgur.com/TmAGVht.png" alt="Untitled"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string cur;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>&amp; n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == n &amp;&amp; right == n)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)&#123;</span><br><span class="line">            cur += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(left + <span class="number">1</span>, right, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)&#123;</span><br><span class="line">            cur += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(left, right + <span class="number">1</span>, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(\dfrac{4^n}{n \sqrt n})$ ➔ 取決於第 <code>n</code> 個 Catalan number $\dfrac{1}{n+1} \left(\begin{array}{ccc} 2n \\ n \ \end{array} \right)$, 近似於 $O(\dfrac{4^n}{n \sqrt n})$<br><a href="https://math.stackexchange.com/questions/1986247/asymptotic-approximation-of-catalan-numbers">證明網址(不重要)</a></li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 array <code>res</code>, 取決於遞迴深度, 遞迴最大深度為 <code>2n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/post/group-anagrams/"/>
      <url>/post/group-anagrams/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a></strong></p><p><strong>題意：</strong>給一 string list <code>strs</code>, 其中 <code>strs[i]</code> 僅由小寫字母所組成, 將 <code>strs</code> 中的<strong>字母異位詞 (Anagram)</strong> 進行分組, 可按任意順序返回。</p><p><strong>字母異位詞 (Anagram) 定義 ：</strong>若 <code>s</code> 和 <code>t</code> 中每個字母的出現次數都相同, 則 <code>s</code> 和 <code>t</code> 互為字母異位詞。</p></blockquote><p><img src="https://i.imgur.com/EGOaFHh.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Sorting + hash table, 遍歷每個 string <code>s</code>, 並對其進行排序得到 string key, 將 <code>key</code> 和對應的 <code>s</code> 加入到 hash table 中。最後再根據 <code>key</code> 取出整個 group 即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : strs) &#123;</span><br><span class="line">            string key = s;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            groups[key].<span class="built_in">emplace_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, group] : groups) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(group);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot log(n))$ ➔ 其中 <code>m</code> 為 string 的個數, <code>n</code> 為 string 的平均長度。<ul><li>$O(n \cdot log(n))$：<code>s</code> 進行 sorting 的時間</li></ul></li><li><strong>space：</strong>$O(m \cdot n)$ ➔ hash table 中儲存所有的 string</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 hash table, 紀錄每個 string <code>s</code> 中每種 char 出現的頻率, 並把每種 char 的頻率當作是 key, 連同 <code>s</code> 一起加入到 hash table 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line">            <span class="function">string <span class="title">freqs</span><span class="params">(<span class="number">26</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>; <span class="comment">// 用 string 代替 vector 紀錄出現頻率</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : str) &#123;</span><br><span class="line">                freqs[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            groups[freqs].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [freq, group] : groups) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(group);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 所有 string 中每種 char 的出現頻率, 其中 <code>m</code> 為 <code>strs</code> 的元素個數, <code>n</code> 為 <code>strs[i]</code> 的平均長度</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>groups</code> 儲存所有的 string</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202. Happy Number</title>
      <link href="/post/happy-number/"/>
      <url>/post/happy-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></strong></p><p><strong>題意：</strong>判斷整數 <code>n</code> 是否為<strong>快樂數</strong>。</p><p><strong>快樂數</strong>的定義為<strong>：</strong></p><ul><li>對於一正整數, 每次將該數轉換為它每一位數的平方和</li><li>重複此步驟直到該數為 <code>1</code>, 也有可能進入無窮迴圈（始終無法變成 <code>1</code> ）</li><li>如果該數能變成 <code>1</code>, 則它就是快樂數</li></ul><p>若 <code>n</code> 為快樂數, 則返回 <code>true</code>; 否則, 返回 <code>false</code>。</p></blockquote><p><img src="https://i.imgur.com/1nDigjm.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table 來記錄出現過的數, 一旦重複出現, 代表會無限循環</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s&#123;n&#125;;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">            n = <span class="built_in">squareSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(n) != s.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.<span class="built_in">emplace</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ 令 <code>k</code> 為 <code>n</code> 除以 <code>10</code> 的次數, $\dfrac{n}{10^k} &#x3D; 1 ➔ k &#x3D; log(n)$</li><li><strong>space：</strong>$O(log(n))$ ➔ <code>s</code> 中儲存 $log(n)$ 次轉換後的元素</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：概念同 Solution 1, 只是改成利用 Two Pointers 來判斷是否出現重複的數, 可參考 <a href="https://zako945.github.io/post/linked-list-cycle/">141. Linked List Cycle</a>, <code>slow</code> 每次只轉換一次, 而 <code>fast</code> 每次轉換兩次</strong></p><ul><li>若存在循環（重複數）, 則 <code>slow</code> 和 <code>fast</code> 必相遇（<code>fast</code> 倒追 <code>slow</code>） ➔ <code>n</code> 不為快樂數</li><li>若不存在循環, 經過 <code>x</code> 步後 <code>fast</code> 必先變成 1, 然後再經過 <code>x</code> 步後 <code>slow</code> 才會接著變成 1</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="built_in">squareSum</span>(n);</span><br><span class="line">        <span class="type">int</span> fast = <span class="built_in">squareSum</span>(<span class="built_in">squareSum</span>(n));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = <span class="built_in">squareSum</span>(slow);</span><br><span class="line">            fast = <span class="built_in">squareSum</span>(<span class="built_in">squareSum</span>(fast));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ 令 <code>k</code> 為 <code>n</code> 除以 <code>10</code> 的次數, $\dfrac{n}{10^k} &#x3D; 1 ➔ k &#x3D; log(n)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1065. Index Pairs of a String</title>
      <link href="/post/index-pairs-of-a-string/"/>
      <url>/post/index-pairs-of-a-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/index-pairs-of-a-string/">https://leetcode.cn/problems/index-pairs-of-a-string/</a></strong></p><p><strong>題意：</strong>給一 string <code>text</code> 和 string list <code>words</code>, 求所有 <code>index pair</code> 使得 <code>text[i~j]</code> 出現在 <code>words</code> 中。</p></blockquote><p><img src="https://i.imgur.com/ITZF5on.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：暴力搜尋法</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">indexPairs</span>(string text, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="type">int</span> m = text.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordset</span><span class="params">(words.begin(), words.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>; start &lt; m; ++start) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> end = start; end &lt; m; ++end) &#123;</span><br><span class="line">                string cur = text.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(wordset.<span class="built_in">count</span>(cur))</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;start, end&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令總共有 <code>n</code> 個 word, 其中 $w_i$ 代表 <code>words[i]</code> 的長度, 且 text 之長度為 <code>m</code></p><ul><li><strong>time：</strong>$O(m^2 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ 因為 c++ 的 <strong><code>find()</code></strong> 不是用 <strong>KMP</strong> 實作的<ul><li>$O(m^2)$<strong>：</strong>每次以 <code>start</code> 為起點往後遍歷, 取 <code>text[start:end]</code> 然後去判斷是否在 <code>wordset</code> 中<ul><li>$m + (m-1) + (m-2) + … + 1$ &#x3D; $\dfrac{(m+1)\cdot m}{2}$</li></ul></li><li>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$<strong>：</strong>每次判斷 <code>text[start:end]</code> 是否在 <code>wordset</code> 中</li></ul></li><li><strong>space：</strong>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ <code>wordset</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Trie(prefix tree), 可參考 <a href="https://zako945.github.io/post/implement-trie-prefix-tree/">208. Implement Trie (Prefix Tree)</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> is_end = <span class="literal">false</span>; <span class="comment">// 預設每個 char 不為 end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : word)&#123;</span><br><span class="line">            <span class="type">int</span> i = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;children[i])</span><br><span class="line">                p-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            p = p-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;is_end = <span class="literal">true</span>; <span class="comment">// 將最後一個 char 設為 end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">search</span>(string text, vector&lt;string&gt;&amp; words)&#123;</span><br><span class="line">        <span class="type">int</span> m = text.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>; start &lt; m; ++start)&#123;</span><br><span class="line">            TrieNode *p = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> end = start; end &lt; m &amp;&amp; p != <span class="literal">nullptr</span>; ++end)&#123;</span><br><span class="line">                p = p-&gt;children[text[end] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(p &amp;&amp; p-&gt;is_end)</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;start, end&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">indexPairs</span>(string text, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        Trie trie;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; word : words)</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        <span class="keyword">return</span> trie.<span class="built_in">search</span>(text, words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令總共有 <code>n</code> 個 word, 其中 $w_i$ 代表 <code>words[i]</code> 的長度, 且 text 之長度為 <code>m</code></p><ul><li><strong>time：</strong>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i + m^2)$<ul><li>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$ : insert 所有 word 到 Trie 中</li><li>$O(m^2)$ : 每次以 <code>start</code> 為起點往後遍歷, 判斷 <code>text[start:end]</code> 是否在 Trie 中<ul><li>$m + (m-1) + (m-2) + … + 1 &#x3D;$ $\dfrac{(m+1)\cdot m}{2}$</li></ul></li></ul></li><li><strong>space：</strong>$O(26 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ worse case : 每個 word 的 <code>prefix</code> 皆不重覆<ul><li>總共 <code>n</code> 個 word, 每一個 word 有 $w_i$ 個 node, 而每個 node 又有 26 個 children</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>226. Invert Binary Tree</title>
      <link href="/post/invert-binary-tree/"/>
      <url>/post/invert-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 反轉其左右子樹。</p></blockquote><p><img src="https://i.imgur.com/0KPB1wQ.png" alt="Untitled"></p><p><img src="https://i.imgur.com/UQcx1Lg.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ worse case : skew tree, 遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(cur-&gt;left, cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>703. Kth Largest Element in a Stream</title>
      <link href="/post/kth-largest-element-in-a-stream/"/>
      <url>/post/kth-largest-element-in-a-stream/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">https://leetcode.cn/problems/kth-largest-element-in-a-stream/</a></strong></p><p><strong>題意：</strong>設計一個找到 stream 中第 <code>k</code> 大的元素。注意是排序後的第 <code>k</code> 大元素, 而非第 <code>k</code> 個不同的元素。</p><p><strong>實現 <code>KthLargest</code> class：</strong></p><ul><li><code>KthLargest(int k, int[] nums)</code>：使用 <code>k</code> 和 <code>nums</code> 來初始化 instance</li><li><code>int add(int val)</code>：將 <code>val</code> 加入倒 <code>nums</code> 中, 並返回第 <code>k</code> 大的元素</li></ul></blockquote><p><img src="https://i.imgur.com/wRrfh84.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution</strong>：</h2><blockquote><p><strong>想法：利用 Heap, 使用 min heap <code>pq</code> 來記錄前 <code>k</code> 大的元素, 其中 <code>pq.top()</code> 代表當前第 <code>k</code> 大的元素</strong></p><ul><li><code>KthLargest(k, nums)</code>：先 push <code>nums[i]</code>, 然後確認 <code>pq.size()</code> 是否 &gt; k。若是的話, 則把 <code>pq.top()</code> 給 pop 掉, 讓 <code>pq</code> 的元素個數維持在 <code>k</code> 個</li><li><code>add(val)</code>：先 push <code>val</code>, 然後確認 <code>pq.size()</code> 是否 <code>&gt; k</code>。若是的話, 則把 <code>pq.top()</code> 給 pop 掉, 讓 <code>pq</code> 的元素個數維持在 <code>k</code> 個</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        k_ = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            <span class="built_in">add</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k_)</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> k_;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>KthLargest(k, nums)</code>：$O(n \cdot log(k))$, 其中 <code>n</code> 為 <code>nums</code> 中的元素個數, 因為 heap 要 add &#x2F; delete 元素皆需花 $O(log(k))$ 來調整 heap</li><li><code>add(val)</code>：$O(log(k))$ ➔ heap 要 add &#x2F; delete 元素皆需花 $O(log(k))$ 來調整 heap</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ <code>pq</code> 中的元素不超過 <code>k + 1</code> 個</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1046. Last Stone Weight</title>
      <link href="/post/last-stone-weight/"/>
      <url>/post/last-stone-weight/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/last-stone-weight/">https://leetcode.cn/problems/last-stone-weight/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>stones</code>, 其中 <code>stones[i]</code> 代表第 <code>i</code> 塊石頭的重量。</p><p>每一回合取出最重的兩塊石頭, 並將其互相撞擊。假設石頭的重量分別為 <code>x</code>、<code>y</code>, 且 <code>x ≤ y</code>。則撞擊後的可能結果如下<strong>：</strong></p><ul><li>若 <code>x == y</code>, 則兩塊石頭都將完全粉碎</li><li>若 <code>x != y</code>, 則重量為 <code>x</code> 的石頭將完全粉碎, 而重量為 <code>y</code> 的石頭之新重量為 <code>y - x</code></li></ul><p>最後, 頂多剩下一塊石頭。若沒有石頭剩下, 則返回 <code>0</code>; 否則, 返回該石頭的重量。</p></blockquote><p><img src="https://i.imgur.com/tUYixRb.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap, 先將所有的元素 push 到 max heap <code>pq</code> 中, 再從 <code>pq</code> 中兩兩取出元素做運算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// max heap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; stone : stones)</span><br><span class="line">            pq.<span class="built_in">emplace</span>(stone);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> y = <span class="built_in">getTop</span>(pq);</span><br><span class="line">            <span class="keyword">auto</span> x = <span class="built_in">getTop</span>(pq);</span><br><span class="line">            pq.<span class="built_in">emplace</span>(y - x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">getTop</span><span class="params">(priority_queue&lt;T&gt;&amp; pq)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ 將所有的 stone push 到 <code>pq</code> 中、將所有 stone 取出來做運算, 其中 <code>n</code> 為 stone 的個數</li><li><strong>space：</strong>$O(n)$ ➔ <code>pq</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle</title>
      <link href="/post/linked-list-cycle/"/>
      <url>/post/linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></strong></p><p><strong>題意：</strong>判斷 linked list 中是否有 cycle。</p></blockquote><p><img src="https://i.imgur.com/Ylw08jF.png" alt="Untitled"></p><p><img src="https://i.imgur.com/m3WoSHi.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用兩個不同步長的 ptr, <code>slow</code> 每次只走一步, 而 <code>fast</code> 每次走兩步</strong></p><ul><li>若存在循環, 則 <code>slow</code> 和 <code>fast</code> 必相遇（<code>fast</code> 倒追 <code>slow</code>）</li><li>若不存在循環, <code>fast</code> 必先抵達 <code>nullptr</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷 fast, 因為若沒有 cycle, fast 會比較快抵達 nullptr</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 一次走一步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 一次走兩步</span></span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中的元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128. Longest Consecutive Sequence</title>
      <link href="/post/longest-consecutive-sequence/"/>
      <url>/post/longest-consecutive-sequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></strong></p><p><strong>題意：</strong>給一<strong>未排序的</strong> array <code>nums</code>, 找出數字連續的最長 sequence（sequence 元素不需在 <code>nums</code> 中位置連續）。</p><p><strong>注意：</strong>請設計 $O(n)$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/JkHCMuK.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將 <code>nums</code> 視覺化發現, 每個 sequence 形成的首要條件就是開頭的數左邊沒有數, 結尾的數右邊沒有數</strong></p><p><img src="https://i.imgur.com/RZNbX7F.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="comment">// 判斷左邊的數有無在 hash table 中</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(num - <span class="number">1</span>) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> end = num + <span class="number">1</span>; <span class="comment">// 則 num 可當作 sequence 的開頭</span></span><br><span class="line">                <span class="keyword">while</span> (s.<span class="built_in">find</span>(end) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, end - num); <span class="comment">// 檢查是否為最長 sequence</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 雖然有 for loop 和 while loop, 但是每一個數<strong>最多</strong>被訪問 &#96;2&#96;&#96; 次<ul><li>一次是 <code>for (const auto&amp; num : nums)</code></li><li>一次是 <code>if (s.find(num - 1) == s.end())</code>, 也就是剛好是某數的左邊</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>s</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>424. Longest Repeating Character Replacement</title>
      <link href="/post/longest-repeating-character-replacement/"/>
      <url>/post/longest-repeating-character-replacement/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">https://leetcode.cn/problems/longest-repeating-character-replacement/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code> 和一整數 <code>k</code>, 你可以選擇將 <code>s</code> 中的任意字元變成其他大寫英文字母, 該操作最多執行 <code>k</code> 次。</p><p>經上述操作後, 返回<strong>僅包含相同字元</strong>的最大 substring 長度。</p><p>s 由大寫英文字母所組成。</p></blockquote><p><img src="https://i.imgur.com/xPxWZv5.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 將 <code>window</code> 中的元素分成兩部分</strong></p><ul><li>出現頻率最多的元素</li><li>扣掉出現頻率最多的元素後，所剩餘的元素</li></ul><p><strong>若剩餘的元素個數 <code>≤ k</code>, 代表剩餘的元素可全部替換為頻率最多的元素。反之, 則不行。做完後, 更新 <code>res</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">window</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            ++window[c - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若剩餘元素個數 &gt; k，則縮小窗口</span></span><br><span class="line">            <span class="keyword">while</span>(right - left - *<span class="built_in">max_element</span>(window.<span class="built_in">begin</span>(), window.<span class="built_in">end</span>()) &gt; k)&#123;</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                --window[d - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(26 \cdot n)$, <code>s</code> 中的每個元素最多被遍歷 2 次（<code>left</code>、<code>right</code>）<ul><li>$O(26 \cdot n)$：while loop 中每次取 <code>max_element()</code> 需 $O(26)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code></li></ul><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a><strong>Solution 2:</strong></h2><blockquote><p><strong>想法: 改善 Solution 1, 將 <code>max_element()</code> 提出, 變成在 while loop 外部維護, 而非在 while loop 中維護</strong></p><ul><li>能這樣做是因為在內層 while loop 中移除 <code>window[s[left]]</code> 後, <code>maxf</code> 只會<strong>越來越小</strong></li><li>也就是說 <code>right - left - maxf(移除前) ≥ right - left - maxf(移除後)</code> 始終是成立的, 因為 <code>maxf(移除後) ≤ maxf(移除前)</code></li><li>若 <code>right - left - maxf(移除前) &gt; k</code> 成立, 則 <code>right - left - maxf(移除後) &gt; k</code> 也必定成立, 因此根本不必在 while loop 中更新 <code>maxf</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            ++window[c];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 widnow 中出現頻率最高的 char 的個數</span></span><br><span class="line">            <span class="type">int</span> maxf = <span class="built_in">max_element</span>(window.<span class="built_in">begin</span>(), window.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; p1, <span class="keyword">auto</span>&amp; p2)&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">            &#125;)-&gt;second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(right - left - maxf &gt; k)&#123;</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                --window[d];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>s</code> 中的每個元素最多被遍歷 2 次（<code>left</code>、<code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code> 長度為 $O(26)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/post/longest-substring-without-repeating-characters/"/>
      <url>/post/longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 返回一沒有重複 char 的<strong>最長 substring</strong> 的長度。</p></blockquote><p><img src="https://i.imgur.com/jg9qqTK.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 類似 <a href="https://zako945.github.io/post/longest-repeating-character-replacement/">424. Longest Repeating Character Replacement</a>, 每次檢查 <code>s[right]</code> 是否已經在 <code>visited</code> 中</strong></p><ul><li>若是, 則移除 <code>s[left]</code>, 且 <code>left + 1</code>, 直到 <code>visited</code> 中不存在 <code>s[right]</code></li><li>將 <code>s[right]</code> 加入到 <code>visited</code> 中</li><li>更新 <code>res</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); ++right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(visited.<span class="built_in">find</span>(s[right]) != visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">emplace</span>(s[right]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>s</code> 中的每個元素最多被拜訪 <code>2</code> 次（<code>left</code>, <code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>cnt</code> 長度最多為 <code>26</code>, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169. Majority Element</title>
      <link href="/post/majority-element/"/>
      <url>/post/majority-element/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/majority-element/">https://leetcode.cn/problems/majority-element/</a></strong></p><p><strong>題意：</strong>給一大小為 <code>n</code> 的 array <code>nums</code>, 找出當中個數<strong>大於</strong> $⌊ \dfrac{n}{2} ⌋$ 的數字(保證存在一個數滿足此條件)。</p><p><strong>進階：</strong>試著用 $O(n)$ time, $O(1)$ space 的演算法解決此問題</p></blockquote><p><img src="https://i.imgur.com/jvwdXOf.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table 紀錄 <code>&#123;num: count&#125;</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, maxCount = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n : nums)&#123;</span><br><span class="line">            ++umap[n];</span><br><span class="line">            <span class="keyword">if</span>(umap[n] &gt; maxCount)&#123;</span><br><span class="line">                res = n;</span><br><span class="line">                maxCount = umap[n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>umap</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p>想法<strong>：</strong>利用 Boyer – Moore 投票法</p><ul><li>當 <code>res = 0</code> 時, 將 <code>res</code> 設為 <code>nums[i]</code></li><li>否則, 檢查 <code>nums[i]</code> 是否為 <code>res</code>。若是的話 <code>res + 1</code>, 否則 <code>res - 1</code></li></ul><p><img src="https://i.imgur.com/ySun2rW.png" alt="Untitled"></p><p><strong>考慮特殊 case</strong>:</p><ol><li><p><code>nums = [2,2,1,1,3]</code>, 得出 <code>res</code> &#x3D; 3</p><table><thead><tr><th>nums[i]</th><th>2</th><th>2</th><th>1</th><th>1</th><th>3</th></tr></thead><tbody><tr><td>cnt</td><td>1</td><td>2</td><td>1</td><td>0</td><td>1</td></tr><tr><td>res</td><td>2</td><td>2</td><td>2</td><td>2</td><td>3</td></tr></tbody></table></li><li><p><code>nums = [2,2,3,4,5]</code>, 得出 <code>res</code> &#x3D; 5</p><table><thead><tr><th>nums[i]</th><th>2</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>cnt</td><td>1</td><td>2</td><td>1</td><td>0</td><td>1</td></tr><tr><td>res</td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td></tr></tbody></table></li></ol><p>➔ 以上情況皆不會在本題出現, 因為 2 的個數並沒有 &gt; $⌊ \dfrac{5}{2} ⌋$<br>➔ <strong>而本題的先決條件就是必有一數的個數 &gt; $⌊ \dfrac{n}{2} ⌋$, 因此 Boyer – Moore 投票法在本題必成立</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">                res = n;</span><br><span class="line">            cnt += (n == res) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104. Maximum Depth of Binary Tree</title>
      <link href="/post/maximum-depth-of-binary-tree/"/>
      <url>/post/maximum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求 <strong>root-to-leaf</strong> 的 path 之最大長度(tree 的最大深度)。</p><ul><li>最大長度<strong>：</strong>path 上的 <code>node</code> 數</li></ul></blockquote><p><img src="https://i.imgur.com/HasniTr.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ worse case : skew tree, 遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left) q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>252. Meeting Rooms</title>
      <link href="/post/meeting-rooms/"/>
      <url>/post/meeting-rooms/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/meeting-rooms/">https://leetcode.cn/problems/meeting-rooms/</a></strong></p><p><strong>題意：</strong>給定一包含開始時間和結束時間的 <code>intervals</code>, 其中<code>intervals[i] = [starti, endi]</code>, 返回一個人是否可以參加所有會議。</p><p><strong>注意：</strong><code>(0,8)</code>、<code>(8,10)</code> 並不衝突</p></blockquote><p><img src="https://i.imgur.com/3p0FW4o.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：先將 <code>intervals</code> 根據 <code>interval.start</code> 進行排序, 然後判斷當前 <code>interval[i - 1].end</code> 是否大於 <code>interval[i].start</code>。若是的話, 代表會衝突到</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canAttendMeetings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 不需要額外空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>617. Merge Two Binary Trees</title>
      <link href="/post/merge-two-binary-trees/"/>
      <url>/post/merge-two-binary-trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></strong></p><p><strong>題意：</strong>給兩棵 BT, 請合併它們。</p><ul><li>如果兩個節點重疊, 則將節點值相加作為合併節點的新值。</li><li>否則, 不為 NULL 的節點將作為新樹的節點。</li></ul></blockquote><p><img src="https://i.imgur.com/ggMDIUx.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// root1, root2 皆存在</span></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ stack 最大長度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. Merge Two Sorted Lists</title>
      <link href="/post/merge-two-sorted-lists/"/>
      <url>/post/merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></strong></p><p><strong>題意：</strong>給兩個 <code>sorted</code> linked list: <code>list1</code> 和 <code>list2</code>, 將兩個合併成一個 <code>sorted</code> linked list。</p></blockquote><p><img src="https://i.imgur.com/CuDl9AB.png" alt="Untitled"></p><p><img src="https://i.imgur.com/uAf35hh.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 dummy node, 其中 <code>tail</code> 指向當前 <code>val</code> 較小的 list node</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *tail = dummy;</span><br><span class="line">        <span class="keyword">while</span>(list1 &amp;&amp; list2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">                tail-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next; <span class="comment">// 指向下一個</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 某中一個 list 結束跳出迴圈, 要處理另一個 list 剩下的元素</span></span><br><span class="line">        <span class="keyword">if</span>(list1)</span><br><span class="line">            tail-&gt;next = list1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2)</span><br><span class="line">            tail-&gt;next = list2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 其中 <code>m</code> 為 <code>list1</code> 的長度, <code>n</code> 為 <code>list2</code> 的長度, worse case：每個點都恰拜訪一次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>876. Middle of the Linked List</title>
      <link href="/post/middle-of-the-linked-list/"/>
      <url>/post/middle-of-the-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/middle-of-the-linked-list/">https://leetcode.cn/problems/middle-of-the-linked-list/</a></strong></p><p><strong>題意：</strong>返回 linked list 的中點, 若 linked list 的 node 數為偶數, 則返回<strong>第二個中點</strong>。</p></blockquote><p><img src="https://i.imgur.com/8nZD1k4.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers<br><code>slow</code> 一次走一步, <code>fast</code> 一次走兩步, 當 <code>fast</code> 走到 <code>NULL</code> 時, <code>slow</code> 剛好走到中點</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當 n 為偶數時, 跳出迴圈是因為 fast == NULL</span></span><br><span class="line">        <span class="comment">// 當 n 為奇數時, 跳出迴圈是因為 fast-&gt;nxt = NULL</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>746. Min Cost Climbing Stairs</title>
      <link href="/post/min-cost-climbing-stairs/"/>
      <url>/post/min-cost-climbing-stairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>cost</code>, 其中 <code>cost[i]</code> 代表從第 <code>i</code> 皆樓梯往上爬所需支付的費用。一旦支付該費用, 可以選擇往上爬一個 or 二個台階。</p><p>可以選擇從 index 為 <code>0</code> or <code>1</code> 的位置開始往上爬。</p><p>請計算到達樓梯頂部 <code>index = cost.size()</code> 所需的最小費用。</p></blockquote><p><img src="https://i.imgur.com/SQZ2B6d.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 定義 <code>dp[i]</code> 為抵達 <code>index = i</code> 所需的最小費用, 因此 <code>dp[i]</code> 為 <code>抵達前一階的最小費用 + 該階的費用</code>、<code>抵達前兩階的最小費用 + 該階的費用</code> 中取較小者</strong></p><ul><li><code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="comment">// index = 0 和 1 的費用都為 0</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為發現計算 <code>dp[i]</code> 只需用到 <code>dp[i - 1]</code>、<code>dp[i - 2]</code> 即可, 也就是說只需紀錄 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> 就好, 根本不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>; <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="type">int</span> two = <span class="number">0</span>; <span class="comment">// dp[i - 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">min</span>(one + cost[i - <span class="number">1</span>], two + cost[i - <span class="number">2</span>]);</span><br><span class="line">            two = one;</span><br><span class="line">            one = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155. Min Stack</title>
      <link href="/post/min-stack/"/>
      <url>/post/min-stack/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/min-stack/">https://leetcode.cn/problems/min-stack/</a></strong></p><p><strong>題意：</strong>設計一個支持 <code>push</code>、<code>pop</code>、<code>top</code> 操作, 並且能在 $O(1)$ time 得到最小元素的 stack。</p><p><strong>實作 <code>MinStack</code> class：</strong></p><ul><li><code>MinStack()</code>：初始化 instance</li><li><code>void push(int val)</code>：將 <code>val</code> push 到 stack 中</li><li><code>void pop()</code>：移除 stack 頂端元素</li><li><code>void top()</code>：得到 stack 頂端元素</li><li><code>int getMin()</code>：得到 stack 中的最小元素</li></ul></blockquote><p><img src="https://i.imgur.com/8x7sde8.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用兩個 Stack, 其中 stack <code>stk</code> 紀錄元素 push &#x2F; pop 的過程, 另一個 stack <code>minStk.top()</code> 紀錄每一次 push 元素到 <code>stk</code> 後, 當前 <code>stk</code> 中的的最小值</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        <span class="comment">// 讓 minStk 初始有一個最大值, 這樣後續 push 時 minStk 一定有 top 元素可比較</span></span><br><span class="line">        minStk.<span class="built_in">emplace</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">emplace</span>(val);</span><br><span class="line">        minStk.<span class="built_in">emplace</span>(<span class="built_in">min</span>(minStk.<span class="built_in">top</span>(), val)); <span class="comment">// 新增元素後, 紀錄當前的最小元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        minStk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minStk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>皆為 $O(1)$</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 的元素個數最多為 <code>n</code>, <code>minStk</code> 的元素個數最多為 <code>n + 1</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111. Minimum Depth of Binary Tree</title>
      <link href="/post/minimum-depth-of-binary-tree/"/>
      <url>/post/minimum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求 <strong>root-to-leaf</strong> 的 path 之最小長度(tree 的最小深度)。</p><ul><li>最小長度: path 上的 <code>node</code> 數</li></ul><p><strong>注意：</strong>若今給一 skew tree, 則 <code>min_depth = n</code></p></blockquote><p><img src="https://i.imgur.com/tbUhkxE.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 需遍歷所有 node</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, stack 長度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 需遍歷所有 node</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, stack 長度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268. Missing Number</title>
      <link href="/post/missing-number/"/>
      <url>/post/missing-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/missing-number/">https://leetcode.cn/problems/missing-number/</a></strong></p><p><strong>題意：</strong>原本有一包含 <code>[0, n]</code> 總共 <code>n + 1</code> 個數的 array, 今給一只有 <code>n</code> 個數的 array <code>nums</code>, 找出缺失的數。</p></blockquote><p><img src="https://i.imgur.com/qAxMn9S.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先將 <code>nums</code> 排序, 然後用 loop 檢查第 <code>i</code> 個數是否在 <code>nums</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>(); <span class="comment">// Example 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ sorting 後 data 仍儲存在 <code>nums</code> 中, 不需要額外空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：先計算 <code>[0, n]</code> 這 <code>n + 1</code> 個數之和, 然後扣掉 <code>nums</code> 中 data 之和, 即可得到缺失的數</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// 取得 nums 總和</span></span><br><span class="line">        <span class="type">int</span> total = nums.<span class="built_in">size</span>() * (nums.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 計算 0 ~ n 之和</span></span><br><span class="line">        <span class="keyword">return</span> total - sum; <span class="comment">// 相減即為缺值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍例 <code>nums</code> 計算所有 data 之和</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 XOR 中 <code>a ^ a = 0</code> 且 <code>0 ^ a = a</code> 的特性（還有交換性）</strong></p><p>e.g. <code>[0, 1, 2, 3] ^ [0, 1, 3] = 2</code></p><p><strong>XOR：</strong></p><ul><li><code>0 ^ 0 = 0</code></li><li><code>b ^ b = b</code></li><li><code>0 ^ a = a</code></li><li><code>a ^ b ^ b = a ^ (b ^ b) = a ^ 0 = a</code></li><li><strong>交換性：</strong><code>b ^ a ^ b = a ^ (b ^ b) = a ^ 0 = a</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            res = res ^ i ^ nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191. Number of 1 Bits</title>
      <link href="/post/number-of-1-bits/"/>
      <url>/post/number-of-1-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></strong></p><p><strong>題意：</strong>給一無號整數 <code>n</code>, 返回其二進制表示中 <code>1</code> 的個數。</p><p><strong>進階：</strong>如果多次呼叫此 function, 要如何優化？</p></blockquote><p><img src="https://i.imgur.com/hvYGLCW.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：每次判斷 <code>n</code> 的最右 bit 是否為 <code>1</code>, 若是的話, 則 <code>cnt++</code>, 判斷完最右 bit 後將 <code>n</code> 右移一位, 重複以上步驟直到 <code>n == 0</code> （沒有 1-bit）為止</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> rightmost = n &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(rightmost == <span class="number">1</span>) cnt++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 因為 <code>n</code> 只有 <code>32</code> bit, 所以最多右移 <code>32</code> 次, 故為 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：<code>n &amp; (n-1)</code> 會讓 <code>n</code> 最右邊的 <code>1</code> 變為 <code>0</code>（重要）, 每做一次 <code>cnt++</code>, 直到 <code>n == 0</code> 為止</strong></p><p>e.g. <code>n = 100</code></p><p><img src="https://i.imgur.com/zB7GfKf.png" alt="Untitled"></p><p>e.g. <code>n = 101</code></p><p><img src="https://i.imgur.com/RyZlDKQ.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 因為 <code>n</code> 只有 <code>32</code> bit, 所以最多右移 <code>32</code> 次, 故為 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112. Path Sum</title>
      <link href="/post/path-sum/"/>
      <url>/post/path-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></strong></p><p><strong>題意：</strong>給一 BT 和一整數 <code>targetSum</code>, 返回是否存在 <strong>root-to-leaf</strong> 之路徑總和為 <code>targetSum</code> 的 path。</p></blockquote><p><img src="https://i.imgur.com/i0rjjOX.png" alt="Untitled"></p><p><img src="https://i.imgur.com/8XRgIUG.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val)</span><br><span class="line">            || <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度最大長度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;); <span class="comment">// sum 初始設 0, 而非 root-&gt;val, 因為等等會加上 root-&gt;val</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">            TreeNode *curNode = front.first;</span><br><span class="line">            <span class="type">int</span> curSum = front.second + curNode-&gt;val;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若為 leaf</span></span><br><span class="line">            <span class="keyword">if</span>(!curNode-&gt;left &amp;&amp; !curNode-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curSum == targetSum)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(curNode-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;curNode-&gt;left, curSum&#125;);</span><br><span class="line">                <span class="keyword">if</span>(curNode-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;curNode-&gt;right, curSum&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/post/palindrome-linked-list/"/>
      <url>/post/palindrome-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></strong></p><p><strong>題意：</strong>判斷 linked list 是否迴文。</p></blockquote><p><img src="https://i.imgur.com/dCswt4N.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 <a href="https://zako945.github.io/post/middle-of-the-linked-list/">876. Middle of the Linked List</a> 的方法取得 linked list 的中點<br>然後 reverse 以 <code>slow</code> 為 head 的 linked list, 最後比較兩個 linked list 是否相等<br>(reverse linked list 可參考 <a href="https://zako945.github.io/post/reverse-linked-list/">206. Reverse Linked List</a>)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast != NULL 代表 linked list 之 node 個數為奇數</span></span><br><span class="line">        <span class="keyword">if</span>(fast)</span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 若為奇數, 則中點往後一位</span></span><br><span class="line">        slow = <span class="built_in">reverse</span>(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(slow)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val != head-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>567. Permutation in String</title>
      <link href="/post/permutation-in-string/"/>
      <url>/post/permutation-in-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/permutation-in-string/">https://leetcode.cn/problems/permutation-in-string/</a></strong></p><p><strong>題意：</strong>給兩 string <code>s1</code> 和 <code>s2</code>, 若 <code>s2</code> 包含 <code>s1</code> 的<strong>排列</strong>, 則返回 <code>true</code>。否則, 返回 <code>false</code>。</p><p><code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>substring</strong>。</p><p><strong>注意：</strong>substring 為連續的, subsequence 為非連續的</p></blockquote><p><img src="https://i.imgur.com/XbTG8Fb.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 類似 <a href="https://zako945.github.io/post/minimum-window-substring/">76. Minimum Window Substring</a></strong></p><ul><li>先不斷地增加 <code>right</code> 來擴大窗口</li><li>縮小窗口的時機是窗口大小 <code>≥ s1.size()</code> 時</li><li>當 <code>valid == need.size()</code> 時, 代表窗口中的 substring 為合法的排列</li></ul><p><strong>注意：這題是「固定長度」的窗口, 因為窗口每次向前滑動時只會移出一個字元, 故可以把內層的 while 改成 if, 其效果是一樣的</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right= <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window, need;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s1)</span><br><span class="line">            ++need[ch];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s2[right];</span><br><span class="line">            window[c]++;</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">find</span>(c) != need.<span class="built_in">end</span>() &amp;&amp; window[c] == need[c])</span><br><span class="line">                ++valid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(right - left &gt;= s1.<span class="built_in">size</span>())&#123; <span class="comment">// 固定窗口，可以改成 if 判斷</span></span><br><span class="line">                <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 存在排列 substring</span></span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> d = s2[left];</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(d) != need.<span class="built_in">end</span>() &amp;&amp; window[d] == need[d]) <span class="comment">// 移出前相等</span></span><br><span class="line">                    --valid;</span><br><span class="line">                --window[d];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n1 + n2)$ ➔ 其中 <code>n1</code>、<code>n2</code> 分別為 <code>s1</code>、<code>s2</code> 的長度<ul><li>$O(n1)$：遍歷 <code>s1</code> 計算 <code>need</code></li><li>$O(n2)$：<code>s2</code> 中的每個元素最多被遍歷 <code>2</code> 次（<code>left</code>、<code>right</code>）</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code>、<code>need</code> 長度皆為 $O(26)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66. Plus One</title>
      <link href="/post/plus-one/"/>
      <url>/post/plus-one/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/plus-one/">https://leetcode.cn/problems/plus-one/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>digits</code> 用來表示一非負整數。返回該非負整數 + 1 後所表示的 <code>digits</code>。</p><p>非負整數的最高為儲存在 <code>digits</code> 的首位, 其中 <code>digits[i]</code> 只儲存單個數字。</p><p>除了 <code>0</code> 之外, 其他整數都不會以 <code>0</code> 作為開頭。</p></blockquote><p><img src="https://i.imgur.com/AGxIfBP.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：遍歷 <code>digits</code>, 並紀錄進位 <code>carry</code>。若最後 <code>carry</code> 為 <code>1</code>, 則在 <code>digits</code> 最前面補上 <code>1</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">1</span>; <span class="comment">// 因為最後一位要加 1, 所以把 carry 設成 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            digits[i] = carry + digits[i];</span><br><span class="line">            carry = digits[i] / <span class="number">10</span>;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">            digits.<span class="built_in">emplace</span>(digits.<span class="built_in">begin</span>(), carry);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 改成一旦不用進位, 則終止循環（循環裡會不斷將 <code>digits[i] + 1</code>）, 並返回 digits</strong></p><ul><li><code>digits[i] &lt; 9</code><strong>：</strong>代表不用進位, 將 <code>digits[i] + 1</code> 後, 終止循環並返回 <code>digits</code></li><li><code>digits[i] == 9</code><strong>：</strong>代表要進位, 將 <code>digits[i]</code> 設為 <code>0</code>, 並繼續循環</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>)&#123;</span><br><span class="line">                ++digits[i];</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 執行到這裡, 代表原先 digits 裡的元素全為 9, 現在全變為 0 了</span></span><br><span class="line">        <span class="comment">// 因此在最前面加入 1 即可, e.g. 999 ➔ 000 ➔ 1000</span></span><br><span class="line">        digits.<span class="built_in">emplace</span>(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>238. Product of Array Except Self</title>
      <link href="/post/product-of-array-except-self/"/>
      <url>/post/product-of-array-except-self/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/product-of-array-except-self/">https://leetcode.cn/problems/product-of-array-except-self/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 返回一 array <code>answer</code>, 其中 <code>answer[i]</code> 為 <code>nums</code> 中除了 <code>nums[i]</code> 以外其餘元素的乘積, 乘積保證在 32-bit 整數的範圍內（不用考慮 overflow）。</p><p><strong>注意：請不要使用除法</strong>, 並在 $O(n)$ time 內解決此問題</p><p><strong>進階：</strong>請設計 $O(1)$ space 的演算法, 其中 output array 不算額外空間</p></blockquote><p><img src="https://i.imgur.com/CDIeTxS.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 prefix 和 postfix, 以 <code>index = i</code> 為分界, <code>prefix[i]</code> 記錄區間 <code>[0, i - 1]</code> 之乘積, <code>postfix[i]</code> 記錄區間 <code>[i + 1, n - 1]</code> 之乘積, 最後 <code>nums[i] = prefix[i] * postfix[i]</code> 即為題目所求</strong></p><ul><li><strong>prefix：</strong><code>prefix[i]</code> 紀錄 <code>num[0] ~ nums[i - 1]</code> 的乘積（由前往後填）</li><li><strong>postfix：</strong><code>postfix[n - i - 1]</code> 紀錄 <code>nums[n - 1] ~ nums[n - i]</code> 的乘積（由後往前填）</li><li><strong>nums：</strong><code>nums[i]</code> 紀錄 <code>prefix[i] * postfix[i]</code>, 也就是除了位置 <code>i</code> 剩餘其他數的乘積</li></ul><p>e.g. <code>nums = [1,2,3,4]</code></p><table><thead><tr><th>nums</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>prefix</td><td>1</td><td>1</td><td>2</td><td>6</td></tr><tr><td>postfix</td><td>24</td><td>12</td><td>4</td><td>1</td></tr><tr><td>nums</td><td>24</td><td>12</td><td>8</td><td>6</td></tr></tbody></table></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">postfix</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            prefix[i] = prefix[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">            postfix[n - i - <span class="number">1</span>] = nums[n - i] * postfix[n - i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = prefix[i] * postfix[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>prefix</code>, <code>postfix</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 將 <code>postfix</code> 直接儲存在 <code>res</code> 中, 然後計算出 <code>prefix</code> 後乘上對應的 <code>postfix</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nums:   [ <span class="number">1</span>,  <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">➔ res: [<span class="number">24</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>] <span class="comment">// postfix 做完</span></span><br><span class="line">➔ res: [<span class="number">24</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">6</span>] <span class="comment">// prefix 做完</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 計算 postfix</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[n - i - <span class="number">1</span>] = res[n - i] * nums[n - i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> prefix = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] *= prefix;</span><br><span class="line">            prefix *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 撇除要返回的 output array <code>res</code>, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>303. Range Sum Query - Immutable</title>
      <link href="/post/range-sum-query-immutable/"/>
      <url>/post/range-sum-query-immutable/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a></strong></p><p><strong>題意：</strong>給一 array, 多次輸入不同的 <code>left</code> 和 <code>right</code>, 求 array 中從 <code>idx = left</code> 到 <code>idx = right</code> 之和。</p></blockquote><p><img src="https://i.imgur.com/JfAhPC1.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法: 每一次 query 都去計算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        nums_ = <span class="built_in">move</span>(nums); <span class="comment">// 複製 nums</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">            sum += nums_[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令 <code>query</code> 次數<strong>：</strong><code>m</code> 次, <code>nums</code> 中元素個數<strong>：</strong><code>n</code></p><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ <code>m</code> 次 query，每次 query 需 $O(n)$ 時間</li><li><strong>space：</strong>$O(n)$ ➔ <code>nums_</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Prefix Sum, 事先計算前 <code>i</code> 個數之和</strong></p></blockquote><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sums</span> 紀錄前 i 個數之和</span><br><span class="line"><span class="attribute">nums</span>:<span class="meta"> [-2,  0, 3, -5,  2, -1]</span></span><br><span class="line"><span class="attribute">sums</span>:<span class="meta"> [-2, -2, 1, -4, -2, -3]</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">range</span>(left, right):</span><br><span class="line">    <span class="attribute">if</span>(left == <span class="number">0</span>) sum = sums[right] // e.g. range(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="attribute">else</span> sum = sums[right] - sums[left-<span class="number">1</span>] // e.g. range(<span class="number">2</span>, <span class="number">5</span>) -&gt; -<span class="number">3</span> - (-<span class="number">2</span>) = <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sums = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            sums[i] = sums[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span>) <span class="keyword">return</span> sums[right];</span><br><span class="line">        <span class="keyword">return</span> sums[right] - sums[left<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令 <code>query</code> 次數<strong>：</strong><code>m</code> 次, <code>nums</code> 中元素個數<strong>：</strong><code>n</code></p><ul><li><strong>time：</strong>$O(m+n)$ ➔ $O(n)$ + $m * O(1)$<ul><li>$O(n)$ : 計算 prefix sum 的時間</li><li>$m * O(1)$ : <code>m</code> 次 query, 每次 query 只需 $O(1)$ 時間</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>sums</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>83. Remove Duplicates from Sorted List</title>
      <link href="/post/remove-duplicates-from-sorted-list/"/>
      <url>/post/remove-duplicates-from-sorted-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> linked list, 刪除 linked list 所有重複的元素, 讓每種元素恰好出現一次。</p></blockquote><p><img src="https://i.imgur.com/06GrNA5.png" alt="Untitled"></p><p><img src="https://i.imgur.com/51OBB5i.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：比較當前 node 和 下一個 node 的 val, 若相同則刪除下一個, 直到下一個的值不同, <code>cur</code> 才前進</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr &amp;&amp; curr-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;val == curr-&gt;next-&gt;val)</span><br><span class="line">                curr-&gt;next = curr-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203. Remove Linked List Elements</title>
      <link href="/post/remove-linked-list-elements/"/>
      <url>/post/remove-linked-list-elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-linked-list-elements">https://leetcode.cn/problems/remove-linked-list-elements</a></strong></p><p><strong>題意：</strong>給一整數 <code>val</code>, 刪除 linked list 中所有 <code>node.val == val</code> 的 node。</p></blockquote><p><img src="https://i.imgur.com/zEGcTRx.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：用 <code>dummy</code> 來指向 head, <code>pre</code> 則記住當前 node 的前一個 node<br>初始化 <code>pre</code> 為 <code>dummy</code>(head 的前一個 node)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dummy 指向 link-list 之 head</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *curr = head, *prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;val == val) <span class="comment">// 當前 node 要刪除</span></span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 不刪除, 往下一個 node 前進, current node 變成前一個 node</span></span><br><span class="line">                prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>190. Reverse Bits</title>
      <link href="/post/reverse-bits/"/>
      <url>/post/reverse-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-bits/">https://leetcode.cn/problems/reverse-bits/</a></strong></p><p><strong>題意：</strong>給一無號整數 <code>n</code>, 請將其二進制進行反轉。</p></blockquote><p><img src="https://i.imgur.com/00zH6zZ.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：每次先把 <code>res</code> 的最右 bit 設為 <code>0</code>（左移一位, 最右 bit 補 0）, 然後取得 <code>n</code> 的最右 bit（對 <code>n</code> 的最右 bit 取 OR）, 做完後將 <code>n</code> 右移一位（捨棄最右 bit）</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">           res &lt;&lt;= <span class="number">1</span>; <span class="comment">// 最右 bit 設 0</span></span><br><span class="line">           res |= (n &amp; <span class="number">1</span>); <span class="comment">// 得到 n 的最右 bit</span></span><br><span class="line">           n &gt;&gt;= <span class="number">1</span>; <span class="comment">// 捨棄最右 bit</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ for loop 只需 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="/post/reverse-linked-list/"/>
      <url>/post/reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></strong></p><p><strong>題意：</strong>反轉 linked-list。</p></blockquote><p><img src="https://i.imgur.com/JN4Kd2M.png" alt="Untitled"></p><p><img src="https://i.imgur.com/l7LB6ZU.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：必須要有 <code>prev</code>, <code>nxt</code> 來記住前一個 node 和 下一個 node</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            nxt = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100. Same Tree</title>
      <link href="/post/same-tree/"/>
      <url>/post/same-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/same-tree/">https://leetcode.cn/problems/same-tree/</a></strong></p><p><strong>題意：</strong>給兩 BT, 求兩者是否相等。</p></blockquote><p><img src="https://i.imgur.com/0OPiUyV.png" alt="Untitled"></p><p><img src="https://i.imgur.com/tWUqJkw.png" alt="Untitled"></p><p><img src="https://i.imgur.com/7UBxdM2.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少其中一個為 null, 兩個都為 null 時, return true; 其他情況皆為 false</span></span><br><span class="line">        <span class="keyword">if</span>(!(p &amp;&amp; q)) <span class="keyword">return</span> p == q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兩個皆不為 null</span></span><br><span class="line">        <span class="keyword">return</span> (p-&gt;val == q-&gt;val)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(min(m, n))$ ➔ 其中 <code>m</code>、<code>n</code> 分別是兩個 BT 的 node 個數, 被訪問到的 node 個數不超過較小的 BT 之節點個數</li><li><strong>space：</strong>$O(min(m, n))$ ➔ 遞迴深度不超過較小的 BT 之節點個數</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 要注意 <code>nullptr</code> 也要 insert 到 queue 中, 否則下方範例會出錯</strong></p><p>e.g. <code>左邊 = [1, null, 2]</code>, <code>右邊 = [1, 2]</code></p><p><img src="https://i.imgur.com/ALYOTs3.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少其中一個為 null, 兩個都為 null 時, return true; 其他情況皆為 false</span></span><br><span class="line">        <span class="keyword">if</span>(!(p &amp;&amp; q)) <span class="keyword">return</span> p == q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兩個皆不為 null</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        queue&lt;TreeNode*&gt; q2;</span><br><span class="line">        q1.<span class="built_in">emplace</span>(p);</span><br><span class="line">        q2.<span class="built_in">emplace</span>(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n1 = q1.<span class="built_in">size</span>(), n2 = q2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(n1 != n2)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; ++i)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur1 = q1.<span class="built_in">front</span>(); q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">auto</span> cur2 = q2.<span class="built_in">front</span>(); q2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 這邊做判斷是為了避免下面出錯</span></span><br><span class="line">                <span class="keyword">if</span>(!(cur1 &amp;&amp; cur2))&#123; <span class="comment">// 其中一個為 null</span></span><br><span class="line">                    <span class="keyword">if</span>(cur1 != cur2) <span class="comment">// 一個是 null, 一個不是</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">// 兩個皆為 null</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur1-&gt;val != cur2-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">add_child</span>(q1, cur1);</span><br><span class="line">                <span class="built_in">add_child</span>(q2, cur2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>() &amp;&amp; q2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// nullptr 也要 insert 到 queue 中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_child</span><span class="params">(queue&lt;TreeNode*&gt;&amp; q, TreeNode* node)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">        q.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(min(m, n))$ ➔ 其中 <code>m</code>、<code>n</code> 分別是兩個 BT 的 node 個數, 被訪問到的 node 個數不超過較小的 BT 之節點個數</li><li><strong>space：</strong>$O(min(m, n))$ ➔ <code>q</code> 的元素個數不超過較小的 BT 之節點個數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136. Single Number</title>
      <link href="/post/single-number/"/>
      <url>/post/single-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></strong></p><p><strong>題意：</strong>給一非空的 array <code>nums</code>, 當中只有一個數 <code>n1</code> 只出現一次, 找出 <code>n1</code>。</p></blockquote><p><img src="https://i.imgur.com/jhihJCU.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 XOR 的特性, <code>a ^ a = 0</code> 且 <code>0 ^ b = b</code>, 還有交換性<br>e.g. <code>b ^ a ^ b = a ^ (b ^ b) = a ^ 0 = a</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>977. Squares of a Sorted Array</title>
      <link href="/post/squares-of-a-sorted-array/"/>
      <url>/post/squares-of-a-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> array <code>nums</code>, 求每個數字平方所組成的 <code>sorted</code> array。</p></blockquote><p><img src="https://i.imgur.com/pOCljbp.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 two pointers</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123; <span class="comment">// res 從後面往前填(先填大的)</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[left]) &gt; <span class="built_in">abs</span>(nums[right]))&#123;</span><br><span class="line">                res[i] = nums[left] * nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i] = nums[right] * nums[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ 扣除返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>572. Subtree of Another Tree</title>
      <link href="/post/subtree-of-another-tree/"/>
      <url>/post/subtree-of-another-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/subtree-of-another-tree/">https://leetcode.cn/problems/subtree-of-another-tree/</a></strong></p><p><strong>題意：</strong>給兩棵 BT <code>root</code> 和 <code>subRoot</code>, 求 <code>subRoot</code> 是否為 <code>root</code> 之 subtree。</p></blockquote><p><img src="https://i.imgur.com/dnJkv2i.png" alt="Untitled"></p><p><img src="https://i.imgur.com/8JvUpJg.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 先判斷是否為 Same Tree（可參考 <a href="https://zako945.github.io/post/same-tree/">100. Same Tree</a>）<br>若不是的話, 則遞迴判斷 <code>subRoot</code> 是否為 <code>root</code> 之左子樹 or <code>root</code> 之右子樹</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!subRoot) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// subRoot == null, 則一定為 root 之 subtree</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// root == null &amp;&amp; subRoot != null</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isSameTree</span>(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubtree</span>(root-&gt;left, subRoot)</span><br><span class="line">            || <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(p &amp;&amp; q)) <span class="keyword">return</span> p == q;</span><br><span class="line">        <span class="keyword">return</span> (p-&gt;val == q-&gt;val)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>令 <code>root</code> 的 node 個數為 <code>m</code>, <code>subRoot</code> 的 node 個數為 <code>n</code><br>令 <code>root</code> 的深度為 <code>s</code>, <code>subRoot</code> 的深度為 <code>t</code></strong></p><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 對於 root 中的每個 node <code>s</code>, 都以 <code>s</code> 為 root 檢查 n 個 node</li><li><strong>space：</strong>$O(max(s, t))$ ➔ 遞迴最大深度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. Top K Frequent Elements</title>
      <link href="/post/top-k-frequent-elements/"/>
      <url>/post/top-k-frequent-elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和一整數 <code>k</code>, 返回出現頻率前 <code>k</code> 高的元素。可以按任何順序返回答案。</p><p><strong>進階：</strong>請設計 $O(n \cdot log(n))$ time 的演算法, 其中 <code>n</code> 為 <code>nums.size()</code>。</p></blockquote><p><img src="https://i.imgur.com/Niq9pgv.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap</strong></p><ul><li>計算每種元素的出現次數</li><li>直接將元素 push 到 min heap <code>pq</code> 中</li><li>若 <code>pq.size() &gt; k</code>, 代表現在 <code>pq</code> 中有 <code>k + 1</code> 個元素, 故把最小的元素給 pop 掉, 讓 <code>pq</code> 元素個數始終保持在 <code>k</code> 個</li><li>此時, <code>pq</code> 中的元素為前 <code>k</code> 大的元素, 將其取出即可</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freqs; <span class="comment">// &#123;num, freq&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            ++freqs[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [num, freq] : freqs) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(pii&#123;freq, num&#125;);</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) &#123; <span class="comment">// 讓 pq 始終儲存前 k 大的元素</span></span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>time: $O(n \cdot log(k))$ ➔ <code>pq</code> 最多 insert &#x2F; delete <code>n</code> 個點, 每次操作需 $O(log(k))$, 因為 <code>pq</code> 中最多 <code>k + 1</code> 個點, 其中 <code>n</code> 為 <code>nums</code> 的元素個數</li><li>space: $O(n)$ ➔ <code>freqs</code> 最大長度為 <code>n</code>, 而 <code>pq</code> 的最大長度為 <code>k + 1</code>, 其中 <code>n ≥ k</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/post/two-sum/"/>
      <url>/post/two-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和一整數 <code>target</code>, 求 <code>nums</code> 中兩數和剛好為 <code>target</code> 之 index, 假設每一種 <code>target</code> 只會對應到一組解。</p><p><strong>注意：</strong>同一個元素不可重複使用, 可按照任意順序返回。</p></blockquote><p><img src="https://i.imgur.com/zKI5XRV.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 hash table, 由於題目保證一定有解, 因此對 <code>nums[i]</code> 而言, 先去 hash table 中找 <code>target - nums[i]</code> 是否存在</strong></p><ul><li>若存在, 則直接返回</li><li>否則, 將 <code>nums[i]</code> 還有其 <code>index</code> 加入到 hash table 中</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;  <span class="comment">// &#123;value, index&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> search = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (umap.<span class="built_in">find</span>(search) != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, umap[search]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            umap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：$O(n)$</strong> ➔ <code>umap</code> 的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167. Two Sum II - Input Array Is Sorted</title>
      <link href="/post/two-sum-ii-input-array-is-sorted/"/>
      <url>/post/two-sum-ii-input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/</a></strong></p><p><strong>題意：</strong>給一 index 從 <code>1</code> 開始的整數 array <code>numbers</code>, 該 array 已按照非遞減順序排列, 請從 <code>numbers</code> 中找出相加等於 <code>target</code> 的兩數之 index <code>index1</code>、<code>index2</code>, 其中 <code>1 ≤ index1 ≤ index2 ≤ numbers.length</code>。</p><p>假設每一種 <code>target</code> 只會對應到一組解, 且同一個元素不可重複使用。</p><p>請設計 $O(1)$ space 的演算法。</p></blockquote><p><img src="https://i.imgur.com/DVvXBxC.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：概念同 <a href="https://zako945.github.io/post/3sum/">15. 3Sum</a>, 由於 array 已排序, 故直接使用 Two Pointers 即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>numbers</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242. Valid Anagram</title>
      <link href="/post/valid-anagram/"/>
      <url>/post/valid-anagram/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a></strong></p><p><strong>題意：</strong>給兩 string <code>s</code> 和 <code>t</code>, 返回 <code>t</code> 是否為 <code>s</code> 的字母異位詞(Anagram) 則返回 <code>true</code>, 其中 <code>s</code> 和 <code>t</code> 僅由<strong>小寫</strong>字母所組成。</p><p><strong>字母異位詞 (Anagram) 定義：</strong>若 <code>s</code> 和 <code>t</code> 中每個字母的出現次數都相同, 則 <code>s</code> 和 <code>t</code> 互為字母異位詞。</p><p><strong>進階：</strong>若 input string 包含 Unicode char, 你要如何調整你的解法？</p></blockquote><p><img src="https://i.imgur.com/x5ZFFwG.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：將 <code>s</code>、<code>t</code> 進行排序, 若排序後 <code>s</code>、<code>t</code> 相等, 就代表為 anagram</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Array 來記錄每個字母的出現次數, 若 <code>s</code> 和 <code>t</code> 為 anagram, 則 <code>s 中每個字母的出現頻率 - t 中每個字母的出現頻率</code> 後, 每個字母的出現頻率應皆為 0</strong></p><p>e.g. <code>s = &quot;abc&quot;</code>, <code>t = &quot;cba&quot;</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">freqs</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freqs[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 s 和 t 長度相等的情況下, 若不為 anagram, 則必存在一 char 相減後的 freq &lt; 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(--freqs[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code></li><li><strong>space：</strong>$O(1)$ ➔ $O(26)$, 只需常數空間</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 hash table, 概念同 Solution 1, 但是 Solution 1 只能解決 <code>s</code> 和 <code>t</code> 為小寫字母的問題, Solution 2 可解決 input string 包含 Unicode char 的問題</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freqs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freqs[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--freqs[ch] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code></li><li><strong>space：</strong>$O(S)$ ➔ $S$ 為 <code>s</code> 和 <code>t</code> union 後的 char set 之元素個數, 本題的 <code>S = 26</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="/post/valid-palindrome/"/>
      <url>/post/valid-palindrome/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-palindrome/">https://leetcode.cn/problems/valid-palindrome/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 將其大寫轉換成小寫、並移除非字母和數字的 char, 返回轉換後是否為迴文。</p></blockquote><p><img src="https://i.imgur.com/9LPedjt.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two pointers, 若當前的 char 不為數字 or 字母則跳過, 直到 <code>left</code>、<code>right</code> 相會。判斷式為 <code>left &lt; right</code> 即可, 因為 <code>left == right</code> 時 <code>s[left]</code>、<code>s[right]</code> 必相等, 因此不用判斷</strong></p><p><strong>注意：</strong>判斷完後記得要更新 <code>left</code>、<code>right</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 注意：這裡更新時還是要保持 left &lt; right</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update ptr</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>s</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. Valid Parentheses</title>
      <link href="/post/valid-parentheses/"/>
      <url>/post/valid-parentheses/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></strong></p><p><strong>題意：</strong>給一只包含 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、<code>&#39;&#123;&#39;</code>、<code>&#39;&#125;&#39;</code>、<code>&#39;[&#39;</code>、<code>&#39;]&#39;</code> 的 string <code>s</code>, 判斷 <code>s</code> 是否有效。</p><p>有效的定義如下：</p><ul><li>左括號必須有相同類型的右括號閉合</li><li>左括號必須以正確的順序閉合</li><li>每個右括號都有一個對應的相同類型之左括號</li></ul></blockquote><p><img src="https://i.imgur.com/1vJ8lkJ.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stk.<span class="built_in">emplace</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>(); <span class="comment">// 若 stack 為空, 則代表有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; pairs = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code>, 其中 <code>n</code> 為 <code>s</code> 的長度</li><li><strong>space：</strong>$O(n)$ ➔ stack 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku</title>
      <link href="/post/valid-sudoku/"/>
      <url>/post/valid-sudoku/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-sudoku/">https://leetcode.cn/problems/valid-sudoku/</a></strong></p><p><strong>題意：</strong>判斷 <code>9 x 9</code> 數獨是否有效, 根據以下規則, 判斷已填入的數字是否有效即可。</p><ul><li>數字 <code>1 - 9</code> 在每一行只能出現一次</li><li>數字 <code>1 - 9</code> 在每一列只能出現一次</li><li>數字 <code>1 - 9</code> 在每一個 <code>3 x 3</code> 九宮格中只能出現一次</li></ul><p>空白格以 <code>&#39;.&#39;</code> 表示。</p></blockquote><p><img src="https://i.imgur.com/CZidDFe.png" alt="Untitled"></p><p><img src="https://i.imgur.com/TiCSPjx.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：一旦 <code>board[r][c]</code> 不為 <code>&#39;.&#39;</code>, 就去判斷該 row、col、block 是否有重複的 char</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> target = board[r][c];</span><br><span class="line">                <span class="keyword">if</span> (target == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isValidRow</span>(board, r, target)</span><br><span class="line">                    || !<span class="built_in">isValidCol</span>(board, c, target)</span><br><span class="line">                    || !<span class="built_in">isValidBlock</span>(board, r, c, target)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidRow</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span>&amp; row, <span class="type">const</span> <span class="type">char</span>&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> seen[<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidCol</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span>&amp; col, <span class="type">const</span> <span class="type">char</span>&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> seen[<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBlock</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span>&amp; row, <span class="type">const</span> <span class="type">int</span>&amp; col, <span class="type">const</span> <span class="type">char</span>&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> blockR = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> blockC = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">bool</span> seen[<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = blockR; r &lt; blockR + <span class="number">3</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = blockC; c &lt; blockC + <span class="number">3</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (seen[board[r][c] - <span class="string">&#x27;1&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                seen[board[r][c] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 每個 <code>board[r][c]</code> 判斷該 row、col、block 是否重複皆需 $O(9)$, 故總共需 $O((9 * 9) \cdot (3 * 9))$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
