<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode 題型難度 &amp; 投資報酬率</title>
      <link href="/post/leetcode-difficulty-roi/"/>
      <url>/post/leetcode-difficulty-roi/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-題型難度-amp-投資報酬率"><a href="#Leetcode-題型難度-amp-投資報酬率" class="headerlink" title="Leetcode 題型難度 &amp; 投資報酬率"></a>Leetcode 題型難度 &amp; 投資報酬率</h1><table><thead><tr><th>類型</th><th>學習難度</th><th>投資報酬率</th></tr></thead><tbody><tr><td>Tree BFS</td><td>低</td><td>高</td></tr><tr><td>Linked List</td><td>低</td><td>高</td></tr><tr><td>Two Pointers</td><td>中</td><td>高</td></tr><tr><td>Tree DFS</td><td>中</td><td>高</td></tr><tr><td>Graph BFS</td><td>中</td><td>高</td></tr><tr><td>Hash</td><td>中</td><td>高</td></tr><tr><td>Graph DFS</td><td>中</td><td>中</td></tr><tr><td>Combinatorial DFS</td><td>中</td><td>中</td></tr><tr><td>Heap</td><td>中</td><td>中</td></tr><tr><td>Binary Search</td><td>中</td><td>中</td></tr><tr><td>Trie</td><td>中</td><td>中</td></tr><tr><td>Union Find</td><td>中</td><td>低</td></tr><tr><td>Greedy</td><td>高</td><td>低</td></tr><tr><td>Dynamic Programming</td><td>高</td><td>低</td></tr><tr><td>Divide and Conquer</td><td>高</td><td>低</td></tr></tbody></table><p><img src="https://i.imgur.com/8W5UBAq.png"></p><p><img src="https://i.imgur.com/2HIi6Lh.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search Template</title>
      <link href="/post/binary-search-template/"/>
      <url>/post/binary-search-template/</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="左閉右開"><a href="#左閉右開" class="headerlink" title="左閉右開"></a>左閉右開</h2><ul><li><p><strong>選擇 <code>[left, right)</code> 左閉右開的原因 : 因為 while 判斷式為 <code>left &lt; right</code>, 當跳出迴圈時, <code>left == right</code>, 不用考慮說是要返回 <code>left</code> 還是 <code>right</code>, 因為兩者相等</strong></p></li><li><p><strong><code>g(x)</code> 為一 function, 找到一元素 <code>m</code> 滿足：</strong></p><ul><li><code>x ≥ m</code> 時, <code>g(x) &gt; 0</code>, 也就是 <code>g(x) = true</code></li><li><code>x &lt; m</code> 時, <code>g(x) ≤ 0</code>, 也就是 <code>g(x) = false</code></li></ul><p>  <strong>➔ 這樣做的用意是：找到一個臨界點 <code>m</code>, 能使區間 <code>[m, ∞)</code> 中的任意元素 <code>x</code> 皆滿足 <code>g(x) &gt; 0</code><br>  且區間 <code>(-∞, m)</code> 中的任意元素 <code>x</code> 皆滿足 <code>g(x) ≤ 0</code></strong></p><p>  <img src="https://i.imgur.com/gztaL7q.png"></p></li><li><p><strong>簡易模板：<a href="https://zako945.github.io/post/binary-search/">704. Binary Search</a></strong></p><p>  <img src="https://i.imgur.com/013DUlA.png"></p></li><li><p><strong>除非是特殊情況, 不然不要在 while 中做任何 return 的動作, 這樣做很有可能導致出錯</strong></p></li><li><p><strong>為何 while 判斷式為 <code>left &lt; right</code> ? 這種時候「考慮 edge case」就對了</strong></p><p>  e.g. <code>nums = [1]</code>, <code>target = 1</code></p><p>  ➔ <strong><code>g(x) = nums[mid] ≥ 1</code>, 目標是找到第一個 idx <code>i</code> 使得 <code>nums[i] ≥ 1</code> 成立</strong></p><ul><li><code>left = 0</code>, <code>right = 1</code> ➔ <code>mid = 0</code>, <code>nums[mid] = 1</code><br>  ➔ 因為 <code>1 ≥ 1</code> 成立, 所以 <code>g(1) = true</code> ➔ <code>right = mid = 0</code></li><li><code>left = 0</code>, <code>right = 0</code>, 跳出迴圈 ➔ 從位置 <code>0</code> 的元素開始 <code>≥ 1</code></li><li>返回 <code>left</code></li></ul></li><li><p><strong>左閉右開的缺點：<code>right</code> 容易 overflow, 像是 <a href="https://zako945.github.io/post/sqrtx/">69. Sqrt(x)</a>、<a href="https://zako945.github.io/post/first-bad-version/">278. First Bad Version</a></strong></p></li></ul><h2 id="左閉右閉（我都用這個）"><a href="#左閉右閉（我都用這個）" class="headerlink" title="左閉右閉（我都用這個）"></a>左閉右閉（我都用這個）</h2><ul><li><p><strong>簡易模板：</strong></p><p>  <img src="https://i.imgur.com/3i5xPAn.png"></p></li><li><p><strong>最後 <code>left</code> 會是第一個滿足 <code>g(x) = true</code> 的元素</strong></p></li><li><p><strong>使用時機：if 判斷式需要存取到 <code>idx = right</code> 的元素</strong></p></li><li><p><strong>範例 : <a href="https://zako945.github.io/post/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a> 由於需要判斷 <code>nums[right]</code> 故不適合用左閉右開</strong></p></li></ul><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><ul><li><p><strong>實現 <code>lowerBound()</code>：</strong></p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowerBound</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mid 右側元素皆 ≥ target, 故往左邊縮小區間</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left; <span class="comment">// left 為第一個 ≥ target 的數</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>實現 <code>upperBound()</code>：</strong></p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">upperBound</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mid 右側元素皆 &gt; target, 故往左邊縮小區間</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left; <span class="comment">// left 為第一個 &gt; target 的數</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 演算法統整 </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sliding Window Template</title>
      <link href="/post/sliding-window-template/"/>
      <url>/post/sliding-window-template/</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 擴大窗口</span></span><br><span class="line">        winodw.<span class="built_in">add</span>(s[right]);</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷窗口是否要收縮</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// 縮小窗口</span></span><br><span class="line">            winodw.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ul><li><strong>先透過擴大窗口來找到一個「可行解」</strong></li><li><strong>然後透過縮小窗口來優化這個「可行解」，進而找到最優解</strong></li></ul><h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><ul><li>區間為<strong>左閉右開 <code>[left, right)</code>,</strong> 因為若為左閉右閉, 則 <code>window</code> 中初始會有一個元素（這不符合我們定義的初始 <code>window</code> 為空）, 故應為左閉右開。</li></ul><h1 id="應注意的部分"><a href="#應注意的部分" class="headerlink" title="應注意的部分"></a>應注意的部分</h1><ul><li>何時移動 <code>right</code> 擴大窗口？窗口加入元素時，應該更新哪些變數？</li><li>窗口何時暫停擴大，開始移動 <code>left</code> 縮小窗口？從窗口移出元素時，應該更新哪些變數？</li><li>結果應該在擴大窗口還是縮小窗口的時候進行更新？</li></ul><h1 id="經典例題"><a href="#經典例題" class="headerlink" title="經典例題"></a>經典例題</h1><h2 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h2><ul><li><a href="https://zako945.github.io/post/minimum-window-substring/">76. Minimum Window Substring</a></li><li><a href="https://zako945.github.io/post/permutation-in-string/">567. Permutation in String</a></li><li><a href="https://zako945.github.io/post/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></li><li><a href="https://zako945.github.io/post/find-all-anagrams-in-a-string/">438. Find All Anagrams in a String</a></li><li><a href="https://zako945.github.io/post/longest-repeating-character-replacement/">424. Longest Repeating Character Replacement</a></li><li><a href="https://zako945.github.io/post/sliding-window-maximum/">239. Sliding Window Maximum</a></li><li><a href="https://zako945.github.io/post/minimum-size-subarray-sum/">209. Minimum Size Subarray Sum</a></li><li><a href="https://zako945.github.io/post/fruit-into-baskets/">904. Fruit Into Baskets</a></li></ul><h2 id="進階（不會也沒差）"><a href="#進階（不會也沒差）" class="headerlink" title="進階（不會也沒差）"></a>進階（不會也沒差）</h2><ul><li><a href="https://zako945.github.io/post/substring-with-concatenation-of-all-words/">30. Substring with Concatenation of All Words</a></li><li><a href="https://zako945.github.io/post/count-unique-characters-of-all-substrings-of-a-given-string/">828. Count Unique Characters of All Substrings of a Given String</a></li><li><a href="https://zako945.github.io/post/minimum-number-of-k-consecutive-bit-flips/">995. Minimum Number of K Consecutive Bit Flips</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 演算法統整 </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Programming Template</title>
      <link href="/post/dynamic-programming-template/"/>
      <url>/post/dynamic-programming-template/</url>
      
        <content type="html"><![CDATA[<h1 id="套路一：基本-1-型（時間序列）"><a href="#套路一：基本-1-型（時間序列）" class="headerlink" title="套路一：基本 1 型（時間序列）"></a>套路一：基本 1 型（時間序列）</h1><h2 id="觀念："><a href="#觀念：" class="headerlink" title="觀念："></a>觀念：</h2><ul><li><strong>給一 sequence, 每個元素可以被視為一天, 且「今天」的狀態只取決於「昨天」的狀態</strong></li></ul><h2 id="套路："><a href="#套路：" class="headerlink" title="套路："></a>套路：</h2><ul><li>定義 <code>dp[i][j]</code> 代表第 <code>i</code> 輪的第 <code>j</code> 個狀態</li><li>想辦法將 <code>dp[i][j]</code> 與前一輪的狀態 <code>dp[i - 1][j]</code> 產生關聯</li><li>最終的結果是 <code>dp[last][j]</code> 中的某種 aggregation（min, max, sum…）</li></ul><h2 id="例題："><a href="#例題：" class="headerlink" title="例題："></a>例題：</h2><ul><li><a href="https://zako945.github.io/post/house-robber/">198. House Robber</a></li><li><a href="https://zako945.github.io/post/house-robber-ii/">213. House Robber II</a></li><li><a href="https://zako945.github.io/post/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock</a></li><li><a href="https://zako945.github.io/post/best-time-to-buy-and-sell-stock-iii/">123. Best Time to Buy and Sell Stock III</a></li><li><a href="https://zako945.github.io/post/best-time-to-buy-and-sell-stock-with-cooldown/">309. Best Time to Buy and Sell Stock with Cooldown</a></li><li><a href="https://zako945.github.io/post/wiggle-subsequence/">376. Wiggle Subsequence</a></li><li><a href="https://zako945.github.io/post/paint-house/">256. Paint House</a></li><li><a href="https://zako945.github.io/post/max-consecutive-ones-ii/">487. Max Consecutive Ones II</a></li><li><a href="https://zako945.github.io/post/maximum-subarray-sum-with-one-deletion/">1186. Maximum Subarray Sum with One Deletion</a></li><li><a href="https://zako945.github.io/post/valid-permutations-for-di-sequence/">903.Valid Permutations for DI Sequence</a></li></ul><h1 id="套路二：基本-2-型（加強版時間序列）"><a href="#套路二：基本-2-型（加強版時間序列）" class="headerlink" title="套路二：基本 2 型（加強版時間序列）"></a>套路二：基本 2 型（加強版時間序列）</h1><h2 id="觀念：-1"><a href="#觀念：-1" class="headerlink" title="觀念："></a>觀念：</h2><ul><li><strong>給一 sequence, 每個元素可以被視為一天, 且「今天」的狀態取決於之前「某一天」的狀態, 需要進行挑選</strong></li></ul><h2 id="套路：-1"><a href="#套路：-1" class="headerlink" title="套路："></a>套路：</h2><ul><li><code>dp[i]</code> 表示第 <code>i</code> 輪的狀態, 通常這個狀態必須與元素 <code>i</code> 直接有關</li><li>想辦法將 <code>dp[i]</code> 與之前的狀態 <code>dp[j]</code> 產生關聯, 其中 <code>1 ≤ j &lt; i</code></li><li>最終的結果是 <code>dp[i]</code> 中的其中一個</li></ul><h2 id="例題：-1"><a href="#例題：-1" class="headerlink" title="例題："></a>例題：</h2><ul><li><a href="https://zako945.github.io/post/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a></li><li><a href="https://zako945.github.io/post/largest-divisible-subset/">368. Largest Divisible Subset</a></li><li><a href="https://zako945.github.io/post/filling-bookcase-shelves/">1105. Filling Bookcase Shelves</a></li><li><a href="https://zako945.github.io/post/minimum-cost-for-tickets/">983. Minimum Cost For Tickets</a></li></ul><h1 id="套路三：雙序列型"><a href="#套路三：雙序列型" class="headerlink" title="套路三：雙序列型"></a>套路三：雙序列型</h1><h2 id="觀念：-2"><a href="#觀念：-2" class="headerlink" title="觀念："></a>觀念：</h2><ul><li><strong>給兩個 sequence <code>s</code>、<code>t</code>, 讓你對它們搞事情</strong></li></ul><h2 id="套路：-2"><a href="#套路：-2" class="headerlink" title="套路："></a>套路：</h2><ul><li><code>dp[i][j]</code> 代表 <code>s[1:i]</code>、<code>t[1:j]</code> 的 subproblem 求解</li><li>將 <code>dp[i][j]</code> 跟之前的狀態 <code>dp[i - 1][j]</code>、<code>dp[i][j - 1]</code>、<code>dp[i - 1][j - 1]</code> 去做轉移</li><li>最終的結果是 <code>dp[m][n]</code></li></ul><h2 id="例題：-2"><a href="#例題：-2" class="headerlink" title="例題："></a>例題：</h2><ul><li><a href="https://zako945.github.io/post/longest-common-subsequence/">1143. Longest Common Subsequences</a></li><li><a href="https://zako945.github.io/post/shortest-common-supersequence/">1092. Shortest Common Supersequences</a></li><li><a href="https://zako945.github.io/post/edit-distance/">72. Edit Distance</a></li><li><a href="https://zako945.github.io/post/distinct-subsequences/">115. Distinct Subsequences</a></li><li><a href="https://zako945.github.io/post/minimum-window-subsequence/">727. Minimum Window Subsequence</a></li></ul><h1 id="套路四：區間-1-型"><a href="#套路四：區間-1-型" class="headerlink" title="套路四：區間 1 型"></a>套路四：區間 1 型</h1><h2 id="觀念：-3"><a href="#觀念：-3" class="headerlink" title="觀念："></a>觀念：</h2><ul><li><strong>給一 sequence <code>s</code>, 明確要求分割成 <code>k</code> 個區間, 要你計算這些區間某個最優性質</strong></li></ul><h2 id="套路：-3"><a href="#套路：-3" class="headerlink" title="套路："></a>套路：</h2><ul><li><code>dp[i][k]</code> 代表 <code>s[1:i]</code> 分割成 <code>k</code> 個區間時所能得到的最優解</li><li>搜尋<strong>最後一個區間的起始位置 <code>j</code></strong>, 將 <code>dp[i][k]</code> 分割成 <code>dp[j - 1][k - 1]</code> 和 <code>s[j:i]</code></li><li>最終的結果是 <code>dp[n][k]</code></li></ul><h2 id="例題序列型："><a href="#例題序列型：" class="headerlink" title="例題序列型："></a>例題序列型：</h2><ul><li><a href="https://zako945.github.io/post/palindrome-partitioning-iii/">1278. Palindrome Partitioning III</a></li><li><a href="https://zako945.github.io/post/largest-sum-of-averages/">813. Largest Sum of Averages</a></li><li><a href="https://zako945.github.io/post/split-array-largest-sum/">410. Split Array Largest Sum</a></li><li><a href="https://zako945.github.io/post/minimum-difficulty-of-a-job-schedule/">1335. Minimum Difficulty of a Job Schedule</a></li></ul><h1 id="套路五：區間-2-型"><a href="#套路五：區間-2-型" class="headerlink" title="套路五：區間 2 型"></a>套路五：區間 2 型</h1><h2 id="觀念：-4"><a href="#觀念：-4" class="headerlink" title="觀念："></a>觀念：</h2><ul><li>給一 sequence <code>s</code>, 求針對該 sequence 的最優解</li></ul><h2 id="套路：-4"><a href="#套路：-4" class="headerlink" title="套路："></a>套路：</h2><ul><li><code>dp[i][j]</code> 代表 <code>s[i:j]</code> 的 subproblem 求解</li><li>將大區間 <code>dp[i][j]</code> 往小區間 <code>dp[i&#39;][j&#39;]</code> 轉移<ul><li>for loop 外層循環是區間大小</li><li>for loop 內層循環是起始位置</li></ul></li><li>最終的結果是 <code>dp[1][n]</code></li></ul><h2 id="例題：-3"><a href="#例題：-3" class="headerlink" title="例題："></a>例題：</h2><ul><li><a href="https://zako945.github.io/post/longest-palindromic-subsequence/">516. Longest Palindromic Subsequence</a></li><li><a href="https://zako945.github.io/post/burst-balloons/">312. Burst Balloons</a></li><li><a href="https://zako945.github.io/post/guess-number-higher-or-lower-ii/">375. Guess Number Higher or Lower II</a></li><li><a href="https://zako945.github.io/post/palindrome-removal/">1246. Palindrome Removal</a></li><li><a href="https://zako945.github.io/post/remove-boxes/">546. Remove Boxes</a></li></ul><h1 id="套路六：背包型"><a href="#套路六：背包型" class="headerlink" title="套路六：背包型"></a>套路六：背包型</h1><h2 id="觀念：-5"><a href="#觀念：-5" class="headerlink" title="觀念："></a>觀念：</h2><ul><li>給 <code>n</code> 件物品, 每個物品可用、可不用（或者有若干個不同的用法）, 要求以某個有上限 <code>c</code> 的代價來實現最大收益</li><li>有時候會反過來，要求以某個有下限的收益來實現最小代價</li></ul><h2 id="套路：-5"><a href="#套路：-5" class="headerlink" title="套路："></a>套路：</h2><ul><li><code>dp[i][c]</code> 代表考慮只從前 <code>i</code> 件物品的 subset 中選擇、代價為 <code>c</code> 的最大收益<br>其中 <code>c = 1, 2, ..., C</code>（逐個列舉）</li><li>將 <code>dp[i][c]</code> 往 <code>dp[i - 1][c&#39;]</code> 轉移, 也就是考慮如何使用物品 <code>i</code>, 對代價／收益的影響<ul><li>外層循環是物品編號 <code>i</code></li><li>內層循環是遍歷「代價」所有可能的值</li></ul></li><li>最終的結果是 <code>max&#123;dp[n][c]&#125;</code>, for <code>c = 1, 2, ..., C</code></li></ul><h2 id="例題：-4"><a href="#例題：-4" class="headerlink" title="例題："></a>例題：</h2><ul><li><a href="https://zako945.github.io/post/target-sum/">494. Target Sum</a></li><li><a href="https://zako945.github.io/post/last-stone-weight-ii/">1049. Last Stone Weight II</a></li><li><a href="https://zako945.github.io/post/ones-and-zeroes/">474. Ones and Zeroes</a></li><li><a href="https://zako945.github.io/post/profitable-schemes/">879. Profitable Schemes</a></li><li><a href="https://zako945.github.io/post/tallest-billboard/">956. Tallest Billboard</a></li><li><a href="https://zako945.github.io/post/coin-change-ii/">518. Coin Change II</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 演算法統整 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Backtracking Template</title>
      <link href="/post/backtracking-template/"/>
      <url>/post/backtracking-template/</url>
      
        <content type="html"><![CDATA[<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ul><li><strong>窮舉所有可能</strong></li><li><strong>透過「撤銷選擇」的方式回到上次做出選擇的分歧點 <code>root</code>，以繼續遍歷其他選擇</strong></li></ul><p><img src="https://i.imgur.com/7gtMgIx.png"></p><h1 id="套路一：排列"><a href="#套路一：排列" class="headerlink" title="套路一：排列"></a>套路一：排列</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(選擇, 選擇列表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (滿足終止條件) &#123; <span class="comment">// 要處裡越界情況</span></span><br><span class="line">        res.<span class="built_in">add</span>(路徑);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; 選擇 : 選擇列表) &#123;</span><br><span class="line">        做選擇;</span><br><span class="line">        <span class="built_in">dfs</span>(選擇, 選擇列表);</span><br><span class="line">        撤銷選擇;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="經典例題"><a href="#經典例題" class="headerlink" title="經典例題"></a>經典例題</h2><ul><li><a href="https://zako945.github.io/post/permutations/">46. Permutations</a></li><li><a href="https://www.notion.so/51-N-Queens-3630c317a41c4a6b9cd1240f54295178?pvs=21">51. N-Queens</a></li><li><a href="https://zako945.github.io/post/n-queens/">47. Permutations II</a></li><li><a href="https://zako945.github.io/post/combinations/">77. Combinations</a></li><li><a href="https://zako945.github.io/post/sudoku-solver/">37. Sudoku Solver</a></li><li><a href="https://zako945.github.io/post/word-search/">79. Word Search</a></li><li><a href="https://zako945.github.io/post/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></li><li><a href="https://zako945.github.io/post/palindrome-partitioning/">131. Palindrome Partitioning</a></li></ul><h1 id="套路二：組合／子集"><a href="#套路二：組合／子集" class="headerlink" title="套路二：組合／子集"></a>套路二：組合／子集</h1><h2 id="寫法一："><a href="#寫法一：" class="headerlink" title="寫法一："></a>寫法一：</h2><pre><code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(選擇, 選擇列表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (滿足終止條件) &#123; <span class="comment">// 要處裡越界情況</span></span><br><span class="line">        res.<span class="built_in">add</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取</span></span><br><span class="line">    path.<span class="built_in">addLast</span>(選擇); <span class="comment">// 做選擇</span></span><br><span class="line">    <span class="built_in">dfs</span>(...);</span><br><span class="line">    path.<span class="built_in">removeLast</span>(選擇); <span class="comment">// 撤銷選擇</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不取</span></span><br><span class="line">    <span class="built_in">dfs</span>(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="寫法二："><a href="#寫法二：" class="headerlink" title="寫法二："></a>寫法二：</h2><pre><code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(選擇, 選擇列表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (滿足終止條件) &#123; <span class="comment">// 要處裡越界情況</span></span><br><span class="line">        res.<span class="built_in">add</span>(路徑);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若要取, 則會遞迴執行；若不取, 則 for loop 迭代到下一輪</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; 選擇 : 選擇列表) &#123;</span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (不滿足要取的條件) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        做選擇;</span><br><span class="line">        <span class="built_in">dfs</span>(選擇, 選擇列表);</span><br><span class="line">        撤銷選擇;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="經典例題-1"><a href="#經典例題-1" class="headerlink" title="經典例題"></a>經典例題</h2><ul><li><a href="https://zako945.github.io/post/subsets/">78. Subsets</a></li><li><a href="https://zako945.github.io/post/subsets-ii/">90. Subsets II</a></li><li><a href="https://zako945.github.io/post/combination-sum/">39. Combination Sum</a></li><li><a href="https://zako945.github.io/post/combination-sum-ii/">40. Combination Sum II</a></li><li><a href="https://zako945.github.io/post/generate-parentheses/">22. Generate Parentheses</a></li><li><a href="https://zako945.github.io/post/partition-to-k-equal-sum-subsets/">698. Partition to K Equal Sum Subsets</a></li><li><a href="https://zako945.github.io/post/generalized-abbreviation/">320. Generalized Abbreviation</a></li><li><a href="https://zako945.github.io/post/combination-sum-iii/">216. Combination Sum III</a></li><li><a href="https://zako945.github.io/post/letter-case-permutation/">784. Letter Case Permutation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 演算法統整 </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Graph Template</title>
      <link href="/post/graph-template/"/>
      <url>/post/graph-template/</url>
      
        <content type="html"><![CDATA[<h1 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h1><ul><li>拜訪過的節點要記得標記，避免重複拜訪</li><li>DFS 沒啥好講的，故跳過</li></ul><h1 id="BFS（剝洋蔥）"><a href="#BFS（剝洋蔥）" class="headerlink" title="BFS（剝洋蔥）"></a>BFS（剝洋蔥）</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(TreeNode* root, TreeNode* target)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    unordered_set&lt;TreeNode*&gt; visited; <span class="comment">// 避免重複拜訪</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>; <span class="comment">// 紀錄步數</span></span><br><span class="line">    q.<span class="built_in">emplace</span>(root); <span class="comment">// 將起點加入到 q 中</span></span><br><span class="line">    visited.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 將當前 q 中的所有節點向四周擴散</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判斷是否達到終點</span></span><br><span class="line">            <span class="keyword">if</span> (cur == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 cur 的相鄰節點加到 q 中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : cur.<span class="built_in">adj</span>()) &#123;</span><br><span class="line">                <span class="comment">// 如果相鄰節點未被拜訪過, 則將其加到 q 中</span></span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">find</span>(v) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    visited.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++step; <span class="comment">// 更新步數</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union Find"></a>Union Find</h1><h2 id="使用時機"><a href="#使用時機" class="headerlink" title="使用時機"></a>使用時機</h2><ul><li>判斷兩個元素「是否在同一個 set」（e.g. 判斷 Graph 中是否有 cycle）</li></ul><h2 id="初始條件"><a href="#初始條件" class="headerlink" title="初始條件"></a>初始條件</h2><ul><li><p>會用 <code>parents</code>、<code>ranks</code> 分別記錄每個 node 的 parent、以該點為 subtree root 的深度</p></li><li><p>一開始每個 node 的 rank 都是 <code>1</code></p></li><li><p>一開始每個 node 都是自己一個 set, 其 parent 指向自己</p><p>  <img src="https://i.imgur.com/LkqHIxD.png"></p></li></ul><h2 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h2><ul><li><p>查詢元素 <code>i</code> 的 root, e.g. 下圖中的 <code>1</code>、<code>5</code> 的 root 皆為 <code>2</code>, 因此 <code>1</code>、<code>5</code> 屬於同一個 set</p><p>  <img src="https://i.imgur.com/GDadqTK.png"></p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i != parents[i]) &#123; <span class="comment">// 若 i 不為 root</span></span><br><span class="line">        i = parents[i]; <span class="comment">// 則向上移動、查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><ul><li>將兩個不同的 set 合併成一個 set<ul><li><p>若深度不同, 則把深度低的 tree root 把深度高的 tree root 作為 parent</p></li><li><p>若深度一樣, 則可以任意選擇一個 root 作為 parent, 只是作為 parent 的 node 之 rank 值會加一, 因為深度變了</p><p>  <img src="https://i.imgur.com/h9zqQaO.png"></p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(parents, n1); <span class="comment">// root of n1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(parents, n2); <span class="comment">// root of n2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">    parents[r2] = r1;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[r1] &lt; ranks[r2]) &#123;</span><br><span class="line">    parents[r1] = r2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parents[r2] = r1;</span><br><span class="line">    ++ranks[r1]; <span class="comment">// 作為 parent 的 node 之 rank 值會變加一, 因為深度變了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Path-Compression"><a href="#Path-Compression" class="headerlink" title="Path Compression"></a>Path Compression</h2><ul><li><p>讓所有路徑上的點「直接」連到 root</p></li><li><p>在 <code>find(i)</code> 時將 <code>i</code> 的父親設為祖父, 直到其父親為 <code>root</code></p><p>  <img src="https://i.imgur.com/abRI1Sx.png"></p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i != parents[i]) &#123; <span class="comment">// 直到找到 root 才停止</span></span><br><span class="line">        parents[i] = parents[parents[i]]; <span class="comment">// 將父親設為祖父</span></span><br><span class="line">        i = parents[i]; <span class="comment">// 向上移動</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>時間複雜度：趨近 $O(1)$ 級別</p><p>  <img src="https://i.imgur.com/NTGGfBT.png"></p></li></ul><h1 id="經典例題"><a href="#經典例題" class="headerlink" title="經典例題"></a>經典例題</h1><ul><li><a href="https://zako945.github.io/post/number-of-islands/">200. Number of Islands</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 演算法統整 </category>
          
          <category> Graph </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BQ 常見問題</title>
      <link href="/post/bq-common-questions/"/>
      <url>/post/bq-common-questions/</url>
      
        <content type="html"><![CDATA[<h1 id="必考題"><a href="#必考題" class="headerlink" title="必考題"></a>必考題</h1><h2 id="對我們公司了解多少？"><a href="#對我們公司了解多少？" class="headerlink" title="對我們公司了解多少？"></a>對我們公司了解多少？</h2><ul><li><p>看面試者是否對於公司 or 這個職位有基礎的了解，他們希望找的人是對公司有熱誠的，而不是隨便海投的</p></li><li><p>他們同時也是在看你是不是個會自行搜尋、查找與整理資料的人，希望應徵的人是知道怎麼問出個好問題，具有好奇心，且知道如何找到答案，這樣可以稍微了解你在工作遇到問題時是怎麼去面對的</p></li><li><p>5W1H</p><ul><li>Who：老闆是誰？公司隸屬於哪個集團？</li><li>What：公司主推的業務、產品或研發內容？之後的目標是什麼？</li><li>Where：主攻哪個市場？有沒有想擴展版圖？</li><li>When：公司成立多久？是新創還是大公司？</li><li>Why：創立公司的理由？有什麼和其他公司不同之處？</li><li>How：公司如何營運？</li></ul></li><li><p>蒐集資料可以從這幾個管道下手</p><ul><li>工作的職缺描述</li><li>LinkedIn 公司首頁</li><li>公司官網上的關於我們、發展歷史</li><li>GlassDoor 上面試的評價和回饋</li><li>社群帳號發文如 Facebook、Twitter、Instagram 等</li><li>新聞媒體報導</li><li>是否有人也在這間公司工作，詢問相關訊息，不管是不是在社交圈內都可以去嘗試詢問</li><li>在 Twitter 上搜尋公司的名字，通常可以找到該公司的員工，如果對方所在的團隊跟自己尋找的職缺相符，可以直接私訊看有沒有機會聊聊，關於在該公司的工作經驗、文化，建立個人 networking，以交朋友的方式閒聊即可</li></ul></li><li><p>回答範例</p><blockquote><p>在我準備面試期間，我深入了解了貴公司的產品和服務。我發現貴公司專注於開發創新的軟體解決方案，涵蓋了多個行業和領域。我還研究了貴公司的核心 tech stack 和開發流程，發現貴公司採用敏捷開發方法，注重團隊合作和持續交付價值。</p><p>此外，我也關注了貴公司在業界的聲譽和地位。我看到貴公司曾獲得多個獎項，證明了其在軟體開發領域的卓越表現。我還留意到貴公司在社區和開源項目中的積極參與，表明貴公司注重知識分享和技術創新。</p><p>通過這些調研，我對貴公司的願景、使命和核心價值觀有了初步的了解，並且對貴公司的工作環境和文化也有了一定的認識。我很欣賞貴公司致力於技術創新和團隊合作的理念，這與我個人的價值觀非常契合。</p><p>然而，我也認識到在面試過程中，我有很多機會深入了解貴公司更多的方面，並與面試官進一步探討貴公司的發展、項目和團隊結構等。我期待有機會加入貴公司，並與團隊共同努力，為公司的成功做出貢獻。</p></blockquote></li></ul><h2 id="為什麼對我們公司感興趣？"><a href="#為什麼對我們公司感興趣？" class="headerlink" title="為什麼對我們公司感興趣？"></a>為什麼對我們公司感興趣？</h2><ul><li><p>了解面試者來應徵這家公司的原因，不希望來應徵的人是隨意挑個職缺來面試，而是這間公司或職缺哪裡吸引你，你對這份工作是有熱情的</p></li><li><p>Tips</p><ul><li>事先調查這間公司的特殊之處，比如這間公司是因為什麼原因而成立的，是哪一點吸引你，把這點連結到你個人的故事敘述出來</li><li>你的經驗如何提升該公司的核心價值、產品或服務，如果有想到營運相關的提案可以運用在這間公司也可以提出來</li><li>利用提及自己跟該公司的某個團隊的成員聊過的經驗當作上述兩點的佐證</li><li>要表現出會選擇該公司並非是海投履歷的結果，而是要表現是對該公司的熱情</li></ul></li><li><p>回答範例</p><blockquote><p>我對貴公司感興趣的原因有幾個方面。首先，貴公司在業界享有很高的聲譽，以開發創新的軟體解決方案而聞名。我一直追求在一個技術先進且富有創造力的環境中工作，而貴公司正是提供這樣的機會。</p><p>其次，我深深被貴公司在技術創新方面的努力所吸引。從我對貴公司的研究中，我了解到貴公司不斷推動最新的技術趨勢，並積極探索人工智能、雲端計算和大數據等領域的前沿技術。作為一名軟體工程師，我希望能夠在一個持續學習和不斷進步的環境中工作，並與頂尖團隊一起追求技術的突破和創新。</p><p>此外，貴公司的工作文化和價值觀也與我非常契合。我看到貴公司強調團隊合作、開放溝通和共同成長。我相信一個積極的工作環境和良好的團隊協作能夠激發個人的最佳表現，並為項目的成功做出貢獻。貴公司所倡導的價值觀也與我個人的價值觀相一致，包括誠信、品質導向和持續創新。</p><p>最後，我對貴公司的產品和服務深感興趣。我認為貴公司所提供的軟體解決方案能夠為客戶帶來真正的價值，並解決他們的問題。作為一名軟體工程師，我希望能夠參與開發出具有影響力和實用性的產品，並為用戶提供卓越的體驗。</p></blockquote></li></ul><h2 id="為什麼想要這份工作？"><a href="#為什麼想要這份工作？" class="headerlink" title="為什麼想要這份工作？"></a>為什麼想要這份工作？</h2><ul><li><p>他們真正想知道的</p><ul><li>評估這間公司的文化、工作環境是否適合你</li><li>衡量錄用你之後會不會因為公司不符合其中幾個條件不滿意而離職</li><li>你是否對於工作內容和公司有一定程度了解</li><li>你有什麼技術、個人特質和這份職缺是有相關的</li><li>團隊文化是否相符你的期望</li></ul></li><li><p>注意事項</p><ul><li>避免一直在談論自己，重點是圍繞在你可以為公司帶來什麼，且公司又能為你做到什麼</li><li>把公司當作跳板、或是之後想去別的國家工作都是避免不要講出來的，儘管想這樣做，但講出來面試官會覺得錄取你沒多久你就會離職了</li><li>將蒐集到的相關資訊與你的目標結合，切中要點的說明為什麼你適合這份職缺，並提到公司和職缺什麼地方最吸引你，你的經驗、技術可以為公司另外帶來什麼利益。e.g. 你運用什麼方式為前公司帶來營收，並提到說在這家公司你會怎麼做來增加營收</li></ul></li><li><p>回答範例</p><blockquote><p>我對這份工作感興趣的原因有幾個方面。首先，作為一名熱衷於軟體工程的專業人士，我對解決複雜問題和構建創新解決方案充滿激情。我了解到貴公司是一家在軟體開發領域具有卓越聲譽的公司，它提供了一個充滿挑戰和成長機會的工作環境。我希望能夠在一個技術先進且富有創造力的團隊中工作，與頂尖的專業人士一起合作，共同推動軟體工程領域的發展。</p><p>其次，我對貴公司所涉及的項目和產品感到非常興趣。通過我的調研，我了解到貴公司正在開發創新的軟體解決方案，應用於各種行業和領域。這些項目不僅具有技術挑戰，而且對於改善用戶體驗和提升業務效率具有重要意義。作為一名軟體工程師，我渴望能夠參與這樣的項目，並將我的技術和創意投入到其中，為客戶和用戶提供卓越的軟體產品。</p><p>此外，貴公司的價值觀和文化也與我個人的價值觀非常契合。我看到貴公司注重團隊合作、開放溝通和持續學習。這種文化氛圍不僅能夠促進團隊的協作和創新，而且能夠激發個人的潛力和成長。我相信在這樣的工作環境中，我可以不斷學習和提升自己的技能，並與優秀的同事們共同成長。</p><p>最後，我對貴公司的發展前景非常樂觀。通過我的研究和了解，我看到貴公司在市場上的競爭力和業務增長潛力。我希望能夠加入一個具有遠見和創新精神的組織，為貴公司的成功貢獻我的才能和努力。我相信在這樣一個具有發展空間和機會的公司中工作，我能夠實現個人和職業目標。</p></blockquote></li></ul><h2 id="介紹你自己"><a href="#介紹你自己" class="headerlink" title="介紹你自己"></a>介紹你自己</h2><ul><li><p>他們真正想知道的</p><ul><li>個人背景、特質、經驗</li><li>你能為公司帶來怎樣的好處？有什麼經驗可以貢獻？</li></ul></li><li><p>Tips</p><ul><li><p>以從你個人的興趣或是經驗談起，講點小故事，引起對方興趣；也可以講現在的職業、學業和工作經驗，以及未來想做什麼</p></li><li><p>剛開始面試前通常對方會先自我介紹，然後按照不同職位的人講不同的自我介紹內容，同時也準備 3 分鐘和 5 分鐘的版本</p></li><li><p>如果是面對 HR</p><ul><li>偏重個性描述，連結自我介紹和這份工作的內容</li><li>了解這公司開這職缺所需要的原因是什麼，提出可以為公司帶來什麼</li></ul></li><li><p>如果是面對技術人員</p><ul><li>偏重技術描述，簡單的介紹自己過去經驗</li><li>為了解決什麼問題，所以使用什麼技術，連結自己技術和這份工作的職缺關鍵字</li><li>了解這公司開這職缺所需要的原因是什麼，提出可以為公司帶來什麼？</li></ul></li></ul></li><li><p>回答範例</p><blockquote><p>參考<a href="https://zako945.github.io/post/self-introduction/">自我介紹</a></p></blockquote></li></ul><h2 id="我們為什麼要錄用你？"><a href="#我們為什麼要錄用你？" class="headerlink" title="我們為什麼要錄用你？"></a>我們為什麼要錄用你？</h2><ul><li><p>他們真正想知道的</p><ul><li>你能為這家公司做什麼？</li><li>為什麼要選擇錄用你，而不是其他人？</li></ul></li><li><p>Tips</p><ul><li>事先列出這份工作的職缺關鍵字，比如需要溝通能力很好、需要特定的技術、公司特別看重什麼部份</li><li>在敘述時連結你的個性、技術與經驗如何應用到這個職位，你可以為公司做到什麼，或是他們網站目前缺少什麼技術你可以導入、你覺得這間公司還可以朝什麼方向發展、增加什麼營運或業務邏輯等</li></ul></li><li><p>回答範例</p><ul><li><p>會問這問題的公司通常都偏雷，至少我面試的時候從沒被問過這種問題。這個應該是公司自己要評估的問題，而不是問面試者，怎麼會有公司職缺開出來連自己要招什麼人、有什麼需求、要解決什麼問題都不知道&#x3D; &#x3D;。如果我遇到這類問題會再次強調自介中提到的優點</p><blockquote><p>我相信我具備了能夠滿足這個職位需求的技能和特質。首先，我擁有廣泛的軟體工程知識和經驗。我在大學和研究所學習計算機科學，並且在過去的工作和專案中，我積累了豐富的實際開發經驗。我熟悉多種程式語言和開發工具，包括C、C++、Python和相關的開發框架。這些技能使我能夠快速適應不同的技術環境並解決複雜的問題。</p><p>此外，我擁有優秀的團隊合作和溝通能力。在之前的工作和專案中，我與不同背景的團隊成員密切合作，我善於協調和組織團隊，並確保項目按時交付。我也能夠清晰地表達自己的想法和觀點，並且能夠有效地與不同的利益相關者進行溝通。</p><p>不僅如此，我對持續學習和專業發展非常重視。我時刻關注著科技行業的最新趨勢和技術變化，並且持續學習和提升自己的技能，以保持自己的競爭力並能夠應對新的挑戰。</p><p>最後，我具備良好的問題解決能力和創造力。我喜歡面對困難並找到解決方案的過程。我相信創新和不斷探索新的方法可以帶來更好的結果。</p><p>綜上所述，我相信我具備了在這個職位上取得成功所需的技能、團隊合作能力、持續學習的心態和問題解決能力。我將致力於在這個公司做出積極的貢獻，並與團隊共同實現公司的目標。</p></blockquote></li></ul></li></ul><h2 id="之後職涯的規劃是什麼？"><a href="#之後職涯的規劃是什麼？" class="headerlink" title="之後職涯的規劃是什麼？"></a>之後職涯的規劃是什麼？</h2><ul><li><p>他們真正想知道的</p><ul><li>你會不會很快就離職</li><li>是否清楚自己未來的計劃</li><li>如何在公司發展你的專業，並承擔工作相關的責任</li><li>公司是否有能力提供你想要的給你</li></ul></li><li><p>Tips</p><ul><li>你的回答應專注在應徵的工作內容做結合，且強調你想把這份工作當成長期目標</li><li>為了什麼目的，想要學習某技術，以利之後用在公司的什麼方面</li></ul></li><li><p>回答範例</p><blockquote><p>我的職業規劃是不斷提升自己的技術能力，承擔更多的責任和角色，並通過跨團隊合作和個人發展成為一名全面發展的軟體工程師。我相信在貴公司這樣具有挑戰和發展機會的環境中，能夠實現我的職業目標並取得長期的成就。</p></blockquote></li></ul><h2 id="個人經歷"><a href="#個人經歷" class="headerlink" title="個人經歷"></a>個人經歷</h2><h3 id="重點"><a href="#重點" class="headerlink" title="重點"></a>重點</h3><ul><li>你待過的公司主要是提供什麼服務？</li><li>工作經歷中間如果有斷層通常會問原因，為什麼離開前一份工作？</li><li>負責的職務、使用的技術、產品的部屬流程、工作的流程、團隊的組成、有沒有和其他人合作的經驗、在履歷上你提到的相關貢獻是使用什麼技術、如何達成，產生什麼結果</li><li>對方如果是新創公司會很愛問你對新創的看法 or 是否有待過新創，感想是什麼？</li><li>開發流程如果有提到敏捷開發，面試官往往都很有興趣問那你們是怎麼跑的</li></ul><h2 id="描述你目前-or-以前的職位"><a href="#描述你目前-or-以前的職位" class="headerlink" title="描述你目前 or 以前的職位"></a>描述你目前 or 以前的職位</h2><ul><li><p>他們真正想知道的</p><ul><li>你在公司是負責什麼職務，這些經驗和技能是否能為公司所用？</li><li>團隊中你是扮演什麼樣的角色？你是一個 problem solver？leader？</li></ul></li><li><p>Tips</p><ul><li>敘述你負責的項目，有沒有特別傑出可以拿出來講的，比如得過麼獎項、運用什麼技術來增進效能、改進什麼業務邏輯提升公司利益，並運用資料去量化相關的指標</li><li>回想你平常在團隊所擔任的角色，有沒有改善工作流程、環境、引進 or 分享技術，大家有問題時會向你請教嗎？</li></ul></li></ul><h2 id="為什麼要辭去工作？"><a href="#為什麼要辭去工作？" class="headerlink" title="為什麼要辭去工作？"></a>為什麼要辭去工作？</h2><ul><li><p>他們真正想知道的</p><ul><li>想知道你是不是被資遣 or 裁員的</li><li>會不會再因為同樣的因素提出辭呈</li></ul></li><li><p>Tips</p><ul><li>誠實敘述你的情況但是要有策略性的回答，保持正向與積極的回答。不要說太多個人的事情，比如對工作感到厭倦、抱怨前公司、前公司沒有挑戰性、同事很難相處之類的話，會讓對方懷疑你的個人特質和技術</li></ul></li><li><p>回答範例</p><ul><li>在前公司較少有機會可以表現，而感到挫折，然後敘述你完成了什麼事情，覺得自己被限制住發展，所以你希望藉由申請此職位達到職涯上的突破</li></ul></li></ul><h2 id="你的優、缺點是什麼？"><a href="#你的優、缺點是什麼？" class="headerlink" title="你的優、缺點是什麼？"></a>你的優、缺點是什麼？</h2><ul><li><p>他們真正想知道的</p><ul><li>是否熟知自己的優點，並知道要如何發揮</li><li>是否了解自己的缺點，並有實際行為去改善</li></ul></li><li><p>Tips</p><ul><li>列出和這份職缺敘述所需的相關優點，和自己的優點相連結，或提出你認為最大的優點，比起只是單純描述，舉出實例來說明比較能說服人</li><li>舉出實例描述不太嚴重的缺點，講出你做了什麼改善，並從中學到什麼</li></ul></li><li><p>回答範例</p><blockquote><p>首先，我認為我有兩個主要的優點。第一個是我對問題的解決能力。作為一名軟體工程師，遇到問題是不可避免的，但我擅長分析和解決這些問題。我能夠快速定位問題的根本原因，並提出有效的解決方案。這使我在面對複雜的技術挑戰時能夠保持冷靜和效率。</p><p>另一個優點是我的學習能力和進取心。我對新技術和工具保持著濃厚的興趣，並不斷致力於自我學習和專業成長。我喜歡探索新的領域，了解最新的發展趨勢。這種學習能力和進取心使我能夠不斷提升自己的技能，並保持與行業的步伐同步。</p><p>接下來是我的一個缺點，那就是我有時候過於追求完美。作為一名軟體工程師，精確和品質是非常重要的，但有時候我會花費過多的時間在細節上，以確保每個方面都完美無缺。這可能會導致我在時間管理方面需要更多的努力，以確保項目能按時完成。不過，我一直都有在努力找尋平衡點，並學習如何在保持品質的同時提高效率。</p></blockquote></li></ul><h2 id="偏好大公司還是新創公司？"><a href="#偏好大公司還是新創公司？" class="headerlink" title="偏好大公司還是新創公司？"></a>偏好大公司還是新創公司？</h2><ul><li><p>他們真正想知道的</p><ul><li>你是否待過大公司 or 新創</li><li>你對新創、大公司的想法</li><li>是否有團隊合作的經驗</li></ul></li><li><p>Tips</p><ul><li>通常對方是新創公司才會問這問題，提出你覺得新創公司好的地方，比如可以身兼多職，學習和挑戰很多事物</li><li>在大公司中，可以得到系統性的訓練、大量的資源，個人履歷也會有大公司品牌的加持。在大公司中的 3 年內可能會學到很多東西，但 3 年後的工作內容極大可能較為重複</li><li>在小公司中，幾年內都會保持非常快速的學習狀態，會比較全面提升自己的能力，雖然可能會缺少豐富的資源。小公司更適合想要學東西、快速成長的人</li></ul></li><li><p>回答範例</p><blockquote><p>我認為大公司和新創公司都有各自的優點，而我的選擇會基於我目前的職業目標和成長需求。對於大公司，我欣賞其穩定性、完善的組織結構和豐富的資源。在一個大型團隊中工作，我可以從資深的同事中學習到許多經驗和知識，並且參與複雜的專案。另一方面，我也對新創公司充滿好奇和興趣。在新創公司，我可以更加靈活和創造性地解決問題，參與整個產品開發的過程並快速學習。最重要的是，我想在一個能夠挑戰和發展我的技能的環境中工作，並能對產品的發展做出實質性的貢獻。所以，無論是大公司還是新創公司，我都期待著能夠在一個充滿活力和成長機會的團隊中工作。如果真的要說的話：</p><ul><li><p>我更喜歡在一個較小的團隊中工作，因為這樣我可以保持非常快速的學習狀態，這樣會比較全面提升自己的能力</p></li><li><p>我更喜歡在一個較大的團隊中工作，因為較大的團隊通常可以發布更大的有影響力的項目</p></li></ul></blockquote></li></ul><h1 id="衝突處理"><a href="#衝突處理" class="headerlink" title="衝突處理"></a>衝突處理</h1><h2 id="跟別人意見不合時會如何處理？"><a href="#跟別人意見不合時會如何處理？" class="headerlink" title="跟別人意見不合時會如何處理？"></a>跟別人意見不合時會如何處理？</h2><ul><li><p>他們真正想知道的</p><ul><li>你遇到你是對的情況時是否會據理力爭，用什麼方式去跟對方溝通</li></ul></li><li><p>Tips</p><ul><li>表示出你有自己的主見，對於正確的事情會堅持，並且擁有良好的溝通技巧</li><li>回答問題時，強調你的積極態度、溝通能力、解決問題的導向和合作精神是非常重要的。這樣的回答可以展示你具備處理衝突的能力，並且能夠在團隊中建立和諧</li></ul></li><li><p>回答範例</p><blockquote><p>首先，我會嘗試以積極的態度和開放的心態面對衝突。我相信發生衝突是很自然的，而且在團隊中也是不可避免的。一個團隊中的成員可能會有不同的觀點、利益和工作風格，這可能導致衝突的發生。</p><p>舉一個實際例子，假設在我之前的團隊項目中，我們面臨了一個時間緊迫的情況，我們需要在短時間內完成一個重要的功能開發。然而，團隊中的兩個成員對於實現該功能的方法存在分歧。一個成員主張採用一種技術方案，而另一個成員則傾向於另一種方案。</p><p>在這種情況下，我會採取以下步驟處理衝突：</p><ul><li><p>聆聽並理解：我會耐心傾聽每個成員的觀點，並努力理解他們的論點和背後的動機。這有助於我獲得全面的認識，並尊重每個成員的意見。</p></li><li><p>尋求共識：我會嘗試促使成員之間達成共識。這可能包括組織小組討論，讓每個成員闡述自己的觀點並試圖找到共同點。通過溝通和協商，我們可以探索折衷方案或整合不同的想法。</p></li><li><p>尋求中立的第三方意見：如果我們陷入了僵局，無法取得共識，我會建議尋求中立的第三方意見。這可以是團隊領導、項目經理或其他具有相關專業知識的人。第三方的觀點可能有助於打破僵局，並找到解決方案。</p></li><li><p>以解決問題為導向：無論最終的決策是什麽，我會確保我們關注解決問題，並專注於達成項目目標。我會與團隊成員合作，確保決策的執行，並確保大家都參與其中。</p></li><li><p>學習和改進：處理衝突是一個學習和成長的機會。我會與團隊成員反思整個衝突解決過程，尋找改進的方法，並確保類似的衝突不再重演。</p></li></ul></blockquote></li></ul><h1 id="時間管理"><a href="#時間管理" class="headerlink" title="時間管理"></a>時間管理</h1><h2 id="當工作很多時，你如何分配時間？"><a href="#當工作很多時，你如何分配時間？" class="headerlink" title="當工作很多時，你如何分配時間？"></a>當工作很多時，你如何分配時間？</h2><ul><li><p>他們真正想知道的</p><ul><li>你是否有良好的時間管理技巧和能力，以確保工作按時完成</li><li>你是否能識別並處理重要且緊急的任務，同時保持對其他任務的關注</li><li>你如何應對突發情況、變動的優先順序或工作量的增加</li><li>你是否能夠保持冷靜、有效地應對壓力，並在高工作量的情況下保持高效</li></ul></li><li><p>Tips</p><ul><li>通常公司會希望找到一位能夠有效處理多個任務並保持高效率的人。因此，回答時應該突出這些方面的能力，並提供具體的例子來佐證</li></ul></li><li><p>回答範例</p><blockquote><p>首先，我會先評估每個任務的優先級和 deadline。然後，我會與相關人員溝通，了解每個任務的重要性和緊急程度，並將它們按照優先級進行排序。這有助於我確定哪些是應該優先處理的任務。</p><p>其次，我會制定一個時間管理計劃，將工作任務分解為小的可管理部分。我會估計每個任務所需的時間，並設定合理的時間目標。這有助於我保持組織性，並確保每個任務都能得到充分的關注和完成。</p><p>此外，我會優化我的工作流程和使用工具來提高效率。我會尋找自動化和自動化工具的機會，減少重複性任務的時間消耗。同時，我會善用任務管理工具和日程安排工具來追蹤和組織我的工作。</p><p>舉個例子來說，如果我面臨多個工作任務，其中一個是修復一個緊急的軟體漏洞，而另一個是參與一個新功能的開發。首先，我會與相關方討論並確定修復漏洞的緊急性。如果漏洞可能導致系統安全風險，我會將其優先級提高。然後，我會將時間分配給修復漏洞，確保它能夠按時解決。</p><p>同時，我會在修復漏洞的同時安排一些時間來研究新功能的需求和相關技術。這樣我可以在修復漏洞後迅速轉移到新功能的開發，以確保進度不會延遲。</p></blockquote></li></ul><h1 id="壓力處理"><a href="#壓力處理" class="headerlink" title="壓力處理"></a>壓力處理</h1><h2 id="你是如何在緊迫的期限內完成任務的？"><a href="#你是如何在緊迫的期限內完成任務的？" class="headerlink" title="你是如何在緊迫的期限內完成任務的？"></a>你是如何在緊迫的期限內完成任務的？</h2><ul><li><p>他們真正想知道的</p><ul><li>如果工作時遇到高壓如何調適，在壓力下是否也能完成工作</li><li>在生活中遇到的壓力是否會影響你的工作表現</li></ul></li><li><p>Tips</p><ul><li>不要否認你從未遇過壓力，舉出實例解釋你如何處理，不要花太多時間在抱怨說你感受到多大的壓力，你是如何去處理且把這件事變成你的優勢</li><li>舉例時需注意不要和職缺有衝突到，比如這份工作需要你同時做很多專案，你又說你對於同時做很多專案感到壓力，會讓人覺得你不適合這份工作</li><li>準備實例讓對方知道你如何處理壓力，表達認真努力的態度以及加班超時工作的底線和原則，面試是雙向的，如果公司是要找一個免洗爆肝奴才，那你最好趕快跑</li></ul></li><li><p>回答範例</p><blockquote><p>有一次，我接到了一項艱鉅的任務，即在緊迫的期限內從頭開始構建一個新的應用程式。認識到在保持高品質標準的同時按時完成任務的重要性，我全身心地投入到這個項目中，努力工作，甚至加班。然而，在那緊張的幾周里，我確保優先考慮兩個關鍵方面：確保我有足夠的睡眠以保持身體健康，並專注於提供一流的應用程式。</p><p>雖然我致力於整天努力工作以實現目標，但我從未在身體健康方面妥協。我堅信，保持健康的身體對於維持生產力和取得最佳成果至關重要。通過在專注工作和自我照顧之間取得平衡，我能夠在 deadline 前成功完成應用程式，既實現了項目目標，也實現了我個人對保持健康生活方式的承諾。</p></blockquote></li></ul><h1 id="環境適應"><a href="#環境適應" class="headerlink" title="環境適應"></a>環境適應</h1><h2 id="如何處理變化？"><a href="#如何處理變化？" class="headerlink" title="如何處理變化？"></a>如何處理變化？</h2><ul><li><p>他們真正想知道的</p><ul><li>想知道如果遇到環境改變或是工作上的臨時狀況，是否可以良好適應</li></ul></li><li><p>Tips</p><ul><li>在遇到環境改變時，是否能從容應對，舉出實例說明</li><li>說明你遇到過什麼事情，如何去克服的；如果沒有也沒關係，比如遇到公司合併這種事也是可以拿出來講</li></ul></li><li><p>回答範例</p><blockquote><p>作為軟體工程師，我了解在項目開發過程中，變化是不可避免的。我有以下幾個方法處理變化：</p><p>首先，我會保持靈活性和開放的態度。我明白要應對變化，我需要擺脫固執的思維模式並願意接受新的觀點和方法。我願意聆聽他人的建議和意見，並願意適應新的需求和情況。</p><p>其次，我會與團隊密切合作。當有變化發生時，我會與團隊成員溝通並共同探討如何適應變化。我相信團隊合作是解決問題和應對變化的關鍵。我會積極參與討論，提出建議並找到適合團隊的解決方案。</p><p>此外，我會進行風險評估和優先排序。當有變化發生時，我會評估變化帶來的風險和影響，並根據優先級進行排序。這有助於確定應該先處理的變化和相應的行動計劃。</p><p>最後，我會保持積極的態度和解決問題的能力。我相信每個變化都是一個機會，可以提升項目的成果和團隊的能力。我會集中精力解決問題，找到解決方案並盡快適應新的情況。</p></blockquote></li></ul><h2 id="遇過最困難的問題是什麼？"><a href="#遇過最困難的問題是什麼？" class="headerlink" title="遇過最困難的問題是什麼？"></a>遇過最困難的問題是什麼？</h2><ul><li><p>他們真正想知道的</p><ul><li>面試官想知道你如何處理衝突 or 挑戰</li></ul></li><li><p>Tips</p><ul><li>可以先反問面試官，是要舉工作上還是生活上的例子</li><li>舉出實例說明你遇到什麼事情，中途遇到什麼困難、如何解決、有沒有與別人求助、有沒有團隊合作等</li><li>展示你在面對困難時的解決問題的能力、團隊合作精神和適應變化的能力。重點強調你的應對措施和取得的成果，以展示你的解決問題的能力和工作素質</li></ul></li><li><p>回答範例</p><blockquote><p>遇到最困難的問題之一是在我上一份工作中，我負責開發一個複雜的應用程式。這個項目在開始時沒有明確的需求和規格說明，而且由於時間緊迫，我們必須在限定的時間內交付。</p><p>為了應對這些挑戰，我採取了以下措施：</p><p>緊密合作：我與團隊成員和 stakeholder 緊密合作，確保大家對項目目標和需求的理解保持一致，並及時解決任何潛在的問題 or 疑慮。</p><p>迭代開發：我們採用了敏捷開發，通過快速迭代和反饋循環，逐步完善需求和功能，並確保我們的開發工作與最終用戶的期望保持一致。</p><p>強調測試和品質：我確保我們的開發工作與高品質的代碼編寫和全面的測試相結合。我們注重自動化測試和 code review，以確保系統的可靠性和穩定性。</p><p>最終，通過團隊的努力和有效的溝通，我們成功地交付了這個應用程式，滿足了客戶的需求並獲得了積極的反饋。</p></blockquote></li></ul><h1 id="工作倫理"><a href="#工作倫理" class="headerlink" title="工作倫理"></a>工作倫理</h1><h2 id="目前工作中最喜歡和最不喜歡的是什麼？"><a href="#目前工作中最喜歡和最不喜歡的是什麼？" class="headerlink" title="目前工作中最喜歡和最不喜歡的是什麼？"></a>目前工作中最喜歡和最不喜歡的是什麼？</h2><ul><li><p>他們真正想知道的</p><ul><li>工作倫理相關，如何應對工作上令你感到不舒適的狀況</li><li>該公司是否也會有相同的文化或流程會讓你感到開心 or 不開心</li></ul></li><li><p>Tips</p><ul><li>面對工作上不喜歡的事物，不要只是抱怨 or 離職，而沒去做相關的改善，舉例說明你使用什麼技術 or 能力去解決這件事</li><li>你可以展示你對技術問題的熱情和解決問題的能力，同時表達了對工作環境和自我成長的關注。這顯示了你對於自我管理和工作滿意度的認識</li></ul></li><li><p>回答範例</p><blockquote><p>我最喜歡的是能夠解決複雜問題，並參與構建有意義的軟體解決方案。在我目前的工作中，我非常享受與團隊合作，共同研究和設計解決方案的過程。我喜歡在面對技術挑戰時能夠提出創新的解決方法，並與同事們合作共同實現項目的目標。</p><p>有一次，我們在一個項目中面臨了一個性能優化的挑戰。我喜歡挖掘代碼中的瓶頸，並提出針對性的優化措施。通過使用各種技術工具和進行代碼分析，我能夠定位問題並提出改進的方案。與團隊合作，我們成功地優化了應用程式的性能，並取得了顯著的改進。</p><p>至於最不喜歡的方面，我可能會提到在項目中遇到的一些挑戰和壓力。有時候，項目進度緊迫，需要在有限的時間內完成任務，這可能導致工作壓力增加。然而，我相信良好的時間管理和團隊協作可以幫助我應對這些挑戰，並找到平衡。</p><p>我會強調我喜歡挑戰和解決問題的過程，但也明確表示我對於良好的工作生活平衡和健康的工作環境的重視。同時，我會提到我正在學習如何更好地管理壓力，並持續改進自己的時間管理和應對能力。</p></blockquote></li></ul><h1 id="失敗處理"><a href="#失敗處理" class="headerlink" title="失敗處理"></a>失敗處理</h1><h2 id="什麼時候受過挫折？"><a href="#什麼時候受過挫折？" class="headerlink" title="什麼時候受過挫折？"></a>什麼時候受過挫折？</h2><ul><li><p>他們真正想知道的</p><ul><li>想知道你是否負責任，不是找藉口 or 責怪別人，而是從錯誤中學習，並且利用此經驗在下一次處理事情上</li></ul></li><li><p>Tips</p><ul><li>不要找藉口 or 怪罪別人</li><li>舉出實例說明，但不要是頻繁發生的問題，這樣會顯示你是個粗心的人，或是可能會造成公司有嚴重的損失</li><li>顯示你從中學到什麼，然後如何運用在之後的事情上</li></ul></li><li><p>回答範例</p><blockquote><p>有一次，後端團隊中的其他人更改了API JSON 輸出格式，導致我們的解碼元件無法解碼這個 JSON 資料。因此，我為解碼元件寫了一個測試單元，以防止這種情況再次發生。</p><p>為了避免再犯同樣的錯誤，我開始學習更多關於測試的知識，例如 TDD（Test-Driven Development）。這使我成為了更好的開發人員。</p></blockquote></li></ul><h1 id="團隊合作"><a href="#團隊合作" class="headerlink" title="團隊合作"></a>團隊合作</h1><h2 id="傾向獨立工作還是團隊合作？"><a href="#傾向獨立工作還是團隊合作？" class="headerlink" title="傾向獨立工作還是團隊合作？"></a>傾向獨立工作還是團隊合作？</h2><ul><li><p>他們真正想知道的</p><ul><li>這份職缺可能需要獨立工作 or 需要跟人合作，想知道你的傾向</li></ul></li><li><p>Tips</p><ul><li>這個問題沒有對或錯的答案，端看你的工作是不是需要跟人合作</li><li>但不管你的傾向如何，不要回答說你沒辦法獨立工作，大部分的組織還是期望員工可以獨立作業也可以和團隊合作，且可以和團隊有良好的互動和即時回饋</li></ul></li><li><p>回答範例</p><blockquote><p>我認為獨立工作和團隊合作在軟體工程師的角色中都扮演著重要的角色，這取決於具體的情境和項目需求。我喜歡在不同的工作方式中找到平衡，並根據情況選擇最適合的方式來實現項目目標。</p><p>例如，當我面臨一個較小的任務 or 一個可以獨立完成的模組時，我喜歡能夠獨自思考和解決問題。在這種情況下，獨立工作可以讓我更好地掌控工作進度和品質，並且更加自由地發揮自己的創造力和技能。</p><p>然而，對於更複雜的項目和大型團隊，我認識到團隊合作的重要性。團隊合作可以促進知識共享、不同角度的思考和協同工作。我喜歡與其他團隊成員合作，共同解決技術挑戰，通過交流和合作實現更好的結果。團隊合作還可以加強項目的穩定性和可擴展性，同時提供一個學習和成長的機會。</p><p>總之，我相信獨立工作和團隊合作在不同的情境中都有其價值和優勢。我喜歡在能夠獨立展示自己的能力的同時，也能夠積極地與團隊合作，共同推動項目的成功。我願意靈活地適應不同的工作方式，並根據具體情況做出最合適的選擇。</p></blockquote></li></ul><h2 id="當你必須和一個性格與你截然不同的人密切合作時，你要如何應對？"><a href="#當你必須和一個性格與你截然不同的人密切合作時，你要如何應對？" class="headerlink" title="當你必須和一個性格與你截然不同的人密切合作時，你要如何應對？"></a>當你必須和一個性格與你截然不同的人密切合作時，你要如何應對？</h2><ul><li><p>他們真正想知道的</p><ul><li>想知道你是不是個能團隊合作的人</li></ul></li><li><p>Tips</p><ul><li>國外很重視團隊合作和溝通，所以在舉出實例說明時可以強調這部份，你們是如何去合作、分配任務、遇到問題時如何溝通</li></ul></li><li><p>回答範例</p><blockquote><p>在軟體工程師的角色中，密切合作是非常重要的，尤其是在團隊項目中。我相信每個人都有自己獨特的思維方式和工作風格，而與性格截然不同的人一起工作可以提供寶貴的學習和成長機會。</p><p>例如，我是一個注重細節和條理性的人，而我必須與一個更加富有創造力和靈活性的人密切合作。首先，我會嘗試理解對方的工作方式和思考方式，意識到我們的差異可能是因為我們各自的優勢和個人風格所致。</p><p>我會通過積極的溝通和協作，尊重對方的觀點和決策，同時也表達我自己的想法。在遇到分歧時，我會採取傾聽和解決問題的態度，尋找雙方都可以接受的解決方案。我相信通過開放的討論和合作，我們可以將各自的優勢和觀點融合在一起，實現更好的工作結果。</p><p>另外，我也會意識到與不同性格的人合作可能會帶來挑戰，但我會把這視為一個機會來培養自己的靈活性和適應能力。我會尋找共同的目標和價值觀，並專注於項目的成功和團隊的合作。我相信通過尊重和理解，可以克服性格上的差異，並建立一種相互尊重和有效合作的關係。</p><p>總之，我認為與性格截然不同的人密切合作是一種挑戰，但也是一個寶貴的學習機會。我願意投入時間和努力來建立良好的溝通和合作關係，以實現項目的成功。我相信通過共同努力和尊重差異，我們可以共同成長並取得卓越的工作成果。</p></blockquote></li></ul><h2 id="講一個你做出的一個艱難決定"><a href="#講一個你做出的一個艱難決定" class="headerlink" title="講一個你做出的一個艱難決定"></a>講一個你做出的一個艱難決定</h2><ul><li><p>他們真正想知道的</p><ul><li>在人際相處的時候，與人討論或產生衝突，是否能有自己主見且願意與人溝通，及如何和同事在此情況下達成共識。</li><li>團隊成員可能來自不同的國家，對於文化上的不同是否有溝通上相關的經驗</li></ul></li><li><p>Tips</p><ul><li>舉出實例，比如先聽取對方意見，試圖理解他為何有如此見解，接著說明自己的理由，並拿出資料佐證</li><li>若時間允許的話也能利用實驗去測試何者方法較為合適，目的是找出能最大化公司和使用者利益的做法</li></ul></li><li><p>回答範例</p><blockquote><p>有一次，我們的團隊面臨一個緊迫的項目截止日期，但在測試階段出現了一個嚴重的問題，可能會導致整個項目延期。這是一個艱難的決定時刻，因為我們必須在時間和品質之間做出權衡。</p><p>在那個時候，我領導了一個小團隊負責開發一個關鍵的功能模組。我們的初步測試發現了一個重要的漏洞，這意味著我們需要在代碼中進行重大的更改和修復，這將導致項目延期。這時，團隊之間的壓力很大，因為大家都期望按時交付項目。</p><p>在面對這個問題時，我認識到品質和可靠性對於我們的產品至關重要。我決定與團隊成員和 stakeholder 進行坦誠的討論，向他們解釋問題的嚴重性以及延期可能帶來的風險。雖然這個決定對於整個團x隊來說是困難的，但我們最終達成了共識，並決定將修復漏洞的工作納入截止日期之後的下一個迭代中。</p><p>這個決定並不容易，因為我們必須向 stakeholder 解釋項目的延期和修復的必要性。然而，這個決定對於產品的品質和長期成功是至關重要的。最終，我們成功修復了漏洞，並在下一個迭代中交付了一個更穩定和可靠的產品。</p><p>這個經歷教會了我在面臨壓力和時間限制時堅持品質和可靠性的重要性，同時也強調了團隊合作和共識的重要性。我相信在面對艱難的決策時，應該堅持團隊的價值觀，並儘力找到平衡的解決方案，以確保產品的成功和客戶的滿意度。</p></blockquote></li></ul><h2 id="是否說過一些嚴肅的話？"><a href="#是否說過一些嚴肅的話？" class="headerlink" title="是否說過一些嚴肅的話？"></a>是否說過一些嚴肅的話？</h2><ul><li><p>他們真正想知道的</p><ul><li>有時候在職場上避免不了和一些人相處時必須嚴厲告訴對方一些事，你是否會為了大家都和平相處而選擇閉口不言，若選擇開口那會用什麼方式去說</li></ul></li><li><p>Tips</p><ul><li>跟對方說，你這次的行為造成了什麼後果，希望你之後如果有相關問題要即時提出，如果有需要幫助的地方我也可以幫你</li></ul></li><li><p>回答範例</p><blockquote><p>在我過去的工作經歷中，有一次我們的團隊遇到了一個嚴重的技術挑戰，導致項目面臨著巨大的風險。在一個關鍵的會議上，我提出了一個非常嚴肅的觀點，指出了當前項目所面臨的困境以及可能的後果。我強調了問題的嚴重性，並建議採取緊急措施來解決它。</p><p>這個觀點引起了團隊成員之間的一些緊張和爭議，因為我的話可能會讓人感到不安或擔憂。然而，我相信在面對嚴峻的挑戰時，誠實和坦率是至關重要的。我認為我們應該面對現實，並採取必要的行動來解決問題，而不是回避或掩蓋它。</p><p>僅管我的觀點可能給人一種嚴肅的印象，但我通過理性和邏輯的論證，向團隊傳達了我的擔憂，並提出了一些解決方案。最終，這個觀點被團隊接受，並成為我們解決問題的關鍵步驟。</p><p>這個經歷讓我明白了在工作中，有時需要說出一些嚴肅的話，以提醒團隊面對現實和解決問題的重要性。作為軟體工程師，我相信誠實和透明是建立良好團隊合作和推動項目成功的關鍵因素。我會在適當的時候表達我的觀點，並與團隊成員共同努力解決問題，以確保項目的順利進行和成功交付。</p></blockquote></li></ul><h2 id="如果無法在-deadline-前完成產品，該如何處理？"><a href="#如果無法在-deadline-前完成產品，該如何處理？" class="headerlink" title="如果無法在 deadline 前完成產品，該如何處理？"></a>如果無法在 deadline 前完成產品，該如何處理？</h2><ul><li><p>他們真正想知道的</p><ul><li>你遇到問題時，是否會運用身邊人力和資源去解決事情</li></ul></li><li><p>Tips</p><ul><li>說明現在遇到的狀況，需要多少時間才能解決，必要時請求他人協助</li><li>怎麼避免下次遇到同樣的狀況，比如在預估時程的時候給予寬鬆一點的時間線</li></ul></li><li><p>回答範例</p><blockquote><p>之前，我參與一個大型軟體開發項目時，由於一些技術挑戰和需求變更，我們在接近 deadline 時發現無法按時完成所有功能。在這種情況下，我會立即與 PM 和團隊成員溝通，共同評估當前的狀況並確定最重要的功能。此外，我們會與 stakeholder 進行溝通，說明延遲情況，並與他們商討如何優先處理關鍵功能。然後，我們會制定一個新的計劃，重新安排任務和資源，並全力以赴按照新的時間表完成關鍵部分。我會密切監控進展並與團隊合作解決任何出現的問題，以盡量縮短延遲的時間並保證產品的品質。</p></blockquote></li></ul><h1 id="面對挑戰"><a href="#面對挑戰" class="headerlink" title="面對挑戰"></a>面對挑戰</h1><h2 id="最引以為豪的成就是什麼？"><a href="#最引以為豪的成就是什麼？" class="headerlink" title="最引以為豪的成就是什麼？"></a>最引以為豪的成就是什麼？</h2><ul><li><p>他們真正想知道的</p><ul><li>你提到的經驗是否是對公司有幫助的事</li><li>瞭解你這個人對於什麼事情會感到有成就感，這個職缺的工作內容是否能讓你感到相同的感受</li></ul></li><li><p>Tips</p><ul><li>提出你工作上曾經做過最困難的事，使用什麼技術，運用數據達成什麼結果；試圖連接這件事和你要應徵的職缺的關聯性，讓對方知道你這些經驗和技術能帶來公司運用</li><li>誠實地提出你自己最自豪的 project，比如 ship 某個 project，或是協助團隊更改了什麼流程，比如建立了團隊的 working agreement 以利長期與其他團隊的合作</li></ul></li><li><p>回答範例</p><blockquote><p>我最引以為豪的成就是在與兆豐銀行的產學合作項目中，成功應用機器學習和資料探勘技術分析客戶行為數據，並預測客戶流失率。作為項目經理，我領導了一個由 10 人組成的團隊，負責監控項目進展並與內部和外部利益相關方協調合作。</p><p>在該項目中，我與業務利益相關者密切合作，確保發現和建議對公司具有相關性和可操作性。通過我的努力，我們成功提供了可靠的客戶流失預測模型，為 兆豐銀行提供了有價值的業務洞察和決策支持。</p><p>這個成就令我感到自豪的原因是，我能夠將理論知識轉化為實際應用，並與團隊合作達成共同目標。同時，我通過這個項目提升了我的領導能力、團隊合作能力和項目管理能力。</p><p>這個經歷不僅展示了我的技術能力，還展示了我的團隊合作和溝通能力。我相信，這個成就為我作為一名軟體工程師提供了寶貴的經驗和技能，使我能夠在複雜的項目中取得成功，並為公司創造價值。</p></blockquote></li></ul><h1 id="決策"><a href="#決策" class="headerlink" title="決策"></a>決策</h1><h2 id="是否做過冒險的決定"><a href="#是否做過冒險的決定" class="headerlink" title="是否做過冒險的決定"></a>是否做過冒險的決定</h2><ul><li><p>他們真正想知道的</p><ul><li>你做了什麼樣的決定，你是按照什麼邏輯去做出這個決定的？</li><li>你有沒有做過什麼決定是可能會危害公司的？</li><li>處理問題的流程，有沒有跟 stakeholder 溝通過，是否有留下相關文件紀錄並經過 review 才進行 implmentation</li></ul></li><li><p>Tips</p><ul><li>說出你之所以做出這個決定的原因，如果你做的決定有引起問題，說明你之後是如何處理，並從中學到什麼，讓你之後下決定後會多考慮什麼因素</li></ul></li><li><p>回答範例</p><blockquote><p>在過去，我曾面臨一個緊迫的項目截止日期，而我們遇到了一些技術上的挑戰。團隊中的其他成員擔心我們無法按時完成任務，他們建議採用傳統的、已知的方法來處理問題。然而，我決定採取一種冒險的做法，嘗試一種全新的技術解決方案。</p><p>我花了很多時間研究和學習這個新技術，明白它的潛在優勢和風險。僅管我知道這是一個冒險的選擇，但我相信這種新技術有潛力解決我們當前面臨的挑戰，並為項目帶來更好的結果。</p><p>在實作過程中，我遇到了一些困難和挑戰。但是，通過與團隊密切合作，我們共同克服了這些難題，並最終成功地實施了這個新技術解決方案。最重要的是，我們在項目截止日期前順利交付了高品質的成果。</p><p>這個決定對我個人和團隊都帶來了很多好處。從個人角度來看，我不僅學到了一種新技術，還展現了勇於嘗試新方法的能力。從團隊角度來看，我們的成功實施增強了團隊的信心，並為公司帶來了更高的客戶滿意度。</p><p>這次冒險的決定教會了我兩個重要的教訓。首先，有時候冒險是值得的，因為它可以帶來新的機遇和突破。其次，團隊合作和相互支持是成功冒險的關鍵因素。</p></blockquote></li></ul><h1 id="領導"><a href="#領導" class="headerlink" title="領導"></a>領導</h1><h2 id="舉一個你主動並帶頭的例子"><a href="#舉一個你主動並帶頭的例子" class="headerlink" title="舉一個你主動並帶頭的例子"></a>舉一個你主動並帶頭的例子</h2><ul><li><p>他們真正想知道的</p><ul><li>你是個主動的人嗎？</li><li>有沒有當主管或領導的資質？</li><li>你能想出新提案去解決問題嗎？</li><li>你可以發現有事情需要改進，去規劃並且執行嗎？</li></ul></li><li><p>Tips</p><ul><li>舉例說明什麼你發現什麼事情需要改進，你制定計劃執行後，造成什麼結果</li></ul></li><li><p>回答範例</p><blockquote><p>之前，我們面臨著一個複雜的技術問題，導致團隊進展受阻。大家都在試圖解決這個問題，但沒有人真正站出來領導並採取行動。我意識到這個問題的緊迫性和重要性，於是我主動邁出了一步，帶領團隊找到解決方案。</p><p>首先，我主動組織了一個小組會議，邀請了受影響的團隊成員參加討論。在會議上，我分享了我對問題的理解和分析，並提出了一些可能的解決方案。我鼓勵團隊成員分享他們的想法和建議，並促進了開放的討論氛圍。</p><p>接著，我主動進行了更深入的研究和調查，以了解該問題的根本原因。我閱讀了相關文獻、參考了類似的案例，並與其他領域的專家進行了交流。通過這個過程，我獲得了更全面的知識，並能夠提出更具體的解決方案。</p><p>在整個過程中，我不僅帶領團隊尋找解決方案，還確保與其他團隊和 stakeholder 進行溝通和合作。我主動與其他團隊成員分享我們的進展和計劃，並尋求他們的意見和支持。我還與上級領導溝通，確保他們了解我們的工作，並獲得必要的資源和支持。</p><p>最終，我們成功地解決了這個技術問題，並將其整合到我們的產品中。這個經歷教會了我主動並帶領團隊解決問題的能力，並展示了我的領導才能和團隊合作精神。</p></blockquote></li></ul><h2 id="如果你是老闆，你願意為公司做什麼樣的事情？"><a href="#如果你是老闆，你願意為公司做什麼樣的事情？" class="headerlink" title="如果你是老闆，你願意為公司做什麼樣的事情？"></a>如果你是老闆，你願意為公司做什麼樣的事情？</h2><ul><li><p>他們真正想知道的</p><ul><li>你期望公司為你做到什麼事情？</li><li>對公司營運或團隊管理的眼界</li></ul></li><li><p>Tips</p><ul><li>回答公司目前有機會可能可以為你達成的，如教育訓練、提供員工參加研討會等</li></ul></li><li><p>回答範例</p><blockquote><p>如果我是老闆，我將致力於創建一個積極和有成效的工作環境，以激發員工的創造力和發展潛力。我相信員工是公司最重要的資產，他們的成長和滿意度對公司的成功至關重要。</p><p>首先，我將致力於建立一個開放和支持性的文化。我會鼓勵員工分享他們的想法和意見，並尊重每個人的獨特貢獻。我會建立一個團隊合作的氛圍，促進跨部門和團隊之間的溝通和合作。我也會提供培訓和發展機會，幫助員工提升技能和職業發展。</p><p>其次，我會關注員工的工作體驗和福利待遇。我會確保他們有適當的工作條件和資源來完成工作。我會關注他們的工作負荷和平衡，避免過度壓力和加班。我還會提供競爭力的薪資和福利，以及靈活的工作安排，以滿足員工的個人需求和生活平衡。</p><p>另外，我會注重公司的創新和發展。我會鼓勵員工提出新的想法和創新解決方案，並提供支持和資源來實現這些創意。我會與團隊合作，建立一個創新的文化，促進持續學習和發展。</p><p>最後，我會關注公司的社會責任和可持續發展。我會積極參與社區活動和慈善事業，以回饋社會並建立積極的企業形象。我也會關注環境保護和可持續經營，採取措施減少公司的環境影響。</p></blockquote></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="你的前老闆會怎樣形容你？"><a href="#你的前老闆會怎樣形容你？" class="headerlink" title="你的前老闆會怎樣形容你？"></a>你的前老闆會怎樣形容你？</h2><ul><li><p>他們真正想知道的</p><ul><li>在同事或主管眼中擁有什麼樣的特質</li><li>你是否擁有此工作所需之特質</li></ul></li><li><p>Tips</p><ul><li>舉出實例，可以按照職缺內容去做調整</li></ul></li><li><p>回答範例</p><blockquote><p>我相信我的前老闆會形容我為一位勤奮、可靠和有責任心的軟體工程師。我始終以高度的職業操守和專注度對待我的工作，並努力達到和超越預期的目標。</p><p>例如，我在之前的工作中負責一個關鍵項目的開發，該項目對公司的業務至關重要。在項目進行過程中，我與團隊密切合作，準確理解客戶需求，並與業務團隊進行良好的溝通。我按時交付高品質的代碼，並積極參與 code review 和測試過程，確保系統的穩定性和可靠性。</p><p>我的前老闆會注意到我對細節的關注和對問題的解決能力。在項目開發中，我遇到了一個複雜的技術挑戰，需要解決一個性能瓶頸。我主動承擔起解決這個問題的責任，深入研究了相關技術和算法，並與團隊合作找到了一個高效的解決方案。我不僅解決了這個問題，還改善了整體系統的性能。</p><p>此外，我的前老闆會注意到我在團隊中的合作精神和積極的貢獻。我善於與其他開發人員、PM 和測試人員合作，共同解決問題並達成共同目標。我樂於分享知識和經驗，幫助團隊成員解決技術難題，並願意承擔額外的責任，以確保項目的成功交付。</p><p>綜上所述，我的前老闆會形容我為一位勤奮、可靠和有責任心的軟體工程師，具備良好的技術能力、解決問題的能力和團隊合作精神。我始終以高標準對待我的工作，並努力為公司的成功做出貢獻。</p></blockquote></li></ul><h2 id="如果你的同事給你負面的評價，該如何處理？"><a href="#如果你的同事給你負面的評價，該如何處理？" class="headerlink" title="如果你的同事給你負面的評價，該如何處理？"></a>如果你的同事給你負面的評價，該如何處理？</h2><ul><li><p>他們真正想知道的</p><ul><li>當你接受到負面的評價的時候，你會如何去面對</li></ul></li><li><p>Tips</p><ul><li>不需要說完全沒有接收過負面評價，說明你先聽取對方意見，並自我反省後檢討做不好的地方並改進，後來改進後得到怎麼樣的回饋</li></ul></li><li><p>回答範例</p><blockquote><p>假設我的同事在 code review 中指出了我某個功能的實現不夠優雅和效率低下。我會先感謝他們的反饋，並請教他們具體的關注點和改進建議。然後，我會仔細分析他們的意見，並反思我的代碼實現。如果我認同他們的觀點，我會展示出改進的態度，並提出一些具體的解決方案，例如重構代碼以提高效率 or 應用更好的設計模式。最後，我會持續改進自己的 coding 能力，通過學習和實踐，以確保在以後的工作中不會再出現類似的問題。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Behavior Question </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>英文面試常用句子</title>
      <link href="/post/interview-english-phrases/"/>
      <url>/post/interview-english-phrases/</url>
      
        <content type="html"><![CDATA[<h1 id="電話"><a href="#電話" class="headerlink" title="電話"></a>電話</h1><h2 id="確認對方身分"><a href="#確認對方身分" class="headerlink" title="確認對方身分"></a>確認對方身分</h2><ul><li>Hi, may I ask who’s calling?</li><li>May I have your name, please?</li></ul><h2 id="正在忙-稍後回撥"><a href="#正在忙-稍後回撥" class="headerlink" title="正在忙, 稍後回撥"></a>正在忙, 稍後回撥</h2><ul><li>I’m glad you called, but I’m a little busy at the moment. Can I call you back in about 30 minutes?</li><li>Is it okay if I call you back later? I’m in the middle of something (a meeting).</li><li>I’m a little tied up, is it okay if I call you back later?</li></ul><h2 id="訊號不好時"><a href="#訊號不好時" class="headerlink" title="訊號不好時"></a>訊號不好時</h2><ul><li>Sorry, you’re breaking up. Could you please look for an area with better reception?</li><li>Give me a second, I’ll find a place with better reception.</li><li>The line is pretty bad. Would you mind speaking up a little?</li><li>The connection is bad. Could you say that again?</li><li>We seem to have a bad connection. Would you mind if I called you back?</li></ul><h1 id="視訊"><a href="#視訊" class="headerlink" title="視訊"></a>視訊</h1><h2 id="確認對方身份"><a href="#確認對方身份" class="headerlink" title="確認對方身份"></a>確認對方身份</h2><ul><li>Are you there?</li><li>Can you see me now?</li><li>Can you hear me now?</li></ul><h2 id="畫面有問題"><a href="#畫面有問題" class="headerlink" title="畫面有問題"></a>畫面有問題</h2><ul><li>You’ve frozen.（靜止）</li><li>Can you turn on your webcam?</li><li>Can you share your screen?</li></ul><h2 id="聲音有問題"><a href="#聲音有問題" class="headerlink" title="聲音有問題"></a>聲音有問題</h2><ul><li>You’re muted.（靜音）</li><li>Can you please mute &#x2F; unmute your microphone?</li><li>Can you turn up &#x2F; down the microphone volume?</li><li>Can you plug in your earphones?</li><li>Your audio is out of sync.（畫面和聲音不同步）</li></ul><h1 id="Small-Talk"><a href="#Small-Talk" class="headerlink" title="Small Talk"></a>Small Talk</h1><ul><li>How are you?</li><li>Is everything okay in your country?</li><li>Did you have trouble finding the office?（No, the directions on the website were great.）</li><li>How was the traffic coming over here?（The traffic was light, no traffic jam.）</li><li>How was your weekend?（I did puzzles.）</li><li>How’s the weather?（The weather is great.）</li></ul><h1 id="面試開場"><a href="#面試開場" class="headerlink" title="面試開場"></a>面試開場</h1><ul><li>Thank you for inviting me for the interview.</li><li>I am also honored to have this opportunity to interview with you.</li></ul><h1 id="沒聽清楚題目"><a href="#沒聽清楚題目" class="headerlink" title="沒聽清楚題目"></a>沒聽清楚題目</h1><ul><li>Sorry, I didn’t quite catch that. Could you explain it one more time?</li><li>Would you mind spelling that out for me?</li><li>I apologize, but I could barely hear you. Would you mind repeating that again?</li></ul><h1 id="思考過程"><a href="#思考過程" class="headerlink" title="思考過程"></a>思考過程</h1><ul><li>OK, I think I understand the problem. Please give me a minute to think of a solution.</li><li>I have come up with a solution. I would like to start presenting my solution.</li><li>I’m not quite sure at the moment, but here’s what I’ve thought about the problem.</li><li>That’s my solution. Does it make sense?</li></ul><h1 id="面試結束時用語"><a href="#面試結束時用語" class="headerlink" title="面試結束時用語"></a>面試結束時用語</h1><ul><li>Thank you very much for your time. It has been nice meeting you.</li><li>It has been a pleasure talking with you.</li><li>Thanks for the opportunity. It’s my pleasure. I look forward to hearing from you soon.</li></ul><h1 id="反問問題"><a href="#反問問題" class="headerlink" title="反問問題"></a>反問問題</h1><ul><li>I have a couple of questions.</li><li>What is your favorite part of working here?</li><li>What is the team culture like?</li><li>What makes a successful software engineer?</li><li>What do you think are the most important qualities for someone to be truly successful in this position?</li><li>What are the common career paths in this department?</li><li>What are the biggest challenges the company &#x2F; team is currently facing?</li><li>Can you share one of the best and one of the worst aspects of your company &#x2F; team?</li><li>What do you learn the most in your position?</li><li>What is your daily workflow?</li></ul>]]></content>
      
      
      <categories>
          
          <category> Behavior Question </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leadership Principles</title>
      <link href="/post/leadership-principles/"/>
      <url>/post/leadership-principles/</url>
      
        <content type="html"><![CDATA[<h1 id="顧客至上（Customer-Obsession）"><a href="#顧客至上（Customer-Obsession）" class="headerlink" title="顧客至上（Customer Obsession）"></a>顧客至上（Customer Obsession）</h1><ul><li>領導者從客戶入手，然後逆向操作。他們努力工作，贏得並維持客戶對他們的信任。雖然領導者會留意競爭對手，但是他們更重視客戶。</li></ul><h1 id="主事者精神（Ownership）"><a href="#主事者精神（Ownership）" class="headerlink" title="主事者精神（Ownership）"></a>主事者精神（Ownership）</h1><ul><li>領導者是主人翁。他們目標長遠，不會為了短期業績而犧牲長期價值。他們的一舉一動不僅僅代表自己的團隊，還代表整個公司。他們從不會說「那不是我份內的事」。</li></ul><h1 id="創新與簡化（Invent-and-Simplify）"><a href="#創新與簡化（Invent-and-Simplify）" class="headerlink" title="創新與簡化（Invent and Simplify）"></a>創新與簡化（Invent and Simplify）</h1><ul><li>領導者期望並要求自己的團隊進行創新和發明，而且無時無刻尋求各種方法來簡化工作。他們了解外界的時勢，到處尋找新的創意，不會因「非由我屬，不為我用」之觀念而故步自封。 當我們展開創新時，要做好可能被長期誤解的心理準備。</li></ul><h1 id="決策大膽正確（Are-Right-A-Lot）"><a href="#決策大膽正確（Are-Right-A-Lot）" class="headerlink" title="決策大膽正確（Are Right, A Lot）"></a>決策大膽正確（Are Right, A Lot）</h1><ul><li>領導者在大多數情況下都能做出正確的決定。他們的判斷力強而且有敏銳的直覺。他們尋求多元化的觀點，並挑戰自己的認知。</li></ul><h1 id="努力學習，保持好奇心（Learn-and-Be-Curious）"><a href="#努力學習，保持好奇心（Learn-and-Be-Curious）" class="headerlink" title="努力學習，保持好奇心（Learn and Be Curious）"></a>努力學習，保持好奇心（Learn and Be Curious）</h1><ul><li>領導者從不停止學習，並不斷尋找各種能提升自我的機會。他們對各種可能性充滿好奇，並身體力行探索真相。</li></ul><h1 id="召賢納士（Hire-and-Develop-the-Best）"><a href="#召賢納士（Hire-and-Develop-the-Best）" class="headerlink" title="召賢納士（Hire and Develop the Best）"></a>召賢納士（Hire and Develop the Best）</h1><ul><li>領導者不斷提升員工聘用與晉升的標準。他們認可優秀的人才，而且願意讓他們在不同的組織職務上展現才華。領導者培養領導人才，在培育後起之秀方面，他們盡心盡責。領導者應體會員工，建立各種職業生涯機制。</li></ul><h1 id="堅持最高標準（Insist-on-the-Highest-Standards）"><a href="#堅持最高標準（Insist-on-the-Highest-Standards）" class="headerlink" title="堅持最高標準（Insist on the Highest Standards）"></a>堅持最高標準（Insist on the Highest Standards）</h1><ul><li>領導者有著近乎嚴苛的高標準 — 對很多人而言，這些標準高得不可能實現。領導者不斷提高標準，敦促自己的團隊提供一流的產品、服務和流程。領導者會確保任何問題不會蔓延，能在第一時間解決問題，一勞永逸。</li></ul><h1 id="胸懷大志（Think-Big）"><a href="#胸懷大志（Think-Big）" class="headerlink" title="胸懷大志（Think Big）"></a>胸懷大志（Think Big）</h1><ul><li>思想狹隘終究不利於己。領導者應制定並闡明大局方針。他們從不同角度考慮問題，積極尋找服務客戶之道。</li></ul><h1 id="付諸行動（Bias-for-Action）"><a href="#付諸行動（Bias-for-Action）" class="headerlink" title="付諸行動（Bias for Action）"></a>付諸行動（Bias for Action）</h1><ul><li>速度對商業而言至關重要。很多決策和行動都可以再做調整，無須進行大量的研究。我們非常重視在經過縝密計算後的風險承擔。</li></ul><h1 id="節儉樸實（Frugality）"><a href="#節儉樸實（Frugality）" class="headerlink" title="節儉樸實（Frugality）"></a>節儉樸實（Frugality）</h1><ul><li>用較少的投入取得更大的成果。勤儉節約能激發大腦的創意、自給自足並不斷創新。增加人力、預算規模以及固定開支並不會為您加分。</li></ul><h1 id="贏得信任（Earn-Trust）"><a href="#贏得信任（Earn-Trust）" class="headerlink" title="贏得信任（Earn Trust）"></a>贏得信任（Earn Trust）</h1><ul><li>領導者要用心傾聽、坦誠溝通，而且尊重他人。領導者勇於自我批判，就算這樣做會讓自己尷尬或難堪。他們不認為自己或其團隊永遠是對的。領導者會以最高標準來要求自己和其團隊。</li></ul><h1 id="追根究底（Dive-Deep）"><a href="#追根究底（Dive-Deep）" class="headerlink" title="追根究底（Dive Deep）"></a>追根究底（Dive Deep）</h1><ul><li>領導者涉足各個環節、隨時掌控細節、時常審視結果，當數據與傳聞不一致時，會抱持懷疑態度。領導者不會錯過任何事。</li></ul><h1 id="有主見；敢承擔（Have-Backbone-Disagree-and-Commit）"><a href="#有主見；敢承擔（Have-Backbone-Disagree-and-Commit）" class="headerlink" title="有主見；敢承擔（Have Backbone; Disagree and Commit）"></a>有主見；敢承擔（Have Backbone; Disagree and Commit）</h1><ul><li>對於無法苟同的決策，領導者應當不卑不亢地提出質疑。即便這樣做會讓人感到不悅或疲於應付。領導者應當意志堅定，不輕易動搖。他們不會為了保持社會凝聚力而輕易妥協退讓。當做出決定之後，他們便勇往直前。</li></ul><h1 id="實現目標（Deliver-Results）"><a href="#實現目標（Deliver-Results）" class="headerlink" title="實現目標（Deliver Results）"></a>實現目標（Deliver Results）</h1><ul><li>領導者會重視決定事情成敗的關鍵因素，而且能保證品質並及時完成。就算遭受挫折，領導者依然勇敢面對，從不輕易放棄。</li></ul><h1 id="努力成為地球上最好的雇主（Strive-to-be-Earth’s-Best-Employer）"><a href="#努力成為地球上最好的雇主（Strive-to-be-Earth’s-Best-Employer）" class="headerlink" title="努力成為地球上最好的雇主（Strive to be Earth’s Best Employer）"></a>努力成為地球上最好的雇主（Strive to be Earth’s Best Employer）</h1><ul><li>領導者每天努力創造一個更安全、更高效、更高績效、更多元化、更公正的工作環境。他們以同理心領導，快樂地工作，並讓其他人也能快樂工作。領導者問自己：我的同事們在成長嗎？他們有被授權嗎？他們準備好面對下一個挑戰了嗎？領導者對員工的個人成功有願景和承諾，無論是在亞馬遜還是其他地方。</li></ul><h1 id="成功和規模帶來廣泛的責任（Success-and-Scale-Bring-Broad-Responsibility）"><a href="#成功和規模帶來廣泛的責任（Success-and-Scale-Bring-Broad-Responsibility）" class="headerlink" title="成功和規模帶來廣泛的責任（Success and Scale Bring Broad Responsibility）"></a>成功和規模帶來廣泛的責任（Success and Scale Bring Broad Responsibility）</h1><ul><li>我們從一個車庫開始，但現在我們已經不在那裡了。我們很大，影響世界，但我們還遠未完美。我們必須謙虛並深思熟慮我們行動的次生影響。我們的當地社區、地球和未來的幾代人需要我們每天變得更好。我們必須以決心開始每一天，為了我們的客戶、員工、合作夥伴和整個世界而做出更好的表現。我們必須以知道明天我們還能做得更多而結束每一天。領導者創造的總是多於他們所消耗的，並始終把事物留得比當初發現時更好。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Behavior Question </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自我介紹</title>
      <link href="/post/self-introduction/"/>
      <url>/post/self-introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="舊版（須更新）"><a href="#舊版（須更新）" class="headerlink" title="舊版（須更新）"></a>舊版（須更新）</h1><h2 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h2><h3 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h3><blockquote><p>您好，我是劉佳泓，我畢業於中山大學資工系，目前就讀於成功大學的資工所。我的碩士論文主要研究深度學習和影像辨識。</p><p>我擅長使用 C++ 和 Python，並且對軟體工程和系統優化有著濃厚的興趣。在資工系的課程扎實的訓練下，我學到了如何分析、解決問題的能力，以及如何將複雜抽象的事物化簡為簡單易懂的方式。</p><p>在研究所期間，我曾擔任產學合作案的專案經理和軟體工程師，主要負責規劃系統架構和 API 規格、引導團隊開發產品、監督專案進度，以及協調內外部各方團隊。</p><p>在大學期間，我擔任過畢業專題的組長，負責分配工作、整合系統和報告呈現。此外，我也開發過多個系統，例如租借系統、網路安全儀錶板和 AI 健康照護網站等等。</p><p>透過上述這些經驗，使我提高了在軟體開發方面的敏銳度，並且學會了如何與客戶溝通，以及如何帶領整個團隊完成任務。</p><p>未來，我希望在資工相關領域運用自身所學，為公司和自己創造新的價值。以上是我的自我介紹，謝謝。</p></blockquote><h3 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h3><blockquote><p>Hello, I’m Jia-Hong Liu, a graduate of the Department of Computer Science at Sun Yat-sen University, and I am currently pursuing my master’s degree in Computer Science at National Cheng Kung University. My master’s thesis focuses on deep learning and image recognition.</p><p>I’m proficient in using C++ and Python, and have a strong interest in software engineering and system optimization. Through rigorous training in computer science courses, I have developed the ability to analyze and solve problems, as well as simplify complex and abstract concepts into easy-to-understand terms.</p><p>During my graduate studies, I served as a project manager and software engineer for an industry-academia collaboration project. My responsibilities included planning system architecture and API specifications, guiding the team in product development, supervising project progress, and coordinating various teams both internally and externally.</p><p>During my undergraduate studies, I served as a team leader for my graduation project, responsible for assigning tasks, integrating systems, and presenting reports. Additionally, I have developed several systems, including rental system, network security dashboard, and AI health care website.</p><p>Through these experiences, I have honed my sensitivity to software development and learned how to communicate with clients and lead teams to complete tasks.</p><p>In the future, I hope to apply my knowledge in the field of computer science to create new value for both the company and myself. That’s all for my self-introduction. Thank you.</p></blockquote><h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><blockquote><p>我是 Cliff Liu，畢業於中山大學的資工系，目前就讀於成功大學的資工所。</p><p>在研究所期間，我曾參與過多個軟體工程項目，並在不同的專案中取得了傑出的成就。其中一個值得一提的專案是與兆豐銀行合作的客戶流失預測專案。我應用機器學習和資料探勘技術，分析客戶行為數據並預測客戶流失率。我與商業利益相關方緊密合作，確保結果和建議對公司具有實際的參考價值。在這個專案中，我扮演了軟體工程師兼 PM 的雙重角色，負責監控項目進度並與內、外部的 stakeholder 協調合作。</p><p>此外，我還參與了一個與新創公司合作的 AI 醫療網站專案。我利用深度學習技術提供皮膚、指甲、舌頭和青春痘等方面的分類服務，並實現了可解釋的人工智能。並開發了一個用戶友好的網站，實現了社交媒體登錄、用戶評論和個性化歷史記錄等功能。同時，我通過實作資料庫正規化技術，將記憶體使用量優化了25%。</p><p>另外，我還參與了一個與成功大學製造所合作的網路安全儀表板項目。我建立了一個安全事件記錄表和視覺化界面，為人員提供監控安全事件的工具。並通過實作後端分頁技術，將延遲和記憶體使用量減少了 90%，顯著改善了用戶的體驗。</p><p>不僅如此，我也參與了一些其他的專案，包括車牌識別和教室及設備預訂系統。我擁有廣泛的程式語言和工具的使用經驗，包括 C、C#、C++、Python、AWS、Docker、Linux、Git、SQL、NoSQL、機器學習和深度學習。</p><p>上述提到的這些經歷和技能使我對軟體工程師的職位充滿熱情。我喜歡解決複雜的問題，並與團隊合作共同實現目標。我希望能在貴公司這樣一個有創造力且具有挑戰性的環境中發揮我的專長，並不斷地學習和成長。真的非常感謝您給我這個機會，我期待能夠為貴公司做出貢獻。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Behavior Question </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Star method</title>
      <link href="/post/star-method/"/>
      <url>/post/star-method/</url>
      
        <content type="html"><![CDATA[<h1 id="什麼是-STAR-method？"><a href="#什麼是-STAR-method？" class="headerlink" title="什麼是 STAR method？"></a>什麼是 STAR method？</h1><ul><li><strong>Ｓ- 情境（Situation）：背景描述，在履歷中提及該經歷處在什麼樣的情況下？面臨什麼問題？遇到什麼樣人、事的衝突或困難？</strong></li><li><strong>Ｔ- 任務（Task）：在 Situation 中面對的情況、問題或困難，你提出了哪些解決方案、被分配哪些任務、主要負責的任務是什麼？</strong></li><li><strong>Ａ- 行動（Action）：根據上述現況、提案及任務，你具體如何執行？採取了哪些行動或應用哪些技能？</strong></li><li><strong>Ｒ- 結果（Result）：執行了上述的任務後，得到了哪些成果？帶給公司本身或客戶哪些好處？在這部分如大多數履歷技巧所說，將結果、成績「量化」、「以商業術語呈現」更能呈現專業感，藉此凸顯出自己與其他 candidate 的差異。</strong></li></ul><h2 id="運用"><a href="#運用" class="headerlink" title="運用"></a>運用</h2><p><img src="https://i.imgur.com/BxtjjbR.png"></p><h2 id="Story-Shape"><a href="#Story-Shape" class="headerlink" title="Story Shape"></a>Story Shape</h2><ul><li><p>在描述情境與任務時，可以<strong>加入衝突（conflicts）、挑戰（challenges）</strong>等元素，這麼做可以讓你後續的行動更被凸顯。畢竟問題越嚴重，越能凸顯解決方案的價值。特別注意，假如你想要挑戰下一個級距的工作（例如你本來是 L4 的工程師，但想挑戰 L5 的職位），那你描述的問題，就不能只是 L4 的問題，而需要是 L5 的問題。</p></li><li><p>舉例來說，協助另一個工程師，這只是 L4 層級的問題。假如你分享的故事是這樣，那你很可能只會拿到 L4 的 offer。如果想要拿到 L5 的 offer，就要提到 L5 的問題。例如不僅是某個工程師的個人產出不佳，而是整個團隊的產出都不如預期。假如你提的是這個問題，那會是更加棘手的挑戰；這意味著，如果你過去曾經順利解決這種整團隊都出問題的狀況，那更能說服面試官相信你具備 L5 的實力。</p></li></ul><h2 id="常見問題"><a href="#常見問題" class="headerlink" title="常見問題"></a>常見問題</h2><ul><li><p><strong>你為什麼想在 XXX 公司工作？</strong></p></li><li><p><strong>你對我們公司的哪個 project 最感興趣？</strong></p></li><li><p><strong>人生中最大的成就／失敗是什麼？</strong></p></li><li><p><strong>你做過最值得驕傲的 project 是什麼？</strong></p></li><li><p><strong>當你有 hard deadline，可是時間不夠，要如何完成 project？</strong></p><p>  <code>做事順序依據四分法：緊急又重要 &gt; 重要但不緊急 &gt; 緊急但不重要 &gt; 不重要又不緊急</code></p></li><li><p><strong>遇過最有挑戰的技術困難是什麼？</strong></p></li><li><p><strong>被主管責難／挫折的經驗？</strong></p></li><li><p><strong>衝突處理（對上、對下、對同位階）</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Behavior Question </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>912. Sort an Array</title>
      <link href="/post/sort-an-array/"/>
      <url>/post/sort-an-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sort-an-array/">https://leetcode.cn/problems/sort-an-array/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>nums</code>, 將其按升序排列後並返回它。</p></blockquote><p><img src="https://i.imgur.com/qPhUFc7.png"></p><h2 id="Solution-1：-TLE-無法通過"><a href="#Solution-1：-TLE-無法通過" class="headerlink" title="Solution 1：(TLE 無法通過)"></a><strong>Solution 1：(TLE 無法通過)</strong></h2><blockquote><p><strong>想法：利用 Bubble Sort, 每次比較相鄰兩元素, 如果第一個比第二個大, 則交換。每一回合結束後, 未排序中的最大值會浮到最右邊</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 總共 (n - 1) 回合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">bool</span> swapped = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第 i 回合只需 compare (n - 1 - i) 次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">                    swapped = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若無 swap 則結束</span></span><br><span class="line">            <span class="keyword">if</span> (swapped == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$. ➔ Bubble Sort 的 avg case 時間複雜度<ul><li>$T(n) &#x3D; T(n - 1) + \dfrac{n}{2}$, 其中 $\dfrac{n}{2}$ 是平均 swap 的次數</li><li>平均 swap 的次數 : $\dfrac{[1 + 2 + … +(n-1)]}{(n-1)} &#x3D; \dfrac{n(n-1)}{2} \cdot \dfrac{1}{(n-1)} &#x3D; \dfrac{n}{2}$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Merge Sort</strong></p><p><img src="https://i.imgur.com/3c0dx5l.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> low, <span class="type">const</span> <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">mergeSort</span>(nums, low, mid);</span><br><span class="line">            <span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">            <span class="built_in">merge</span>(nums, low, mid, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> low, <span class="type">const</span> <span class="type">int</span> mid, <span class="type">const</span> <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> left = low, right = mid + <span class="number">1</span>, len = high - low + <span class="number">1</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sorted</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= high) &#123;</span><br><span class="line">                sorted[k++] = (nums[left] &lt; nums[right]) ? nums[left++] : nums[right++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= mid) &#123;</span><br><span class="line">                sorted[k++] = nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (right &lt;= high) &#123;</span><br><span class="line">                sorted[k++] = nums[right++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">                nums[low + k] = sorted[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ Merge Sort 的時間複雜度, $T(n) &#x3D; 2 \cdot T(\dfrac{n}{2}) + O(n)$<ul><li>每回合的合併需要花：$O(n)$</li><li>回合數：$O(log(n))$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ $O(n + log(n))$<ul><li>$O(n)$：merge 後的 sorted 長度最多為 <code>n</code></li><li>$O(log(n))$：取決於遞迴深度, 最大遞迴深度為 log(n)</li></ul></li></ul><h2 id="Solution-3：-TLE-無法通過"><a href="#Solution-3：-TLE-無法通過" class="headerlink" title="Solution 3：(TLE 無法通過)"></a><strong>Solution 3：(TLE 無法通過)</strong></h2><blockquote><p><strong>想法：利用 Selection Sort, 每一回合中從第 <code>(i + 1) ~ n</code> 筆中找最小值, 並和第 <code>i</code> 筆做 swap</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做 n - 1 回合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            minIndex = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每一回合從未排序的 array 中找出最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[minIndex]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ Selection Sort 的 avg case 時間複雜度<ul><li>$T(n) &#x3D; T(n - 1) + O(n)$, 其中 $O(n)$ 是從未排序的 array 中找出最小值的時間複雜度</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-4：-TLE-無法通過"><a href="#Solution-4：-TLE-無法通過" class="headerlink" title="Solution 4：(TLE 無法通過)"></a><strong>Solution 4：(TLE 無法通過)</strong></h2><blockquote><p><strong>想法：利用 Insertion Sort</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做 n - 1 回合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找出 nums[i] 在前面 0 ~ (i - 1) sorted array 中要插入的 idx</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idx = <span class="built_in">binarySearch</span>(nums, <span class="number">0</span>, i - <span class="number">1</span>, nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 nums[i] 插入到 idx</span></span><br><span class="line">            <span class="built_in">insert</span>(nums, idx, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">const</span> <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[mid]) &#123; <span class="comment">// mid 右側元素皆 &gt; target, 故往左邊搜尋</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> idx, <span class="type">const</span> <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> tmp = nums[i]; <span class="comment">// 先記住要插入的數</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 idx ~ (i - 1) 的數往後移一位(順序必須由後往前, 不然會蓋掉後面的數)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt;= idx + <span class="number">1</span>; --k) &#123;</span><br><span class="line">            nums[k] = nums[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[idx] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ Insertion Sort 的 avg case 時間複雜度<ul><li>$T(n) &#x3D; T(n - 1) + [O(log(n)) + O(n)]$ ➔ $T(n) &#x3D; T(n - 1) + O(n)$</li><li>其中 $O(log(n))$ 是 binary search 的時間複雜度, $O(n)$ 是 insert 的時間複雜度</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>394. Decode String</title>
      <link href="/post/decode-string/"/>
      <url>/post/decode-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/decode-string/">https://leetcode.cn/problems/decode-string/</a></strong></p><p><strong>題意</strong>：給一經過編碼的 string, 返回它解碼後的 string。</p><p>編碼規則為：<code>k[encoded_string]</code>, 表示括號中的 <code>encoded_string</code> 重覆 <code>k</code> 次, 其中 <code>k</code> 保證為正整數。</p><p>input string 總是有效的, 其中沒有額外的空格, 且括號總是符合格式要求的。</p><p>此外, 所有的數字都只表示重覆的次數 <code>k</code>, e.g. 不會出現像 <code>3a</code> 或 <code>2[4]</code> 的輸入。</p></blockquote><p><img src="https://i.imgur.com/9G0xJkN.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack, 可分成以下四種情況</strong></p><ul><li>當 <code>s[i]</code> 為數字時, 則不斷更新當前數字 <code>num</code></li><li>當 <code>s[i]</code> 為字母時, 則不斷更新當前 string <code>res</code></li><li>當 <code>s[i]</code> 為 <code>[</code> 時, 則將 <code>num</code>、<code>res</code> 各自 push 到對應的 stack 中</li><li>當 <code>s[i]</code> 為 <code>]</code> 時<ul><li>取出 <code>times = nums.top()</code>, 並將當前 string <code>res</code> 累加 <code>times</code> 次到 <code>strs.top()</code> 中</li><li>再將 <code>strs.top()</code> assign 給 <code>res</code></li><li>最後, 分別 pop <code>nums</code>、<code>strs</code></li></ul></li></ul><p>e.g. <code>s = &quot;3[a2[c]]&quot;</code></p><ul><li><code>i = 0</code>, <code>s[i] = &quot;3&quot;</code>：<code>num = 3</code>, <code>res = &quot;&quot;</code></li><li><code>i = 1</code>, <code>s[i] = &quot;[&quot;</code>：<code>nums = &#123;3&#125;</code>, <code>strs = &#123;&quot;&quot;&#125;</code>, 且 <code>num = 0</code>, <code>res = &quot;&quot;</code></li><li><code>i = 2</code>, <code>s[i] = &quot;a&quot;</code>：<code>num = 0</code>, <code>res = &quot;a&quot;</code></li><li><code>i = 3</code>, <code>s[i] = &quot;2&quot;</code>：<code>num = 2</code>, <code>res = &quot;a&quot;</code></li><li><code>i = 4</code>, <code>s[i] = &quot;[&quot;</code>：<code>nums = &#123;3, 2&#125;</code>, <code>strs = &#123;&quot;&quot;, &quot;a&quot;&#125;</code>, 且 <code>num = 0</code>, <code>res = &quot;&quot;</code></li><li><code>i = 5</code>, <code>s[i] = &quot;c&quot;</code>：<code>num = 0</code>, <code>res = &quot;c&quot;</code></li><li><code>i = 6</code>, <code>s[i] = &quot;]&quot;</code>：<ul><li><code>num = 2</code>, <code>res = &quot;c&quot;</code> ➔ <code>nums = &#123;3&#125;</code>, <code>strs = &#123;&quot;&quot;, &quot;acc&quot;&#125;</code><br>  ➔ <code>strs = &#123;&quot;&quot;&#125;</code>, <code>res = &quot;acc&quot;</code></li></ul></li><li><code>i = 7</code>, <code>s[i] = &quot;]&quot;</code>：<ul><li><code>num = 3</code>, <code>res = &quot;acc&quot;</code> ➔ <code>nums = &#123;&#125;</code>, <code>strs = &#123;&quot;&quot;, &quot;accaccacc&quot;&#125;</code><br>  ➔ <code>strs = &#123;&quot;&quot;&#125;</code>, <code>res = &quot;accaccacc&quot;</code></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        stack&lt;string&gt; strs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">                res += s[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                nums.<span class="built_in">emplace</span>(num);</span><br><span class="line">                strs.<span class="built_in">emplace</span>(res);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若 s[i] == &#x27;]&#x27;</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> times = nums.<span class="built_in">top</span>();</span><br><span class="line">                nums.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; times; ++k) &#123;</span><br><span class="line">                    strs.<span class="built_in">top</span>() += res;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                res = strs.<span class="built_in">top</span>();</span><br><span class="line">                strs.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code>, 其中 <code>n</code> 為 <code>s</code> 的長度</li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮 <code>res</code>, 則取決於 <code>nums</code>、<code>strs</code> 的長度, 而兩者的長度皆不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>399. Evaluate Division</title>
      <link href="/post/evaluate-division/"/>
      <url>/post/evaluate-division/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/evaluate-division/">https://leetcode.cn/problems/evaluate-division/</a></strong></p><p><strong>題意</strong>：給一變數 pair array <code>equations</code>, 和一實數 array <code>values</code>, 其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示  <code>Ai / Bi = values[i]</code>。每個 <code>Ai</code> 或 <code>Bi</code> 是一個表示單個變數的 string。</p><p>另外, 有一些以 array <code>queries</code> 表示的問題, 其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 個問題, 請根據已知條件找出 <code>Cj / Dj = ?</code> 的結果作為答案。</p><p>返回所有問題的答案。若存在某個無法確定的答案, 則用 <code>-1.0</code> 替代這個答案。若問題中出現已知條件中沒有出現的 string, 也用 <code>-1.0</code> 替代這個答案。</p><p><strong>注意</strong>：輸入皆為有效的, 除法運算中不會出現除數為 <code>0</code> 的情況, 且不存在任何矛盾的結果。</p></blockquote><p><img src="https://i.imgur.com/CrlWGgi.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Graph + DFS, 先建立有向圖, 若 <code>query = [a, b]</code>, 且 <code>a -&gt; b</code> 沒有直接連接, 則用 DFS 去尋找是否存在中繼點 <code>c</code>, 使得 <code>a -&gt; c -&gt; b</code></strong></p><p><img src="https://i.imgur.com/1NeKmNV.png"></p><p><strong>每個 query 都要用 <code>visited</code> 紀錄哪些點已經拜訪過, 否則可能會陷入死循環。</strong><br>e.g. <code>a -&gt; c -&gt; a -&gt; c ...</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;string, <span class="type">double</span>&gt; psd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">calcEquation</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations,</span></span></span><br><span class="line"><span class="params"><span class="function">                                vector&lt;<span class="type">double</span>&gt;&amp; values,</span></span></span><br><span class="line"><span class="params"><span class="function">                                vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立有向圖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 紀錄相鄰的點和對應的 weight =&gt; &#123;node, weight&#125;</span></span><br><span class="line">            adj[equations[i][<span class="number">0</span>]].<span class="built_in">emplace_back</span>(psd&#123;equations[i][<span class="number">1</span>], values[i]&#125;);</span><br><span class="line">            adj[equations[i][<span class="number">1</span>]].<span class="built_in">emplace_back</span>(psd&#123;equations[i][<span class="number">0</span>], <span class="number">1.0</span> / values[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍歷每個 query</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; query : queries) &#123;</span><br><span class="line">            <span class="comment">// 每個 query 中都要記錄已經拜訪過的點, 避免陷入死循環</span></span><br><span class="line">            unordered_set&lt;string&gt; visited;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若已知條件沒有該 node, 則答案為 -1</span></span><br><span class="line">            <span class="keyword">if</span> (adj.<span class="built_in">find</span>(query[<span class="number">0</span>]) == adj.<span class="built_in">end</span>() || adj.<span class="built_in">find</span>(query[<span class="number">1</span>]) == adj.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(<span class="number">-1.0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 否則, DFS 尋找中繼點</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="built_in">dfs</span>(query[<span class="number">0</span>], query[<span class="number">1</span>], visited));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 紀錄每個 node 和其直接相鄰的 node 和對應的 val</span></span><br><span class="line">    unordered_map&lt;string, vector&lt;psd&gt;&gt; adj; <span class="comment">// adjacent list, 紀錄 &#123;node, weight&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs(a, b, visited) 返回 a / b</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(string&amp; a, string&amp; b, unordered_set&lt;string&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若起點 = 終點, 則返回 1.0（因為 a / a = 1）</span></span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍歷 a 的 neighbor</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [c, weight1] : adj[a]) &#123;</span><br><span class="line">            <span class="comment">// 若已經拜訪過, 則跳過</span></span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(c) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 c 加入到 visited 中</span></span><br><span class="line">            visited.<span class="built_in">emplace</span>(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// DFS 得到 c / b</span></span><br><span class="line">            <span class="type">double</span> weight2 = <span class="built_in">dfs</span>(c, b, visited);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若存在中繼點 c 能抵達 b, 則返回 a / b = (a / c) * (c / b)</span></span><br><span class="line">            <span class="keyword">if</span> (weight2 != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> weight1 * weight2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>; <span class="comment">// 不存在中繼點 c 能抵達 b, 返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(e + q \cdot e)$ ➔ <code>e</code> 為 <code>equations</code> 的長度, <code>q</code> 為 <code>queries</code> 的長度<ul><li>$O(e)$：建立有向圖</li><li>$O(q \cdot e)$：遍歷 <code>queries</code>, 而每個 query 的遞迴深度不超過 <code>e</code></li></ul></li><li><strong>space：</strong>$O(e)$ ➔ 遞迴深度、<code>equations</code> 的長度不超過 <code>e</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>388. Longest Absolute File Path</title>
      <link href="/post/longest-absolute-file-path/"/>
      <url>/post/longest-absolute-file-path/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-absolute-file-path/">https://leetcode.cn/problems/longest-absolute-file-path/</a></strong></p><p><strong>題意</strong>：假設有一個同時儲存檔案和目錄的 file system。下圖展示了 file system 的一個範例：</p><p><img src="https://i.imgur.com/I6MnZam.png"></p><p><code>dir</code> 作為根目錄中的唯一目錄, 其中 <code>dir</code> 包含兩個子目錄 <code>subdir1</code> 和 <code>subdir2</code></p><ul><li><code>subdir1</code> 包含檔案 <code>file1.ext</code> 和子目錄 <code>subsubdir1</code></li><li><code>subdir2</code> 包含子目錄 <code>subsubdir2</code>, 該子目錄下包含檔案 <code>file2.ext</code></li></ul><p>文字格式如下所示（其中 <code>⟶</code> 表示 <code>tab</code>）：</p><p><img src="https://i.imgur.com/XRO5LJW.png"></p><p>上面的 file system 以 code 格式可表示為（其中 <code>\n</code>、<code>\t</code> 分別表示 <code>換行</code>、<code>tab</code>）</p><p><img src="https://i.imgur.com/jMhR7uZ.png"></p><p>file system 中每個檔案、目錄都有一個唯一的<strong>絕對路徑</strong>, e.g. <code>file2.ext</code> 的絕對路徑是 <code>dir/subdir2/subsubdir2/file2.ext</code></p><ul><li>每個目錄名由字母、數字、<code>/</code> or 空格所組成</li><li>每個檔案名遵循 <code>name.extension</code> 的格式, 其中 <code>name</code> 和 <code>extension</code> 由字母、數字和、<code>/</code> or 空格所組成</li></ul><p>給一 file system 的 code 格式 string <code>input</code>, 返回 file system 中指向<strong>檔案</strong>的<strong>最長絕對路徑</strong>之長度。若 file system 中沒有檔案, 則返回 <code>0</code>。</p></blockquote><p><img src="https://i.imgur.com/sGc4nDn.png"></p><p><img src="https://i.imgur.com/lgUIMtF.png"></p><p><img src="https://i.imgur.com/h1PlhZU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：level 最大的 file 絕對路徑的長度不一定會是最長的 , 所以不能直接使用 Greedy。e.g. 下圖中, level 較大的 <code>dir/abc/1.txt</code> 長度比 <code>dir/123456789.jpg</code> 小</strong></p><p><img src="https://i.imgur.com/aExxRHr.png"></p><p><strong>故分成以下步驟：</strong></p><ul><li>先根據 <code>\\n</code> 拆出每個 file</li><li>再根據 <code>\\t</code> 計算出當前 file 的 level</li><li>將 file 中的 <code>\\t</code> 去掉, 並加入到 <code>dir[level]</code> 中</li><li>加總 <code>sum&#123;dir[i] | 0 ≤ i ≤ level&#125;</code>, 最後再加上 <code>level</code>（因為每一個 level 都會在絕對路徑中產生一個 <code>/</code>）</li></ul><p>e.g. <code>input = dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext</code></p><ul><li>首先, 會先拆出 <code>dir</code>、<code>\\tsubdir1</code>、<code>\\tsubdir2</code>、<code>\\t\\tfile.ext</code> 四個 file</li><li>最一開始, <code>dir</code> 會是空的, 然後會隨著 file 的 level 增加而不斷 resize</li><li>將每個 file 根據 level 加入到 <code>dir</code> 中, 若該 file 包含 <code>.</code> 則要計算長度<ul><li>file <code>dir</code> 的 <code>level = 0</code> ➔ <code>dir[0] = dir</code></li><li>file <code>\\tsubdir1</code> 的 <code>level = 1</code> ➔ <code>dir[1] = subdir1</code></li><li>file <code>\\tsubdir2</code> 的 <code>level = 1</code> ➔ <code>dir[1] = subdir2</code> <strong>直接覆蓋</strong>掉原本的 <code>dir[1]</code><br>  （直接覆蓋是沒問題的, 因為當某個 <code>file.ext</code> 被加入時, 其所有 parent dir 一定都在 <code>dir</code> 中, 因為其 parent dir 一定會先被拜訪, 並覆寫掉之前 file 的 dir 資訊）</li><li>file <code>\\t\\tfile.ext</code> 的 <code>level = 2</code> ➔ <code>dir[2] = file.ext</code></li></ul></li><li>因為 <code>file.ext</code> 為檔案, 故要加總當前 <code>dir[0~level]</code> 的長度</li><li>此時加總了 <code>dir</code>、<code>subdir2</code>、<code>file.ext</code> 的長度, 但別忘了絕對路徑是 <code>dir/subdir2/file.ext</code>, 還要加上 <code>/</code> 的個數, 也就是 <code>file.ext</code> 的 <code>level</code> 才為答案</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthLongestPath</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = input.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; files;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根據 \\n 切割出 file</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; input[i] != <span class="string">&#x27;\\n&#x27;</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            files.<span class="built_in">emplace_back</span>(input.<span class="built_in">substr</span>(start, i - start));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;string&gt; dir;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; file : files) &#123;</span><br><span class="line">            <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根據 \\t 計算當前 file 的 level</span></span><br><span class="line">            <span class="keyword">while</span> (level &lt; file.<span class="built_in">size</span>() &amp;&amp; file[level] == <span class="string">&#x27;\\t&#x27;</span>) &#123;</span><br><span class="line">                ++level;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 dir 的 level ≤ 當前 file 的 level, 則重新 resize</span></span><br><span class="line">            <span class="keyword">if</span> (dir.<span class="built_in">size</span>() &lt;= level) &#123;</span><br><span class="line">                dir.<span class="built_in">resize</span>(level + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將去掉 \\t 的 file 放入 dir 中</span></span><br><span class="line">            dir[level] = file.<span class="built_in">substr</span>(level);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若當前的 file 為檔案（包含 &quot;.&quot;）, 則計算其絕對路徑的長度</span></span><br><span class="line">            <span class="keyword">if</span> (dir[level].<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>) != string::npos) &#123;</span><br><span class="line">                <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= level; ++i) &#123;</span><br><span class="line">                    len += dir[i].<span class="built_in">size</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                len += level; <span class="comment">// 加上 level, 因為每一個 level 都會在絕對路徑產生一個 &quot;/&quot;</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop 遍歷 <code>input</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>files</code> 紀錄每個 file 的名稱</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34. Find First and Last Position of Element in Sorted Array</title>
      <link href="/post/find-first-and-last-position-of-element-in-sorted-array/"/>
      <url>/post/find-first-and-last-position-of-element-in-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></strong></p><p><strong>題意</strong>：給一按照非遞減順序排列的整數array <code>nums</code>, 和一個整數 <code>target</code>。請找出給定 <code>target</code> 在 <code>nums</code> 中的開始位置和結束位置。</p><p>如果 <code>nums</code> 中不存在  <code>target</code>, 則返回 <code>[-1, -1]</code>。</p><p>設計 $O(log(n))$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/Tv2KiwP.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> lower = <span class="built_in">firstPos</span>(nums, target);</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> upper = <span class="built_in">lastPos</span>(nums, target);</span><br><span class="line">        <span class="keyword">return</span> &#123;lower, upper&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstPos</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// mid 右側元素皆 &gt;= target, 故往左邊尋找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left 越界 or nums[left] 不為 target, 則返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> (left == n || nums[left] != target) ? <span class="number">-1</span> : left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastPos</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --left; <span class="comment">// left 為第一個 &gt; target 的數, 而 left - 1 為最後一個 &lt;= target 的數</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (left &lt; <span class="number">0</span> || nums[left] != target) ? <span class="number">-1</span> : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search 的時間複雜度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>151. Reverse Words in a String</title>
      <link href="/post/reverse-words-in-a-string/"/>
      <url>/post/reverse-words-in-a-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">https://leetcode.cn/problems/reverse-words-in-a-string/</a></strong></p><p><strong>題意</strong>：給一 string <code>s</code>, 請你反轉 <code>s</code> 中單字的順序。</p><p>單字是由非空格 char 所組成的 string, <code>s</code> 中至少使用一空格將 string 中的單字分開。</p><p><strong>注意</strong>：<code>s</code> 中可能會存在前導空格、尾隨空格 or 單字間的多個空格。返回的 output 中, 單字間應當僅用單個空格分隔, 且不包含任何額外的空格。</p><p><strong>進階</strong>：如果 <code>s</code> 在你使用的語言中是可變的, 設計 $O(1)$ space 的演算法。</p></blockquote><p><img src="https://i.imgur.com/gNWaY1X.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Stack, 先將分割出每個 word, 並把 word 加到 stack 中, 然後再一一 pop 出來, 要注意最後一個 word 後面不能有空格</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;string&gt; stk; <span class="comment">// 讓後面的 word 先被 pop 出去</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            string word;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word += s[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">emplace</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            s += stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是最後一個 word 的話, 則要加 &quot; &quot;</span></span><br><span class="line">            <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 儲存每個 word</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers 先去除多餘的空格(可參考 <a href="https://zako945.github.io/post/remove-element/">27. Remove Element</a>), 然後 reverse string, 最後再 reverse 每一個 word</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">removeExtraSpace</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        string word;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> left = i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word += s[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverseWord</span>(s, left, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpace</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刪除 s 前面多餘的空格, e.g &quot; hello word&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n &amp;&amp; s[fast] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刪除 s 中間多餘的空格, e.g &quot;hello  word&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (; fast &lt; n; ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast &gt; <span class="number">1</span> &amp;&amp; s[fast - <span class="number">1</span>] == s[fast] &amp;&amp; s[fast] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[slow++] = s[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉 string 末尾的空格</span></span><br><span class="line">        <span class="comment">// 檢查最後一個 char, 也就是 s[slow - 1] 是否為 &#x27; &#x27;, 若是的話要捨棄</span></span><br><span class="line">        <span class="keyword">if</span> (slow &gt; <span class="number">1</span> &amp;&amp; s[slow - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">resize</span>(slow - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.<span class="built_in">resize</span>(slow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseWord</span><span class="params">(string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[left++], s[right--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code></li><li><strong>space：</strong>$O(1)$ ➔ in-place, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>701. Insert into a Binary Search Tree</title>
      <link href="/post/insert-into-a-binary-search-tree/"/>
      <url>/post/insert-into-a-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">https://leetcode.cn/problems/insert-into-a-binary-search-tree/</a></strong></p><p><strong>題意</strong>：給一 BST 的 <code>root</code> 和要插入的值 <code>val</code>, 返回插入後 BST 的 <code>root</code>, BST 中所有的 <code>node.val</code> 皆為獨一無二的。</p><p><strong>注意</strong>：可能存在多種有效的插入方式, 返回任意一種即可。</p></blockquote><p><img src="https://i.imgur.com/hUtTelS.png"></p><p><img src="https://i.imgur.com/ZudwfoN.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ worse case：遍歷 BST</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case：skew tree</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 從 recursive 改成 iterative</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; cur-&gt;val) &#123;</span><br><span class="line">                <span class="comment">// 往右子樹尋找, 一旦為 null 則插入 val</span></span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 往左子樹尋找, 一旦為 null 則插入 val</span></span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ worse case：遍歷 BST</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>450. Delete Node in a BST</title>
      <link href="/post/delete-node-in-a-bst/"/>
      <url>/post/delete-node-in-a-bst/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">https://leetcode.cn/problems/delete-node-in-a-bst/</a></strong></p><p><strong>題意</strong>：給一 BST 的 <code>root</code> 和一個值 <code>key</code>, 刪除 BST 中的 <code>key</code> 對應的 node, 並保證 BST 的性質不變。返回刪除後 BST 的 <code>root</code>。</p><p>一般來說，刪除 node 可分為兩個步驟：</p><ul><li>首先找到需要刪除的 node</li><li>如果找到了, 則刪除它</li></ul></blockquote><p><img src="https://i.imgur.com/sG42d6G.png"></p><p><img src="https://i.imgur.com/7xX1zow.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p><ul><li>若 <code>key &gt; root-&gt;val</code>, 則去右子樹中刪除</li><li>若 <code>key &lt; root-&gt;val</code>, 則去左子樹中刪除</li><li>若 <code>key == root-&gt;val</code>, 則分為以下三種情況：<ul><li><p>若 <code>root</code> 無左子, 則 <code>root</code> 的右子頂替其位置</p></li><li><p>若 <code>root</code> 無右子, 則 <code>root</code> 的左子頂替其的位置</p></li><li><p>若 <code>root</code> 左右子都有, 則將其左子樹轉移到其右子樹的最左 node (也就是右子樹中最小的 node) 的左子樹上, 然後 <code>root</code> 的右子樹頂替其位置</p><p>  <img src="https://i.imgur.com/6meaQJi.png"></p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &gt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left) &#123; <span class="comment">// 無左子</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;right) &#123; <span class="comment">// 無右子</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 到右子中找到最小的 node</span></span><br><span class="line">            <span class="comment">// 最小的 node 其左子必為空, 不然它不會是右子中最小的 node</span></span><br><span class="line">            TreeNode *node = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (node-&gt;left) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node-&gt;left = root-&gt;left; <span class="comment">// 把 root-&gt;left 成為右子樹中最小的 node 之左子</span></span><br><span class="line">            root = root-&gt;right; <span class="comment">// root 的右子樹頂替其位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(h)$ ➔ 最多拜訪 <code>h</code> 個 node</li><li><strong>space：</strong>$O(h)$ ➔ 取決於遞迴深度, 遞迴深度不超過樹高 <code>h</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>189. Rotate Array</title>
      <link href="/post/rotate-array/"/>
      <url>/post/rotate-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/rotate-array/">https://leetcode.cn/problems/rotate-array/</a></strong></p><p><strong>題意</strong>：給一 array <code>nums</code>, 將其往右旋轉 <code>k</code> 次, 其中 <code>k</code> 為非負整數。</p></blockquote><p><img src="https://i.imgur.com/NaGQ6UI.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：用額外的 array 來記住原本的 <code>nums</code> 來進行旋轉, 由於 <code>k</code> 有可能會大於 <code>n</code>, 所以先將 <code>k</code> 做 mod 運算</strong></p><p>e.g. <code>nums = [1, 2, 3]</code>, <code>k = 4</code>, 其實 <code>k</code> 等價於 <code>4 % 3 = 1</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; tmp = nums;</span><br><span class="line"></span><br><span class="line">        k %= n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            nums[(i + k) % n] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>tmp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：將 <code>nums</code> 分成兩個部分, 旋轉後不會溢出 <code>nums</code> 的、旋轉後會溢出 <code>nums</code> 的。發現可以先將 <code>nums</code> 進行 reverse, 然後針對那兩個 group 再做一次 reverse 即為所求</strong></p><p><img src="https://i.imgur.com/AkZPWv4.png"></p><p><img src="https://i.imgur.com/cHdN41M.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k %= n;</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[left++], nums[right--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ reverse 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>474. Ones and Zeroes</title>
      <link href="/post/ones-and-zeroes/"/>
      <url>/post/ones-and-zeroes/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/ones-and-zeroes/">https://leetcode.cn/problems/ones-and-zeroes/</a></strong></p><p><strong>題意</strong>：給一二進制 string array <code>strs</code> 和兩整數 <code>m</code> 和 <code>n</code>。</p><p>給你 <code>m</code> 個 <code>0</code> 和 <code>n</code> 個 <code>1</code>, 求最多可以組成幾個 <code>strs</code> 中的 string。</p></blockquote><p><img src="https://i.imgur.com/QPWQa2L.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 本題有兩種容量（<code>0</code>、<code>1</code> 數量）, 因此使用三維 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>strs</code> 前先加上一個 <code>&quot;&quot;</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j][k]</code>：<code>strs[1:i]</code> 中, 使用 <code>j</code> 個 <code>0</code> 和 <code>k</code> 個 <code>1</code> 最多所能組成的 string 個數</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><p>假設 <code>strs[i]</code> 有 <code>zeros</code> 個 <code>0</code> 和 <code>ones</code> 個 <code>1</code>, 則每個 <code>strs[i]</code> 有兩種選擇（選 or 不選）</p></li><li><p>若 <code>zeros &gt; j</code> 或 <code>ones &gt; k</code>, 則 <code>strs[i]</code> 必不能選（超過個數上限）<br>➔ <code>dp[i][j][k] = dp[i - 1][j][k]</code></p></li><li><p>若 <code>zeros ≤ m</code> 或 <code>ones ≤ n</code>：</p><ul><li>若 <code>strs[i]</code> 要選, 則 <code>dp[i][j][k] = dp[i - 1][j - zeros][k - ones] + 1</code></li><li>若 <code>strs[i]</code> 不選, 則 <code>dp[i][j][k] = dp[i - 1][j][k]</code></li></ul><p>  <img src="https://i.imgur.com/43OAV4B.png"></p></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0][0]</code>：當沒有元素時, <code>0</code> 個 <code>0</code>、<code>0</code> 個 <code>1</code> 最多組成 <code>0</code> 的 string</li><li>其餘皆初始成 <code>0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = strs.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(len + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">        strs.<span class="built_in">emplace</span>(strs.<span class="built_in">begin</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> zeros = <span class="number">0</span>, ones = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : strs[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    ++zeros;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++ones;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k]; <span class="comment">// 先預設 strs[i] 不選（無法滿足下面條件）</span></span><br><span class="line">                    <span class="keyword">if</span> (j &gt;= zeros &amp;&amp; k &gt;= ones) &#123; <span class="comment">// 若沒超過上限個數, 則挑兩者中最大的</span></span><br><span class="line">                        dp[i][j][k] = <span class="built_in">max</span>(dp[i][j][k], dp[i - <span class="number">1</span>][j - zeros][k - ones] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len][m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(len \cdot m \cdot n + L)$ ➔ for loop, <code>len</code> 是 <code>strs</code> 的長度, <code>L</code> 是所有 string 長度之和<ul><li>$O(len \cdot m \cdot n)$：for loop</li><li>$O(L)$：計算所有 string 的 <code>0</code>、<code>1</code> 個數</li></ul></li><li><strong>space：</strong>$O(len \cdot m \cdot n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>dp[i][j][k]</code> 只會用到上一列的狀態, 因此只需保存上一列的狀態即可, 根本不需開到 $O(len \cdot m \cdot n)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = strs.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        strs.<span class="built_in">emplace</span>(strs.<span class="built_in">begin</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> zeros = <span class="number">0</span>, ones = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : strs[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    ++zeros;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++ones;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> prevRow = dp; <span class="comment">// 紀錄上一列的狀態</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = zeros; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = ones; k &lt;= n; ++k) &#123;</span><br><span class="line">                    dp[j][k] = <span class="built_in">max</span>(prevRow[j][k], prevRow[j - zeros][k - ones] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(len \cdot m \cdot n + L)$ ➔ <code>len</code> 是 <code>strs</code> 的長度, <code>L</code> 是所有 string 長度之和<ul><li>$O(len \cdot m \cdot n)$：for loop</li><li>$O(L)$：計算所有 string 的 <code>0</code>、<code>1</code> 個數</li></ul></li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1278. Palindrome Partitioning III</title>
      <link href="/post/palindrome-partitioning-iii/"/>
      <url>/post/palindrome-partitioning-iii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindrome-partitioning-iii/">https://leetcode.cn/problems/palindrome-partitioning-iii/</a></strong></p><p><strong>題意</strong>：給一由小寫字母組成的 string <code>s</code>, 和一整數 <code>k</code>。</p><p>請按下面的要求分割 <code>s</code>：</p><ul><li>首先, 你可以將 <code>s</code> 中的部分 char 修改為其他的小寫英文字母</li><li>接著, 你需要把 <code>s</code> 分割成 <code>k</code> 個非空且不相交的 substring, 並且每個 substring 都是回文</li></ul><p>返回以這種方式分割 <code>s</code> 所需修改的最少 char 數目。</p></blockquote><p><img src="https://i.imgur.com/slmWMfj.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>s</code> 前先加上一個 <code>#</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][k]</code>：<code>s[1:i]</code> 切割成 <code>k</code> 個回文 substring 的最少修改數</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>dp[i][k] = min(dp[i][k], dp[j - 1][k - 1] + helper(s, j, i))</code>, for <code>1 ≤ j ≤ i</code></li><li><code>j</code> 初始化成 <code>k</code> 而非 <code>1</code>, 是因為 <code>dp[j - 1][k - 1]</code> 指 <code>nums[1:(j-1)]</code> 拆成 <code>k - 1</code> 個 subarray, 而每個 subarray 至少一個數（<code>j</code> 如果太小, <code>nums[1:(j-1)]</code> 是沒辦法拆成 <code>k - 1</code> 個 subarray 的）<br>➔ 故 <code>j</code> 前面至少 <code>k - 1</code> 個數, 所以 <code>j</code> 的 index 可從 <code>k</code> 開始算</li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：當 <code>s = &quot;&quot;</code> 時, 切割成 <code>0</code> 個回文 substring 的最少修改數為 <code>0</code><br>➔ <code>dp[0][0] = 0</code></li><li><code>dp[i][0]</code>：當 <code>s</code> 不為空時, <code>s</code> 不可能透過修改 char 使得自身可以切割成 <code>0</code> 個回文 substring, 故將 <code>dp[i][0]</code> 設為 <code>INT_MAX / 2</code> 代表<strong>不可能</strong>。設 <code>INT_MAX / 2</code> 而非 <code>INT_MAX</code> 是為了避免 overflow（題目要求最小, 故初始值要設大）<br>➔ <code>dp[i][0] = INT_MIN / 2</code>, 其中 <code>1 ≤ i ≤ n</code></li><li><code>dp[0][k]</code>：當 <code>s = &quot;&quot;</code> 時, <code>s</code> 不可能透過修改 char 使得自身可以切割成 <code>k</code> 個回文 substring, 故將 <code>dp[0][k]</code> 設為 <code>INT_MAX / 2</code> 代表<strong>不可能</strong><br>➔ <code>dp[0][k] = INT_MIN / 2</code>, 其中 <code>1 ≤ k ≤ k_</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">palindromePartition</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> k_ = k;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&#x27;#&#x27;</span> + s;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">min</span>(i, k_); ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = k; j &lt;= i; ++j) &#123; <span class="comment">// j 起始設 k, 因為 j 前面至少要有 k - 1 個數</span></span><br><span class="line">                    dp[i][k] = <span class="built_in">min</span>(dp[i][k], dp[j - <span class="number">1</span>][k - <span class="number">1</span>] + <span class="built_in">helper</span>(s, j, i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 計算將 s[left:right] 變成回文的最小操作數, time complexity = O(n)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^3 \cdot k)$ ➔ for loop<ul><li>$O(n^2 \cdot k)$：<code>i</code>、<code>k</code>、<code>j</code> 所需的時間分別為 $O(n)$、$O(k)$、$O(n)$</li><li>$O(n)$：<code>helper()</code> 所需的時間</li></ul></li><li><strong>space：</strong>$O(n \cdot k)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改善 Solution 1, 將 <code>helper()</code> 改成用 DP 計算（區間 2 型）, 藉此優化時間複雜度</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>s</code> 前先加上一個 <code>#</code>, 代表什麼元素都沒有的狀態</li><li><code>count[i][j]</code>：<code>s[i:j]</code> 修改成回文所需的最少操作數</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li>若 <code>s[i] == s[j]</code>, 則不需修改任何 char<br>➔ <code>count[i][j] = count[i + 1][j - 1]</code></li><li>否則, 需要修改其中一個 char<br>➔ <code>count[i] = count[i + 1][j - 1] + 1</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>count[0][0]</code>：當 <code>s = &quot;&quot;</code> 時, 修改成回文所需的最少操作數為 <code>0</code><br>➔ <code>count[0][0] = 0</code></li><li><code>count[i][i]</code>：當 <code>s[i:j]</code> 中只有一個 char 時, 修改成回文所需的最少操作數為 <code>0</code><br>➔ <code>count[i][i] = 0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">palindromePartition</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> k_ = k;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&#x27;#&#x27;</span> + s;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">count</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            count[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    count[i][j] = count[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count[i][j] = count[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">min</span>(i, k_); ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = k; j &lt;= i; ++j)  &#123; <span class="comment">// j 起始設 k, 因為前面至少要有 k - 1 個數</span></span><br><span class="line">                    dp[i][k] = <span class="built_in">min</span>(dp[i][k], dp[j - <span class="number">1</span>][k - <span class="number">1</span>] + count[j][i]); <span class="comment">// j 在 i 前</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2 \cdot k)$ ➔ for loop</li><li><strong>space：</strong>$O(n^2 + n \cdot k)$ ➔ <code>count</code>、<code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>983. Minimum Cost For Tickets</title>
      <link href="/post/minimum-cost-for-tickets/"/>
      <url>/post/minimum-cost-for-tickets/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-cost-for-tickets/">https://leetcode.cn/problems/minimum-cost-for-tickets/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>days</code> 代表旅行的日子, 其中 <code>1 ≤ days[i] ≤ 365</code>。</p><p>車票有三種不同的銷售方式 ：</p><ul><li>一張 <strong>1-day</strong> 通行證的售價為 <code>costs[0]</code></li><li>一張 <strong>7-day</strong> 通行證的售價為 <code>costs[1]</code></li><li>一張 <strong>30-day</strong> 通行證的售價為 <code>costs[2]</code></li></ul><p>通行證允許數天無限制的旅行。例如, 如果我們在第 <code>2</code> 天獲得一張 <strong>7-day</strong> 的通行證, 則可以連著旅行 <code>7</code> 天：第 <code>2</code> 天、第 <code>3</code> 天、第 <code>4</code> 天、第 <code>5</code> 天、第 <code>6</code> 天、第 <code>7</code> 天和第 <code>8</code> 天。</p><p>返回滿足 <code>days</code> 中每一天都旅行所需的最低花費。</p><p><strong>注意</strong>：<code>days</code> 是<strong>嚴格遞增</strong>的。</p></blockquote><p><img src="https://i.imgur.com/aavcLxF.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li><code>dp[i]</code>：代表旅行到第 <code>i</code> 天所需的最小花費</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li>若 <code>i not in days</code>：也就是第 <code>i</code> 天實際上不用旅行, 因此直接使用上一次的狀態即可<br>➔ <code>dp[i] = dp[i - 1]</code></li><li><code>i in days</code>：有三種選擇, 取其中最小的<ul><li>第 <code>i</code> 天購買 1-day 通行證, 總花費 &#x3D; 前 <code>i - 1</code> 天的花費 + <code>costs[0]</code><br>  ➔ <code>dp[i] = dp[i - 1] + costs[0]</code></li><li>第 <code>i - 6</code> 天購買 7-day 通行證, 總花費 &#x3D; 前 <code>i - 7</code> 天的花費 + <code>costs[1]</code><br>  ➔ <code>dp[i] = dp[i - 7] + costs[1]</code></li><li>第 <code>i - 29</code> 天購買 30-day 通行證, 總花費 &#x3D; 前 <code>i - 30</code> 天的花費 + <code>costs[2]</code><br>  ➔ <code>dp[i] = dp[i - 30] + costs[2]</code></li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0]</code>：旅行到第 <code>0</code> 天所需的最小花費為 <code>0</code></li></ul><p><strong>4. 你可能會問：「為什麼不能用其他的組合？e.g. 第 <code>i - 2</code> 天時購買 7-day 的通行證, 這樣一樣可以 cover 到第 <code>i</code> 天」</strong></p><ul><li><p><strong>定理：當 <code>j &lt; i</code> 時, <code>dp[j] ≤ dp[i]</code> 恆成立</strong></p><p>  反證法：假設 <code>dp[j] &gt; dp[i]</code>, 那第 <code>j</code> 天時就使用第 <code>i</code> 天的方案, 剩下的天數寧可浪費掉, 這樣一來 <code>dp[j] = dp[i]</code> ➔ 與一開始的假設<code>dp[j] &gt; dp[i]</code> 相互矛盾, 故 <code>dp[j] ≤ dp[i]</code></p></li><li><p>由上述定理可得知, <code>dp[i - 7] ≤ dp[i - 2]</code>, 故只需考慮 <code>dp[i - 7] + costs[1]</code> 就好, 而不需考慮 <code>dp[i - 2] + costs[1]</code></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mincostTickets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; days, vector&lt;<span class="type">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(days.begin(), days.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(days.back() + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// + 1 是因為含第 0 天</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= days.<span class="built_in">back</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(i) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 注意 i - k 時可能會越界, k = 1, 7, 30</span></span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> day = dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">1</span>)] + costs[<span class="number">0</span>];</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> week = dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">7</span>)] + costs[<span class="number">1</span>];</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> month = dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">30</span>)] + costs[<span class="number">2</span>];</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(&#123;day, week, month&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[days.<span class="built_in">back</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ $O(365)$, 因為 for loop 取決於 <code>days.back()</code></li><li><strong>space：</strong>$O(1)$ ➔ $O(365)$, 因為 <code>dp</code> 的大小取決於 <code>days.back()</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>813. Largest Sum of Averages</title>
      <link href="/post/largest-sum-of-averages/"/>
      <url>/post/largest-sum-of-averages/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/largest-sum-of-averages/">https://leetcode.cn/problems/largest-sum-of-averages/</a></strong></p><p><strong>題意</strong>：給一 array <code>nums</code> 和一整數 <code>k</code>, 將 <code>nums</code> 分成最多 <code>k</code> 個相鄰的非空 subarray。<strong>分數</strong>為每個 subarray 內的平均值之總和。</p><p><strong>注意</strong>：必須使用 <code>nums</code> 中的每一個數進行分組, 且分數不一定是整數。</p><p>返回所能得到的<strong>最大分數</strong>, 答案誤差在 $10^{-6}$ 內都會被視為是正確的。</p></blockquote><p><img src="https://i.imgur.com/o0Eg3xQ.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>nums</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][k]</code>：<code>nums[1:i]</code> 分成 <code>k</code> 個 group 的平均值之最大總和</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>dp[i][k] = max(dp[i][k], dp[j - 1][k - 1] + sum / (i - j + 1));</code>, 其中 <code>1 ≤ j ≤ i</code></li><li>最後一個元素 <code>nums[i]</code>, 必定是在當前最後一個<strong>連續</strong> subarray 中, 因此要考慮這個區間的起始元素 <code>j</code> 會在哪裡 ➔ 故從 <code>i</code> 往前倒推</li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：空 array 分成 <code>0</code> 個 group 之最大平均值之總和為 <code>0</code><br>➔ <code>dp[0][0] = 0</code></li><li><code>dp[i][0]</code>：非空 array 不可能分成 <code>0</code> 個 group, 故用 <code>INT_MIN / 2</code> 代表<strong>不可能</strong>。由於題目要求最大值, 故初始值要設小, 但設 <code>INT_MIN</code> 後續計算會 overflow, 故設 <code>INT_MIN / 2</code><br>➔ <code>dp[i][0] = INT_MIN / 2</code>, 其中 <code>1 ≤ i ≤ n</code></li><li><code>dp[0][k]</code>：空 array 不可能分成 <code>k</code> 個 group, 故用 <code>INT_MIN / 2</code> 代表<strong>不可能</strong><br>➔ <code>dp[0][k] = INT_MIN / 2</code>, 其中 <code>1 ≤ k ≤ k_</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> k_ = k;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(k + <span class="number">1</span>, INT_MIN / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">min</span>(i, k_); ++k) &#123;</span><br><span class="line">                <span class="type">double</span> sum = <span class="number">0</span>; <span class="comment">// 計算最後一個區間之平均</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= k; --j) &#123; <span class="comment">// 從最後一個元素 i 往前倒推</span></span><br><span class="line">                    sum += nums[j];</span><br><span class="line">                    dp[i][k] = <span class="built_in">max</span>(dp[i][k], dp[j - <span class="number">1</span>][k - <span class="number">1</span>] + sum / (i - j + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2 \cdot k)$ ➔ for loop 中 <code>i</code>、<code>k</code>、<code>j</code> 所需的時間分別為 $O(n)$、$O(k)$、$O(n)$</li><li><strong>space：</strong>$O(n \cdot k)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>375. Guess Number Higher or Lower II</title>
      <link href="/post/guess-number-higher-or-lower-ii/"/>
      <url>/post/guess-number-higher-or-lower-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">https://leetcode.cn/problems/guess-number-higher-or-lower-ii/</a></strong></p><p><strong>題意</strong>：我們正在玩一個猜數遊戲, 遊戲規則如下：</p><ol><li>我從 <code>1</code> 到 <code>n</code> 之間選擇一個數字</li><li>你來猜我選了哪個數字</li><li>如果你猜到正確的數字, 就會<strong>贏得遊戲</strong></li><li>如果你猜錯了, 那麽我會告訴你, 我選的數字比你的更大 or 更小, 並且你需要繼續猜數</li><li>每當你猜了數字 <code>x</code> 並且猜錯了的時候, 你需要支付金額為 <code>x</code> 的現金。如果你花光了錢, 就會<strong>輸掉遊戲</strong>。</li></ol><p>給你一個特定的數字 <code>n</code>, 返回能夠確保你獲勝的<strong>最小現金</strong>, 不管我選擇哪個數字。</p></blockquote><p><img src="https://i.imgur.com/cXyYqEB.png"></p><p><img src="https://i.imgur.com/lSZoKMA.png"></p><p><img src="https://i.imgur.com/8jC01Gw.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li><code>dp[i][j]</code>：區間 <code>[i, j]</code> 中確保獲勝的最小現金</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li>選 <code>k</code> 且猜錯, 則確保獲勝的最小金額為 <code>k + max(dp[i][k - 1, dp[k + 1][j])</code>。<br>➔ 取兩個區間中的最大值是因為要確保必須考慮最差情況</li><li><code>dp[i][j] = min(dp[i][j], k + max(dp[i][k - 1], dp[k + 1][j]))</code>, for <code>i ≤ k ≤ j</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：沒有數時, 確保獲勝的最小現金為 <code>0</code></li><li><code>dp[i][i]</code>：當區間中只有一個數時, 確保獲勝的最小現金為 <code>0</code>。其中, <code>1 ≤ i ≤ n</code></li></ul><p><strong>注意：</strong></p><ul><li><code>dp</code> 的長度之所以要開 <code>n + 2</code> 而非 <code>n + 1</code>, 是因為 <code>i ≤ k ≤ j</code><br>➔ <code>dp[k + 1][j]</code> 中的 <code>k + 1</code> 最多是 <code>n + 1</code>, 故長度開 <code>n + 2</code></li><li>當 <code>k + 1 &gt; n</code> 時, <code>dp[k + 1][j]</code> 的值為 <code>0</code><br>➔ 根據 <code>dp[i][j]</code> 的定義, <code>dp[k + 1][j]</code> 為空區間, 故設為 <code>0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = INT_MAX; <span class="comment">// 要取最小值, 故將初始值設最大</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], k + <span class="built_in">max</span>(dp[i][k - <span class="number">1</span>], dp[k + <span class="number">1</span>][j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^3)$ ➔ for loop</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>516. Longest Palindromic Subsequence</title>
      <link href="/post/longest-palindromic-subsequence/"/>
      <url>/post/longest-palindromic-subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></strong></p><p><strong>題意</strong>：給一 string <code>s</code>, 找出其中最長的回文 subsequence, 並返回該 subsequence 的長度。</p><p>subsequence：不改變 char 順序的情況下, 刪除某些 char 或者不刪除任何 char 形成的一個 sequence。</p></blockquote><p><img src="https://i.imgur.com/9dL80CY.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>s</code> 前先加上一個 <code>#</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code>：區間 <code>s[i:j]</code> 中最長回文 subseq 之長度</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li>若 <code>s[i] == s[j]</code>, 則取出小區間 <code>s[i + 1][j - 1]</code> + 2<br>➔ <code>dp[i][j] = dp[i + 1][j - 1] + 2</code></li><li>否則, 取 <code>dp[i][j - 1]</code>、<code>dp[i + 1][j]</code> 這兩個小區間中較大者<br>➔ <code>dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[i][i]</code>：當區間中只有一個 char 時, 最長回文 subseq 之長度為 <code>1</code>, 其中 <code>1 ≤ i ≤ n</code></li><li>其餘區間之初始值皆設 <code>0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&#x27;#&#x27;</span> + s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123; <span class="comment">// 區間長度, 從 2 開始（因為 len = 1 已處理）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; ++i) &#123; <span class="comment">// // i 為區間的起始位置</span></span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> j = i + len - <span class="number">1</span>; <span class="comment">// j 為區間的結束位置</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1105. Filling Bookcase Shelves</title>
      <link href="/post/filling-bookcase-shelves/"/>
      <url>/post/filling-bookcase-shelves/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/filling-bookcase-shelves/">https://leetcode.cn/problems/filling-bookcase-shelves/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>books</code>,其中 <code>books[i] = [thickness_i, height_i]</code> 表示第 <code>i</code> 本書的厚度和高度。且會得到一個整數 <code>shelfWidth</code>。</p><p><strong>按順序</strong>將這些書擺放到總寬度為 <code>shelfWidth</code> 的書架上。</p><p>先選幾本書放在書架上（它們的厚度之和小於等於書架的寬度 <code>shelfWidth</code>）, 然後再建一層書架。重覆這個過程, 直到把所有的書都放在書架上。</p><p>需要注意的是, 在上述過程的步驟中, 擺放書的順序須與整理好的順序相同。</p><ul><li>例如, 如果有 <code>5</code> 本書, 那麼可能的一種擺放情況是：第一和第二本書放在第一層書架上, 第三本書放在第二層書架上, 第四和第五本書放在最後一層書架上。</li></ul><p>返回以這種方式布置書架的最小高度。</p></blockquote><p><img src="https://i.imgur.com/ymjxs9K.png"></p><p><img src="https://i.imgur.com/ety51lW.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>books</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i]</code>：代表 <code>books[1:i]</code> 中布置書架的最小高度</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li>若 <code>sum(books[j:i].width) ≤ shelfWidth</code>, 則將 <code>books[j:i]</code> 放在同一層, 並更新當前層的最大高度 <code>height</code>, 則 <code>dp[i]</code> 可由上一層建構而來<br>➔ 故 <code>dp[i] = max(dp[i], dp[j - 1] + height)</code>, 其中 <code>1 ≤ j &lt; i</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0]</code>：沒有書的書架, 其書架的最小高度為 <code>0</code></li><li><code>dp[1]</code>：只有一本書的書架, 其書架的最小高度為 <code>books[1].height</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minHeightShelves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; books, <span class="type">int</span> shelfWidth)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = books.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        books.<span class="built_in">emplace</span>(books.<span class="built_in">begin</span>(), vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        dp[<span class="number">1</span>] = books[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> width = books[i][<span class="number">0</span>], height = books[i][<span class="number">1</span>];</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + height; <span class="comment">// 初始化 dp[i] : 將 books[i] 放到下一層</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) &#123; <span class="comment">// 由於同一層是連續的, 所以從 i - 1 倒推</span></span><br><span class="line">                <span class="comment">// books[i], books[j] 在同一層</span></span><br><span class="line">                width += books[j][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (width &gt; shelfWidth) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                height = <span class="built_in">max</span>(height, books[j][<span class="number">1</span>]); <span class="comment">// 更新當前層的最大高度</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[j - <span class="number">1</span>] + height); <span class="comment">// 注意是 j - 1, 因為 i, j 同層</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1186. Maximum Subarray Sum with One Deletion</title>
      <link href="/post/maximum-subarray-sum-with-one-deletion/"/>
      <url>/post/maximum-subarray-sum-with-one-deletion/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/">https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/</a></strong></p><p><strong>題意</strong>：給一整數 array, 返回其 <strong>non-empty</strong> subarray（連續元素）在執行最多一次的刪除操作後, 所能得到的最大元素總和。</p><p><strong>注意</strong>：刪除一個元素後的 subarray 不能為空。</p></blockquote><p><img src="https://i.imgur.com/LW4BIMU.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>arr</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>noDel[i]</code>：<code>arr[1:i]</code> 中, 沒有任何刪除操作的最大 subarray 和</li><li><code>oneDel[i]</code>：<code>arr[1:i]</code> 中, 有一次刪除操作的最大 subarray 和</li></ul><p><strong>2. 得到狀態轉移方程：</strong></p><ul><li><p><code>noDel[i]</code>：由於沒有刪除操作, 故 <code>arr[i]</code> 一定在 subarry 中, 因此有兩種可能</p><ul><li>以 <code>arr[i]</code> 為結尾, 所有往前延伸之 subarray 中最大的（<code>subarray.size() &gt; 1</code>）<br>  ➔ 遞迴調用 <code>noDel[i - 1] + arr[i]</code></li><li>只有 <code>arr[i]</code>（前面 <code>arr[0:(i-1)]</code> 皆為負數, 加了只會更小, 不如不加）</li></ul><p>  <strong>➔ <code>noDel[i] = max(noDel[i - 1] + arr[i], arr[i])</code></strong></p></li><li><p><code>oneDel[i]</code>：有兩種可能</p><ul><li><code>arr[1:i]</code> 沒任何刪除操作, 刪除的是 <code>arr[i]</code> ➔ <code>noDel[i - 1]</code></li><li><code>arr[1:i]</code> 已經有一次刪除操作, 所以 <code>arr[i]</code> 不刪除<br>  ➔ <code>oneDel[i - 1] + arr[i]</code></li></ul><p>  <strong>➔ <code>oneDel[i] = max(oneDel[i - 1] + arr[i], noDel[i - 1])</code></strong></p></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>noDel[0]</code>、<code>oneDel[0]</code>：當沒有元素時, 最大元素總和為 <code>0</code></li><li><code>noDel[1]</code>：只有一個元素 <code>arr[1]</code> 時, 且沒有任何刪除操作<br><strong>➔ <code>noDel[1] = arr[1]</code></strong></li><li><code>oneDel[1]</code>：只有一個元素 <code>arr[1]</code> 時, 且有一次刪除操作<br>**➔ <code>oneDel[1] = 0</code>**（<code>arr[1]</code> 被刪除）</li><li><code>res</code>：照理來說, <code>res</code> 為上述兩者中取較大者, 也就是 <code>res = max(0, arr[1])</code>（<code>arr[1]</code> 有可能為負數）。但是, 題目有規定刪除一個元素後 subarray 不能為空, 所以當只有一個元素時, 是不能有任何刪除操作的, 所以 <code>res</code> 只能為 <code>noDel[1]</code>, 也就是 <code>arr[1]</code><strong>➔ <code>res = arr[1]</code></strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">noDel</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">oneDel</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        arr.<span class="built_in">emplace</span>(arr.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        noDel[<span class="number">1</span>] = arr[<span class="number">1</span>], oneDel[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            noDel[i] = <span class="built_in">max</span>(noDel[i - <span class="number">1</span>] + arr[i], arr[i]);</span><br><span class="line">            oneDel[i] = <span class="built_in">max</span>(oneDel[i - <span class="number">1</span>] + arr[i], noDel[i - <span class="number">1</span>]);</span><br><span class="line">            res = <span class="built_in">max</span>(&#123;res, noDel[i], oneDel[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>noDel</code>, <code>oneDel</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 由於 <code>noDel[i]</code>, <code>oneDel[i]</code> 只會用到第 <code>i - 1</code> 次的狀態, 因此只需儲存上一次的狀態即可, 根本不需要開到 $O(n)$ space。由於 <code>oneDel[i]</code> 會用到 <code>noDel[i - 1]</code>, 所以要先更新 <code>oneDel</code>, 再更新 <code>noDel</code>, 這樣才不會使 <code>oneDel</code> 拿到新的 <code>noDel</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        arr.<span class="built_in">emplace</span>(arr.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> noDel = arr[<span class="number">1</span>], oneDel = <span class="number">0</span>, res = arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            oneDel = <span class="built_in">max</span>(oneDel + arr[i], noDel);</span><br><span class="line">            noDel = <span class="built_in">max</span>(noDel + arr[i], arr[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(&#123;res, noDel, oneDel&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>368. Largest Divisible Subset</title>
      <link href="/post/largest-divisible-subset/"/>
      <url>/post/largest-divisible-subset/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/largest-divisible-subset/">https://leetcode.cn/problems/largest-divisible-subset/</a></strong></p><p><strong>題意</strong>：給一無重覆正整數組成的集合 <code>nums</code>, 找出並返回其中最大的整除 subset <code>answer</code>, 使得其中每一個 pair <code>(answer[i], answer[j])</code> 都應當滿足：</p><ul><li><code>answer[i] % answer[j] == 0</code> 或</li><li><code>answer[j] % answer[i] == 0</code></li></ul><p>如果存在多個 subset, 則返回其中一個即可。</p></blockquote><p><img src="https://i.imgur.com/oMQIZ8j.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>nums</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i]</code>：在 <code>nums</code> 為<strong>升序</strong>的前提下, 代表 <code>nums[1:i]</code> 中以 <code>nums[i]</code> 為結尾的最大整除 subset 之長度</li><li><code>prev[i]</code>：代表 <code>nums[i]</code> 是由哪一個 idx 的狀態轉移過來的, 以便回溯找出整個 subset</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li>若 <code>nums[i] % nums[j] == 0</code>：則 <code>dp[i] = max(dp[i], dp[j] + 1)</code>, 其中 <code>1 ≤ j &lt; i</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0]</code>：當沒有元素時, 最大整除 subset 之長度為 <code>0</code></li><li><code>dp[i]</code>：至少一個元素時, 以 <code>nums[i]</code> 為結尾的最大整除 subset 之長度最小為 <code>1</code>, 其中 <code>1 ≤ i ≤ n</code></li><li><code>prev[1]</code>：為了讓 <code>idx</code> 不斷往前回溯, 進而找出整個 subset。必須設一個終止條件, 將 <code>prev[1]</code> 設為一個不可能會出現的數（由於 <code>prev[i]</code> 存的是 idx, 故設為越界的 idx）<br>➔ <code>prev[1] = -1</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestDivisibleSubset</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prev</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (dp[i] == dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                        prev[i] = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 dp 中最大元素的 idx</span></span><br><span class="line">        <span class="type">int</span> idx = dp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; dp[idx]) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (idx != <span class="number">-1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums[idx]);</span><br><span class="line">            idx = prev[idx];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code>, <code>prev</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>487. Max Consecutive Ones II</title>
      <link href="/post/max-consecutive-ones-ii/"/>
      <url>/post/max-consecutive-ones-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/max-consecutive-ones-ii/">https://leetcode.cn/problems/max-consecutive-ones-ii/</a></strong></p><p><strong>題意</strong>：給一 binary array <code>nums</code>, 你最多能反轉一個 <code>0</code>, 返回最大連續 <code>1</code> 的個數。</p></blockquote><p><img src="https://i.imgur.com/vv6lstQ.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>nums</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>flip[i]</code> 為 <code>nums[1:i]</code> 中某個元素反轉後, <code>nums[i] = 1</code> 的最大連續 <code>1</code> 個數</li><li><code>noFlip[i]</code> 為 <code>nums[1:i]</code> 中沒有任何元素反轉, <code>nums[i] = 1</code> 的最大連續 <code>1</code> 個數</li></ul><p><strong>2. 得到狀態轉移方程：</strong></p><ul><li>當 <code>nums[i] == 0</code>：<ul><li><code>flip[i]</code> 必須使 <code>nums[i] = 1</code>, 故將 flip 的次數用在 <code>nums[i]</code> 上<br>  ➔ <code>flip[i] = noFlip[i - 1] + 1</code></li><li><code>noFlip[i]</code> 必須使 <code>nums[i] = 1</code>, 但是在不 flip 的情況下, <code>nums[i]</code> 不可能為 <code>1</code><br>  ➔ <code>noFlip[i] = 0</code></li></ul></li><li>當 <code>nums[i] == 1</code>：<ul><li><code>flip[i]</code> 必須使 <code>nums[i] = 1</code>, 但 <code>nums[i]</code> 已經是 <code>1</code>, 故直接接上<br>  ➔ <code>flip[i] = flip[i - 1] + 1</code></li><li><code>noFlip[i]</code> 必須使 <code>nums[i] = 1</code>, 但 <code>nums[i]</code> 已經是 <code>1</code>, 故直接接上<br>  ➔ <code>noFlip[i] = noFlip[i - 1] + 1</code></li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li><p><code>flip[0]</code>、<code>noFlip[0]</code>：沒有任何元素時, 最大連續 <code>1</code> 個數為 <code>0</code></p></li><li><p><code>flip[1]</code>：根據定義, 先將 <code>nums[1]</code> 取 flip, 然後計算 <code>nums[1] = 1</code> 的最大連續 <code>1</code> 個數</p><ul><li>當 <code>nums[1] = 0</code> 時, 先取 flip 得 <code>nums[1] = 1</code> ➔ <code>flip[1] = 1</code></li><li>當 <code>nums[1] = 1</code> 時, 先取 flip 得 <code>nums[1] = 0</code> ➔ <code>flip[1] = 0</code></li></ul><p>  ➔ <strong>由上述得到 <code>flip[1] = 1 - nums[1]</code>（<code>nums[1]</code> 取 flip）</strong></p></li><li><p><code>noFlip[1]</code>：根據定義, 不做任何 flip, 然後計算 <code>nums[1] = 1</code> 的最大連續 <code>1</code> 個數</p><ul><li>當 <code>nums[1] = 0</code> 時 ➔ <code>noFlip[1] = 0</code></li><li>當 <code>nums[1] = 1</code> 時 ➔ <code>noFlip[1] = 1</code></li></ul><p>  ➔ <strong>由上述得到 <code>noFlip[1] = nums[1]</code></strong></p></li><li><p><code>res</code>：上述兩者中取較大者, <code>max(flip[1], noFlip[1]) = max(1 - nums[1], nums[1]) = 1</code></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">flip</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">noFlip</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        flip[<span class="number">1</span>] = <span class="number">1</span> - nums[<span class="number">1</span>], noFlip[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                flip[i] = noFlip[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                noFlip[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flip[i] = flip[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                noFlip[i] = noFlip[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(&#123;res, flip[i], noFlip[i]&#125;); <span class="comment">// 三者中取較大者</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>flip</code>, <code>noflip</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 由於 <code>flip[i]</code>, <code>noFlip[i]</code> 只會用到第 <code>i - 1</code> 次的狀態, 因此只需儲存上一次的狀態即可, 根本不需要開到 $O(n)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> flip = <span class="number">1</span> - nums[<span class="number">1</span>], noFlip = nums[<span class="number">1</span>], res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                flip = <span class="number">1</span> + noFlip;</span><br><span class="line">                noFlip = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++flip;</span><br><span class="line">                ++noFlip;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(&#123;res, flip, noFlip&#125;); <span class="comment">// 三者中取較大者</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>256. Paint House</title>
      <link href="/post/paint-house/"/>
      <url>/post/paint-house/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/paint-house/">https://leetcode.cn/problems/paint-house/</a></strong></p><p><strong>題意</strong>：假如有一排房子, 共 <code>n</code> 間, 每間房子可以被刷成紅、藍 、綠這三種顏色中的一種, 刷所有的房子, 並使其相鄰的兩間房子顏色不能相同。</p><p>由於市場上不同顏色的油漆其價格是不同的, 所以房子刷成不同顏色的成本也是不同的。每間房子刷成不同顏色的花費是以一個 <code>n x 3</code> 的正整數 matrix <code>costs</code> 來表示的。</p><p>e.g. <code>costs[0][0]</code> 表示第 <code>0</code> 號房子刷成紅色的成本；<code>costs[1][2]</code> 表示第 <code>1</code> 號房子刷成綠色的成本, 依此類推…</p><p>計算刷完所有房子所需的最少花費。</p></blockquote><p><img src="https://i.imgur.com/8QSznbR.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>costs</code> 前先加上 <code>&#123;0,0,0&#125;</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code> 為前 <code>i</code> 間房子中, 其中第 <code>i</code> 間房子刷成第 <code>j</code> 種顏色所需的最少成本</li></ul><p><strong>2. 得到狀態轉移方程：</strong></p><ul><li><code>dp[i][j] = min(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3]) + costs[i][j]</code></li></ul><p>若第 <code>2</code> 間房子刷成第 <code>1</code> 種顏色, 則第 <code>1</code> 間房子要選第 <code>0</code> 和 <code>2</code> 種顏色中成本較少的</p><p>➔ <code>dp[2][1] = min(costs[1][2], costs[1][0]) + costs[2][1]</code></p><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][j]</code>：當沒有房子時, 將其刷成第 <code>j</code> 種顏色的最小成本為 <code>0</code></li><li><code>dp[1][j]</code>：當只有一間房子時, 將其刷成第 <code>j</code> 種顏色的最小成本為 <code>cost[1][j]</code></li></ul><p>e.g. <code>costs = [[17,2,17],[16,16,5],[14,3,19]]</code></p><p><img src="https://i.imgur.com/0usLEWI.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = costs.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        costs.<span class="built_in">emplace</span>(costs.<span class="built_in">begin</span>(), vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        dp[<span class="number">1</span>] = costs[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][(j + <span class="number">1</span>) % <span class="number">3</span>], dp[i - <span class="number">1</span>][(j + <span class="number">2</span>) % <span class="number">3</span>]) + costs[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp[n].<span class="built_in">begin</span>(), dp[n].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop 需 $O(3 \cdot n)$ time</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code> 需 $O(3 \cdot n)$ space</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>dp[i][j]</code> 只需用到第 <code>i - 1</code> 次的狀態, 因此只需儲存上一次的狀態即可, 根本不需要開到 $O(n)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = costs.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        costs.<span class="built_in">emplace</span>(costs.<span class="built_in">begin</span>(), vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp = costs[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextRow</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                nextRow[j] = <span class="built_in">min</span>(dp[(j + <span class="number">1</span>) % <span class="number">3</span>], dp[(j + <span class="number">2</span>) % <span class="number">3</span>]) + costs[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop 需 $O(3 \cdot n)$ time</li><li><strong>space：</strong>$O(1)$ ➔ <code>dp</code>, <code>nextRow</code> 只需 $O(3)$ space</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>376. Wiggle Subsequence</title>
      <link href="/post/wiggle-subsequence/"/>
      <url>/post/wiggle-subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/wiggle-subsequence/">https://leetcode.cn/problems/wiggle-subsequence/</a></strong></p><p><strong>題意</strong>：如果連續數字之間的差值在正數和負數之間交替, 則該 subsequence 稱為 <strong>Wiggle Subsequence</strong>。第一個差值（如果存在的話）可能是正數 or 負數。僅有一個元素 or 兩個不相等元素的 subsequence 也被視作 <strong>Wiggle Subsequence</strong>。</p><ul><li>e.g. <code>[1, 7, 4, 9, 2, 5]</code> 是一個 <strong>Wiggle Subsequence</strong>, 因為差值 <code>(6, -3, 5, -7, 3)</code> 是正負交替出現的。</li></ul><p>subsequence 可以通過從原 array 中刪除一些（也可以不刪除）元素來獲得, 剩下的元素保持其原先順序。</p><p>給一整數 array <code>nums</code>, 返回 <code>nums</code> 中 <strong>最長 Wiggle Subsequence 的長度</strong>。</p><p><strong>進階</strong>：設計 $O(n)$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/3MK1qxe.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>nums</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>up[i]</code> 代表 <code>nums[1:i]</code> 中以某一元素為結尾, 且「結尾上升」的最長 wiggle subsequence 之長度</li><li><code>down[i]</code> 代表 <code>nums[1:i]</code> 中以某一元素為結尾, 且「結尾下降」的最長 wiggle subsequence 之長度</li></ul><p><strong>2. 得到狀態轉移方程：</strong></p><ul><li>若 <code>nums[i] &gt; nums[i - 1]</code>：可以選出更長的結尾上升 wiggle subsequence, 但是結尾下降 wiggle subsequence 則無法選出更長的<ul><li><code>up[i] = max(up[i - 1], down[i - 1] + 1)</code></li><li><code>down[i] = down[i - 1]</code></li></ul></li><li>若 <code>nums[i] &lt; nums[i - 1]</code>：可以選出更長的結尾下降 wiggle subsequence, 但是結尾上升 wiggle subsequence 則無法選出更長的<ul><li><code>up[i] = up[i - 1]</code></li><li><code>down[i] = max(down[i - 1], up[i - 1] + 1)</code></li></ul></li><li>若 <code>nums[i] == nums[i - 1]</code>：則結尾上升、下降 wiggle subsequence 都無法選出更長的<ul><li><code>up[i] = up[i - 1]</code></li><li><code>down[i] = down[i - 1]</code></li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li>當沒有元素時, <code>up[0] = down[0] = 0</code></li><li>當只有一個元素時, 也會被視作為 wiggle subsequence, 故 <code>up[1] = down[1] = 1</code></li></ul><p><strong>4. 你可能會問：<code>up[i]</code> 和 <code>down[i]</code> 只記錄 <code>nums[1:i]</code> 中結尾上升、下降最長 wiggle subsequence 的長度, 又沒紀錄 subsequence 的結尾 <code>end</code>, 為什麼可以透過比較 <code>nums[i]</code> 和 <code>nums[i - 1]</code> 來決定狀態的轉移？不是應該比較 <code>nums[i]</code> 和 <code>end</code> 嗎？</strong></p><ul><li><p><strong>當 <code>nums[i] &gt; nums[i - 1]</code> 時：</strong></p><ul><li><p>假設 <code>down[i - 1]</code> 的結尾<strong>最大</strong> idx <code>j</code> 為 <code>i - 1</code>, 則 <code>nums[j]</code> 剛好遇到上升元素</p><p>  ➔ <code>up[i] = down[i - 1] + 1</code></p></li><li><p>假設 <code>down[i - 1]</code> 的結尾<strong>最大</strong> idx <strong><code>j</code> 小於 <code>i - 1</code></strong>, 則 <code>nums[j] &lt; nums[i - 1]</code>。因為如果 <code>nums[j] &gt; nums[i - 1]</code>, 則 <code>nums[i - 1]</code> 可替換 <code>nums[j]</code> 成為結尾, 但實際上 <code>j &lt; i - 1</code>, 故矛盾</p><p>  <strong>➔ 若 <code>j &lt; i - 1</code>, 則 <code>nums[j] &lt; nums[i - 1]</code></strong></p><ul><li><p><strong>且 <code>nums[j:(i-1)]</code> 必為遞增的</strong>。因為若非遞增, 則會產生波動, 並產生新的拐點 <code>k</code> 使得 <code>down[j] &lt; down[k]</code>, 這與之前假設的 <code>down[i - 1]</code> 的結尾<strong>最大</strong> idx <code>j</code> 矛盾</p><p>  ➔ <strong><code>down[j:(i-1)]</code> 皆等於 <code>down[j]</code>, 因為 <code>nums[j:(i-1)]</code> 必為遞增的</strong></p></li></ul><p>  <strong>➔ 當 <code>j &lt; i - 1</code> 且 <code>nums[i] &gt; nums[i - 1]</code>, 依然滿足 <code>up[i] = down[i - 1] + 1</code></strong></p></li></ul></li><li><p><strong><code>nums[i] &lt; nums[i - 1]</code>：同理</strong></p></li><li><p><strong>當 <code>nums[i] == nums[i - 1]</code>：新元素無法用於任何 subsequence, 故保持不變</strong></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">down</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        up[<span class="number">1</span>] = <span class="number">1</span>, down[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up[i] = <span class="built_in">max</span>(up[i - <span class="number">1</span>], down[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = <span class="built_in">max</span>(down[i - <span class="number">1</span>], up[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(up.<span class="built_in">back</span>(), down.<span class="built_in">back</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>up</code>, <code>down</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 由於 <code>up[i]</code>, <code>down[i]</code> 只會用到 <code>i - 1</code> 的狀態, 因此只須記住上一次的狀態即可, 根本不需要開到 $O(n)$ space。由於 <code>up</code>, <code>down</code> 記住了上一次的狀態, 所以原先在 Solution 1 的 for loop 中沒有更新的部分在 Solution 2 就不用寫出來, e.g. <code>up[i] = up[i - 1]</code>, <code>down[i] = down[i - 1]</code>, 只需要寫更新的部分即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = <span class="built_in">max</span>(up, <span class="number">1</span> + down);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = <span class="built_in">max</span>(down, <span class="number">1</span> + up);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 盡可能地加入拐點。用 <code>diff</code> 紀錄當前的斜率, <code>prevDiff</code> 紀錄上一次的斜率, 只要 <code>diff != prevDiff</code> 就把當前的點加入。若 <code>diff</code> 和 <code>prevDiff</code> 是同個趨勢 or <code>nums[i] == nums[i - 1]</code>, 則不加入</strong></p><p><img src="https://i.imgur.com/394y2EB.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, diff = <span class="number">0</span>; <span class="comment">// 初始斜率為 0</span></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> prevDiff = diff;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                diff = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                diff = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                diff = prevDiff;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (diff != prevDiff) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>438. Find All Anagrams in a String</title>
      <link href="/post/find-all-anagrams-in-a-string/"/>
      <url>/post/find-all-anagrams-in-a-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">https://leetcode.cn/problems/find-all-anagrams-in-a-string/</a></strong></p><p><strong>題意</strong>：給兩 string <code>s</code> 和 <code>p</code>, 找到 <code>s</code> 中所有 <code>p</code> 的異位詞, 並返回這些 substring 的起始 index。</p><p>異位詞：由相同字母重排列形成的 string（包括相同的 string）</p></blockquote><p><img src="https://i.imgur.com/DO3HnYj.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 同 <a href="https://zako945.github.io/post/permutation-in-string/">567. Permutation in String</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window, need;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : p) &#123;</span><br><span class="line">            ++need[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> c = s[right];</span><br><span class="line">            ++window[c];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">find</span>(c) != need.<span class="built_in">end</span>() &amp;&amp; window[c] == need[c]) &#123;</span><br><span class="line">                ++valid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (right - left &gt;= p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (valid == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> d = s[left];</span><br><span class="line">                <span class="keyword">if</span> (need.<span class="built_in">find</span>(d) != need.<span class="built_in">end</span>() &amp;&amp; window[d] == need[d]) &#123;</span><br><span class="line">                    --valid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                --window[d];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n1 + n2)$ ➔ <code>n1</code>、<code>n2</code> 分別為 <code>s</code>、<code>p</code> 的長度<ul><li>$O(n1)$：<code>s</code> 中的每個元素最多被遍歷 2 次（<code>left</code>、<code>right</code>）</li><li>$O(n2)$：遍歷 <code>p</code> 計算 <code>need</code></li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code>、<code>need</code> 長度皆為 $O(26)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1293. Shortest Path in a Grid with Obstacles Elimination</title>
      <link href="/post/shortest-path-in-a-grid-with-obstacles-elimination/"/>
      <url>/post/shortest-path-in-a-grid-with-obstacles-elimination/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/">https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/</a></strong></p><p><strong>題意</strong>：給一 <code>m x n</code> 的矩陣 <code>grid</code>, 其中每個 cell 不是 <code>0</code>（空）就是 <code>1</code>（障礙物）。每一步都可以在空白 cell 中上、下、左、右移動。</p><p>另給一整數 <code>k</code>, 代表最多可以消除 <code>k</code> 個障礙物。</p><p>返回從左上角 <code>(0, 0)</code> 到右下角 <code>(m-1, n-1)</code> 的最短路徑長度。若找不到這樣的路徑, 則返回 <code>-1</code>。</p></blockquote><p><img src="https://i.imgur.com/3H2Hu64.png"></p><p><img src="https://i.imgur.com/Sa0ePPb.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：看到走迷宮求最短路徑, 馬上想到 BFS。我們可以使用 <code>(y, x, e)</code> 代表一個搜索狀態, 其中 <code>(y, x)</code> 代表當前位置, <code>e</code> 代表當前消除障礙物的個數。此外, 我們還需用 <code>visited</code> 來記錄已拜訪的位置, 避免重複拜訪</strong></p><ul><li>當 <code>grid[i][j] == 1</code> 時：若當前消除障礙物的個數 <code>e</code> 小於 <code>k</code>, 且 <code>visited[i][j][e + 1] = false</code> ➔ 可以選擇消除此障礙物, 並把 <code>(i, j, e + 1)</code> push 到 <code>q</code> 中</li><li>當 <code>grid[i][j] == 0</code> 時：若 <code>visited[i][j][e] = false</code> ➔ 可以把 <code>(i, j, e)</code> push 到 <code>q</code> 中</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; t3i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當 grid = [[0]], 即起點 = 終點時, 只需要 0 步</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span> &amp;&amp; n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消除個數狀態有 k + 1 種（0 ~ k）</span></span><br><span class="line">        visited.<span class="built_in">resize</span>(m, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(k + <span class="number">1</span>, <span class="literal">false</span>)));</span><br><span class="line"></span><br><span class="line">        queue&lt;t3i&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(t3i&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> len = q.<span class="built_in">size</span>(); len &gt; <span class="number">0</span>; --len) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [y, x, e] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [offsetY, offsetX] : dirs) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> i = y + offsetY;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> j = x + offsetX;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 若抵達終點, 則返回 step + 1（因為是下一步才到）</span></span><br><span class="line">                    <span class="keyword">if</span> (i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">outOfBound</span>(i, j)) &#123;</span><br><span class="line">                        <span class="comment">// 若為障礙物, 則可以選擇消除</span></span><br><span class="line">                        <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (e == k) &#123; <span class="comment">// 如果消除個數已達上限, 則跳過</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!visited[i][j][e + <span class="number">1</span>]) &#123; <span class="comment">// 若未拜訪, 則加到 q 中</span></span><br><span class="line">                                visited[i][j][e + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                                q.<span class="built_in">emplace</span>(t3i&#123;i, j, e + <span class="number">1</span>&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!visited[i][j][e]) &#123; <span class="comment">// 若未拜訪, 則加到 q 中</span></span><br><span class="line">                                visited[i][j][e] = <span class="literal">true</span>;</span><br><span class="line">                                q.<span class="built_in">emplace</span>(t3i&#123;i, j, e&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++step;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot k)$ ➔ <code>q</code> 中的元素個數不超過 <code>m * n * k</code>, for loop 最多執行 <code>m * n * k</code> 次</li><li><strong>space：</strong>$O(m \cdot n \cdot k)$ ➔ <code>visited</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>843. Guess the Word</title>
      <link href="/post/guess-the-word/"/>
      <url>/post/guess-the-word/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/guess-the-word/">https://leetcode.cn/problems/guess-the-word/</a></strong></p><p><strong>題意</strong>：給一由不同 string 所組成的單字列表 <code>words</code>, 其中 <code>words[i]</code> 長度均為 <code>6</code>。<code>words</code> 中的一個單字將被選作秘密單字 <code>secret</code>。</p><p>另外, 給一輔助對象 <code>Master</code>, 你可以調用 <code>Master.guess(word)</code> 來猜單字, 其中參數 <code>word</code> 長度為 <code>6</code>, 且必須是 <code>words</code> 中的 string。</p><p><code>Master.guess(word)</code> 將會返回以下結果：</p><ul><li>若 <code>word</code> 不是 <code>words</code> 中的 string, 則返回 <code>1</code></li><li>返回一個整數, 表示你所猜測的單詞 <code>word</code> 與 <code>secret</code> 的準確匹配（值和位置同時匹配）的數目</li></ul><p>此外, 還會給一參數 <code>allowedGuesses</code>, 代表調用 <code>Master.guess(word)</code> 的最大次數。</p><p>在不超過允許猜測次數的前提下, 你應該調用 <code>Master.guess</code> 來猜出 <code>secret</code>, 並得到以下結果：</p><ul><li>若調用 <code>Master.guess</code> 的次數大於 <code>allowedGuesses</code> or 你沒有用 <code>Master.guess</code> 猜到 <code>secret</code>, 則得到 <code>&quot;Either you took too many guesses, or you did not find the secret word.&quot;</code></li><li>若調用 <code>Master.guess</code> 猜到 <code>secret</code>, 且調用 <code>Master.guess</code> 的次數不超過 <code>allowedGuesses</code>, 則得到 <code>&quot;You guessed the secret word correctly.&quot;</code></li></ul><p>題目保證你可以透過某種合理的策略（而非暴力法）猜到 <code>secret</code>。</p></blockquote><p><img src="https://i.imgur.com/GSpt7dm.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用刪去法</strong></p><ul><li>先隨機選擇一單字 <code>s</code>, 然後計算 <code>s</code> 與 <code>secret</code> 的相似度 <code>cnt</code></li><li>若 <code>cnt == 6</code>, 代表 <code>s</code> 為 <code>secret</code></li><li>否則, 遍歷 <code>words</code> 中其他的單字 <code>word</code>, 並計算 <code>s</code> 和 <code>word</code> 的相似度<br>然後將 <code>count(s, word) == cnt</code> 的單字加到 <code>filter</code> 中<br>➔ 能這樣做是因為 <code>s</code> 和 <code>secret</code> 的相似度等於 <code>cnt</code>, 若剩下的單字 <code>word</code> 要等於 <code>secret</code>, 則 <code>word</code> 和 <code>s</code> 的相似度必須要等於 <code>cnt</code></li><li>將 <code>words</code> 更新成 <code>filter</code></li><li>重複以上步驟直到 <code>words</code> 為空</li></ul><p>e.g. <code>secret = &quot;acckzz&quot;</code>, <code>words = [&quot;acckzz&quot;,&quot;ccbazz&quot;,&quot;eiowzz&quot;,&quot;abcczz&quot;]</code></p><ul><li>假設隨機選到 <code>s = eiowzz</code>, 此時 <code>s</code> 與 <code>secret</code> 的相似度 <code>cnt = 2</code><ul><li>遍歷 <code>words</code> 其他單字 <code>word</code>, 並把符合 <code>count(s, word) == 2</code> 的單字加到 <code>filter</code> 中</li><li><code>word = acckzz</code>, <code>count(s, word) = 2 = cnt</code> ➔ <code>filter = &#123;acckzz&#125;</code></li><li><code>word = ccbazz</code>, <code>count(s, word) = 2 = cnt</code> ➔ <code>filter = &#123;acckzz, ccbazz&#125;</code></li><li><code>word = abcczz</code>, <code>count(s, word) = 2 = cnt</code> ➔ <code>filter = &#123;acckzz, ccbazz, abcczz&#125;</code></li><li>更新 <code>words</code> ➔ <code>words = &#123;acckzz, ccbazz, abcczz&#125;</code></li></ul></li><li>假設隨機選到 <code>s = abcczz</code>, 此時 <code>s</code> 與 <code>secret</code> 的相似度 <code>cnt = 4</code><ul><li>遍歷 <code>words</code> 其他單字 <code>word</code>, 並把符合 <code>count(s, word) == 4</code> 的單字加到 <code>filter</code> 中</li><li><code>word = acckzz</code>, <code>count(s, word) = 4 = cnt</code> ➔ <code>filter = &#123;acckzz&#125;</code></li><li><code>word = ccbazz</code>, <code>count(s, word) = 2 != cnt</code> ➔ <code>filter = &#123;acckzz&#125;</code></li><li>更新 <code>words</code> ➔ <code>words = &#123;acckzz&#125;</code></li></ul></li><li>選 <code>s = acckzz</code>, 此時 <code>s</code> 與 <code>secret</code> 的相似度 <code>cnt = 6</code>, 代表找到 <code>secret</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findSecretWord</span><span class="params">(vector&lt;string&gt;&amp; words, Master&amp; master)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 這個數是試出來的, 若用 srand(time(0)) 隨機生成亂數, 有時會成功, 有時會失敗</span></span><br><span class="line">        <span class="built_in">srand</span>(<span class="number">1671613492</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!words.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 先隨機選一單字, 並計算其和 secret 的相似度</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> s = words[<span class="built_in">rand</span>() % words.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> cnt = master.<span class="built_in">guess</span>(s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若相似度為 6, 代表找到 secret</span></span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vector&lt;string&gt; filter;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 所以遍歷 words 剩下的 word, 計算 word 和 s 的相似度</span></span><br><span class="line">            <span class="comment">// 若 count(s, word) != cnt, 則將 word 剔除掉</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == word) &#123; <span class="comment">// 若為 s, 則跳過</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">count</span>(s, word) == cnt) &#123;</span><br><span class="line">                    filter.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            words = <span class="built_in">move</span>(filter); <span class="comment">// 將 words 更新成 filter</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 計算 s 和 word 的相似度, 只需 O(1) time, 因為 s、word 的長度必為 6</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; word)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == word[i]) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ worse case：每次 <code>s</code> 都只從 <code>words</code> 中剔除掉一個 <code>word</code><br>故時間複雜度為 $n + (n-1) + (n-2) + … + 1 &#x3D; O(n^2)$</li><li><strong>space：</strong>$O(n)$ ➔ <code>filter</code> 的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>123. Best Time to Buy and Sell Stock III</title>
      <link href="/post/best-time-to-buy-and-sell-stock-iii/"/>
      <url>/post/best-time-to-buy-and-sell-stock-iii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>prices</code>, 其中第 <code>i</code> 個元素代表第 <code>i</code> 天的股價。</p><p>最多完成兩筆交易, 返回最大利潤。</p><p><strong>注意</strong>：不能同時參與多筆交易（必須在再次購買前出售掉之前的股票）。</p></blockquote><p><img src="https://i.imgur.com/0kh9NVx.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>prices</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>hold1[i]</code>：第 <code>i</code> 天買入第一支股票的最大收益</li><li><code>sold1[i]</code>：第 <code>i</code> 天賣出第一支股票的最大收益</li><li><code>hold2[i]</code>：第 <code>i</code> 天買入第二支股票的最大收益</li><li><code>hold2[i]</code>：第 <code>i</code> 天賣出第二支股票的最大收益</li></ul><p><strong>2. 得到狀態轉移方程：</strong></p><ul><li><p><code>hold1[i]</code>：可由以下兩種狀態轉移</p><ul><li>第 <code>i - 1</code> 天買入第一支, 第 <code>i</code> 天不操作 ➔ <code>hold1[i - 1]</code></li><li>第 <code>i - 1</code> 天不操作（沒任何股票）, 第 <code>i</code> 天買入第一支 ➔ <code>0 - prices[i]</code></li></ul><p>  <strong>➔ <code>hold1[i] = max(hold1[i - 1], -prices[i])</code></strong></p></li><li><p><code>sold1[i]</code>：可由以下兩種狀態轉移</p><ul><li>第 <code>i - 1</code> 天賣出第一支, 第 <code>i</code> 天不操作 ➔ <code>sold1[i - 1]</code></li><li>第 <code>i - 1</code> 天不操作（買入第一支的狀態）, 第 <code>i</code> 天賣出第一支<br>  ➔ <code>hold1[i - 1] + prices[i]</code></li></ul><p>  <strong>➔ <code>sold1[i] = max(sold1[i - 1], hold1[i - 1] + prices[i])</code></strong></p></li><li><p><code>hold2[i]</code>：可由以下兩種狀態轉移</p><ul><li>第 <code>i - 1</code> 天買入第二支, 第 <code>i</code> 天不操作 ➔ <code>hold2[i - 1]</code></li><li>第 <code>i - 1</code> 天不操作（賣出第一支的狀態）, 第 <code>i</code> 天買入第二支<br>  ➔ <code>sold1[i - 1] - prices[i]</code></li></ul><p>  <strong>➔ <code>hold2[i] = max(hold2[i - 1], sold1[i - 1] - prices[i])</code></strong></p></li><li><p><code>sold2[i]</code>：可由以下兩種狀態轉移</p><ul><li>第 <code>i - 1</code> 天賣出第二支, 第 <code>i</code> 天不操作 ➔ <code>sold2[i - 1]</code></li><li>第 <code>i - 1</code> 天不操作（買入第二支的狀態）, 第 <code>i</code> 天賣出第二支<br>  ➔ <code>hold2[i - 1] + prices[i]</code></li></ul><p>  <strong>➔ <code>sold2[i] = max(sold2[i - 1], hold2[i - 1] + prices[i])</code></strong></p></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>hold1[0]</code>、<code>sold1[0]</code>、<code>hold2[0]</code>、<code>sold2[0]</code>：沒有股票時, 最大利潤為 <code>0</code></li><li><code>hold1[1]</code>：第一天買入股票 ➔ 此時的最大利潤為 <code>prices[1]</code></li><li><code>sold1[1]</code>：在第一天買入, 並且賣出 ➔ 此時的最大利潤為 <code>0</code></li><li><code>hold2[1]</code>：在第一天買入, 並且賣出, 然後再買入 ➔ 此時的最大利潤為 <code>prices[1]</code></li><li><code>sold2[1]</code>：在第一天買入, 並且賣出, 然後再買入、再賣出 ➔ 此時的最大利潤為 <code>0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hold1</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">sold1</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hold2</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">sold2</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        prices.<span class="built_in">emplace</span>(prices.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        hold1[<span class="number">1</span>] = -prices[<span class="number">1</span>], hold2[<span class="number">1</span>] = -prices[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            hold1[i] = <span class="built_in">max</span>(hold1[i - <span class="number">1</span>], -prices[i]);</span><br><span class="line">            sold1[i] = <span class="built_in">max</span>(sold1[i - <span class="number">1</span>], hold1[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            hold2[i] = <span class="built_in">max</span>(hold2[i - <span class="number">1</span>], sold1[i - <span class="number">1</span>] - prices[i]);</span><br><span class="line">            sold2[i] = <span class="built_in">max</span>(sold2[i - <span class="number">1</span>], hold2[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大利潤必發生在沒有持有股票的狀態, 故不考慮 hold1, hold2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(sold1.<span class="built_in">back</span>(), sold2.<span class="built_in">back</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>hold1</code>, <code>sold1</code>, <code>hold2</code>, <code>sold2</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>hold1[i]</code>, <code>sold1[i]</code>, <code>hold2[i]</code>, <code>sold2[i]</code> 只會用到 <code>i - 1</code> 的狀態, 因此只要儲存 <code>i - 1</code> 的狀態即可, 根本不需要開到 $O(n)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        prices.<span class="built_in">emplace</span>(prices.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hold1 = -prices[<span class="number">1</span>], sold1 = <span class="number">0</span>, hold2 = -prices[<span class="number">1</span>], sold2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> prevHold1 = hold1, prevSold1 = sold1;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> prevHold2 = hold2, prevSold2 = sold2;</span><br><span class="line"></span><br><span class="line">            hold1 = <span class="built_in">max</span>(prevHold1, -prices[i]);</span><br><span class="line">            sold1 = <span class="built_in">max</span>(prevSold1, prevHold1 + prices[i]);</span><br><span class="line">            hold2 = <span class="built_in">max</span>(prevHold2, prevSold1 - prices[i]);</span><br><span class="line">            sold2 = <span class="built_in">max</span>(prevSold2, prevHold2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大利潤必發生在沒有持有股票的狀態, 故不考慮 hold1, hold2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(sold1, sold2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1335. Minimum Difficulty of a Job Schedule</title>
      <link href="/post/minimum-difficulty-of-a-job-schedule/"/>
      <url>/post/minimum-difficulty-of-a-job-schedule/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/">https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/</a></strong></p><p><strong>題意</strong>：你需要制定一份 <code>d</code> 天的工作計劃表, 每個工作之間是互相依賴的, 要想執行第 <code>i</code> 項工作, 則必須完成前 <code>j</code> 項工作（<code>0 ≤ j &lt; i</code>）。</p><p>每天<strong>至少</strong>需要完成一項任務, 工作計劃的總難度是這 <code>d</code> 天每一天的難度之和, 而一天的工作難度是當天應該完成工作的最大難度。</p><p>給一整數 array <code>jobDifficulty</code> 和一整數 <code>d</code>, 分別代表工作難度和需要計劃的天數, 其中第 <code>i</code> 項工作的難度是 <code>jobDifficulty[i]</code>。</p><p>返回整個工作計劃的<strong>最小難度</strong>。若無法制定工作計劃, 則返回 <code>-1</code>。</p></blockquote><p><img src="https://i.imgur.com/O1FqvYX.png"></p><p><img src="https://i.imgur.com/XNBS7ZC.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>jobDifficulty</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][k]</code>：<code>jobDifficulty[1:i]</code> 分割成 <code>k</code> 個 subarray 的最小難度和</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>dp[i][k] = min(dp[i][k], dp[j - 1][k - 1] + curMax)</code>, 其中 <code>1 ≤ j ≤ i</code></li><li>最後一個元素 <code>jobDifficulty[i]</code>, 必定是在當前最後一個連續 subarray 中, 因此要考慮這個區間的起始元素 <code>j</code> 會在哪裡 ➔ 故從 <code>i</code> 往前倒推</li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：空 array 分割成 <code>0</code> 個 subarray 的最小難度和為 <code>0</code><br>➔ <code>dp[0][0] = 0</code></li><li><code>dp[i][0]</code>：非空 array 不可能分割成 <code>0</code> 個 subarray, 故用 <code>INT_MAX / 2</code> 代表<strong>不可能</strong>。由於題目要求最小值, 故初始值要設大, 但設 <code>INT_MAX</code> 會導致後續計算 overflow, 故設 <code>INT_MAX / 2</code><br>➔ <code>dp[i][0] = INT_MIN / 2</code>, 其中 <code>1 ≤ i ≤ n</code></li><li><code>dp[0][k]</code>：空 array 不可能分成 <code>k</code> 個 subarray, 故用 <code>INT_MAX / 2</code> 代表<strong>不可能</strong><br>➔ <code>dp[0][k] = INT_MIN / 2</code>, 其中 <code>1 ≤ k ≤ k_</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDifficulty</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; jobDifficulty, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = jobDifficulty.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(d + <span class="number">1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        jobDifficulty.<span class="built_in">emplace</span>(jobDifficulty.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">min</span>(i, d); ++k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> curMax = jobDifficulty[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= k; --j) &#123;</span><br><span class="line">                    curMax = <span class="built_in">max</span>(curMax, jobDifficulty[j]);</span><br><span class="line">                    dp[i][k] = <span class="built_in">min</span>(dp[i][k], dp[j - <span class="number">1</span>][k - <span class="number">1</span>] + curMax);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (dp[n][d] &gt;= INT_MAX / <span class="number">2</span>) ? <span class="number">-1</span> : dp[n][d];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2 \cdot k)$ ➔ for loop 中 <code>i</code>、<code>k</code>、<code>j</code> 所需的時間分別為 $O(n)$、$O(k)$、$O(n)$</li><li><strong>space：</strong>$O(n \cdot k)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1092. Shortest Common Supersequence</title>
      <link href="/post/shortest-common-supersequence/"/>
      <url>/post/shortest-common-supersequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/shortest-common-supersequence">https://leetcode.cn/problems/shortest-common-supersequence/</a></strong></p><p><strong>題意</strong>：給兩 string <code>str1</code> 和 <code>str2</code>, 返回同時以 <code>str1</code> 和 <code>str2</code> 作為 subsequence 的最短 string。如果答案不止一個, 則返回滿足條件的任意一個答案。</p><p>如果從 string <code>T</code> 中刪除一些char（也可能不刪除, 並且選出的這些 char 可以位於 <code>T</code> 中的<strong>任意位置</strong>）, 可以得到 string <code>S</code>, 那麼 <code>S</code> 就是 <code>T</code> 的subsequence）</p><p><strong>注意：</strong><code>str1</code>、<code>str2</code> 皆由小寫字母所組成。</p></blockquote><p><img src="https://i.imgur.com/1GWaWov.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>str1</code>、<code>str2</code> 前先加上一個 <code>#</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code>：<code>str1[1:i]</code>、<code>str2[1:j]</code> 的 SCS 之長度</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li>若 <code>str1[i] == str2[j]</code>：此時的 SCS 為原先的 SCS 加上 <code>str1[i]</code> 即可<br>➔ <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li><li>否則, 此時的 SCS 為原先的 SCS 加上 <code>str1[i]</code> 或 <code>str2[j]</code><br>➔ <code>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：兩個空 <code>&quot;&quot;</code> 的 SCS 為 <code>&quot;&quot;</code></li><li><code>dp[i][0]</code>：<code>str1[1:i]</code> 和 <code>&quot;&quot;</code> 的 SCS 為 <code>str1[1:i]</code><br>➔ <code>dp[i][0] = i</code>, 其中 <code>1 ≤ i ≤ m</code></li><li><code>dp[0][j]</code>：<code>&quot;&quot;</code> 和 <code>str2[1:j]</code> 的 SCS 為 <code>str2[1:j]</code><br>➔ <code>dp[0][j] = j</code>, 其中 <code>1 ≤ j ≤ n</code></li></ul><p>最後, 再從 <code>str1</code>、<code>str2</code>、<code>dp</code> 由後往前回推, 以構建出 SCS</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">shortestCommonSupersequence</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = str1.<span class="built_in">size</span>(), n = str2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        str1 = <span class="string">&#x27;#&#x27;</span> + str1;</span><br><span class="line">        str2 = <span class="string">&#x27;#&#x27;</span> + str2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = m, j = n;</span><br><span class="line">        string res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">                res += str1[i];</span><br><span class="line">                --i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j] == dp[i - <span class="number">1</span>][j] + <span class="number">1</span>) &#123;</span><br><span class="line">                res += str1[i];</span><br><span class="line">                --i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += str2[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += str1[i--];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += str2[j--];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()); <span class="comment">// 從後面回推 SCS, 故要 reverse</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>410. Split Array Largest Sum</title>
      <link href="/post/split-array-largest-sum/"/>
      <url>/post/split-array-largest-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/split-array-largest-sum/">https://leetcode.cn/problems/split-array-largest-sum/</a></strong></p><p><strong>題意</strong>：給一非負整數 array <code>nums</code> 和一整數 <code>k</code>, 將 <code>nums</code> 分成 <code>k</code> 個非空的連續 subarray。</p><p>設計一個演算法最小化這 <code>k</code> 個 subarray 和的最大值（盡可能讓每個 subarray 之和都差不多）。</p></blockquote><p><img src="https://i.imgur.com/1YLjFJI.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>nums</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][k]</code>：<code>nums[1:i]</code> 中 <code>k</code> 個 subarray 和的最大值之最小化</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>dp[i][k] = min(dp[i][k], max(dp[j - 1][k - 1], sum))</code>, 其中 <code>1 ≤ j ≤ i</code></li><li>最後一個元素 <code>nums[i]</code>, 必定是在當前最後一個連續 subarray 中, 因此要考慮這個區間的起始元素 <code>j</code> 會在哪裡 ➔ 故從 <code>i</code> 往前倒推</li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：空 array 可分割成 <code>0</code> 個 subarray, 且 subarray 最大和最小化之值為 <code>0</code><br>➔ <code>dp[0][0] = 0</code></li><li><code>dp[i][0]</code>：非空 array 不可能分割成 <code>0</code> 個 subarray, 故用 <code>INT_MAX / 2</code> 代表<strong>不可能</strong>。由於題目要求最小值, 故初始值要設大, 但設 <code>INT_MAX</code> 可能會導致後續計算 overflow, 故設 <code>INT_MAX / 2</code><br>➔ <code>dp[i][0] = INT_MIN / 2</code>, 其中 <code>1 ≤ i ≤ n</code></li><li><code>dp[0][k]</code>：空 array 不可能分成 <code>k</code> 個 subarray, 故用 <code>INT_MAX / 2</code> 代表<strong>不可能</strong><br>➔ <code>dp[0][k] = INT_MIN / 2</code>, 其中 <code>1 ≤ k ≤ k_</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> k_ = k;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>, INT_MAX / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">min</span>(i, k_); ++k) &#123;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= k; --j) &#123; <span class="comment">// 從最後一個元素 i 往前倒推</span></span><br><span class="line">                    sum += nums[j];</span><br><span class="line">                    dp[i][k] = <span class="built_in">min</span>(dp[i][k], <span class="built_in">max</span>(dp[j - <span class="number">1</span>][k - <span class="number">1</span>], sum));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2 \cdot k)$ ➔ for loop 中 <code>i</code>、<code>k</code>、<code>j</code> 所需的時間分別為 $O(n)$、$O(k)$、$O(n)$</li><li><strong>space：</strong>$O(n \cdot k)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1246. Palindrome Removal</title>
      <link href="/post/palindrome-removal/"/>
      <url>/post/palindrome-removal/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindrome-removal/">https://leetcode.cn/problems/palindrome-removal/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>arr</code>, 每次操作你都可以刪除一個<strong>回文</strong> subarray <code>arr[i], arr[i+1], ..., arr[j]</code>（<code>i ≤ j</code>）。</p><p>每當你刪掉一個 subarray, 其右側元素會向前填補空位。</p><p>計算從 <code>arr</code> 中刪除所有數字所需的最少操作數。</p></blockquote><p><img src="https://i.imgur.com/gnjtVug.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP, 當找不出突破口時, 試著從最後一個元素下手</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>arr</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code>：<code>arr[i:j]</code> 刪除所有數字的最小操作數</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><p>要在 <code>arr[i:j]</code> 中找回文, 就先判斷 <code>arr[j]</code> 要和哪個數消除</p><ul><li>若 <code>arr[j]</code> 和 <code>arr[k]</code> 相等時, 則一同消除, 其中 <code>i ≤ k ≤ j</code><br>  ➔ <code>dp[i][j] = dp[i + 1][k] + dp[k + 1][j - 1]</code></li><li>當 <code>dp[k + 1][j - 1]</code> 不為空區間時, 則 <code>arr[k]</code>、<code>arr[j]</code> 可以被算在子區間的最後一次刪除中<ul><li>e.g. <code>arr = [1, 2, 3, 1]</code> ➔ <code>[0, 1, 2, 3, 1]</code><ul><li>其中 <code>dp[2][3] = 2</code>, 要刪除 <code>[2, 3]</code> 需操作 <code>2</code> 次</li><li>由於 <code>arr[1] == arr[4]</code>, 可以先刪除子區間中的 <code>2</code>, 此時 <code>arr</code> 變成 <code>[1,3,1]</code> 為回文, 故只要再刪一次</li></ul></li></ul></li></ul></li><li><p>狀態轉移方程：</p><ul><li><code>dp[i][j] = min(dp[i][j], dp[i][k - 1] + max(1, dp[k + 1][j - 1]))</code></li><li><code>max(1, dp[k + 1][j - 1])</code> 是因為 <code>k + 1</code> 可能會越界。若越界, 根據 <code>dp[i][j]</code> 的定義, <code>dp[k + 1][j - 1]</code> 為空區間, 故設為 <code>0</code>。但此時要消除 <code>dp[k][j]</code> 的代價應為 <code>1</code>, 而不是 <code>0</code><ul><li>當 <code>dp[k + 1][j - 1] == 0</code> 時, 取 <code>1</code></li><li>當 <code>dp[k + 1][j - 1] != 0</code> 時, 取 <code>dp[k + 1][j - 1]</code></li></ul></li></ul><p>  <img src="https://i.imgur.com/NqgJB6b.png"></p></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：為空區間, 刪除所有數字的最小操作數 <code>0</code></li><li><code>dp[i][i]</code>：當區間中只有一個數時, 刪除所有數字的最小操作數 <code>1</code>。其中, <code>1 ≤ i ≤ n</code></li></ul><p><strong>4. 注意事項：</strong></p><ul><li><code>dp</code> 的長度之所以要開 <code>n + 2</code> 而非 <code>n + 1</code>, 是因為 <code>i ≤ k ≤ j</code><br>➔ <code>dp[k + 1][j - 1]</code> 中的 <code>k + 1</code> 最多是 <code>n + 1</code>, 故長度開 <code>n + 2</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumMoves</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        arr.<span class="built_in">emplace</span>(arr.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = INT_MAX; <span class="comment">// 題目要取最小, 故初始值設最大</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[k] == arr[j]) &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k - <span class="number">1</span>] + <span class="built_in">max</span>(<span class="number">1</span>, dp[k + <span class="number">1</span>][j - <span class="number">1</span>]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^3)$ ➔ for loop</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>727. Minimum Window Subsequence</title>
      <link href="/post/minimum-window-subsequence/"/>
      <url>/post/minimum-window-subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-window-subsequence/">https://leetcode.cn/problems/minimum-window-subsequence/</a></strong></p><p><strong>題意</strong>：給兩 string <code>s1</code>、<code>s2</code>, 找出 <code>s1</code> 中最短的連續 substring <code>w</code>, 使得 <code>s2</code> 是 <code>w</code> 的 subsequence。</p><p>如果 <code>s1</code> 中沒有 window 可以包含 <code>s2</code> 中的所有 char, 則返回 <code>&quot;&quot;</code>。如果有不只一個最短長度的窗口, 則返回<strong>開始位置最靠左的</strong>那個。</p><p><strong>注意</strong>：<code>s1</code>、<code>s2</code> 皆只由小寫英文所組成。</p></blockquote><p><img src="https://i.imgur.com/5iXB7gO.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>s1</code>、<code>s2</code> 前先加上一個 <code>#</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code>：以 <code>s[i]</code> 為結尾, 用 <code>s1[1:i]</code>、<code>s2[1:j]</code> 的 Minimum Window Subsequence 之長度</li></ul><p><strong>2. 得到轉移方程：</strong></p><p>令 <code>s1[1:i] = XXXXi</code>, <code>s2[1:j] = YYYj</code></p><ul><li>若 <code>s1[i] == s2[j]</code>, 則 <code>[XXXX]</code>、<code>[YYY]</code> 建構的 substring 加上 <code>s1[i]</code> 即可<br>➔ <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li><li>否則, <code>[XXXX]</code>、<code>[YYYj]</code> 建構的 substring 加上 <code>s1[i]</code> 即可<br>➔ <code>dp[i][j] = dp[i - 1][j] + 1</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：兩個 empty string <code>&quot;&quot;</code> 之 Minimum Window Subsequence 是 <code>&quot;&quot;</code><br>➔ <code>dp[0][0] = 0</code></li><li><code>dp[i][0]</code>：<code>s1[1:i]</code>、<code>&quot;&quot;</code> 的 Minimum Window Subsequence 永遠是 <code>&quot;&quot;</code><br>➔ <code>dp[i][0] = 0</code>, 其中 <code>1 ≤ i ≤ m</code></li><li><code>dp[0][j]</code>：<code>s1[1:i] = &quot;&quot;</code>、<code>s2[1:j]</code> 之 Minimum Window Subsequence 設為 <code>INT_MAX / 2</code>, 代表 <strong><code>s1[1:j]</code> 不存在包含 <code>s2[1:j]</code> 之 substring</strong>。之所以不設成 <code>INT_MAX</code> 是因為這樣後續計算 <code>dp[i][j]</code> 時會 overflow<br>➔ <code>dp[0][j] = INT_MAX / 2</code>, 其中 <code>1 ≤ j ≤ n</code></li></ul><p><strong>4. 注意事項：</strong></p><ul><li>做完後, 找出所有 <code>dp[i][n]</code> 中最小的 <code>i</code>。如此一來, 就取得了 substring 結尾的 idx <code>i</code> 和長度 <code>dp[i][n]</code><br>➔ 從而倒推出 substring 的起始 idx <code>i - dp[i][n] + 1</code></li><li>由於可能 <code>s1</code> 沒有 window 可以包含 <code>s2</code> 中的所有 char。但在狀態轉移方程中, 我們在 <code>s1[i] != s2[j]</code> 時, 仍直接把 <code>s1[i]</code> 加入到 window 中, 且 <code>dp[0][j]</code> 之初始值為 <code>INT_MAX</code><br>➔ 因此我們最後要檢查最短窗口的長度是否 <code>≥ INT_MAX</code>。若是的話, 代表 <code>s1</code> 中不存在包含 <code>s2</code> 的 window</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        s1 = <span class="string">&#x27;#&#x27;</span> + s1;</span><br><span class="line">        s2 = <span class="string">&#x27;#&#x27;</span> + s2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = INT_MAX / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1[i] == s2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = INT_MAX / <span class="number">2</span>, end;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][n] &lt; len) &#123;</span><br><span class="line">                len = dp[i][n];</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (len &gt;= INT_MAX / <span class="number">2</span>) ? <span class="string">&quot;&quot;</span> : s1.<span class="built_in">substr</span>(end - len + <span class="number">1</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>879. Profitable Schemes</title>
      <link href="/post/profitable-schemes/"/>
      <url>/post/profitable-schemes/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/profitable-schemes/">https://leetcode.cn/problems/profitable-schemes/</a></strong></p><p><strong>題意</strong>：集團里有 <code>n</code> 名員工, 他們可以完成各種各樣的工作創造利潤。</p><p>第 <code>i</code> 種工作會產生 <code>profit[i]</code> 的利潤, 它要求 <code>group[i]</code> 名成員共同參與。如果成員參與了其中一項工作, 就不能參與另一項工作。</p><p>選取一些工作, 這些工作需產生至少 <code>minProfit</code> 的利潤, 且工作的成員總數不得超過 <code>n</code>。</p><p>有多少種方案可以選擇？因為答案很大, 所以返回<strong>結果 mod <code>$10^9 + 7$</code> 的值</strong>即可。</p></blockquote><p><img src="https://i.imgur.com/iMrfMK5.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 本題有兩種容量, 因此使用三維 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>group</code>、<code>profit</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j][k]</code>：前 <code>i</code> 個工作中「恰好」選擇了 <code>j</code> 個員工, 並滿足利潤為「至少」為 <code>k</code> 的方案數</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li>第 <code>i</code> 個工作有「選 or 不選」兩種選擇：<ul><li><p>若不選, 則要用前 <code>i - 1</code> 個工作完成選擇 <code>j</code> 個員工, 並滿足最小利潤為 <code>k</code><br>  ➔ <code>dp[i][j][k] = dp[i - 1][j][k]</code></p></li><li><p>若要選, 假設第 <code>i</code> 個工作需 <code>person</code> 個員工, 且能創造 <code>earn</code> 利潤。則前 <code>i - 1</code> 個工作需選擇 <code>j - person</code> 個員工, 且至少需創造 <code>k - earn</code> 利潤<br>  ➔ <code>dp[i][j][k] = dp[i - 1][j - person][k - earn]</code></p><ul><li>由於我們定義的 <code>dp[i][j][k]</code> 是利潤「至少」為 <code>k</code>, 而不是利潤「恰好」為 <code>k</code>, 故上述的第三維應改為 <code>max(0, k - earn)</code> 而不是 <code>k - earn</code></li><li>理由：若 <code>earn &gt; k</code>, 代表光是第 <code>i</code> 個工作的利潤就超過要求 <code>k</code> 了, 但我們題目要求的是「至少」, 也就是說如果要求利潤「至少」為 <code>k</code>, 則利潤為 <code>k</code>、<code>k + 1</code>、<code>k + 2</code>、… 也都是滿足條件的</li><li>e.g. 若 <code>earn &gt; k</code>, 則應選擇第 <code>i</code> 個工作（假設沒超過人數上限）, 並把該方案數加到 <code>dp[i][j - person][0]</code> 中, 代表前 <code>i - 1</code> 個工作就算利潤為 <code>0</code> 也沒關係, 只要選了第 <code>i</code> 個工作就能滿足利潤至少為 <code>k</code></li></ul><p>  ➔ <code>dp[i][j][k] = dp[i - 1][j - person][max(0, k - earn)]</code></p></li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0][0]</code>：當沒有工作時, 選擇 <code>0</code> 個員工, 並滿足利潤為「至少」為 <code>0</code> 的方案數為 <code>1</code>（什麼都不選也是一種方案）<br>➔ <code>dp[0][0][0] = 1</code></li></ul><p>題目要求的是所有工作中, 利潤至少為 <code>minProfit</code>, 且工作的成員總數「不得超過」<code>n</code>, 因此選擇的人數可以是 <code>0</code>、<code>1</code>、…、<code>n</code>, 故答案要對所有可能人數的方案數進行加總<br>➔ <code>res = (res + dp[m][j][minProfit])</code>, for <code>0 ≤ j ≤ n</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> minProfit, vector&lt;<span class="type">int</span>&gt;&amp; group, vector&lt;<span class="type">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = group.<span class="built_in">size</span>(), mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(minProfit + <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        group.<span class="built_in">emplace</span>(group.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        profit.<span class="built_in">emplace</span>(profit.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123; <span class="comment">// task</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> person = group[i], earn = profit[i]; <span class="comment">// 第 i 個工作所需的員工數、產生的利潤</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123; <span class="comment">// person</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= minProfit; ++k) &#123; <span class="comment">// profit</span></span><br><span class="line">                    <span class="keyword">if</span> (j &lt; person) &#123; <span class="comment">// 第 i 個工作的人數超過上限 j, 則不選</span></span><br><span class="line">                        dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第 i 個工作的人數沒超過上限, 則選、不選的方案都得考慮</span></span><br><span class="line">                        dp[i][j][k] = (dp[i - <span class="number">1</span>][j][k] + dp[i - <span class="number">1</span>][j - person][<span class="built_in">max</span>(<span class="number">0</span>, k - earn)]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有工作中, 人數 ≤ n, 且利潤至少為 minProfit 的方案數加總</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            res = (res + dp[m][j][minProfit]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot minProfit)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n \cdot minProfit)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 由於 <code>dp[i][j][k]</code> 只會用到上一列的狀態, 因此只需保存上一列的狀態即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> minProfit, vector&lt;<span class="type">int</span>&gt;&amp; group, vector&lt;<span class="type">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = group.<span class="built_in">size</span>(), mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(minProfit + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        group.<span class="built_in">emplace</span>(group.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        profit.<span class="built_in">emplace</span>(profit.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123; <span class="comment">// task</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> prevRow = dp; <span class="comment">// 記住上一列</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> person = group[i], earn = profit[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123; <span class="comment">// person</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= minProfit; ++k) &#123; <span class="comment">// profit</span></span><br><span class="line">                    <span class="keyword">if</span> (j &lt; person) &#123;</span><br><span class="line">                        dp[j][k] = prevRow[j][k];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[j][k] = (prevRow[j][k] + prevRow[j - person][<span class="built_in">max</span>(<span class="number">0</span>, k - earn)]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            res = (res + dp[j][minProfit]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot minProfit)$ ➔ for loop</li><li><strong>space：</strong>$O(n \cdot minProfit)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>956. Tallest Billboard</title>
      <link href="/post/tallest-billboard/"/>
      <url>/post/tallest-billboard/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/tallest-billboard/">https://leetcode.cn/problems/tallest-billboard/</a></strong></p><p><strong>題意</strong>：你正在安裝一個廣告牌, 並希望它高度最大。這塊廣告牌將有兩個鋼制支架, 兩邊各一個, 且每個鋼支架的高度必須相等。</p><p>你有一堆可以焊接在一起的鋼筋 <code>rods</code>, e.g. 如果鋼筋的長度為 <code>1</code>、<code>2</code> 和 <code>3</code>, 則可以將它們焊接在一起形成長度為 <code>6</code> 的支架。</p><p>返回廣告牌可能的最大安裝高度, 如果無法安裝廣告牌, 則返回 <code>0</code>。</p></blockquote><p><img src="https://i.imgur.com/GlG28hY.png"></p><h2 id="Solution-1：-TLE-無法通過"><a href="#Solution-1：-TLE-無法通過" class="headerlink" title="Solution 1：(TLE 無法通過)"></a><strong>Solution 1：(TLE 無法通過)</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>rods</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j][k]</code>：<code>rods[1:i]</code> 中湊出左邊為 <code>j</code>、右邊為 <code>k</code> 是否可行</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>rods[i]</code> 有「選 or 不選」兩種可能：<ul><li><code>rods[i]</code> 不選, 則 <code>dp[i][j][k] = dp[i - 1][j][k]</code></li><li><code>rods[i]</code> 要選（<code>rods[i] = h</code>）：<ul><li>將 <code>rods[i]</code> 加入左邊, 則 <code>dp[i][j][k] = dp[i - 1][j - h][k]</code></li><li>將 <code>rods[i]</code> 加入右邊, 則 <code>dp[i][j][k] = dp[i - 1][j][k - h]</code></li></ul></li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0][0]</code>：當沒有元素時, 左邊為 <code>0</code>, 且右邊為 <code>0</code> 是可行的（什麼都不選）<br>➔ <code>dp[0][0][0] = true</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tallestBillboard</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rods)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = rods.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(rods.<span class="built_in">begin</span>(), rods.<span class="built_in">end</span>(), <span class="number">0</span>), half = sum / <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(half + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(half + <span class="number">1</span>, <span class="literal">false</span>)));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        rods.<span class="built_in">emplace</span>(rods.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = rods[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= half; ++j) &#123; <span class="comment">// 左邊長度最多為 half</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= half; ++k) &#123; <span class="comment">// 右邊長度最多為 half</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j][k]) &#123;</span><br><span class="line">                        dp[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= len &amp;&amp; dp[i - <span class="number">1</span>][j - len][k]) &#123; <span class="comment">// 小心越界</span></span><br><span class="line">                        dp[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt;= len &amp;&amp; dp[i - <span class="number">1</span>][j][k - len]) &#123; <span class="comment">// 小心越界</span></span><br><span class="line">                        dp[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由後往前取最大長度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = sum / <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = sum / <span class="number">2</span>; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[n][j][k] &amp;&amp; j == k) &#123; <span class="comment">// 可行 &amp; 左、右長度相等</span></span><br><span class="line">                    <span class="keyword">return</span> j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot half^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n \cdot half^2)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>rods</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code>：<code>rods[1:i]</code> 中湊出兩邊長度差為 <code>j</code> 時, 較短邊的最大長度</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>rods[i]</code> 有「選 or 不選」兩種可能：<ul><li><code>rods[i]</code> 不選, 則 <code>dp[i][j] = dp[i - 1][j]</code></li><li><code>rods[i]</code> 要選（<code>rods[i] = h</code>）：<ul><li><p>將 <code>rods[i]</code> 加入短邊, 且加入後短邊長度仍小於長邊。若加入前的長度差為 <code>j</code>, 則加入後的差為 <code>j - h</code>, 且加入後較小邊的最大長度要加上 <code>h</code><br>  ➔ <code>dp[i][j - h] = dp[i - 1][j] + h</code></p><p>  <img src="https://i.imgur.com/w5JJf5c.png"></p></li><li><p>將 <code>rods[i]</code> 加入短邊, 且加入後短邊長度大於長邊。若加入前的長度差為 <code>j</code>, 則加入後的差為 <code>h - j</code>, 且加入後較小邊的最大長度要加上 <code>j</code><br>  ➔ <code>dp[i][h - j] = dp[i - 1][j] + j</code></p><p>  <img src="https://i.imgur.com/NiDfxuY.png"></p></li><li><p>將 <code>rods[i]</code> 加入長邊：加入前長度之差為 <code>j</code>, 則代表加入後的長度差為 <code>j + h</code>, 且加入後較短邊的最大長度不變<br>  ➔ <code>dp[i][j + h] = dp[i - 1][j]</code></p><p>  <img src="https://i.imgur.com/CmT7Ps7.png"></p></li></ul></li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：當沒有元素時, 左、右兩邊長度皆為 <code>0</code>, 此時長度差為 <code>0</code>, 較短邊的最大長度為 <code>0</code><br>➔ <code>dp[0][0] = 0</code></li><li>其餘皆初始為 <code>INT_MIN / 2</code>, 代表還不知道較小邊的最大長度是多少（因為題目要求最大, 故初始值設小, 除 2 是因為怕操作時會 overflow）</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tallestBillboard</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rods)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = rods.<span class="built_in">size</span>(), sum = <span class="built_in">accumulate</span>(rods.<span class="built_in">begin</span>(), rods.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(sum + <span class="number">1</span>, INT_MIN / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        rods.<span class="built_in">emplace</span>(rods.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = rods[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= sum; ++j) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j]); <span class="comment">// 不使用</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加入短邊, 且加入後短邊長度仍小於長邊</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                    dp[i][j - len] = <span class="built_in">max</span>(dp[i][j - len], dp[i - <span class="number">1</span>][j] + len);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加入短邊, 且加入後短邊長度大於長邊</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt;= j) &#123;</span><br><span class="line">                    dp[i][len - j] = <span class="built_in">max</span>(dp[i][len - j], dp[i - <span class="number">1</span>][j] + j);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加入長邊, 較短邊的最大長度不變</span></span><br><span class="line">                <span class="keyword">if</span> (j + len &lt;= sum) &#123;</span><br><span class="line">                    dp[i][j + len] = <span class="built_in">max</span>(dp[i][j + len], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot sum)$ ➔ for loop</li><li><strong>space：</strong>$O(n \cdot sum)$ ➔ <code>dp</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, 由於 <code>dp[i][j]</code> 只會用到上一列的狀態, 因此只需保存上一列的狀態即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tallestBillboard</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rods)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = rods.<span class="built_in">size</span>(), sum = <span class="built_in">accumulate</span>(rods.<span class="built_in">begin</span>(), rods.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>, INT_MIN / <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        rods.<span class="built_in">emplace</span>(rods.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = rods[i];</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> prevRow = dp; <span class="comment">// 記住上一列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= sum; ++j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], prevRow[j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                    dp[j - len] = <span class="built_in">max</span>(dp[j - len], prevRow[j] + len);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (len &gt;= j) &#123;</span><br><span class="line">                    dp[len - j] = <span class="built_in">max</span>(dp[len - j], prevRow[j] + j);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j + len &lt;= sum) &#123;</span><br><span class="line">                    dp[j + len] = <span class="built_in">max</span>(dp[j + len], prevRow[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot sum)$ ➔ for loop</li><li><strong>space：</strong>$O(sum)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>903. Valid Permutations for DI Sequence</title>
      <link href="/post/valid-permutations-for-di-sequence/"/>
      <url>/post/valid-permutations-for-di-sequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-permutations-for-di-sequence/">https://leetcode.cn/problems/valid-permutations-for-di-sequence/</a></strong></p><p><strong>題意</strong>：給一長度為 <code>n</code> 的 string <code>s</code> , 其中 <code>s[i]</code> 可能是：</p><ul><li><code>D</code> 代表減少</li><li><code>I</code> 代表增加</li></ul><p><strong>有效排列</strong>是對在 <code>[0, n]</code>  範圍內的所有整數的一個排列 <code>perm</code>, 使得對所有的 <code>i</code> 滿足以下規則：</p><ul><li>若 <code>s[i] == &#39;D&#39;</code>, 則 <code>perm[i] &gt; perm[i + 1]</code></li><li>若 <code>s[i] == &#39;I&#39;</code>, 則 <code>perm[i] &lt; perm[i + 1]</code></li></ul><p>返回<strong>有效排列</strong> <code>perm</code> 的數量, 因為答案可能很大, 所以請返回你的答案對 <code>$10^9 + 7$</code> 取餘數。</p></blockquote><p><img src="https://i.imgur.com/sNuPtbt.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 由於 <code>s[i]</code> 決定的只是 <code>perm</code> 中的「相對」大小, 故 <code>perm[i]</code> 的值僅由 <code>s[i - 1]</code> 和 <code>perm[i - 1]</code> 決定。</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>s</code> 前先加上一個 <code>#</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code>：<code>s[1:i]</code> 中, 結尾為 <code>perm[i] = j</code> 的有效排列數。其中 <code>0 ≤ j ≤ i</code><br>➔ 相當於是 <code>[0, i]</code> 的有效排列數</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li>若 <code>s[i] == &#39;I&#39;</code>, 因 <code>perm[i] = j</code>, 所以有效排列數為加總前一個數 <code>s[i - 1]</code> 在區間 <code>[0, j - 1]</code> 的有效排列數<br>➔ <code>dp[i][j] = sum(dp[i - 1][k])</code>, for <code>0 ≤ k ≤ j - 1</code></li><li>若 <code>s[i] == &#39;D&#39;</code>, 因 <code>perm[i] = j</code>, 那有效排列數是不是為加總前一個數 <code>s[i - 1]</code> 在區間 <code>[j + 1, i]</code> 的有效排列數呢？其實不是, <code>s[i - 1]</code> 要改成在區間 <code>[j, i]</code> 才對<br>➔ <code>dp[i][j] = sum(dp[i - 1][k])</code>, for <code>j ≤ k ≤ i</code><ul><li><p>理由如下, 假如我們現在已經有了一個 <code>&quot;DID&quot;</code> 的排列 <code>1032</code>。若我們還想加一個 <code>D</code>, 將其變成 <code>&quot;DIDD&quot;</code> 的排列, 應該如何加數字呢？多了一個數字 <code>4</code>, 但顯然直接加 <code>4</code> 是不行的</p><ul><li>可以在末尾加 <code>2</code>, 但是要先把原排列中 <code>≥ 2</code> 的數字都先 <code>+1</code>, 即 <code>1032</code> ➔ <code>1043</code>, 然後再加 <code>2</code>, 變成 <code>10432</code></li><li>也可以在末尾加 <code>1</code>, 但是要先把原排列中 <code>≥ 1</code> 的數字都先 <code>+1</code>, 即 <code>1032</code> ➔ <code>2043</code>, 然後再加 <code>1</code>, 變成 <code>20431</code></li><li>也可以在末尾加 <code>0</code>, 但是要先把原排列中 <code>≥ 0</code> 的數字都先 <code>+1</code>, 即 <code>1032</code> ➔ <code>2143</code>, 然後再加 <code>0</code>, 變成 <code>21430</code></li><li>但是, 無法再末尾加 <code>3</code> 或 <code>4</code>, 因為原排列中的最後一位為 <code>2</code>, 所以只有 <code>≤ 2</code> 的數能被加在末尾, 否則無法形成降序（<code>s = &quot;DIDD&quot;</code>, 最後必須是降序）</li></ul><p>  ➔ 故 <code>k</code> 的區間為 <code>[j, i]</code>, 其中 <code>j</code> 為原排列的末尾 <code>perm[i - 1]</code> 之值</p></li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：當範圍為 <code>[0, 0]</code> 時, 只有 <code>1</code> 種有效排列數<br>➔ <code>dp[0][0] = 1</code></li><li>其餘皆初始成 <code>0</code></li></ul><p><strong>題目要求的是所有有效的排列數, 故答案為加總最後一位所有的可能性</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numPermsDISequence</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>(), mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        s = <span class="string">&#x27;#&#x27;</span> + s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j - <span class="number">1</span>; ++k) &#123;</span><br><span class="line">                        dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][k]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= i - <span class="number">1</span>; ++k) &#123;</span><br><span class="line">                        dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][k]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有效排列數為加總最後一位的所有可能性</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            res = (res + dp[n][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 由於 <code>dp[i][j]</code> 只會用到上一列的狀態, 故只需儲存上一列的狀態即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numPermsDISequence</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>(), mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        s = <span class="string">&#x27;#&#x27;</span> + s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> prevRow = dp; <span class="comment">// 記住上一列的狀態</span></span><br><span class="line">            dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 因為 dp[j] 要加總, 故加總前要先清除舊值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= i - <span class="number">1</span>; ++k) &#123;</span><br><span class="line">                        dp[j] = (dp[j] + prevRow[k]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j - <span class="number">1</span>; ++k) &#123;</span><br><span class="line">                        dp[j] = (dp[j] + prevRow[k]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有效排列數為加總最後一位的所有可能性</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            res = (res + dp[j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code>, <code>prevRow</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>546. Remove Boxes</title>
      <link href="/post/remove-boxes/"/>
      <url>/post/remove-boxes/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-boxes/">https://leetcode.cn/problems/remove-boxes/</a></strong></p><p><strong>題意</strong>：給一些不同顏色的盒子 <code>boxes</code>, 盒子的顏色由不同的正數表示。</p><p>你將經過若干輪操作去移除盒子, 直到所有的盒子都被移除為止。每一輪你可以移除具有相同顏色的連續 <code>k</code> 個盒子（<code>k ≥ 1</code>）, 這樣一輪之後你將得到 <code>k * k</code> 個積分。</p><p>返回你能獲得的最大積分和。</p></blockquote><p><img src="https://i.imgur.com/hJjVRiw.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：我們很容易陷入這樣一個錯誤的思路：用 <code>dfs(l, r)</code> 來表示移除區間 <code>[l, r]</code> 內所有的盒子能得到的最大積分, 然後去探索某一種移除盒子的策略來進行狀態轉移。但實際上, 我們並不能直接使用起點和終點來決定最大分數, 因為這個分數並不只依賴於 subarray, 也依賴於之前的移動對 array 的影響（概念類似 <a href="https://zako945.github.io/post/burst-balloons/">312. Burst Balloons</a>）, 最終的 subarray 在原先的 array 中可能不是連續的。</strong></p><p>e.g. <code>boxes = [3,4,2,4,4]</code></p><ul><li>若先移除 <code>2</code>, 使 <code>[3,4,2,4,4]</code> ➔ <code>[3,4,4,4]</code>, 再移除 <code>3</code> 個 <code>4</code><br>➔ 對積分的貢獻為 <code>$1^2 + 3^2 = 10$</code></li><li>若先移除右邊 <code>2</code> 個 <code>4</code>, 使 <code>[3,4,2,4,4]</code> ➔ <code>[3,4,2]</code>, 再移除 <code>4</code> 和 <code>2</code><br>➔ 對積分的貢獻為 <code>$2^2 + 1^2 + 1^2 = 6$</code></li><li>顯然先移除 <code>2</code> 的方案比較好, 但剩下的 <code>3</code> 個 <code>4</code> 在原先的 array 中並不是連續的</li></ul><p><strong>➔ 利用 DFS + Memorization, 因為本題 bottom-up 的 DP 不好做</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li><p><code>dfs(l, r, k)</code>：移除區間 <code>boxes[l:r]</code> 的盒子, 加上該區間右邊等於 <code>boxes[r]</code> 的 <code>k</code> 個元素所能獲得的最大積分</p><p>  e.g. <code>boxes = [l, l+1, ..., r-1, r, 值同r, 值同r, 值同r]</code></p><ul><li><p><code>index = r</code> 的右邊有 <code>3</code> 個元素和 <code>boxes[r]</code> 相同, 故 <code>k = 3</code>。因為有 <code>3</code> 個和 <code>r</code> 相同, 故可以消掉 <code>4</code> 個, 所以加上 <code>4 * 4</code><br>  ➔ <code>dp[l][r][3] = dp[0][r - 1][0] + 4 * 4</code></p></li><li><p>因此, 得到初始條件 <code>dp[l][r][k] = dp[l][r - 1][0] + pow(k + 1, 2)</code></p></li><li><p>但是, 也有可能在 <code>boxes[l:r]</code> 中存在和 <code>boxes[r]</code> 值相同的元素</p><ul><li>e.g. <code>boxes = [l, l+1, ..., i, i+1, ..., r-1, 值同i(原來是r), 值同i(原來是r+1), 值同i(原來是r+2), 值同i(原來是r+3)]</code>（假設 <code>boxes[i] == boxes[r]</code>）</li><li>先移除 <code>boxes[i+1:r-1]</code>, 使原來的 <code>dp[l][r][3]</code> 中的 <code>k = 3</code> 變的更大, 但是 <code>r</code> 變得更小, 這樣有機會使積分和更大<ul><li>先移除 <code>boxes[i+1:r-1]</code> 的最大積分和為 <code>dp[i + 1][r - 1][0]</code></li><li>移除剩餘部分 <code>[l, l+1, ..., i, 值同i(原來是r), 值同i(原來是r+1), 值同i(原來是r+2), 值同i(原來是r+3)]</code> 的最大積分和為 <code>dp[l][i][k + 1]</code></li></ul></li></ul><p>  ➔ <code>dp[l][r][k] = dp[i + 1][r - 1][0] + dp[l][i][k + 1]</code></p></li></ul></li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li>先將 <code>dp[l][r][k]</code> 初始為 <code>dp[l][r - 1][0] + pow(k + 1, 2)</code></li><li>當 <code>boxes[i] == boxes[r]</code> 時, <code>dp[l][r][k] = max(dp[l][r][k], dp[i + 1][r - 1][0] + dp[l][i][k + 1])</code>。其中, <code>l ≤ i &lt; r</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li>初始積分皆設為 <code>0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeBoxes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; boxes)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = boxes.<span class="built_in">size</span>();</span><br><span class="line">        dp.<span class="built_in">resize</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(boxes, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; boxes, <span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[l][r][k] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r][k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[l][r][k] = <span class="built_in">dfs</span>(boxes, l, r - <span class="number">1</span>, <span class="number">0</span>) + <span class="built_in">pow</span>(k + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (boxes[i] == boxes[r]) &#123;</span><br><span class="line">                dp[l][r][k] = <span class="built_in">max</span>(dp[l][r][k], <span class="built_in">dfs</span>(boxes, i + <span class="number">1</span>, r - <span class="number">1</span>, <span class="number">0</span>) + <span class="built_in">dfs</span>(boxes, l, i, k + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[l][r][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^4)$ ➔ 計算每個 <code>dfs(l, r, k)</code> 需 $O(n)$, 因為 for loop 不超過 $O(n)$。總共有 $O(n^3)$ 個狀態, 且計算每個狀態需 $O(n)$</li><li><strong>space：</strong>$O(n^3)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23. Merge k Sorted Lists</title>
      <link href="/post/merge-k-sorted-lists/"/>
      <url>/post/merge-k-sorted-lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></strong></p><p><strong>題意：</strong>給一 linked list array <code>lists</code>, 每個 linked list 都已按照升序排列。</p><p>將所有 linked list 合併成一個升序的 linked list, 並返回合併後的 linked list。</p></blockquote><p><img src="https://i.imgur.com/ZJQkf3W.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Heap 來紀錄所有 linked list 當前的 <code>node.val</code>, 每次取 heap 中最小的 node <code>cur</code>, 並加到新的 linked list 中。若 <code>cur-&gt;next</code> 不為 null, 則將其加到 heap 中（能這樣做是因為每個 linked list 皆已排序過）</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; n1, <span class="keyword">auto</span>&amp; n2)&#123;</span><br><span class="line">            <span class="keyword">return</span> n1-&gt;val &gt; n2-&gt;val;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// min heap</span></span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; node : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *tail = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> top = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            tail-&gt;next = top;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tail-&gt;next) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(tail-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(nk \cdot log(k))$<ul><li>假設每個 linked list 的平均長度為 <code>n</code>, 總共 <code>k</code> 個 linked list</li><li>$O(nk)$ : 總共有 $n \cdot k$ 個 node</li><li>$O(log(k))$ : heap 中的元素不超過 <code>k</code> 個, 因此每 insert &#x2F; delete 一個 node 需花 $O(log(k))$</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ heap 中的元素不超過 <code>k</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 merge sort, 類似 <a href="https://zako945.github.io/post/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a>, 只是變成合併 <code>k</code> 個 list</strong></p><p><img src="https://i.imgur.com/bH84QnR.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lists.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> n = lists.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;ListNode*&gt; newLists;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                ListNode *l1 = lists[i];</span><br><span class="line">                ListNode *l2 = (i + <span class="number">1</span> &lt; n) ? lists[i + <span class="number">1</span>] : <span class="literal">nullptr</span>;</span><br><span class="line">                newLists.<span class="built_in">emplace_back</span>(<span class="built_in">merge</span>(l1, l2));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(lists, newLists);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode *l1, ListNode *l2)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *tail = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            tail-&gt;next = l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            tail-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>space：</strong>$O(nk \cdot log(k))$<ul><li>假設每個 linked list 的平均長度為 <code>n</code>, 總共 <code>k</code> 個 linked list</li><li>$O(log(k))$ : $\dfrac{k}{2^x} &#x3D; 1$ ➔ $x &#x3D; log(k)$ &#x3D; 層數</li><li>$O(nk)$ : 共 $n \cdot k$ 個 node, worse case : 每個 node 皆被拜訪 $log(k)$ 次(每一層最多拜訪一次)</li></ul></li><li><strong>space：</strong>$O(n \cdot k)$ ➔ <code>newLists</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25. Reverse Nodes in k-Group</title>
      <link href="/post/reverse-nodes-in-k-group/"/>
      <url>/post/reverse-nodes-in-k-group/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">https://leetcode.cn/problems/reverse-nodes-in-k-group/</a></strong></p><p><strong>題意：</strong>給一 linked list 的 <code>head</code>, 每 <code>k</code> 個 node 一組進行 reverse, 返回修改後的 linked list。</p><p><code>k</code> 為一正整數, 其中 <code>k ≤ linkedList.size()</code>。如果 node 數不為 <code>k</code> 的倍數, 則讓剩餘的 node 保持原先的順序。</p><p>必須實際進行 swap node, 不能只是單純改變 <code>node.val</code>。</p><p><strong>進階：</strong>設計 $O(1)$ space 的演算法。</p></blockquote><p><img src="https://i.imgur.com/WKkh7aa.png"></p><p><img src="https://i.imgur.com/SuF4mNW.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：分成以下步驟</strong></p><ul><li>先用 <code>groupPre</code> 指向 group 開頭的前一個 node</li><li>取得該 group 的第 <code>k</code> 個 node <code>kth</code>, 也就是 group end</li><li>reverse 從 group head ~ group end 的 node<ul><li><strong>prev 起始設為 <code>kth-&gt;next</code></strong>, 因為 <strong>reverse 後 group end 必須連接到剩下的 node</strong></li></ul></li><li>reverse 完後, 首先記住 reverse 後的 group end（因為等等要將 <code>groupPre</code> 更新成 group end, 只是在那之前要先讓 <code>groupPre-&gt;next</code> 指向新的 group head）</li><li>將 <code>groupPre-&gt;next</code> 指向 reverse 後的 group head</li><li>更新 <code>groupPre</code> 為 reverse 後的 group end</li><li>重複以上步驟</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *groupPre = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ListNode *kth = <span class="built_in">getKth</span>(groupPre, k);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 group 的第 k 個為 null, 則代表該 group 不足 k 個, 故直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (!kth) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reverse the group</span></span><br><span class="line">            ListNode *groupNext = kth-&gt;next; <span class="comment">// 下一個 group 的 head</span></span><br><span class="line">            ListNode *prev = groupNext, *curr = groupPre-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (curr != groupNext) &#123;</span><br><span class="line">                ListNode *nxt = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = prev;</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = nxt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 記住 reverse 後的 group end(reverse 前的 group head)</span></span><br><span class="line">            ListNode *originalHead = groupPre-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 group dummy 指向 reverse 後的 group head(reverse 前的 group end)</span></span><br><span class="line">            groupPre-&gt;next = kth;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 group dummy 為 reverse 後的 group end</span></span><br><span class="line">            groupPre = originalHead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKth</span><span class="params">(ListNode* curr, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>124. Binary Tree Maximum Path Sum</title>
      <link href="/post/binary-tree-maximum-path-sum/"/>
      <url>/post/binary-tree-maximum-path-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">https://leetcode.cn/problems/binary-tree-maximum-path-sum/</a></strong></p><p><strong>題意：</strong>給一 BT 的 <code>root</code>, 返回其最大的 path sum。</p><p><strong>path 定義：</strong>為一條從 tree 中任意 node 出發, 最後抵達任意 node 的 sequence。同一個 node 在一條 path 中至多出現一次。該 path 至少包含一個 node, 且不一定經過 <code>root</code>。</p></blockquote><p><img src="https://i.imgur.com/ZU9AHD4.png"></p><p><img src="https://i.imgur.com/30WOiQg.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 類似 <a href="https://zako945.github.io/post/diameter-of-binary-tree/">543. Diameter of Binary Tree</a>, <code>dfs(node)</code> 返回以 <code>node</code> 為 root 之 subtree 中 path sum 之最大值, 只有當前 node 可以同時使用左子樹和右子樹, 也就是計算 <code>res</code> 時可同時用左子樹和右子樹, 但返回時只能 return 單邊路徑。由於 path 不一定要經過 root, 因此可用 global 變數 <code>res</code> 來記錄最大 path sum</strong></p><p><img src="https://i.imgur.com/tdpm7ci.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = root-&gt;val;</span><br><span class="line">        <span class="built_in">dfs</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">dfs</span>(root-&gt;left, res);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">dfs</span>(root-&gt;right, res);</span><br><span class="line">        left = <span class="built_in">max</span>(left, <span class="number">0</span>); <span class="comment">// 如果 left &lt; 0, 則不取</span></span><br><span class="line">        right = <span class="built_in">max</span>(right, <span class="number">0</span>); <span class="comment">// 如果 right &lt; 0, 則不取</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, root-&gt;val + left + right); <span class="comment">// 當前 root 可同時使用左、右子樹</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(left, right); <span class="comment">// 只能返回單邊路徑和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case：skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>297. Serialize and Deserialize Binary Tree</title>
      <link href="/post/serialize-and-deserialize-binary-tree/"/>
      <url>/post/serialize-and-deserialize-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/</a></strong></p><p><strong>題意：</strong>Serialize 是將資料結構轉換成一系列的 bit, 進而將其儲存在 file 或 buffer 中, 也可以透過網路傳輸到另一台電腦, 並重構得到原資料。</p><p>設計一個 BT 的 Serialize 和 Deserialize 功能, 讓一個 BT 可透過 Serialize 轉換成 string, 並透過 Deserialize 重構回 BT。</p></blockquote><p><img src="https://i.imgur.com/ufwR4dr.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS, 用 preorder 遍歷 BT, 並加入到 string 中, 記得 <code>val</code> 之間要用 <code>&#39;,&#39;</code> 隔開, 且用 <code>&#39;#&#39;</code> 代表 <code>nullptr</code></strong></p><ul><li><code>idx</code> 的 left child 必為 <code>idx + 1</code></li><li>當 <code>decodeDFS(nodes, idx)</code> 做完後, <code>idx</code> 會指向下一個 preorder 位置</li><li>所以當 <code>root-&gt;left = decodeDFS(nodes, idx)</code> 做完後, <code>idx</code> 會指向 <code>root-&gt;right</code> 的位置</li></ul><p>e.g. <code>root = [1,2,3]</code>, 可得到 <code>nodes = [&quot;1&quot;,&quot;2&quot;,&quot;#&quot;,&quot;#&quot;,&quot;3&quot;,&quot;#&quot;,&quot;#&quot;]</code></p><p><img src="https://i.imgur.com/F5auUO6.png"></p><ul><li><code>idx = 0</code> 時, 呼叫 <code>encodeDFS(nodes, 0)</code><ul><li>nodes[0]-&gt;left :<ul><li>會先呼叫 <code>encodeDFS(nodes, 1)</code><ul><li>首先會先呼叫 <code>encodeDFS(nodes, 2)</code></li><li>由於 <code>nodes[2]</code> 為 <code>&quot;#&quot;</code>, idx + 1 &#x3D; 3, 並返回 nullptr<br>  ➔ <code>nodes[1]</code> 得到 left child &#x3D; nullptr</li><li>接著呼叫 <code>encodeDFS(nodes, 3)</code>, 由於 <code>nodes[3]</code> 為 <code>&quot;#&quot;</code>, idx + 1 &#x3D; 4, 並返回 nullptr<br>  ➔ <code>nodes[1]</code> 得到 right child &#x3D; nullptr</li></ul></li><li>然後 <code>encodeDFS(nodes, 1)</code> 返回 <code>nodes[1]</code> ➔ <code>nodes[0]</code> 得到其 left child</li></ul></li><li>nodes[0]-&gt;right :<ul><li>接著, 呼叫 <code>encodeDFS(nodes, 4)</code><ul><li>首先會先呼叫 <code>encodeDFS(nodes, 5)</code></li><li>由於 <code>nodes[5]</code> 為 <code>&quot;#&quot;</code>, idx + 1 &#x3D; 6, 並返回 nullptr<br>  ➔ <code>nodes[4]</code> 得到 left child &#x3D; nullptr</li><li>接著呼叫 <code>encodeDFS(nodes, 6)</code>, 由於 <code>nodes[6]</code> 為 <code>&quot;#&quot;</code>, idx + 1 &#x3D; 7, 並返回 nullptr<br>  ➔ <code>nodes[4]</code> 得到 right child &#x3D; nullptr</li></ul></li><li>然後 <code>encodeDFS(nodes, 4)</code> 返回 <code>nodes[4]</code> ➔ <code>nodes[0]</code> 得到其 right child</li></ul></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="built_in">encodeDFS</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        vector&lt;TreeNode*&gt; nodes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先將 string 中每個 val 拆出來, 並轉換成 TreeNode</span></span><br><span class="line">        <span class="comment">// 然後再將 TreeNode* push 到 nodes 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = i; <span class="comment">// 從 i 開始往後找</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// j 指向 i 後面第一個 &#x27;,&#x27; 的位置</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; data[j] != <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出兩個 &#x27;,&#x27; 之間的 substring</span></span><br><span class="line">            <span class="type">const</span> string str = data.<span class="built_in">substr</span>(i, j - i);</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">                nodes.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> val = <span class="built_in">stoi</span>(str); <span class="comment">// string 轉換成 int</span></span><br><span class="line">                nodes.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i = j; <span class="comment">// 讓 i 下一輪從 &#x27;,&#x27; 的下一個 idx 開始</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">decodeDFS</span>(nodes, idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// preorder 遍歷 BT</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">encodeDFS</span><span class="params">(TreeNode* root, string&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            res += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res += (<span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>); <span class="comment">// int 轉換成 string</span></span><br><span class="line">        <span class="built_in">encodeDFS</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">encodeDFS</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將 preorder 轉換成 BT</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">decodeDFS</span><span class="params">(vector&lt;TreeNode*&gt;&amp; nodes, <span class="type">int</span>&amp; idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nodes[idx]) &#123;</span><br><span class="line">            ++idx;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> root = nodes[idx];</span><br><span class="line">        ++idx; <span class="comment">// idx 指向 root-&gt;left 的位置</span></span><br><span class="line">        root-&gt;left = <span class="built_in">decodeDFS</span>(nodes, idx); <span class="comment">// 做完後, idx 會指向 root-&gt;right 的位置</span></span><br><span class="line">        root-&gt;right = <span class="built_in">decodeDFS</span>(nodes, idx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>nodes</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 用 level-order 遍歷 BT, 並建立 string。然後用 <code>i</code> 來遍歷 parent node, 而 <code>j</code> 用來指向 <code>nodes[i]</code> 的 child node</strong></p><p>e.g. <code>root = [1,2,3]</code>, 可得到 <code>nodes = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]</code></p><p><img src="https://i.imgur.com/F5auUO6.png"></p><ul><li>i &#x3D; 0 時, j &#x3D; 1 ➔ <code>nodes[0]</code> 得到 <code>nodes[1]</code>、<code>nodes[2]</code> 分別為其 left、right child<ul><li>j +&#x3D; 2 指向下一個不為 nullptr 的 <code>nodes[i]</code> 之 left child</li><li>i +&#x3D; 1 移動到下一個 parent node</li></ul></li><li>i &#x3D; 1 時, j &#x3D; 3 ➔ <code>nodes[1]</code> 得到 <code>nodes[3]</code>、<code>nodes[4]</code> 分別為其 left、right child<ul><li>j +&#x3D; 2 指向下一個不為 nullptr 的 <code>nodes[i]</code> 之 left child</li><li>i +&#x3D; 1 移動到下一個 parent node</li></ul></li><li>i &#x3D; 3 時, j &#x3D; 5 ➔ <code>nodes[3]</code> 得到 <code>nodes[5]</code>、<code>nodes[6]</code> 分別為其 left、right child<ul><li>j +&#x3D; 2 指向下一個不為 nullptr 的 <code>nodes[i]</code> 之 left child</li><li>i +&#x3D; 1 移動到下一個 parent node</li></ul></li><li>i &#x3D; 4 時, j &#x3D; 7 ➔ 跳出迴圈</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">                res += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += (<span class="built_in">to_string</span>(node-&gt;val) + <span class="string">&quot;,&quot;</span>); <span class="comment">// int 轉換成 string</span></span><br><span class="line">                q.<span class="built_in">emplace</span>(node-&gt;left); <span class="comment">// push left child into q</span></span><br><span class="line">                q.<span class="built_in">emplace</span>(node-&gt;right); <span class="comment">// push right child into q</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;TreeNode*&gt; nodes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先將 string 中每個 val 拆出來, 並轉換成 TreeNode</span></span><br><span class="line">        <span class="comment">// 然後再將 TreeNode* push 到 nodes 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = i; <span class="comment">// 從 i 開始往後找</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// j 指向 i 後面第一個 &#x27;,&#x27; 的位置</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; data[j] != <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出兩個 &#x27;,&#x27; 之間的 substring</span></span><br><span class="line">            <span class="type">const</span> string str = data.<span class="built_in">substr</span>(i, j - i);</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">                nodes.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> val = <span class="built_in">stoi</span>(str); <span class="comment">// string 轉換成 int</span></span><br><span class="line">                nodes.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i = j; <span class="comment">// 讓 i 下一輪從 &#x27;,&#x27; 的下一個 idx 開始</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; <span class="comment">// i 代表 parent idx, j、j + 1 分別代表 left、right child</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; nodes.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes[i]) &#123;</span><br><span class="line">                nodes[i]-&gt;left = nodes[j];</span><br><span class="line">                nodes[i]-&gt;right = nodes[j+<span class="number">1</span>];</span><br><span class="line">                j += <span class="number">2</span>; <span class="comment">// 指向下一個 parent 的 child</span></span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>nodes</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>212. Word Search II</title>
      <link href="/post/word-search-ii/"/>
      <url>/post/word-search-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/word-search-ii/">https://leetcode.cn/problems/word-search-ii/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的網格 <code>board</code>, 和一 string list <code>words</code>, 返回同時存在於 <code>board</code> 和 <code>words</code> 中的所有單字。</p><p>單字必須按照字母順序, 並通過相鄰的 cell 所構成, 其中相鄰是指水平相鄰 or 垂直相鄰, 且同一位置的 cell 不允許被重複使用。</p><p>其中 <code>board[i][j]</code> 和 <code>words[i]</code> 皆由<strong>小寫</strong>字母組成, 且 <code>word</code> 中的 string 互不相同。</p></blockquote><p><img src="https://i.imgur.com/D4btxIv.png"></p><p><img src="https://i.imgur.com/cd9iCm3.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking, 同 <a href="https://zako945.github.io/post/word-search/">79. Word Search</a>, 每一個 <code>words[i]</code> 都從 <code>(0, 0)</code> ~ <code>(m, n)</code> 為起點開始搜索</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">exist</span>(board, word)) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, i, j, word, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> i, <span class="type">int</span> j, string&amp; word, <span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">outOfBound</span>(i, j) || board[i][j] != word[idx]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> cur = board[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將當前的 char 改成不該出現在 word 中的 char</span></span><br><span class="line">        <span class="comment">// 本題 word 中只能為英文字母, 故這邊設為數字</span></span><br><span class="line">        <span class="comment">// 這樣下方 dfs 中若走到拜訪過的位置必和 word[idx] 不相等, 並返回 false</span></span><br><span class="line">        <span class="comment">// 代表一定不會重複取同樣位置的 cell</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 標記成拜訪過的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往 上、下、左、右 四個方向搜索</span></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> found = <span class="built_in">dfs</span>(board, i - <span class="number">1</span>, j, word, idx + <span class="number">1</span>) ||</span><br><span class="line">                           <span class="built_in">dfs</span>(board, i + <span class="number">1</span>, j, word, idx + <span class="number">1</span>) ||</span><br><span class="line">                           <span class="built_in">dfs</span>(board, i, j - <span class="number">1</span>, word, idx + <span class="number">1</span>) ||</span><br><span class="line">                           <span class="built_in">dfs</span>(board, i, j + <span class="number">1</span>, word, idx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DFS 做完了, 代表當前 char 的所有可能都搜索完了, 還原當前的 char, 理由如下:</span></span><br><span class="line">        <span class="comment">// 若為 true, 則返回 true</span></span><br><span class="line">        <span class="comment">// 否則, 返回 false, 但下一個 char 為起始點是可以探索這個 char 的, 故要還原</span></span><br><span class="line">        board[i][j] = cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(w \cdot m \cdot n \cdot 4^L)$ ➔ <code>w</code> 為 <code>words</code> 中單字的個數, <code>L</code> 為 <code>words</code> 中<strong>最長</strong>單字的長度<ul><li>$O(w)$：總共要搜索 $w$ 個 word</li><li>$O(m \cdot n)$：每個 word 需以 $m * n$ 個 cell 為起點開始遍歷</li><li>$O(4^L)$：每個 cell 最多被拜訪 $4^L$ 次</li></ul></li><li><strong>space：</strong>$O(L)$ ➔ 取決於 dfs 的遞迴深度, 也就是 <code>words</code> 中最長單字的長度</li></ul><h2 id="Solution-2：（TLE-無法通過）"><a href="#Solution-2：（TLE-無法通過）" class="headerlink" title="Solution 2：（TLE 無法通過）"></a><strong>Solution 2：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 Trie + DFS + Backtracking</strong></p><ul><li>Trie 儲存 words, 可利用 prefix 來剪枝和節省空間</li><li>DFS + Backtracking 搜索 board</li></ul><p><img src="https://i.imgur.com/bGWOxJ3.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>; <span class="comment">// 預設每個 char 不為 end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;children[i]) &#123;</span><br><span class="line">                cur-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;isEnd = <span class="literal">true</span>; <span class="comment">// 將最後一個 char 設為 end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// insert words into trie</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一個 (i, j) 作為起點向外搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                TrieNode *node = trie.root;</span><br><span class="line">                string word; <span class="comment">// 紀錄遍歷 board 時的 word</span></span><br><span class="line">                <span class="built_in">dfs</span>(board, i, j, node, word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ans</span><span class="params">(res.begin(), res.end())</span></span>; <span class="comment">// 將 set 轉回 vector</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    Trie trie;</span><br><span class="line">    unordered_set&lt;string&gt; res; <span class="comment">// 同一個單字有可能在不同的路徑中出現, 故取 set</span></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dir = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, TrieNode* node, string&amp; word)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若超出邊界 or 已被拜訪, 則返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">outOfBound</span>(i, j) || board[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> ch = board[i][j];</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> idx = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 board[i][j] 不為下一個 char, 則返回</span></span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;children[idx]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 board[i][j] 為下一個 char, 則把它加到 word 中, 並前進到下一個 char</span></span><br><span class="line">        word += ch;</span><br><span class="line">        node = node-&gt;children[idx];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 將 (i, j) 標記為已拜訪</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若為結尾, 則將 word 加到 res 中, 並繼續往下搜索, 而非直接返回</span></span><br><span class="line">        <span class="comment">// 因為若 words = [aa, aaa], 在 board 中找到 aa 後, 仍要繼續找看看有沒有 aaa</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;isEnd) &#123;</span><br><span class="line">            res.<span class="built_in">emplace</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往 上、下、左、右 四個方向搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; dir.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> row = i + dir[k].first;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> col = j + dir[k].second;</span><br><span class="line">            <span class="built_in">dfs</span>(board, row, col, node, word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = ch; <span class="comment">// 返回上一層時, 要把 (i, j) 標記成未拜訪</span></span><br><span class="line">        word.<span class="built_in">pop_back</span>(); <span class="comment">// 返回上一層時, 要把 ch 給 pop 掉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> row, <span class="type">const</span> <span class="type">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= m || col &lt; <span class="number">0</span> || col &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot 4^L)$ ➔ <code>L</code> 為 <code>words</code> 中<strong>最長</strong>單字的長度<ul><li>$O(m \cdot n)$：需遍歷 $m * n$ 個 cell</li><li>$O(4^L)$：每個 cell 最多被拜訪 $4^L$ 次</li></ul></li><li><strong>space：</strong>$O(w \cdot L)$ ➔ 其中 <code>w</code> 為 <code>words</code> 中單字的個數, 而 <code>L</code> 為<strong>最長</strong>單字的長度, worse case：<code>trie</code> 中最多有 $O(w \cdot L)$ 個 node</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改善 Solution 2, 將已找到的單字從 <code>trie</code> 中刪除, 藉此來進行剪枝, 避免重複搜索已找到的單字。因此我們在 TrieNode 中新增一屬性 <code>cnt</code> 用來記錄該 char 被走過的次數。一旦某個單字被找到我們就把它從 Trie 移除, 移除的方法分成兩步驟：</strong></p><ul><li>遍歷 word 每一個 char, 並把 trie 中該 char 的 cnt 減一</li><li>把 word 最後一個 char 標記成 not end</li></ul><p>e.g. <code>words = [a, aa]</code>, 則 Trie 如下圖</p><ul><li>第一個 a 的 cnt &#x3D; 2, 是因為 a 和 aa 都會走到</li><li>第二個 a 的 cnt &#x3D; 1, 是因為只有 aa 會走到</li></ul><p><img src="https://i.imgur.com/QEYdTx0.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>; <span class="comment">// 預設每個 char 不為 end</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 紀錄每個 char 被走過幾遍(也就是有幾個 word)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;children[i]) &#123;</span><br><span class="line">                cur-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;children[i];</span><br><span class="line">            cur-&gt;cnt += <span class="number">1</span>; <span class="comment">// cnt + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;isEnd = <span class="literal">true</span>; <span class="comment">// 將最後一個 char 設為 end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// word 中每個 char 之都要 cnt 減一</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            node-&gt;children[i]-&gt;cnt -= <span class="number">1</span>;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">false</span>; <span class="comment">// 把 word 最後一個 char 標記成 not end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// insert words into trie</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一個 (i, j) 作為起點向外搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> node = trie.root;</span><br><span class="line">                string word; <span class="comment">// 紀錄遍歷 board 時的 word</span></span><br><span class="line">                <span class="built_in">dfs</span>(board, i, j, node, word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ans</span><span class="params">(res.begin(), res.end())</span></span>; <span class="comment">// 將 set 轉回 vector</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    Trie trie;</span><br><span class="line">    unordered_set&lt;string&gt; res; <span class="comment">// 同一個單字有可能在不同的路徑中出現, 故取 set</span></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dir = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, TrieNode* node, string&amp; word)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若超出邊界 or 已被拜訪, 則返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">outOfBound</span>(i, j) || board[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> ch = board[i][j];</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> idx = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 board[i][j] 不為下一個 char, 則返回</span></span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;children[idx]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若下一個 char 的 cnt 為 0, 則返回</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children[idx]-&gt;cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 board[i][j] 為下一個 char, 則把它加到 word 中, 並前進到下一個 char</span></span><br><span class="line">        word += ch;</span><br><span class="line">        node = node-&gt;children[idx];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 將 (i, j) 標記為已拜訪</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若為結尾, 則將 word 加到 res 中, 並繼續往下搜索, 而非直接返回</span></span><br><span class="line">        <span class="comment">// 因為若 words = [aa, aaa], 在 board 中找到 aa 後, 仍要繼續找看看有沒有 aaa</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;isEnd) &#123;</span><br><span class="line">            res.<span class="built_in">emplace</span>(word);</span><br><span class="line">            trie.<span class="built_in">remove</span>(word); <span class="comment">// 從 trie 中移除 word</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往 上、下、左、右 四個方向搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; dir.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> row = i + dir[k].first;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> col = j + dir[k].second;</span><br><span class="line">            <span class="built_in">dfs</span>(board, row, col, node, word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = ch; <span class="comment">// 返回上一層時, 要把 (i, j) 標記成未拜訪</span></span><br><span class="line">        word.<span class="built_in">pop_back</span>(); <span class="comment">// 返回上一層時, 要把 ch 給 pop 掉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> row, <span class="type">const</span> <span class="type">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= m || col &lt; <span class="number">0</span> || col &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot 4^L)$ ➔ <code>L</code> 為 <code>words</code> 中<strong>最長</strong>單字的長度<ul><li>$O(m \cdot n)$：需遍歷 $m * n$ 個 cell</li><li>$O(4^L)$：每個 cell 最多被拜訪 $4^L$ 次</li></ul></li><li><strong>space：</strong>$O(w \cdot L)$ ➔ 其中 <code>w</code> 為 <code>words</code> 中單字的個數, 而 <code>L</code> 為<strong>最長</strong>單字的長度, worse case：<code>trie</code> 中最多有 $O(w \cdot L)$ 個 node</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>295. Find Median from Data Stream</title>
      <link href="/post/find-median-from-data-stream/"/>
      <url>/post/find-median-from-data-stream/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/</a></strong></p><p><strong>題意：</strong>中位數是指有序 array 裡中間的數。若 array 長度偶數, 則中位數是中間兩數的平均值。</p><ul><li><code>arr = [2,3,4]</code>, 則中位數 &#x3D; <code>3</code></li><li><code>arr = [2,3]</code>, 則中位數 &#x3D; <code>(2+3) / 2 = 2.5</code></li></ul><p><strong>請實現 <code>MedianFinder</code> class：</strong></p><ul><li><code>MedianFinder()</code>：初始化 MedianFinder</li><li><code>void addNum(int num)</code>：新增 <code>num</code> 到資料結構中</li><li><code>double findMedian()</code>：找出目前的中位數</li></ul></blockquote><p><img src="https://i.imgur.com/01w3qdU.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1</strong>：</h2><blockquote><p><strong>想法：利用 Balanced BST(紅黑樹), C++ 可直接使用 <code>multiset</code>, 將元素 push 到 multiset 中它會自動排好序。我們用一個 iterator <code>mid</code> 指向目前的中位數（若 multiset 中的元素個數為偶數, 則讓 mid 指向中間靠左的元素）</strong></p><ul><li>若 <code>num</code> 加入前, <code>set</code> 中的元素為偶數個(<code>OOXOOO</code>, 其中 <code>X</code> 代表 <code>mid</code>), 則加入 <code>nums</code> 後, 分兩種情況:<ul><li>若 <code>nums &gt;= *mid</code> : <code>OOXOOO</code>(加入前) ➔ <code>OOXOOOO</code>(加入後), 則要將 <code>mid</code> 往右移一位, <code>OOXOOOO</code> ➔ <code>OOOXOOO</code></li><li>若 <code>nums &lt; *mid</code> : <code>OOXOOO</code>(加入前) ➔ <code>OOOXOOO</code>(加入後), 則 <code>mid</code> 不需移動</li><li>加入 <code>num</code> 後, <code>set</code> 中的元素變為奇數個, 因此返回 <code>mid</code> 即可</li></ul></li><li>若 <code>num</code> 加入前, <code>set</code> 中的元素為奇數個(<code>OOXOO</code>), 則加入 <code>nums</code> 後, 分兩種情況:<ul><li>若 <code>nums &gt;= *mid</code> : <code>OOXOO</code>(加入前) ➔ <code>OOXOOO</code>(加入後), 則 <code>mid</code> 不需移動</li><li>若 <code>nums &lt; *mid</code> : <code>OOXOO</code>(加入前) ➔ <code>OOOXOO</code>(加入後), 則要將 <code>mid</code> 往左移一位, <code>OOOXOO</code> ➔ <code>OOXOOO</code></li><li>加入 <code>num</code> 後, <code>set</code> 中的元素變為偶數個, 因此要返回<strong>中間兩數的平均值</strong></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        set.<span class="built_in">emplace</span>(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若為第一個元素, 則初始化 mid</span></span><br><span class="line">        <span class="keyword">if</span> (set.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            mid = set.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入 num 前為偶數個, OOXOOO</span></span><br><span class="line">        <span class="keyword">if</span> (set.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= *mid) &#123;</span><br><span class="line">                mid = <span class="built_in">next</span>(mid, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 加入 num 前為奇數個, OOXOO</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt; *mid) &#123;</span><br><span class="line">                mid = <span class="built_in">prev</span>(mid, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 若 set.size() 為偶數, 則中位數 = (左中位數 + 右中位數) / 2, 要避免 overflow</span></span><br><span class="line">        <span class="keyword">return</span> *mid * <span class="number">0.5</span> + *<span class="built_in">next</span>(mid, (set.<span class="built_in">size</span>() + <span class="number">1</span>) % <span class="number">2</span>) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;::iterator mid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>addNum()</code>：$O(log(n))$, Balanced BST 新增元素所需的時間複雜度為 $O(h)$, 因為是 Balanced, 所以 $h &#x3D; log(n)$</li><li><code>findMedian()</code>：$O(1)$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>set</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Heap, 使用兩個 heap 來分別記錄中間左中位數、右中位數, 因為當 <code>set</code> 中元素為偶數時, 我們需要取得這兩個數來計算平均值</strong></p><ul><li><strong>Max Heap <code>smaller</code> 紀錄所有 <code>≤ 中位數的數</code>, <code>smaller.top()</code> 可得到所有 <code>≤ 中位數的數</code> 中最大的值, 也就是左中位數</strong></li><li><strong>Min Heap <code>larger</code> 紀錄所有 <code>&gt; 中位數的數</code>, <code>larger.top()</code> 可得到所有 <code>&gt; 中位數的數</code> 中最小的值, 也就是右中位數</strong></li></ul><p><strong>在新增 <code>num</code> 時, 我們必須使兩個 heap 的長度保持平衡, 平衡的定義如下:</strong></p><ul><li><strong>滿足 <code>0 ≤ | smaller.size() - larger.size() | ≤ 1</code></strong></li></ul><p><strong>當兩個 heap 的長度不平衡時, 則把長度較長者的 top 給 pop 掉, 並把其 push 到另一個 heap</strong></p><ul><li><strong>要返回中位數時, 我們比較兩個 heap 的長度</strong><ul><li><p><strong>若 <code>smaller.size() &gt; larger.size()</code> 時, 返回 <code>smaller.top()</code></strong></p><p>  e.g. <code>smaller = [1,2,3]</code>, <code>larger = [4,5]</code>, 則中位數 &#x3D; <code>3</code></p></li><li><p><strong>若 <code>larger.size() &gt; smaller.size()</code> 時, 返回 <code>larger.top()</code></strong></p><p>  e.g. <code>smaller = [1,2]</code>, <code>larger = [3,4,5]</code>, 則中位數 &#x3D; <code>3</code></p></li><li><p><strong>若 <code>smaller.size() == larger.size()</code>, 代表 <code>set</code> 中元素個數為<font color="#f00">偶數</font>, 返回中間兩數的平均值, 也就是 <code>(smaller.top() + larger.top()) / 2.0</code></strong></p><p>  e.g. <code>smaller = [1,2,3]</code>, <code>larger = [4,5,6]</code>, 則中位數 &#x3D; <code>(3 + 4) / 2 = 3.5</code></p></li></ul></li></ul><p><img src="https://i.imgur.com/DMAxGkm.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 將 num 加入到 heap 中</span></span><br><span class="line">        <span class="keyword">if</span> (smaller.<span class="built_in">empty</span>() || num &lt;= smaller.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            smaller.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            larger.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = smaller.<span class="built_in">size</span>(), n = larger.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平衡 smaller 和 larger 的 size</span></span><br><span class="line">        <span class="keyword">if</span> (m - n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            larger.<span class="built_in">emplace</span>(smaller.<span class="built_in">top</span>());</span><br><span class="line">            smaller.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n - m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            smaller.<span class="built_in">emplace</span>(larger.<span class="built_in">top</span>());</span><br><span class="line">            larger.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (smaller.<span class="built_in">size</span>() &gt; larger.<span class="built_in">size</span>()) &#123; <span class="comment">// s = [1,2,3], l = [4,5]</span></span><br><span class="line">            <span class="keyword">return</span> smaller.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (larger.<span class="built_in">size</span>() &gt; smaller.<span class="built_in">size</span>()) &#123; <span class="comment">// s = [1,2], l = [3,4,5]</span></span><br><span class="line">            <span class="keyword">return</span> larger.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> smaller.<span class="built_in">top</span>() * <span class="number">0.5</span> + larger.<span class="built_in">top</span>() * <span class="number">0.5</span>; <span class="comment">// 避免 overflow 的寫法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; smaller; <span class="comment">// max heap</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; larger; <span class="comment">// min heap</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>addNum()</code>：$O(log(n))$ 從 heap 中新增 or 刪除元素</li><li><code>findMedian()</code>：$O(1)$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>smaller</code> + <code>larger</code> 的長度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51. N-Queens</title>
      <link href="/post/n-queens/"/>
      <url>/post/n-queens/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/n-queens/">https://leetcode.cn/problems/n-queens/</a></strong></p><p><strong>題意：</strong>按照國際象棋的規則, 皇后可以攻擊處於同一行 or 同一列 or 同一斜線上的棋子。</p><p><strong>n-queens 問題</strong>是研究如何將 <code>n</code> 個皇后放在 <code>n x n</code> 的棋盤上, 並使皇后們之間不能互相攻擊。</p><p>給一整數 <code>n</code>, 返回所有不同的 n-queens 問題的解法, 可以任意順序返回。</p><p>每一種解法包含一種放置棋子的方式, 其中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分別代表皇后跟空格。</p></blockquote><p><img src="https://i.imgur.com/XOkrEgh.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking, 單一格之兩條對角線可用公式表示</strong></p><ul><li><p>對角線1<strong>：f(x) &#x3D; x + y</strong>, 範圍：<code>[0, 2n - 2]</code> ➔ 總共 <code>2n - 1</code> 條</p><p>  <img src="https://i.imgur.com/96aO5ZX.png"></p></li><li><p>對角線2：<strong>f(x) &#x3D; x - y</strong>, 範圍：<code>[-(n - 1), (n - 1)]</code> ➔ 因為 vector 的 idx 從 <code>0</code> 開始, 所以要將範圍由 <code>[-(n - 1), (n - 1)]</code> 轉為 <code>[0, 2n - 2]</code> ➔ 得新公式：<strong>f(x) &#x3D; x - y + (n - 1)</strong></p><p>  <img src="https://i.imgur.com/tTWD0mJ.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        board.<span class="built_in">resize</span>(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        col.<span class="built_in">resize</span>(n, <span class="number">0</span>); <span class="comment">// col 是否被占用</span></span><br><span class="line">        diag1.<span class="built_in">resize</span>(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 正對角線是否被占用</span></span><br><span class="line">        diag2.<span class="built_in">resize</span>(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 負對角線是否被占用</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; col, diag1, diag2;</span><br><span class="line">    vector&lt;string&gt; board;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判斷 col 和兩條對角線上是否有衝突</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 只有在同 col 和兩條對角線都不衝突的情況下才能放</span></span><br><span class="line">        <span class="keyword">return</span> !col[x] &amp;&amp; !diag1[x + y] &amp;&amp; !diag2[x - y + n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateBoard</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y, <span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">bool</span> status)</span></span>&#123;</span><br><span class="line">        col[x] = status;</span><br><span class="line">        diag1[x + y] = status;</span><br><span class="line">        diag2[x - y + n - <span class="number">1</span>] = status;</span><br><span class="line">        board[y][x] = status ? <span class="string">&#x27;Q&#x27;</span> : <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// y 為 row</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> y, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在同一 row 中嘗試各個 col</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isValid</span>(x, y, n)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">updateBoard</span>(x, y, n, <span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(y + <span class="number">1</span>, n);</span><br><span class="line">            <span class="built_in">updateBoard</span>(x, y, n, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n!)$ ➔ 第一列最多有 <code>n</code> 種選擇, 而第二列最多有 <code>n - 1</code> 種選擇, 依此類推…</li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮 <code>board</code> 和要返回的 <code>res</code>, 則取決於遞迴深度, 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>332. Reconstruct Itinerary</title>
      <link href="/post/reconstruct-itinerary/"/>
      <url>/post/reconstruct-itinerary/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reconstruct-itinerary/">https://leetcode.cn/problems/reconstruct-itinerary/</a></strong></p><p><strong>題意：</strong>給一航線列表 <code>tickets</code>, 其中 <code>tickets[i] = [from_i, to_i]</code> 表示飛機出發和降落的地點。請你對該行程進行重新規劃排序。</p><p>所有這些機票都屬於一個從 <code>JFK</code> 出發的人, 所以該行程必須從 <code>JFK</code> 開始。如果存在多種有效的行程, 請你按字典排序返回最小的行程組合。</p><p>e.g. 行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 與 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小, 排序會更靠前</p><p>假定所有機票至少存在一種合理的行程。所有的機票都必須使用, 且每張只能用一次</p></blockquote><p><img src="https://i.imgur.com/Oa6PQ6n.png"></p><p><img src="https://i.imgur.com/FvitHhn.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>首先考慮下面這張圖, 總共有兩條合法路徑：</strong></p><ul><li><code>JFK ➔ AAA ➔ JFK ➔ BBB ➔ JFK</code></li><li><code>JFK ➔ BBB ➔ JFK ➔ AAA ➔ JFK</code></li><li>由於要選擇字典順序最小的, 所以我們選擇第一條</li><li>要如何每次都先拜訪最小的鄰近 node, 並記錄重複的點<br>➔ 將 <code>adj[v]</code> 宣告成 <a href="https://hackmd.io/@cliff0917/set-unordered_set-multiset-stl">multiset</a>, 這樣 insert 到 <code>adj[v]</code> 的 node 就會自動由小到大排序, 且允許重複元素。因為有可能 <code>v1</code> 重複拜訪 <code>v2</code> 多次, 由於每張票都必須被使用, 故 <code>adj[v1]</code> 要重複紀錄 <code>v2</code></li></ul><p><img src="https://i.imgur.com/jVYQmlM.png"></p><p><strong>考慮下面的特殊情形：</strong></p><ul><li>若先拜訪 <code>AAA</code>, 就沒辦法回到 <code>JFK</code> 了 ➔ 這樣就無法拜訪剩餘的邊</li><li>也就是說, 當我們 Greedy 拜訪順序最小的 node 時, 很可能會踏入「死路」導致無法遍歷所有的邊</li><li>因此, 我們利用 post order 倒著遍歷。若當前 node 不能繼續往下走, 則把它加到 <code>res</code> 中, 最後再將 <code>res</code> 反轉即可</li></ul><p><img src="https://i.imgur.com/O81YIMR.png"></p><p><strong>想法：利用 Hierholzer 演算法 (DFS + post order)</strong></p><ul><li>從起點出發, 進行 DFS</li><li>當沿著邊 <code>e</code> 從某個 <code>v1</code> 移動到另外一個頂點 <code>v2</code> 時, 需要刪除 <code>e</code> (避免重複拜訪)</li><li>如果沒有可移動的路徑, 則將所在節點加入到 <code>res</code> 中, 並返回</li><li>反轉 <code>res</code></li></ul><p>下圖可以看到由 <code>tickets</code> 所建立的 tree, 對該 tree 取 post order 再反轉即為答案</p><p><img src="https://i.imgur.com/2mRTlnd.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [src, dst] ：tickets) &#123;</span><br><span class="line">            adj[src].<span class="built_in">emplace</span>(dst);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;JFK&quot;</span>, res);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用 multiset 是因為 adj[v] 的 node 會由小到大排序, 這樣就會先拜訪 string 順序較小的</span></span><br><span class="line">    <span class="comment">// 且有可能 v1 重複拜訪 v2 多次, 由於每張票都必須被使用, 故 adj[v1] 要重複紀錄 v2</span></span><br><span class="line">    unordered_map&lt;string, multiset&lt;string&gt;&gt; adj; <span class="comment">// adjacent list</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; src, vector&lt;string&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!adj[src].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> next = *adj[src].<span class="built_in">begin</span>();</span><br><span class="line">            adj[src].<span class="built_in">erase</span>(adj[src].<span class="built_in">begin</span>());</span><br><span class="line">            <span class="built_in">dfs</span>(next, res);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(src);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(E \cdot log(E))$ ➔ 從 multiset 中移除一條邊需花 $O(log(E))$, 總共需移除 <code>E</code> 條</li><li><strong>space：</strong>$O(V + E)$ ➔ <code>adj</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Advanced Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>127. Word Ladder</title>
      <link href="/post/word-ladder/"/>
      <url>/post/word-ladder/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/word-ladder/">https://leetcode.cn/problems/word-ladder/</a></strong></p><p><strong>題意：</strong>一個 transform sequence 指的是 <code>wordList</code> 中從單字 <code>beginWord</code> 到 <code>endWord</code> 的 sequence <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>, 且 transform sequence 需滿足以下條件：</p><ul><li>相鄰的兩個單字只差一個字母</li><li>每個 <code>si</code> 都在 <code>wordList</code> 中, 其中 <code>1 ≤ i ≤ k</code>。注意, <code>beginWord</code> 不需在 <code>wordList</code> 中</li><li><code>sk == endWord</code></li></ul><p>給兩個單字 <code>beginWord</code> 和 <code>endWord</code>, 以及一字典 <code>wordList</code>, 返回從 <code>beginWord</code> 到 <code>endWord</code> 的<strong>最短</strong> transform sequence 中的<strong>單字個數</strong>。若不存在這樣的 transform sequence, 則返回 <code>0</code>。</p><p><strong>注意：</strong><code>wordList[i]</code> 僅由<strong>小寫</strong>字母所組成。</p></blockquote><p><img src="https://i.imgur.com/WCO5VDn.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：看到最短路徑會直覺想到 Dijkstra, 但在 unweighted graph 中, 其實只需要用 BFS 就可求得最短路徑了。故利用 BFS, 從 queue <code>q</code> 中取出當前的 word <code>curWord</code>, 然後將每個 <code>curWord[i]</code> 替換成 <code>a - z</code> 的其他 char。若更改後的 <code>curWord</code> 存在於 <code>dict</code> 中, 則將其加到 <code>q</code> 中, 並將其從 <code>dict</code> 中刪除以避免下一輪中 <code>q</code> 重複添加</strong></p><p><strong>e.g. <code>hit -&gt; hot -&gt; hit</code></strong></p><p><img src="https://i.imgur.com/JE8J6AM.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 將 wordList 轉成 hash set 方便查找</span></span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">dict</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 endWord 不在 dict 中, 則返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (dict.<span class="built_in">find</span>(endWord) == dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, len = beginWord.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">queue&lt;string&gt; <span class="title">q</span><span class="params">(&#123;beginWord&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> curWord = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> ch = curWord[j]; <span class="comment">// 記住當前第 j 位的 char, 等等要還原</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c) &#123;</span><br><span class="line">                        curWord[j] = c; <span class="comment">// 變更第 j 位的 char 為 c</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 若變更完後為 endWord, 則直接返回 res + 1</span></span><br><span class="line">                        <span class="keyword">if</span> (curWord == endWord) &#123;</span><br><span class="line">                            <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 若變更完後的 word 在 dict 中, 則將其加到 q 中</span></span><br><span class="line">                        <span class="keyword">if</span> (dict.<span class="built_in">find</span>(curWord) != dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            q.<span class="built_in">emplace</span>(curWord);</span><br><span class="line">                            dict.<span class="built_in">erase</span>(curWord); <span class="comment">// 刪除當前 word, 避免下一輪重複添加</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    curWord[j] = ch; <span class="comment">// 還原回原先的 word</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// not found</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot len)$ ➔ $O(n \cdot 26 \cdot len)$, 其中 <code>n</code> 為 word 的個數, <code>len</code> 為每個 word 的長度<ul><li>$O(n)$：每一輪最少要從 <code>wordList</code> 中取一個 word, 故最多有 <code>n</code> 輪, 總共最多取 <code>n</code> 個 word</li><li>$O(26 \cdot len)$：每個 word 可產生 $26 * len$ 個單字</li></ul></li><li><strong>space：</strong>$O(n \cdot len)$ ➔ <code>dict</code> 儲存每個 word</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Bidirectional BFS（雙向 BFS）, 從 <code>beginWord</code> 和 <code>endWord</code> 兩端開始拓展, 兩端產生的 word 分別用 <code>s1</code>、<code>s2</code> 儲存, 讓 <code>s1</code> 永遠為較小的 hash set, 這樣 for loop 進行拓展的 word 會比較少。一旦 <code>s1</code> 的 word 所拓展出來的 new word 出現在 <code>s2</code> 中, 代表兩端碰頭, 故返回 <code>res + 1</code></strong></p><p><img src="https://i.imgur.com/1VWmQ2u.png"></p><p>e.g. <code>wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code>, <code>begin = &quot;hit&quot;</code>, <code>end = &quot;cog&quot;</code></p><ul><li>一開始, <code>s1 = &#123;hit&#125;</code>, <code>s2 = &#123;cog&#125;</code></li><li>第一輪, <code>s1</code> 拓展 ➔ <code>s1 = &#123;hit, hot&#125;</code>, <code>s2 = &#123;cog&#125;</code></li><li>第二輪<ul><li><code>s1</code> 和 <code>s2</code> 先 swap ➔ <code>s1 = &#123;cog&#125;</code>, <code>s2 = &#123;hit, hot&#125;</code></li><li><code>s1</code> 拓展 ➔ <code>s1 = &#123;cog, dog, log&#125;</code>, <code>s2 = &#123;hit, hot&#125;</code></li></ul></li><li>第三輪<ul><li><code>s1</code> 和 <code>s2</code> 先 swap ➔ <code>s1 = &#123;hit, hot&#125;</code>, <code>s2 = &#123;cog, dog, log&#125;</code></li><li><code>s1</code> 拓展 ➔ <code>s1 = &#123;hit, hot, dot, lot&#125;</code>, <code>s2 = &#123;cog, dog, log&#125;</code></li></ul></li><li>第四輪<ul><li><code>s1</code> 和 <code>s2</code> 先 swap ➔ <code>s1 = &#123;cog, dog, log&#125;</code>, <code>s2 = &#123;hit, hot, dot, lot&#125;</code></li><li><code>s1</code> 拓展 ➔ <code>s1 = &#123;cog, dog, log, dot&#125;</code>, 發現 <code>dot</code> 已出現在 <code>s2</code> 中, 故中止</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 將 wordList 轉成 hash set 方便查找</span></span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">dict</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 endWord 不在 dict 中, 則返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (dict.<span class="built_in">find</span>(endWord) == dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = beginWord.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">s1</span><span class="params">(&#123;beginWord&#125;)</span></span>;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">s2</span><span class="params">(&#123;endWord&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>() &amp;&amp; !s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++res;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 讓 s1 永遠是較小的 hash set, 這樣下面 for loop 會比較快結束</span></span><br><span class="line">            <span class="keyword">if</span> (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(s1, s2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            unordered_set&lt;string&gt; tmpSet; <span class="comment">// 紀錄由 curWord 產生的所有 new word</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> curWord : s1) &#123; <span class="comment">// set 中的元素為 const, 禁止用 auto&amp; 直接修改</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> ch = curWord[i]; <span class="comment">// 記住當前第 i 位的 char, 等等要還原</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c) &#123;</span><br><span class="line">                        curWord[i] = c; <span class="comment">// 變更第 i 位的 char 為 c</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 若變更完後的 word 在 s2 中, 則直接返回 res + 1</span></span><br><span class="line">                        <span class="keyword">if</span> (s2.<span class="built_in">find</span>(curWord) != s2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 變更完後的 word 在 dict 中, 則將其加到 tmpSet 中</span></span><br><span class="line">                        <span class="keyword">if</span> (dict.<span class="built_in">find</span>(curWord) != dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            tmpSet.<span class="built_in">emplace</span>(curWord);</span><br><span class="line">                            dict.<span class="built_in">erase</span>(curWord); <span class="comment">// 刪除當前 word, 避免下一輪重複拜訪</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    curWord[i] = ch; <span class="comment">// 還原回原先的 word</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(s1, tmpSet); <span class="comment">// s1 更新成由 curWord 產生的 word set</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// not found</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot len)$ ➔ $O(n \cdot 26 \cdot len)$, 其中 <code>n</code> 為 word 的個數, <code>len</code> 為每個 word 的長度<ul><li>$O(n)$：每一輪最少要從 <code>wordList</code> 中取一個 word, 故最多有 <code>n</code> 輪, 總共最多取 <code>n</code> 個 word</li><li>$O(26 \cdot len)$：每個 word 可產生 $26 * len$ 個單字</li></ul></li><li><strong>space：</strong>$O(n \cdot len)$ ➔ <code>dict</code> 儲存每個 word</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>778. Swim in Rising Water</title>
      <link href="/post/swim-in-rising-water/"/>
      <url>/post/swim-in-rising-water/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/swim-in-rising-water/">https://leetcode.cn/problems/swim-in-rising-water/</a></strong></p><p><strong>題意：</strong> 在一個 <code>n x n</code> 的整數矩陣 <code>grid</code> 中, 每一個 <code>grid[i][j]</code> 表示位置 <code>(i, j)</code> 的平台高度。</p><p>當開始下雨時, 在時間為 <code>t</code> 時, 水池中的水位為 <code>t</code>。你可以從一個平台游向四周相鄰的任意平台, 前提是此時的水位必須同時淹沒這兩個平台才行。假設你可以瞬間移動無限距離, 也就是默認在 <code>grid</code> 內移動是不耗時的。</p><p>返回從左上角 <code>(0, 0)</code> 出發, 到達右下角 <code>(n-1, n-1)</code> 所需的最少時間。</p></blockquote><p><img src="https://i.imgur.com/TGttyP6.png"></p><p><img src="https://i.imgur.com/QdODCir.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS + Min Heap, 把目前拜訪過的格子之鄰居（未拜訪過的）加入到 min heap <code>pq</code> 中, 然後每次取最小的出來, 直到抵達終點為止, 而 <code>res</code> 就是從 <code>pq</code> 取出過最大的高度</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">swimInWater</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = grid.<span class="built_in">size</span>()</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> t3i = tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line">        priority_queue&lt;t3i, vector&lt;t3i&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(t3i&#123;grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [height, y, x] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            visited[y][x] = <span class="literal">true</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res, height); <span class="comment">// 更新 res</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x == n - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [yOffset, xOffset] : dirs) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> newY = y + yOffset;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> newX = x + xOffset;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若沒超過邊界, 且未拜訪, 則將其加到 pq 中</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">outOfBound</span>(newY, newX, n) &amp;&amp; !visited[newY][newX]) &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(t3i&#123;grid[newY][newX], newY, newX&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> y, <span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span> || y &gt;= n || x &lt; <span class="number">0</span> || x &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2 \cdot log(n))$ ➔ <code>pq</code> 中最多有 $n^2$ 個元素, 每 push &#x2F; pop 一個元素皆需花 $O(log(n^2))$</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>visited</code>、<code>pq</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Advanced Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>269. Alien Dictionary</title>
      <link href="/post/alien-dictionary/"/>
      <url>/post/alien-dictionary/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/alien-dictionary/">https://leetcode.cn/problems/alien-dictionary/</a></strong></p><p><strong>題意：</strong>有一種使用英文的外星語言, 其字母的順序與英文的順序不同。</p><p>給一 word list <code>words</code> 作為該外星語言的字典, <code>wrods</code> 中的 string 已按照外星語言的字母順序進行排序。</p><p>請按照 <code>words</code> 還原出該語言中已知的字母順序, 並按字母的遞增順序排列。若不存在合法的字母順序, 則返回 <code>&quot;&quot;</code>。若存在多種合法的順序, 則返回任意一種即可。</p><p>string <code>s</code> 小於 string <code>t</code> 有兩種情況:</p><ul><li>在第一個不同的字母處, <code>s</code> 的字母順序在 <code>t</code> 的字母之前</li><li>如果前 <code>min(s.length, t.length)</code> 個字母都相同, 且 <code>s.length &lt; t.length</code></li></ul><p><code>words[i]</code> 僅由<strong>小寫</strong>字母組成。</p></blockquote><p><img src="https://i.imgur.com/93FBYdM.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + BFS, 類似 <a href="https://zako945.github.io/post/course-schedule/">207. Course Schedule</a>, 相鄰兩個 word 可建構一條順序</strong></p><p>e.g. <code>words = [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]</code></p><ul><li><p>取 <code>wrt</code> 和 <code>wrf</code> ➔ 得 <code>t &lt; f</code></p></li><li><p>取 <code>wrf</code> 和 <code>er</code> ➔ 得 <code>w &lt; e</code></p></li><li><p>取 <code>er</code> 和 <code>ett</code> ➔ 得 <code>r &lt; t</code></p></li><li><p>取 <code>ett</code> 和 <code>rftt</code> ➔ 得 <code>e &lt; r</code></p><p>  <img src="https://i.imgur.com/hPvfXDb.png"></p></li></ul><p>最終得 <code>w &lt; e &lt; r &lt; t &lt; f</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">alienOrder</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, unordered_set&lt;<span class="type">char</span>&gt;&gt; adj; <span class="comment">// adjacency list</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; inDegree; <span class="comment">// 紀錄每個 char 的 in degree</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將所有會出現的 char 的 in degree 設成 0</span></span><br><span class="line">        <span class="comment">// 因為有解的話會有 char 的 in degree = 0</span></span><br><span class="line">        <span class="comment">// 若不在這邊設成 0 的話, 到時候初始化 q 時會取不出 char</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">                inDegree[ch] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次取出兩個 string 來比較, 並建構 char 的順序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = t.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">const</span> string s = words[i], t = words[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// words 中 s 的順序在 t 之前, 且 s 包含 t</span></span><br><span class="line">            <span class="comment">// 不合 s &lt; t 的第二條規則, 照理來說 t 應放在 s 之前(words 中給的順序是錯的)</span></span><br><span class="line">            <span class="keyword">if</span> (m &gt; n &amp;&amp; s.<span class="built_in">substr</span>(<span class="number">0</span>, n) == t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">min</span>(m, n); ++j) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> c1 = s[j], c2 = t[j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 若 char 相同則跳過, 去比較下一個 char</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若不相同, 則 check c1 的 adj list 中是否已經有紀錄 c2</span></span><br><span class="line">                <span class="comment">// 若沒有, 則要把 c2 加入到 c1 的 adj list 中, 並將 c2 的 in degree + 1</span></span><br><span class="line">                <span class="keyword">if</span> (adj[c1].<span class="built_in">find</span>(c2) == adj[c1].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    adj[c1].<span class="built_in">emplace</span>(c2);</span><br><span class="line">                    ++inDegree[c2];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 比較完第一個不同的 char 之順序後, 便跳出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出 in degree = 0 之 char 來初始化 q</span></span><br><span class="line">        queue&lt;<span class="type">char</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ch, degree] : inDegree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res += cur;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把 cur 給 pop 掉後, 將 cur 的 adjacent vertex 之 in degree - 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 res 的長度 &lt; words 中 char 的個數, 代表有 char 的 in degree 無法變成 0</span></span><br><span class="line">        <span class="comment">// 也就是說存在 cycle, 故返回 &quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>() &lt; inDegree.<span class="built_in">size</span>() ? <span class="string">&quot;&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot L)$ ➔ $O(n \cdot L) + O(26 + n)$<ul><li>$O(n \cdot L)$：建立 <code>inDegree</code> 需遍歷 words 中的每個 char<ul><li>其中 n 為 <code>words</code> 的個數, <code>L</code> 為每個 word 的平均長度</li></ul></li><li>$O(26 + n)$：$O(V + E)$ 也就是 BFS 的時間複雜度<ul><li>edge 最多 <code>n - 1</code> 條（相鄰 2 個 word 建構一個字母順序）</li><li>vertex 最多 26 個, 因為 <code>inDegree</code> 最多紀錄 26 個 char 的 in degree</li></ul></li></ul></li><li><strong>space：</strong>$O(n)$ ➔ $O(26 + n)$<ul><li>$O(26 + n)$：$O(V + E)$ 為 <code>adj</code> 所需的空間, 其中 <code>n</code> 為 <code>words</code> 的個數<ul><li>edge 最多 <code>n - 1</code> 條（相鄰 2 個 word 建構一個字母順序）</li><li>vertex 最多 26 個, 因為 <code>inDegree</code> 最多紀錄 26 個 char 的 in degree</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Advanced Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>329. Longest Increasing Path in a Matrix</title>
      <link href="/post/longest-increasing-path-in-a-matrix/"/>
      <url>/post/longest-increasing-path-in-a-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 整數矩陣 <code>matrix</code>, 找出其中<strong>最長遞增路徑</strong>的長度。</p><p>對於每個 cell, 可以往上、下、左、右四個方向移動。</p><p><strong>不能在對角線方向</strong>上移動 or <strong>移動到邊界外</strong>。</p></blockquote><p><img src="https://i.imgur.com/OM7OxTZ.png"></p><p><img src="https://i.imgur.com/zCjO8RR.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + DP, 其中 <code>dp[i][j]</code> 紀錄以 <code>(i, j)</code> 為起點的最長遞增路徑之長度。透過 DP 可避免重複計算。e.g. 假設先計算完 <code>dfs(A)</code>, 只後執行 <code>dfs(C)</code> 時, 發現 <code>C</code> 會拜訪 <code>A</code>, 透過 DP 可直接得到先前計算過的 <code>dfs(A)</code>, 而不用重新計算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        dp.<span class="built_in">resize</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(matrix, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] != <span class="number">0</span>) &#123; <span class="comment">// 如果已計算過 (i, j), 則直接返回</span></span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>; <span class="comment">// 每個 cell 的最小長度為 1 (path 中只有自己)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> newY = i + dir.first;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> newX = j + dir.second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">outOfBound</span>(newY, newX)) &#123; <span class="comment">// 若超出邊界, 則跳過</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matrix[newY][newX] &lt;= matrix[i][j]) &#123; <span class="comment">// 若非遞增, 則跳過</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="number">1</span> + <span class="built_in">dfs</span>(matrix, newY, newX));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[i][j] = res; <span class="comment">// 用 dp[i][j] 紀錄以 (i, j) 為起點的最長遞增路徑之長度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 每個 <code>matrix[i][j]</code> 最多拜訪一次</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>115. Distinct Subsequences</title>
      <link href="/post/distinct-subsequences/"/>
      <url>/post/distinct-subsequences/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/distinct-subsequences/">https://leetcode.cn/problems/distinct-subsequences/</a></strong></p><p><strong>題意：</strong>給兩 string <code>s</code> 和 <code>t</code>, 返回在 <code>s</code> 的 subsequence 中 <code>t</code> 出現的個數。</p><p>題目保證答案符合 32-bit 有號整數的範圍。</p></blockquote><p><img src="https://i.imgur.com/NdEo7JK.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li><code>dp[i][j]</code>：<code>s[1:i]</code>中 subseq 為 <code>t[1:j]</code> 的個數</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><p>當 <code>s[i] == t[j]</code> 時, 有兩種情況：</p><ul><li>用 <code>s[i]</code> 去匹配 <code>t[j]</code>：<br>  ➔ 則問題變成 <code>s[1:(i-1)]</code> 中 subseq 為 <code>t[1:(j-1)]</code> 的數量<br>  ➔ <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>不用 <code>s[i]</code> 去匹配 <code>t[j]</code>：<br>  ➔ 則問題變成 <code>s[1:(i-1)]</code> 中 subseq 為 <code>t[1:j]</code> 的數量<br>  ➔ <code>dp[i][j] = dp[i - 1][j]</code></li></ul><p>  <img src="https://i.imgur.com/QXIcXAK.png"></p></li><li><p>否則, 問題變成 <code>s[1:(i-1)]</code> 中 subseq 為 <code>t[1:j]</code> 的數量<br>➔ <code>dp[i][j] = dp[i - 1][j]</code></p></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[i][0]</code>：當 <code>t = &quot;&quot;</code> 時, <code>s</code> 中能匹配的 subseq 就只有 <code>&quot;&quot;</code> 一種（取法只有一種, 就是什麼都不取）<br>➔ <code>dp[i][0] = 1</code></li><li><code>dp[0][j]</code>：當 <code>s = &quot;&quot;</code> 時, 除了 <code>dp[0][0] = 1</code> 以外, 其餘的 <code>dp[0][j] = 0</code>, 其中 <code>1 ≤ j ≤ n</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&#x27;#&#x27;</span> + s;</span><br><span class="line">        t = <span class="string">&#x27;#&#x27;</span> + t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改善 Solution 1, 由於 <code>dp[i][j]</code> 只會用到上一列狀態的 <code>dp[i - 1][j - 1]</code> 和 <code>dp[i - 1][j]</code>, 故只需要儲存上一列的狀態即可, 根本不需開到 $O(m \cdot n)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&#x27;#&#x27;</span> + s;</span><br><span class="line">        t = <span class="string">&#x27;#&#x27;</span> + t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; nextRow = dp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                    nextRow[j] = dp[j - <span class="number">1</span>] + dp[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextRow[j] = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>72. Edit Distance</title>
      <link href="/post/edit-distance/"/>
      <url>/post/edit-distance/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/edit-distance/">https://leetcode.cn/problems/edit-distance/</a></strong></p><p><strong>題意：</strong>給兩 string <code>word1</code> 和 <code>word2</code>, 返回將 <code>word1</code> 轉換成 <code>word2</code> 的最少操作數。</p><p>可對單字進行以下操作：</p><ul><li>插入一個 char</li><li>刪除一個 char</li><li>替換一個 char</li></ul></blockquote><p>!<a href="https://i.imgur.com/Lw9oEAc.png">https://i.imgur.com/Lw9oEAc.png</a></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li><code>dp[i][j]</code>：<code>word1[1:i]</code> 轉換成 <code>word2[1:j]</code> 的最少操作數</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><p>若 <code>word1[i] == word2[j]</code>, 則問題變成 <code>word1[1:(i-1)]</code> 轉換成 <code>word2[1:(j-1)]</code> 的最少操作數<br>➔ <code>dp[i][j] = dp[i - 1][j - 1]</code></p></li><li><p>否則, 有三種情況：</p><ul><li><p><code>word1[1:i]</code> 插入 <code>word2[j]</code>, 則問題變成 <code>word1[1:i]</code> 轉換成 <code>word2[1:(j-1)]</code> 的最少操作數 + 1（+1 是因為插入操作）<br>  ➔ <code>dp[i][j] = dp[i][j - 1] + 1</code></p></li><li><p><code>word1[1:i]</code> 刪除 <code>word1[i]</code>, 則問題變成 <code>word1[1:(i-1)]</code> 轉換成 <code>word2[1:j]</code> 的最少操作數 + 1（+1 是因為刪除操作）<br>  ➔ <code>dp[i][j] = dp[i - 1][j] + 1</code></p></li><li><p><code>word1[1:i]</code> 替換 <code>word1[i]</code> 成 <code>word2[j]</code>, 則問題變成 <code>word1[1:(i-1)]</code> 轉換成 <code>word2[1:(j-1)]</code> 的最少操作數 + 1（+1 是因為替換操作）<br>  ➔ <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p></li></ul><p>  ➔ <code>dp[i][j]</code> 為以上三種情況取最小的</p></li></ul><p><strong>3. 初始化：</strong></p><ul><li><p><code>dp[i][0]</code>：當 <code>word2 = &quot;&quot;</code> 時, <code>word1[1:i]</code> 必須刪除所有的 char 才會匹配 <code>word2</code>, 所以 <code>word1[1:i]</code> 必須進行 <code>i</code> 次刪除操作（因為有 <code>i</code> 個 char）<br>➔ <code>dp[i][0] = i</code></p></li><li><p><code>dp[0][j]</code>：當 <code>word1 = &quot;&quot;</code> 時, <code>word1</code> 必須插入 <code>word2[1:j]</code> 中所有的 char 才會匹配 <code>word2[1:j]</code>, 所以 <code>word1</code> 必須進行 <code>j</code> 次插入操作（因為有 <code>ｊ</code> 個 char）<br>➔ <code>dp[0][j] = j</code></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = word1.<span class="built_in">size</span>(), n = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        word1 = <span class="string">&#x27;#&#x27;</span> + word1;</span><br><span class="line">        word2 = <span class="string">&#x27;#&#x27;</span> + word2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 三種情形中取最小的</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. Regular Expression Matching</title>
      <link href="/post/regular-expression-matching/"/>
      <url>/post/regular-expression-matching/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/regular-expression-matching/">https://leetcode.cn/problems/regular-expression-matching/</a></strong></p><p><strong>題意：</strong>給你一個 string <code>s</code> 和一個 string pattern <code>p</code>，請實現一個支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正則表達式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意單個 char</li><li><code>&#39;*&#39;</code> 匹配 0 個 or 多個前面的那一個元素</li></ul><p>所謂匹配, 是要涵蓋整個 <code>s</code> 的, 而不是部分 string。</p></blockquote><p><img src="https://i.imgur.com/25uRzyL.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i][j]</code> 判斷 <code>s[0 ~ (i - 1)]</code> 和 <code>p[0 ~ (j - 1)]</code> 是否匹配，每次判斷當前 <code>s</code>、<code>p</code> 的最後一個 char 是否匹配</strong></p><ul><li><strong>若 <code>s[i - 1] == p[j - 1]</code> 或 <code>p[j - 1] == &#39;.&#39;</code></strong> : 代表當前 <code>s</code>、<code>p</code> 的最後一個 char 匹配, 則當前 <code>s</code>、<code>p</code> 是否匹配取決於前面的 substring, 也就是說 <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li><strong>若 <code>p[j - 1] == &#39;*&#39;</code></strong> : 代表要看 <code>p[j - 1]</code> 的前一個 char <code>p[j - 2]</code><ul><li><p><strong>若 <code>s[i - 1] == p[j - 2]</code> 或 <code>p[j - 2] == &#39;.&#39;</code></strong> : 代表當前 <code>s</code>、<code>p</code> 最後一個 char 是匹配的, 則 &#96;&#96; 分别可重覆 0 次 or 重覆 1 次 or 重覆 2 次以上</p><ul><li><p><code>重覆 0 次</code> : <code>s[i - 1]</code> 要和 <code>p[j - 3]</code> 比較 ➔ <code>dp[i][j] = dp[i][j - 2]</code></p></li><li><p><code>重覆 1 次</code> : <code>s[i - 2]</code> 要和 <code>p[j - 3]</code> 比較 ➔ <code>dp[i][j] = dp[i - 1][j - 2]</code></p></li><li><p><code>重覆 2 次以上</code> : <code>s</code> 去掉最後一個 char, 而 <code>p</code> 不動➔ <code>dp[i][j] = dp[i - 1][j]</code></p><p>  <img src="https://i.imgur.com/FYNNm98.png"></p></li></ul></li><li><p><strong>若 <code>s[i - 1] != p[j - 2]</code></strong> : 當前 <code>s</code>、<code>p</code> 最後一個 char 不匹配, 則 &#96;&#96; 重覆 0 次。<code>s</code> 不動, <code>p</code> 要往前取看是否匹配 ➔ <code>dp[i][j] = dp[i][j - 2]</code></p></li></ul></li></ul><p><strong>除此之外, 還要考慮邊界條件</strong></p><ul><li>當 <code>s</code>、<code>p</code> 皆為空時, 兩者匹配</li><li>當 <code>s</code> 為空, 且 <code>p</code> 不為空時, 兩者卻匹配的情況。e.g. <code>s = &quot;&quot;</code>, <code>p = &quot;a*a*a*&quot;</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s、p 皆為空, 兩者匹配</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s 為空, p 不為空, 但 s、p 匹配的情況, e.g. s = &quot;&quot;, p = &quot;a*a*a*&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="comment">// j = 1 時, p[j - 1] 必不為 `*`, 因此不會執行到 dp[0][j - 2] 導致越界</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &amp;&amp; dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] : 判斷 s[0 ~ (i - 1)]、p[0 ~ (j - 1)] 是否匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="comment">// 若 s[i - 1]、p[j - 1] 匹配</span></span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">// * 分别是重覆 0 次 or 重覆 1 次 or 重覆 2 次以上</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// s[i - 1] != p[j - 1], 則 * 重複 0 次</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1851. Minimum Interval to Include Each Query</title>
      <link href="/post/minimum-interval-to-include-each-query/"/>
      <url>/post/minimum-interval-to-include-each-query/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-interval-to-include-each-query/">https://leetcode.cn/problems/minimum-interval-to-include-each-query/</a></strong></p><p><strong>題意：</strong>給一個二維整數 array <code>intervals</code>, 其中 <code>intervals[i] = [left_i, right_i]</code> 表示第 <code>i</code> 個區間開始於 <code>left_i</code>、結束於 <code>right_i</code>。</p><p>定義 <code>intervals[i]</code> 的<strong>長度</strong>為 <code>right_i - left_i + 1</code>。</p><p>再給一整數 array <code>queries</code>, 第 <code>j</code> 個查詢的答案是滿足 <code>left_i ≤ queries[j] ≤ right_i</code> 的最小區間 <code>i</code> 之長度。若不存在這樣的區間, 則答案為 <code>-1</code>。</p><p>以 array 的形式返回對應查詢的所有答案。</p></blockquote><p><img src="https://i.imgur.com/z4RCLzA.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 offline 算法 + Min Heap + Greedy, 先將所有滿足 <code>interval.left ≤ query</code> 的區間加到 <code>pq</code> 中, 再判斷 <code>pq</code> 中的這些 interval 是否滿足 <code>interval.right ≥ query</code></strong></p><p><strong>offline 算法：</strong></p><ul><li>將 <code>queries</code> 由小到大排序, 並記錄每個 <code>query</code> 原先的 index</li><li>將 <code>intervals</code> 根據 <code>left</code> 由小到大排序</li></ul><p><strong>遍歷每個 query：</strong></p><ul><li>Min Heap <code>pq</code> 儲存滿足 <code>interval.left ≤ query</code> 的區間之長度 <code>duration</code> 和 <code>right</code></li><li>對於每個 <code>query</code>：<ul><li>先將符合 <code>interval.left ≤ query</code> 的所有區間加入到 min heap <code>pq</code> 中, 其中 <code>pq</code> 是根據區間長度 <code>duration</code> 由小到大排序</li><li>不斷檢查 <code>pq.top().right</code> 是否 <code>≥ query</code>。若滿足 <code>pq.top() ≥ query</code>, 則該區間即為符合條件的最小區間</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minInterval</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = queries.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pii&gt; querySet;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先將 query 由小到大排序, 並記錄其 index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            querySet.<span class="built_in">emplace_back</span>(pii&#123;queries[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// offline 算法</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(querySet.<span class="built_in">begin</span>(), querySet.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍歷每個 query</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [query, idx] : querySet) &#123;</span><br><span class="line">            <span class="comment">// 把 left ≤ query 的區間加到 pq 中, 讓 pq 根據 duration 由小到大排序</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= query) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> duration = intervals[i][<span class="number">1</span>] - intervals[i][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(pii&#123;duration, intervals[i][<span class="number">1</span>]&#125;);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 剔除中 right &lt; query 的區間, 讓 pq.top() 為 ≥ query 的區間</span></span><br><span class="line">            <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>().second &lt; query) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 pq.top() 存在, 即為該 query 的最小區間</span></span><br><span class="line">            <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                res[idx] = pq.<span class="built_in">top</span>().first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot log(m) + n \cdot log(n))$ ➔ <code>m</code> 為 interval 的個數、<code>n</code> 為 query 的個數<ul><li>$O(m \cdot log(m))$<ul><li>排序 <code>intervals</code></li><li>每個 <code>intervals[i]</code> 最多被加入到 <code>pq</code> 一次, 而 <code>pq</code> 每 insert &#x2F; delete 一個元素皆需 $O(log(m))$</li></ul></li><li>$O(n \cdot log(n))$：排序 <code>querySet</code></li></ul></li><li><strong>space：</strong>$O(m + n)$<ul><li>$O(m)$：<code>pq</code> 中的元素個數不超過 $m$ 個, <code>m</code> 為 <code>intervals</code> 的個數</li><li>$O(n)$：<code>querySet</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>41. First Missing Positive</title>
      <link href="/post/first-missing-positive/"/>
      <url>/post/first-missing-positive/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/first-missing-positive/">https://leetcode.cn/problems/first-missing-positive/</a></strong></p><p><strong>題意</strong>：給一未排序的整數 array <code>nums</code>, 返回其中未出現的最小正整數。</p><p>必須設計 $O(n)$ time 且 $O(1)$ space 的演算法。</p></blockquote><p><img src="https://i.imgur.com/YLRz6o1.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table, 首先 hash table 儲存出現過的數, 然後再從 <code>1</code> 開始遍歷到 <code>n</code>。若其中有不在 hash table 中的, 則直接返回該數。否則, 返回 <code>n + 1</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(i) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>umap</code>, 並不符合題目要求</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 把 <code>nums</code> 本身當作 hash table 使用, 利用 <code>nums[i]</code> 判斷 <code>i + 1</code> 是否存在。若 <code>i + 1</code> 存在, 則 <code>nums[i] == i + 1</code></strong></p><ul><li>若 <code>nums[i]</code> 超出邊界, 或 <code>nums[i]</code> 已經放在正確的位置上, 則往下一個數</li><li>否則, 用 swap 將 <code>nums[i]</code> 放在正確的位置上。可是 swap 完後, 不保證 <code>idx = i</code> 的位置擺的是正確的值, 因此要用 while loop 來確認, 直到 <code>nums[i] == i + 1</code>, 才能往下一個數</li></ul><p><img src="https://i.imgur.com/nforC3P.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> val = nums[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 val 不為範圍內之正整數 || val 已經放在 idx = val - 1 的位置上</span></span><br><span class="line">                <span class="keyword">if</span> (val &lt;= <span class="number">0</span> || val &gt;= n || val == nums[val - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否則, 將其放在正確的位置上</span></span><br><span class="line">                    <span class="built_in">swap</span>(nums[i], nums[val - <span class="number">1</span>]); <span class="comment">// 此時, 0 ≤ val &lt; n, 不用取 abs</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop, 因為 while loop 中每個 idx 的位置最多做常數次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>37. Sudoku Solver</title>
      <link href="/post/sudoku-solver/"/>
      <url>/post/sudoku-solver/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sudoku-solver/">https://leetcode.cn/problems/sudoku-solver/</a></strong></p><p><strong>題意</strong>：寫一程式, 可填充空格來解決數獨問題。</p><p>數獨的解法<strong>需遵從以下規則：</strong></p><ul><li>數字 <code>1-9</code> 在每一行只能出現一次</li><li>數字 <code>1-9</code> 在每一列只能出現一次</li><li>數字 <code>1-9</code> 在每一個以粗實線分隔的 <code>3x3</code> 九宮格內只能出現一次</li></ul><p>數獨部分空格已填入數字, 而空格用 <code>&#39;.&#39;</code> 來表示。</p></blockquote><p><img src="https://i.imgur.com/bjxvGvT.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">fill</span>(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// y 為 row, x 為 col</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fill</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> y, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 代表 0 ~ 8 列所有空格都能填完, 故返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> nextY = (x == <span class="number">8</span>) ? y + <span class="number">1</span> : y;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> nextX = (x == <span class="number">8</span>) ? <span class="number">0</span> : x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board[y][x] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 嘗試填入 1 ~ 9</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch = <span class="string">&#x27;1&#x27;</span>; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ++ch) &#123;</span><br><span class="line">                <span class="comment">// 若 board[y][x] 不可填入 ch, 則嘗試下一個數</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isValid</span>(board, y, x, ch)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 可以填入 ch</span></span><br><span class="line">                board[y][x] = ch;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遞迴找下去, 若可以填, 則返回 true</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fill</span>(board, nextY, nextX)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 否則, 恢復盤面, 並嘗試下一數</span></span><br><span class="line">                board[y][x] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若 board[y][x] 已經有數字, 則跳過</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fill</span>(board, nextY, nextX);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 檢查在 board[y][x] 填入數字 i 是否會衝突</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span> y, <span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[y][i] == ch) &#123; <span class="comment">// 同 row 是否衝突</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (board[i][x] == ch) &#123; <span class="comment">// 同 col 是否衝突</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> blockY = <span class="number">3</span> * (y / <span class="number">3</span>) + (i / <span class="number">3</span>); <span class="comment">// 3 * (y / 3) 為 blockY 的起始位置</span></span><br><span class="line">            <span class="type">int</span> blockX = <span class="number">3</span> * (x / <span class="number">3</span>) + (i % <span class="number">3</span>); <span class="comment">// 3 * (x / 3) 為 blockX 的起始位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (board[blockY][blockX] == ch) &#123; <span class="comment">// 同 block 是否衝突</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(9^m)$ ➔ <code>m</code> 為所有的空格數, 每一個空格最多有 <code>9</code> 種選擇</li><li><strong>space：</strong>$O(1)$ ➔ $O(9*9)$, 遞迴深度最多不超過 <code>9 * 9</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>632. Smallest Range Covering Elements from K Lists</title>
      <link href="/post/smallest-range-covering-elements-from-k-lists/"/>
      <url>/post/smallest-range-covering-elements-from-k-lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/">https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/</a></strong></p><p><strong>題意</strong>：給一包含 <code>k</code> 個<strong>非遞減排列</strong>整數 array 的 list <code>nums</code>。找到一<strong>最小區間</strong>, 使得每個 array 中皆至少有一個整數包含在該區間中。</p><p>定義區間 <code>[a, b]</code> &lt; <code>[c, d]</code>, 滿足下列其中一個條件便成立：</p><ul><li><code>b-a &lt; d-c</code></li><li><code>b-a == d-c</code> 且 <code>a &lt; c</code></li></ul></blockquote><p><img src="https://i.imgur.com/KwcsQ99.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 類似 76. Minimum Window Substring</strong></p><ul><li>首先, 取出每個 array 中的最小值, 並加入到 <code>set</code> 中</li><li>取出 <code>set</code> 中最大、最小的值, 並計算出 <code>newRange</code></li><li>若 <code>newRange &lt; range</code>, 則更新 range 和最小區間</li><li><strong>移除 <code>set</code> 中的最小元素</strong>, 並將 insert 其所對應的 array 之下一個元素<br>若該元素為不存在, 則直接返回</li></ul><p>e.g. <code>nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</code>, 其中 i、j、k 分別代表 <code>idx = 0 ~ 2</code> 的 array 當前 <code>set</code> 中的元素 idx</p><ul><li>一開始 <code>i、j、k</code> 皆為 <code>0</code>, <code>set = &#123;0,4,5&#125;</code>。此時 set 中 <strong>[最小值, 最大值]</strong> 的區間 <code>[0, 5]</code> 可包含每個 array 中的一個整數</li><li><strong>移除 <code>set</code> 中的最小元素 <code>0</code></strong>, 並將其對應到的 array 之 <code>ptr + 1</code>, 也就是 <code>j + 1</code>。並將 9 加到 set 中。此時 <code>set = &#123;4, 5, 9&#125;</code></li><li>依此類推, 可參考下圖</li></ul><p><img src="https://i.imgur.com/Quk7dTh.png"></p><p><strong>為何是移動最小元素的 ptr?</strong></p><p>因為如果當前 <strong><code>set</code> 中的 max 不變, 而最小值變大</strong> ➔ <strong>最小區間的範圍會縮小</strong></p><p>e.g. 上圖中綠框的部分, 在兩次更新中 max 皆為 24, 但 min 從 18 變成 20</p><p>➔ 使得最小區間由 5 變成 4</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestRange</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;pii&gt; ordered; <span class="comment">// 紀錄 set 中元素的 val、對應的 array idx</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個 array 當前在 set 中的元素之 ptr</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取每個 array 的第一個元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ordered.<span class="built_in">emplace</span>(pii&#123;nums[i][<span class="number">0</span>], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> range = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 取 set 中最小、最大的元素</span></span><br><span class="line">            <span class="type">int</span> minValue = ordered.<span class="built_in">begin</span>()-&gt;first;</span><br><span class="line">            <span class="type">int</span> maxValue = ordered.<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">            <span class="type">int</span> newRange = maxValue - minValue;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新區間</span></span><br><span class="line">            <span class="keyword">if</span> (newRange &lt; range) &#123;</span><br><span class="line">                range = newRange;</span><br><span class="line">                res = &#123;minValue, maxValue&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 要將最小元素從 set 中取出, 並 insert 對應 array 的下一個元素</span></span><br><span class="line">            <span class="type">int</span> i = ordered.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">            ++ptr[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果下一個元素不存在, 則直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (ptr[i] == nums[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ordered.<span class="built_in">erase</span>(ordered.<span class="built_in">begin</span>());</span><br><span class="line">            ordered.<span class="built_in">emplace</span>(pii&#123;nums[i][ptr[i]], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(nk \cdot log(k))$<ul><li>假設每個 array 的平均長度為 <code>n</code>, 且總共 <code>k</code> 個 array</li><li>$O(nk)$：總共 $nk$ 個元素</li><li>$O(log(k))$：每次 <code>set</code> 新增元素, <code>set</code> 調整成 ordered 的所需時間為 $O(log(k))$, 因為 <code>set.insert()</code> 是用 red-black tree 所實現的。調整成 ordered 才能在 $O(1)$ time 取得 min、max</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ <code>set</code> 中的元素個數不超過 <code>k</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Heap, 道理同 Solution 1</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestRange</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> cmp = [](<span class="type">const</span> pii&amp; p1, <span class="type">const</span> pii&amp; p2)&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.first &gt; p2.first;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個 array 當前在 heap 中的元素之 ptr</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// min heap, 紀錄 heap 中元素的 val、對應的 array idx</span></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取每個 array 的第一個元素, 並計算最大值</span></span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue, nums[i][<span class="number">0</span>]);</span><br><span class="line">            q.<span class="built_in">emplace</span>(pii&#123;nums[i][<span class="number">0</span>], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> range = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 取 heap 中最小、最大的元素</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [minValue, i] = q.<span class="built_in">top</span>();</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> newRange = maxValue - minValue;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新區間</span></span><br><span class="line">            <span class="keyword">if</span> (newRange &lt; range) &#123;</span><br><span class="line">                range = newRange;</span><br><span class="line">                res = &#123;minValue, maxValue&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 要將最小元素從 heap 中取出, 並 insert 對應 array 的下一個元素</span></span><br><span class="line">            ++ptr[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果下一個元素不存在, 則直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (ptr[i] == nums[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">emplace</span>(pii&#123;nums[i][ptr[i]], i&#125;);</span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue, nums[i][ptr[i]]); <span class="comment">// 維護最大值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(nk \cdot log(k))$<ul><li>假設每個 array 的平均長度為 <code>n</code>, 且總共 <code>k</code> 個 array</li><li>$O(nk)$：總共 $nk$ 個元素</li><li>$O(log(k))$：heap 每 insert &#x2F;delete 一個元素所需的時間</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ heap 中的元素個數不超過 <code>k</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>759. Employee Free Time</title>
      <link href="/post/employee-free-time/"/>
      <url>/post/employee-free-time/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址： <a href="https://leetcode.cn/problems/employee-free-time/">https://leetcode.cn/problems/employee-free-time/</a></strong></p><p><strong>題意</strong>：給一員工的 <code>schedule</code> 列表, 表示每個員工的工作時間。</p><p>每個員工都有一個非重疊的時段 <code>Intervals</code> 列表, 這些時段皆已由小到大排序。</p><p>返回這些員工<strong>共同、為正數長度</strong>的有限時段列表, 需由小到大排序。</p><p><strong>注意</strong>：類似 <code>[5, 5]</code> 這樣的時段不能成為答案, 因為長度為 <code>0</code>, 而非正數</p></blockquote><p><img src="https://i.imgur.com/KBJ4br2.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先將所有 intervals flatten 成一維, 再將這些 intervals 由小到大進行排序</strong></p><ul><li>若 <strong><code>intervals[i - 1].end &lt; intervals[i].start</code></strong> 代表兩個區間沒重疊, 須將 <code>Interval(intervals[i - 1].end, intervals[i].start)</code> 加入到 <code>res</code> 中</li><li>若 <strong><code>intervals[i - 1].end &gt;= intervals[i].start</code></strong> 代表兩個區間有重疊</li><li>須更新 <code>end = max(intervals[i - 1].end, intervals[i].end)</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;Interval&gt; <span class="title">employeeFreeTime</span><span class="params">(vector&lt;vector&lt;Interval&gt;&gt; schedule)</span> </span>&#123;</span><br><span class="line">        vector&lt;Interval&gt; all;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; intervals : schedule) &#123;</span><br><span class="line">            all.<span class="built_in">insert</span>(all.<span class="built_in">end</span>(), intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>(), [](<span class="type">const</span> Interval&amp; i1, <span class="type">const</span> Interval&amp; i2)&#123;</span><br><span class="line">            <span class="keyword">return</span> i1.start &lt; i2.start;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;Interval&gt; res;</span><br><span class="line">        <span class="type">int</span> end = all.<span class="built_in">front</span>().end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; all.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (all[i].start &gt; end) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(<span class="built_in">Interval</span>(end, all[i].start));</span><br><span class="line">            &#125;</span><br><span class="line">            end = <span class="built_in">max</span>(end, all[i].end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ $O(n) + O(n \cdot log(n)) +O(n)$<ul><li><code>n</code>：所有 interval 的數量</li><li>$O(n)$：遍歷所有 interval, 並建立 <code>all</code></li><li>$O(n \cdot log(n))$：sorting</li><li>$O(n)$：遍歷 <code>all</code></li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>all</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 heap, 概念同 Solution 1, 但是可以少遍歷一次所有的 interval</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;Interval&gt; <span class="title">employeeFreeTime</span><span class="params">(vector&lt;vector&lt;Interval&gt;&gt; schedule)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> cmp = [](<span class="type">const</span> Interval&amp; i1, <span class="type">const</span> Interval&amp; i2)&#123;</span><br><span class="line">            <span class="keyword">return</span> i1.start &gt; i2.start;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// min heap</span></span><br><span class="line">        priority_queue&lt;Interval, vector&lt;Interval&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; intervals : schedule) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(interval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> [start, end] = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;Interval&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [nextStart, nextEnd] = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (end &lt; nextStart) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(<span class="built_in">Interval</span>(end, nextStart));</span><br><span class="line">            &#125;</span><br><span class="line">            end = <span class="built_in">max</span>(end, nextEnd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ $O(n)+ O(n \cdot log(n))$<ul><li><code>n</code>：所有 interval 的數量</li><li>$O(n)$：遍歷所有 interval, 並建立 min heap, <strong>heapify 只需 $O(n)$</strong></li><li>$O(n \cdot log(n))$：從 heap 中每 pop 一個元素需 $O(log(n))$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ heap 中元素不超過 <code>n</code> 個</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>327. Count of Range Sum</title>
      <link href="/post/count-of-range-sum/"/>
      <url>/post/count-of-range-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/count-of-range-sum/">https://leetcode.cn/problems/count-of-range-sum/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>nums</code> 以及兩個整數 <code>lower</code> 和 <code>upper</code>。求 <code>nums</code> 中, 值位於 <code>[lower, upper]</code> 之<strong>區間和個數</strong>。</p><p>區間和 <code>S(i, j)</code> 表示在 <code>nums</code> 中, idx 從 <code>i</code> 到 <code>j</code> 中的區間之和, 包含 <code>i</code> 和 <code>j</code>（<code>i</code> ≤ <code>j</code>）。</p></blockquote><p><img src="https://i.imgur.com/vr5NnYj.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Prefix Sum + Binary Search + Merge Sort, 類似 <a href="https://zako945.github.io/post/range-sum-query-immutable/">303. Range Sum Query - Immutable</a>。<code>presum[0]</code> 必須為 <code>0</code>, 若我們想求一區間和 <code>S(i, j)</code> 可看做是 <code>prefix[j + 1] - prefix[i]</code></strong></p><p>我們先考慮以下的問題:</p><p><strong>給兩個升序的 array <code>n1</code> 和 <code>n2</code>, 找出所有 <code>(i, j)</code> 滿足 : <code>n2[j] - n2[i] ∈ [lower,upper]</code></strong></p><ul><li>我們在 <code>n2</code> 中使用兩個 ptr <code>left</code> 和 <code>right</code>, 初始皆為 <code>n2</code> 的起始位置。</li><li>考慮 <code>n1</code> 的第一個元素<ul><li>將 <code>left</code> 不斷右移, 直到 <strong><code>n2[left] ≥ n1[0] + lower</code></strong> 為止<br>  ➔ 此時, <code>left</code> 以及其右邊元素皆 ≥ <code>n1[0] + lower</code></li><li>將 <code>right</code> 不斷右移, 直到 <strong><code>n2[right] &gt; n1[0] + upper</code></strong> 為止<br>  ➔ 此時, <code>right</code> 的左邊元素皆 <code>≤ n1[0] + upper</code></li><li>得到區間 <code>[left, right)</code> 中所有的 <code>j</code> 皆滿足 : <code>n2[j] - n1[0] ∈ [lower,upper]</code></li></ul></li><li>接著考慮 <code>n1</code> 的第二個元素, 依此類推, 遍歷完 <code>n1</code> 後可得到所有符合條件的 (i, j) 之數量</li></ul><p><strong>但 <code>presum</code> 不保證是升序的, 因為 <code>nums[i]</code> 有可能為負數, 因此採用 Merge Sort 來解決此問題</strong></p><ul><li>首先, 我們將 presum 的元素都拆成一個一組, 然後開始兩兩合併</li><li>合併的過程中, 會先遍歷左區間所有的idx <code>i</code>, 然後到右區間去找符合條件的 idx <code>j</code> 之個數<br>找到後, 合併兩區間, 並由小到大排序, 將問題轉換成上面討論的問題</li></ul><p>e.g. <code>nums = [-2, 5, -1]</code> ➔ <code>presum = [0, -2, 3, 2]</code></p><ul><li><code>[0]、[-2]</code> 合併時, 左區間元素 &#x3D; 0, 右區間 <code>x = 1, y = 2</code> ➔ 得到一組解</li><li><code>[3]、[2]</code> 合併時, 左區間元素 &#x3D; 3, 右區間 <code>x = 3, y = 4</code> ➔ 得到一組解</li><li><code>[-2, 0]、[2, 3]</code> 合併時<ul><li>左區間第一個元素 &#x3D; -2, 右區間 <code>x = 2, y = 2</code> ➔ 沒有滿足條件之 <code>j</code></li><li>左區間第一個元素 &#x3D; 0, 右區間 <code>x = 2, y = 3</code> ➔ 得到一組解</li></ul></li></ul><p><img src="https://i.imgur.com/cRqjfHZ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">long</span>&gt;&amp; presum, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 [left, right] 拆成左、右兩個區間, 分別是 [left, mid] 和 [mid + 1, right]</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(presum, left, mid, lower, upper);</span><br><span class="line">        <span class="built_in">mergeSort</span>(presum, mid + <span class="number">1</span>, right, lower, upper);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = mid + <span class="number">1</span>, y = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍歷左區間的元素, 並從右區間中找出滿足:</span></span><br><span class="line">        <span class="comment">//    prefix[j] - prefix[i] in [lower, upper] 的個數, 其中 x ≤ j &lt; y</span></span><br><span class="line">        <span class="comment">// 代表 prefix[i] 可找到 (y-x) 個 j 滿足題目條件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= mid; ++i) &#123;</span><br><span class="line">            <span class="comment">// 從右區間中找到第一個 &gt;= lower 的 idx</span></span><br><span class="line">            <span class="keyword">while</span> (x &lt;= right &amp;&amp; presum[x] - presum[i] &lt; lower) &#123;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 從右區間中找到第一個 &gt; upper 的 idx, 則 y - 1 為 &lt;= upper 之 idx</span></span><br><span class="line">            <span class="keyword">while</span> (y &lt;= right &amp;&amp; presum[y] - presum[i] &lt;= upper) &#123;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 區間 [x, y) 的個數, 代表滿足區間和 [lower, upper] 之個數</span></span><br><span class="line">            res += (y - x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 對左、右區間進行 merge 並 sorting</span></span><br><span class="line">        <span class="built_in">merge</span>(presum, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 對左、右區間進行 merge 並 sorting, 只需 O(n) time</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">long</span>&gt;&amp; presum, <span class="type">int</span>&amp; left, <span class="type">int</span>&amp; mid, <span class="type">int</span>&amp; right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p1 = left, p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">sorted</span><span class="params">(right - left + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳出 loop 代表其中一個區間已做完</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (presum[p1] &lt; presum[p2]) &#123;</span><br><span class="line">                sorted[p++] = presum[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sorted[p++] = presum[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左區間已做完, 將右區間剩下的元素加入到 sorted 中</span></span><br><span class="line">        <span class="keyword">if</span> (p1 &gt; mid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = p2; i &lt;= right; ++i) &#123;</span><br><span class="line">                sorted[p++] = presum[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右區間已做完, 將左區間剩下的元素加入到 sorted 中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = p1; i &lt;= mid; ++i) &#123;</span><br><span class="line">                sorted[p++] = presum[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 sorted 覆蓋掉原本 presum 的 [left, right) 區間中未排序的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sorted.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            presum[left + i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">presum</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            presum[i+<span class="number">1</span>] = presum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mergeSort</span>(presum, <span class="number">0</span>, n, lower, upper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ $T(n) &#x3D; 2 \cdot T(\dfrac{n}{2}) + O(n)$ 利用 Master theorem 計算得到<ul><li>$2 \cdot T(\dfrac{n}{2})$：遞迴左、右區間</li><li>$O(n)$：merge 左、右區間並做 sorting</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ $O(log(n)) + O(n)$<ul><li>$O(log(n))$：遞迴深度</li><li>$O(n)$：每層遞迴產生的 <code>sorted</code> 長度不超過 <code>n</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>995. Minimum Number of K Consecutive Bit Flips</title>
      <link href="/post/minimum-number-of-k-consecutive-bit-flips/"/>
      <url>/post/minimum-number-of-k-consecutive-bit-flips/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/">https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/</a></strong></p><p><strong>題意</strong>：給一 binary array <code>nums</code> 和一整數 <code>k</code>。</p><p><strong>k-bit flip</strong> 指的是從 <code>nums</code> 中選擇一長度為 <code>k</code> 的 subarray, 並把 subarray 中的每一個 bit 進行反轉。</p><p>返回 <code>nums</code> 中不存在 <code>0</code> 所需的最小 <strong>k-bit flip</strong> 次數。若不可能, 則返回 <code>-1</code>。</p><p>subarray 指的是 array 的<strong>連續</strong>部分。</p></blockquote><p><img src="https://i.imgur.com/qJtgSJs.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 Greedy, 因為對於每個位置而言, 只有初始狀態和 flip 次數決定了自己最終的狀態。每一個長度為 <code>k</code> 的區間, 最多只會被 flip 一次, 因為 flip 兩次對最終結果沒有影響。</strong></p><ul><li>因此, 我們由左向右遍歷 <code>nums</code>, 一旦 <code>nums[i]</code> 為 <code>0</code>, 則將其做為 sliding window 的開頭往後取 <code>k - 1</code> 個元素進行 flip</li><li>若 <code>i + k - 1 ≥ n</code>, 代表無法將最後幾個 <code>0</code> 反轉, 故返回 <code>1</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minKBitFlips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + k - <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= i + k - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                        nums[j] = <span class="number">1</span> - nums[j]; <span class="comment">// flip</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot k)$ ➔ worse case：每一個元素 <code>i</code> 都要往後檢查 <code>k</code> 個</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 我們發現：</strong></p><ul><li>當 flip 次數為奇數次, 元素會反轉。而當 flip 次數為偶數次, 元素不變</li><li>當前位置 <code>i</code> 受到前 <code>k - 1</code> 個元素是否 flip 的影響, 因此我們只需要知道前 <code>k - 1</code> 個元素 flip 的次數</li><li>用 queue 來模擬 sliding window, 其中 queue 紀錄當前位置 <code>i</code> 之前的 <code>k - 1</code> 個數中, 哪些位置為首的子區間進行了 flip<ul><li>其中 <code>q.size()</code> 代表 <code>idx = i</code> 之前, 區間 <code>[i - k + 1, i]</code> 中有幾個數進行了 flip</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minKBitFlips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 若 q.front() 不在 [i - k + 1, i] 的 sliding window 中, 則其 flip 次數應刪除</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> flips = q.<span class="built_in">size</span>(); <span class="comment">// 當前元素 nums[i] 的 flip 次數(前 k - 1 個數所造成的)</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> cur = (nums[i] + flips) % <span class="number">2</span>; <span class="comment">// 當前元素進行 flip 之後的值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若當前元素進行 flip 之後的值為 0, 代表要 flip</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 後面的數不夠, cur 無法作為開頭組成新的 sliding window 來反轉自己成 1</span></span><br><span class="line">                <span class="keyword">if</span> (i + k - <span class="number">1</span> &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// nums[i] 做為進行 flip 的 sliding window 開頭加到 queue 中</span></span><br><span class="line">                ++res;</span><br><span class="line">                q.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(k)$ ➔ <code>q</code> 中元素不超過 <code>k - 1</code> 個</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, 利用 Sliding Window, 紀錄總共 flip 的次數, 隨著 window 右移, 左側超出 window 且有 flip 的元素, 應被扣除。</strong></p><ul><li>用 <code>flip</code> 來記錄所有元素 flip 的總數</li><li>每次 sliding window 右移時, 當前區間為 <code>[i - k + 1, i]</code>, 要檢查被移出 sliding window 的元素 <code>i - k</code> 是否有 flip</li><li><code>當前 flip 總數</code> - <code>左側超出 window 且有 flip 的元素個數</code> &#x3D; <code>當前元素 flip 的次數</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minKBitFlips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> flips = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 左側超出 window 且有 flip 的元素要扣除（有 flip 的元素, 會被標記成 &gt; 1）</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k &amp;&amp; nums[i - k] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                --flips;</span><br><span class="line">                nums[i - k] -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若當前元素進行 flip 之後的值為 0, 代表要 flip</span></span><br><span class="line">            <span class="keyword">if</span> ((nums[i] + flips) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + k - <span class="number">1</span> &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++flips;</span><br><span class="line">                ++res;</span><br><span class="line">                nums[i] += <span class="number">2</span>; <span class="comment">// 將有 flip 的元素, 標記成 &gt; 1 的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>828. Count Unique Characters of All Substrings of a Given String</title>
      <link href="/post/count-unique-characters-of-all-substrings-of-a-given-string/"/>
      <url>/post/count-unique-characters-of-all-substrings-of-a-given-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/">https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/</a></strong></p><p><strong>題意</strong>：定義一函數 <code>countUniqueChars(s)</code> 返回 string <code>s</code> 中只出現一次的 char 之個數。</p><p>e.g. <code>s = &quot;LEETCODE&quot;</code>, 其中 <code>L</code>、<code>T</code>、<code>C</code>、<code>O</code>、<code>D</code> 皆只出現過一次, 因此 <code>countUniqueChars(s) = 5</code>。</p><p>今給一 string <code>s</code>, 返回 <code>countUniqueChars(t)</code> 的總和, 其中 <code>t</code> 是 <code>s</code> 的 substring。</p><p><strong>注意：</strong></p><ul><li>有些 substring 是會重複的, 計算時也必須算上這些重複的 substring（也就是說, 統計 <code>s</code> 所有 substring 中只出現一次的 char）。</li><li><code>s</code> 僅由<strong>大寫</strong>英文所組成。</li></ul></blockquote><p><img src="https://i.imgur.com/KSf2zwP.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：與其計算所有 substring 中的 unique char 個數, 不如計算單一 char 在哪些 substring 是 unique char, 最後做加總即為所求</strong></p><ul><li>考慮 <code>s = XAXAXXAX</code> 並專注於使第二個 <code>A</code> 成為 unique char</li><li>我們可以取 <code>XA(XAXX)AX</code>, 其中 <code>()</code> 中間的範圍就是符合條件的 substring 範圍</li><li>因此, 能使第二個 <code>A</code> 為 unique char 的總共有 6 種 substring<ul><li>第二個 <code>A</code> 以左（不含 <code>A</code>）可取 <code>&quot;&quot;</code>、<code>X</code> 這 2 種 substring</li><li>第二個 <code>A</code> 以右（不含 <code>A</code>）可取 <code>&quot;&quot;</code>、<code>X</code>、<code>XX</code> 這 3 種 substring</li><li>總共有 <code>A</code>、<code>AX</code>、<code>AXX</code> 和 <code>XA</code>、<code>XAX</code>、<code>XAXX</code> 這 6 種 substring</li></ul></li><li>若想求 <code>idx = i</code> 的 char 為 unique char 的 substring 個數, 我們需要：<ul><li>前一個跟 <code>s[i]</code> 相同的 char 的 idx <code>j</code></li><li>後一個跟 <code>s[i]</code> 相同的 char 的 idx <code>k</code></li><li>substring 個數 &#x3D; <code>(i - j) * (k - i)</code></li></ul></li><li>因此, 我們要紀錄相同的 char 所有出現的位置</li><li><strong>特殊情況</strong>：當 <code>s</code> 中和 <code>s[i]</code> 相同的 char 不滿 2 個時, 也就是 <code>s[i]</code> 找不到前一個相同的 char 或後一個相同的 char 時</li><li><strong>解決辦法</strong>：在每個 char 紀錄所有位置的開頭加上 <code>1</code>, 且結尾加上 <code>n</code>, 這樣即便 <code>s</code> 中沒有任何跟 <code>s[i]</code> 相同的 char 也能計算 substring 個數 &#x3D; <code>(i + 1) * (n - i)</code><ul><li>e.g. <code>s = XA</code>, 可得到 <code>A</code> 的 <code>idx = [-1, 1, 2]</code><ul><li><code>A</code> 以左（不含 <code>A</code>）可取 <code>&quot;&quot;</code>、<code>X</code> 這 2 種 substring</li><li><code>A</code> 以右（不含 <code>A</code>）可取 <code>&quot;&quot;</code> 這 1 種 substring</li><li><code>(1 + 1) * (2 - 1) = 2</code>, 總共有 <code>A</code>、<code>XA</code> 這 2 種 substring</li></ul></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniqueLetterString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">idx</span>(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有位置開頭之前加上 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            idx[i].<span class="built_in">emplace_back</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 紀錄所有 s[i] 出現的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            idx[s[i] - <span class="string">&#x27;A&#x27;</span>].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有位置結尾之後加上 n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            idx[s[i] - <span class="string">&#x27;A&#x27;</span>].<span class="built_in">emplace_back</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; idx[i].<span class="built_in">size</span>() - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                res += (idx[i][j] - idx[i][j - <span class="number">1</span>]) * (idx[i][j + <span class="number">1</span>] - idx[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>idx</code> 紀錄 <code>s</code> 中每個元素出現的位置</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Sliding window, 概念同 Solution 1, 只是計算 <code>idx = i</code> 之 substring 個數時, 只會用到前一個和後一個相同 char 的 idx, 故不需要一次紀錄所有相同 char 的位置</strong></p><ul><li>首先, 我們先將 <code>last2idx</code> 每個 char 的<strong>前兩個位置</strong>初始化為 <code>1, -1</code>（當前 <code>i</code> 作為第三個位置）<br>➔ 貢獻值公式：<code>(第二個位置 - 第一個位置) * (i - 第二個位置)</code></li><li>遍歷 <code>s</code> 中每個 char, 此時計算前一個 char（第二個位置）的貢獻值, 並累加到 <code>res</code> 中</li><li>假如當前 char 是首次出現, 因為前兩個 char 的出現位置都是 <code>1</code>, 相減後為 <code>0</code>, 所以累加值還是 <code>0</code></li><li>然後更新 <code>last2idx</code> 中的值</li><li><strong>由於每次都是計算該 char 的前一個位置之貢獻值, 所以最後還需要一個 for loop 去計算每個 char 最後出現位置的貢獻值</strong>。由於最後一個 char 後面沒有相同 char 了, 故用 <code>n</code> 來替代其後一個 idx</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniqueLetterString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 紀錄前兩次相同 char 出現的位置</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">last2idx</span>(<span class="number">26</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前兩次的出現位置，加上當前位置 i，可得知前一個位置的貢獻值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> ch = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            res += (last2idx[ch][<span class="number">1</span>] - last2idx[ch][<span class="number">0</span>]) * (i - last2idx[ch][<span class="number">1</span>]);</span><br><span class="line">            last2idx[ch][<span class="number">0</span>] = last2idx[ch][<span class="number">1</span>];</span><br><span class="line">            last2idx[ch][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 計算每個 char 最後出現位置的貢獻值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ch = <span class="number">0</span>; ch &lt; <span class="number">26</span>; ++ch) &#123;</span><br><span class="line">            res += (last2idx[ch][<span class="number">1</span>] - last2idx[ch][<span class="number">0</span>]) * (n - last2idx[ch][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code></li><li><strong>space：</strong>$O(1)$ ➔ $O(26 \cdot 2)$, 因為 <code>last2idx</code> 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30. Substring with Concatenation of All Words</title>
      <link href="/post/substring-with-concatenation-of-all-words/"/>
      <url>/post/substring-with-concatenation-of-all-words/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">https://leetcode.cn/problems/substring-with-concatenation-of-all-words/</a></strong></p><p><strong>題意</strong>：給一 string <code>s</code> 和一些長度相同的單字 <code>words</code>。返回 <code>s</code> 中恰好可以由 <code>words</code> 中所有單字串聯而成的 substring 之起始位置。</p><p><strong>注意</strong>：substring 要與 <code>words</code> 中的單字完全相同, 中間不可參雜其他 char, 而單字串聯的順序可以是任意的。</p></blockquote><p><img src="https://i.imgur.com/EDycThd.png"></p><p><img src="https://i.imgur.com/2ZFQv5N.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window</strong></p><ul><li>由於單字串聯的順序可以是任意的, 故利用 <code>freqs</code> 來記錄 <code>words</code> 中每個單字的出現次數</li><li>以 <code>i</code> 為起點, 往後取 <code>wordsNum</code> 個單字<ul><li>用 <code>cur</code> 來記錄當前 substring 中每種單字的出現次數</li><li>每個 <code>word</code> 的開頭 &#x3D; <code>i + j * wordLen</code>, 其中 <code>j</code> 表示以 <code>i</code> 為起點目前取到第幾個單字</li><li>若 <code>word</code> 不存在於 <code>freqs</code> 中, 則代表當前 substring 不符合<br>  ➔ 故 <code>i</code> 往下一個嘗試</li><li>若 <code>word</code> 在 <code>cur</code> 中的次數 &gt; 該 <code>word</code> 在 <code>freqs</code> 中的次數, 則代表當前 substring 不符合<br>  ➔ 故 <code>i</code> 往下一個嘗試</li><li>若 <code>j == wordsNum - 1</code>, 則代表以 <code>i</code> 為起點往後取的每個 <code>word</code> 都存在於 <code>words</code> 中<br>  總共取了 <code>wordsNum</code> 個 <code>word</code>, 且每個 <code>word</code> 皆沒超過 <code>freqs</code> 中對應的個數<br>  ➔ 代表每個 <code>word</code> 都恰好取了 <code>freqs[word]</code> 次</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> wordNum = words.<span class="built_in">size</span>(), wordLen = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wordNum * wordLen &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; freqs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            ++freqs[word];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - wordNum * wordLen + <span class="number">1</span>; ++i) &#123; <span class="comment">// 遍歷所有可能的起點</span></span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; cur;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; wordNum; ++j) &#123; <span class="comment">// 依序取出當前 substring 中每個的 word</span></span><br><span class="line">                string word = s.<span class="built_in">substr</span>(i + j * wordLen, wordLen);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// word 不存在 freqs 中</span></span><br><span class="line">                <span class="keyword">if</span> (freqs.<span class="built_in">find</span>(word) == freqs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++cur[word];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// word 超過需要的次數</span></span><br><span class="line">                <span class="keyword">if</span> (cur[word] &gt; freqs[word]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 以 i 為起點往後取的每個 word 都存在於 words 中</span></span><br><span class="line">                <span class="comment">// 總共取了 wordsNum 個 word, 且沒超過都 freqs 中對應的個數</span></span><br><span class="line">                <span class="comment">// 代表每個 word 都恰好取了 freqs[word] 次</span></span><br><span class="line">                <span class="keyword">if</span> (j == wordNum - <span class="number">1</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot wordsNum \cdot wordLen)$ ➔ 每次以 <code>i</code> 為起點, 去取 <code>wordsNum</code> 個 word, 而每個 word 長度為 <code>wordLen</code></li><li><strong>space：</strong>$O(wordsNum \cdot wordLen)$ ➔ <code>freqs</code> 保存所有 word</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>358. Rearrange String k Distance Apart</title>
      <link href="/post/rearrange-string-k-distance-apart/"/>
      <url>/post/rearrange-string-k-distance-apart/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/rearrange-string-k-distance-apart/">https://leetcode.cn/problems/rearrange-string-k-distance-apart/</a></strong></p><p><strong>題意</strong>：給一 string <code>s</code> 和一整數 <code>k</code>, 重新排列 <code>s</code> 使得相同 char 位置間隔距離至少為 <code>k</code>。若無法做到, 則返回 <code>&quot;&quot;</code>。</p></blockquote><p><img src="https://i.imgur.com/RIDYMn8.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy 和 Heap, 類似 <a href="https://zako945.github.io/post/task-scheduler/">621. Task Scheduler</a> 和 <a href="https://zako945.github.io/post/reorganize-string/">767. Reorganize String</a>, 要相同 char 之間距離為 <code>k</code>, 可想成是若每一輪能取出不同 <code>k</code> 個 char, 則每一輪相同 char 之間距離一定 <code>≥ k</code>, 要記得考慮不滿 <code>k</code> 個 char 的情況</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">rearrangeString</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在沒有限制間隔距離的情況下, 直接返回 s</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 計算 s 中每種 char 的出現次數</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freq[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt; q; <span class="comment">// max heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ch, num] : freq) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(num, ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> m = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// q.size() &lt; k 代表此輪為最後一輪</span></span><br><span class="line">            <span class="comment">// 若剩餘 char 的最大出現次數 &gt; 1, 表示最後一輪必定重複</span></span><br><span class="line">            <span class="keyword">if</span> (m &lt; k &amp;&amp; q.<span class="built_in">top</span>().first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> cycle = <span class="built_in">min</span>(k, m); <span class="comment">// 可能有不滿 k 個的情況(最後一輪)</span></span><br><span class="line">            vector&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一次取出 n 個不同種類的 char, 取出後出現次數要 - 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cycle; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [num, ch] = q.<span class="built_in">top</span>();</span><br><span class="line">                s += ch;</span><br><span class="line">                tmp.<span class="built_in">emplace_back</span>(num - <span class="number">1</span>, ch); <span class="comment">// 出現次數 - 1</span></span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若取出後的 char 之出現次數 &gt; 0, 則 push 回 q 中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [num, ch] : tmp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(num, ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ 每次 heap 取出元素後, 需花 $O(log(n))$ 調整 heap, 總共取 <code>n</code> 次</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>630. Course Schedule III</title>
      <link href="/post/course-schedule-iii/"/>
      <url>/post/course-schedule-iii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/course-schedule-iii/">https://leetcode.cn/problems/course-schedule-iii/</a></strong></p><p><strong>題意</strong>：有 <code>n</code> 個不同的課程, 編號從 <code>1</code> 到 <code>n</code>。給一整數 array <code>course</code>, 其中 <code>courses[i] = [duration_i, lastDay_i]</code> 代表第 <code>i</code> 門課程會持續 <code>duration_i</code> 天, 且須在 <code>lastDay_i</code> 之前完成。</p><p>學期從第 <code>1</code> 天開始, 且不得同時修習兩門(含)以上的課程。</p><p>返回最多可修習的課程數目。</p></blockquote><p><img src="https://i.imgur.com/1SUVyTh.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy + Heap, 由於我們希望能修習的課越多越好, 因此我們要先將課程根據 deadline 由小到大排序, 因為 deadline 越是緊急的課越應該優先完成, 完成後才接著去安排 deadline 相對寬鬆的課</strong></p><ul><li>將所有課程根據 deadline 由小到大排序</li><li>用 max heap <code>q</code> 維護目前取的課程中 duration 最長的課</li><li>按照 deadline 的順序, 一一嘗試加入課程。一旦有課程無法在 deadline 前完成, 則取消掉目前取的課程中 duration 最長的課</li></ul><p>e.g. <code>courses = [[3, 5], [4, 7], [2, 8]]</code></p><ul><li>第一天取 <code>[3, 5]</code> 在第三天時修完第一門, 然後取 <code>[4, 7]</code> 於第 7 天完成第二門, 接著取 <code>[2, 8]</code>, 但是第三門無法在 deadline 前完成, 因為 7 + 2 &#x3D; 9 &gt; 8</li><li>我們會希望在修習相同課程數的條件下, <code>days</code> 能越小越好, 因為這樣後面課程才越有機會在 deadline 前完成</li><li>所以我們取消掉 <code>[4, 7]</code>, 因為它的 duration 最長。此時我們取了 <code>[3, 5]</code> 和 <code>[2, 8]</code> 這兩門課只花了 5 天, 而非 <code>[3, 5]</code> 和 <code>[4, 7]</code> 這樣需花 7 天。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scheduleCourse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> cmp = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; c1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; c2)&#123;</span><br><span class="line">            <span class="keyword">return</span> c1[<span class="number">1</span>] &lt; c2[<span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(courses.<span class="built_in">begin</span>(), courses.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> days = <span class="number">0</span>; <span class="comment">// 從第一天就開始修課</span></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// max heap, 維護目前取的課程中 duration 最長的課</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; course : courses) &#123;</span><br><span class="line">            <span class="type">int</span> duration = course[<span class="number">0</span>], lastDay = course[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先嘗試取當前課程</span></span><br><span class="line">            q.<span class="built_in">emplace</span>(duration);</span><br><span class="line">            days += duration;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若超出 deadline, 則取消 q 中 duration 最長的課程</span></span><br><span class="line">            <span class="keyword">if</span> (days &gt; lastDay) &#123;</span><br><span class="line">                days -= q.<span class="built_in">top</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">size</span>(); <span class="comment">// 代表最後取了幾門課</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ 每次 heap 取出元素後, 需花 $O(log(n))$ 調整 heap, 總共取 <code>n</code> 次</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中元素不超過 <code>n</code> 個</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>895. Maximum Frequency Stack</title>
      <link href="/post/maximum-frequency-stack/"/>
      <url>/post/maximum-frequency-stack/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-frequency-stack/">https://leetcode.cn/problems/maximum-frequency-stack/</a></strong></p><p><strong>題意</strong>：設計一個類似 stack 的資料結構, 將元素 push 到 stack 中, 並從 stack 中 pop 出頻率最高的元素。</p><p>請實現 <code>FreqStack</code> class：</p><ul><li><code>FreqStack()</code>：建立一個空的 stack</li><li><code>void push(int val)</code>：將整數 <code>val</code> push 到 stack 中</li><li><code>int pop()</code>：刪除並返回 stack 中頻率最高的元素<ul><li>若頻率最高的元素不只一個, 則刪除並返回最接近 stack top 的元素</li></ul></li></ul></blockquote><p><img src="https://i.imgur.com/MLuaaiQ.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Bucket, 使用多個 stack, 來模擬 <code>FreqStack</code>。每 push 一個元素就要 push 到當前對應頻率的 stack 中。同一頻率中, 越晚加入的元素就會越接近其對應頻率的 stack 之 top</strong></p><p>e.g. push <code>[5, 7, 5, 7, 4, 5]</code>, 最後可得到下圖中右下角的表格, 然後依序從 freq 高的開始 pop ➔ pop 的順序由下往上、由右至左為 <code>[5, 7, 5, 4, 7 ,5]</code></p><p><img src="https://i.imgur.com/0VQmRGz.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreqStack</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> freq = ++freqs[val];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若還不存在對應的頻率 stack, 則要新增</span></span><br><span class="line">        <span class="keyword">if</span> (stacks.<span class="built_in">size</span>() &lt; freq) &#123;</span><br><span class="line">            stacks.<span class="built_in">emplace_back</span>(<span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stacks[freq - <span class="number">1</span>].<span class="built_in">emplace</span>(val); <span class="comment">// push 元素到對應的頻率 stack</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 將當前最大頻率且最接近 top 的元素 pop 掉</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> val = stacks.<span class="built_in">back</span>().<span class="built_in">top</span>();</span><br><span class="line">        stacks.<span class="built_in">back</span>().<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若該最大頻率的 stack 中已經沒有任何元素, 則應將其 pop 掉</span></span><br><span class="line">        <span class="comment">// e.g. pop() 一次後, 頻率 = 3 的 stack[2] 中已沒任何元素, 則應將其 pop 掉</span></span><br><span class="line">        <span class="keyword">if</span> (stacks.<span class="built_in">back</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stacks.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --freqs[val];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;stack&lt;<span class="type">int</span>&gt;&gt; stacks;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freqs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令 <code>n</code> 為 push 的次數</p><ul><li><strong>time：</strong><ul><li><code>push()</code>：$O(1)$, push 元素到 stack 中</li><li><code>pop()</code>：$O(1)$, 從 stack 中 pop 元素</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ stacks 中的元素不超過 <code>n</code> 個</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Heap, 概念同 Solution 1, 本題的困難點在於：</strong></p><ul><li>每次 pop 時, 必須知道頻率最高的元素是哪個</li><li>若頻率最高的元素不只一個, 還得知道最晚 push 進來的元素是哪個</li></ul><p><strong>因此, 我們須做到以下幾點：</strong></p><ul><li>用 max heap <code>q</code> 來維護當前 stack 中頻率最高的元素</li><li>用 <code>timestamp</code> 紀錄每個元素 push 進來的順序(越晚 push 進來的元素, 其 <code>timestamp</code> 越大)</li><li>若 <code>q</code> 中有相同頻率的元素, 得用 <code>timestamp</code> 來判斷要優先取哪個。因此 <code>q</code> 中應保存 <code>&#123;freq, timestamp, val&#125;</code>, 這樣當 <code>freq</code> 相同時, top 就會優先取 <code>timestamp</code> 高的元素</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreqStack</span>() : <span class="built_in">timestamp</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(++freqs[val], timestamp++, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> val = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q.<span class="built_in">top</span>());</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        --freqs[val];</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> timestamp; <span class="comment">// 紀錄元素 push 進來的順序, 越晚表示越大</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freqs;</span><br><span class="line">    priority_queue&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; q; <span class="comment">// max heap, 紀錄 &#123;freq, timestamp, val&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令 <code>n</code> 為 push 的次數</p><ul><li><strong>time：</strong><ul><li><code>push()</code>：$O(log(n))$, 因為元素 push 到 heap 中, 需調整 heap</li><li><code>pop()</code>：$O(log(n))$, 因為元素 pop 後, 需調整 heap</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素不超過 <code>n</code> 個</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>480. Sliding Window Median</title>
      <link href="/post/sliding-window-median/"/>
      <url>/post/sliding-window-median/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sliding-window-median">https://leetcode.cn/problems/sliding-window-median</a></strong></p><p><strong>題意</strong>：中位數是指有序 array 裡中間的數。若 array 長度偶數, 則中位數是中間兩數的平均值。</p><ul><li><code>arr = [2,3,4]</code>, 則中位數 &#x3D; <code>3</code></li><li><code>arr = [2,3]</code>, 則中位數 &#x3D; <code>(2+3) / 2 = 2.5</code></li></ul><p>給一整數 array <code>nums</code> 和一整數 <code>k</code>, 有一長度為 <code>k</code> 的 sliding window 從 <code>nums</code> 最左端滑到最右端, 每次向右移動一位, 求每次移動 sliding window 後得到的中位數, 並返回由這些中位數所組成的 array。</p></blockquote><p><img src="https://i.imgur.com/exqRG0U.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap, 類似 <a href="https://zako945.github.io/post/find-median-from-data-stream/">295. Find Median from Data Stream</a>, 使用兩個 heap + 延遲刪除, 我們定義平衡：</strong></p><ul><li>滿足 <code>smaller.size() - larger.size() ≤ 1</code></li></ul><p><strong>也就是說 <code>smaller</code> 的元素個數要麼比 <code>larger</code> 多一, 要麼相同</strong></p><p>這樣設計的好處在於：</p><ul><li>當 <code>k</code> 為偶數時, 各自的 top 之平均值即為中位數</li><li>當 <code>k</code> 為奇數時, 則 <code>smaller.top()</code> 即為中位數</li></ul><p><strong>每次移動 window 的操作：</strong></p><ul><li>在每次移動 sliding window 前都為平衡的, 也就是 <code>smaller.size() - larger.size() ≤ 1</code></li><li>設置 <code>balance = 0</code>, 用來記錄<strong>該次</strong>移動 window 中, <code>smaller</code> 和 <code>larger</code> 元素個數的差值</li><li>刪除 window 左側的元素<ul><li>由於 heap 沒辦法刪除指定的元素 <code>val</code>, 因此先欠下這個帳, 等到 <code>val</code> 出現在 <code>heap.top()</code> 時, 再進行刪除。</li><li><code>delay</code> 紀錄 <code>val</code> 欠賬的次數, 因此 <code>++delay[val]</code></li></ul></li><li>新增 window 右側的元素<ul><li>若 <code>nums[i] &lt;= smaller.top()</code>, 則把 <code>nums[i]</code> 放到 <code>smalller</code> 中, 然後 <code>++balance</code></li><li>否則, 把 <code>nums[i]</code> 放到 <code>larger</code> 中, 然後 <code>-balance</code></li></ul></li><li>經過上述刪除&#x2F;新增的操作, 此時 <code>balance</code> 為 <code>2</code>、<code>0</code>、<code>2</code> 這三種情況之一：<ul><li><code>2</code>：本次移動中刪除的元素是在 <code>smaller</code> 中的, 且新增的元素是 <code>larger</code></li><li><code>0</code>：<ul><li>本次移動中刪除的元素是在 <code>smaller</code> 中的, 且新增的元素是在 <code>smaller</code></li><li>本次移動中刪除的元素是在 <code>larger</code> 中的, 且新增的元素是在 <code>larger</code></li></ul></li><li><code>2</code>：本次移動中刪除的元素是在 <code>larger</code> 中的, 且新增的元素是 <code>smaller</code></li></ul></li><li>我們需要進行調整, 使 <code>balance = 0</code>, 也就 <code>smaller.size() - larger.size() ≤ 1</code>:<ul><li>若 <code>balance== -2</code>, 則把 <code>larger.top()</code> 給 pop 掉, 並將其 push 到 <code>smaller</code> 中</li><li>若 <code>balance== 0</code>, 則不需調整</li><li>若 <code>balance == 2</code>, 則把 <code>smaller.top()</code> 給 pop 掉, 並將其 push 到 <code>larger</code> 中</li></ul></li><li>調整完後, 接著要計算中位數。但在計算中位數前, 必須先把欠的帳給還了, 避免那些應該刪除的數影響到中位數的計算<ul><li>分別檢查兩邊的 heap, 若 <code>heap.top()</code> 欠著債, 則將其 pop 掉, 直到 <code>heap.top()</code> 沒有欠債為止</li><li>若那些應刪除的數不為 <code>heap.top()</code> 該怎麼辦 ? 由於計算中位數的時候只與 <code>heap.top()</code> 有關, 至於那些不為 <code>heap.top()</code> 但欠著債的, 就讓他們欠著吧, 等他們成為 <code>heap.top()</code> 的時候再 pop 掉就行了</li></ul></li><li>最後, 計算中位數</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 k 個元素 push 到 smaller 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            smaller.<span class="built_in">emplace</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 (k / 2) 個元素從 smaller 中 pop 掉, 並 push 到 larger 中</span></span><br><span class="line">        <span class="comment">// 若 k 為奇數, 則此時 smaller 的元素個數比 larger 多一</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            larger.<span class="built_in">emplace</span>(smaller.<span class="built_in">top</span>());</span><br><span class="line">            smaller.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到第一個中位數</span></span><br><span class="line">        res.<span class="built_in">emplace_back</span>(<span class="built_in">getMedian</span>(k));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到剩下 (n - k) 個中位數, 總共 (n - k + 1) 個中位數</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> balance = <span class="number">0</span>; <span class="comment">// 每次插入 nums[i] 前都為平衡的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判斷從哪個 heap 中刪除 nums[i-k]</span></span><br><span class="line">            <span class="built_in">remove</span>(nums[i-k], balance);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判斷 nums[i] 要加入到哪個 heap 中</span></span><br><span class="line">            <span class="built_in">insert</span>(nums[i], balance);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在刪除/新增元素後, 要仍保持平衡</span></span><br><span class="line">            <span class="built_in">makeBalance</span>(balance);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 heap.top() 恰為要刪除的數, 則要在計算中位數前刪除掉</span></span><br><span class="line">            <span class="built_in">prune</span>(smaller);</span><br><span class="line">            <span class="built_in">prune</span>(larger);</span><br><span class="line"></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="built_in">getMedian</span>(k));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; delay; <span class="comment">// 紀錄要刪除的數, 以及其次數</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; smaller; <span class="comment">// max heap</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; larger; <span class="comment">// min heap</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getMedian</span><span class="params">(<span class="type">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> smaller.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> smaller.<span class="built_in">top</span>() * <span class="number">0.5</span> + larger.<span class="built_in">top</span>() * <span class="number">0.5</span>; <span class="comment">// 避免 overflow 的寫法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>&amp; val, <span class="type">int</span>&amp; balance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!smaller.<span class="built_in">empty</span>() &amp;&amp; val &lt;= smaller.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            smaller.<span class="built_in">emplace</span>(val);</span><br><span class="line">            ++balance;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            larger.<span class="built_in">emplace</span>(val);</span><br><span class="line">            --balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span>&amp; val, <span class="type">int</span>&amp; balance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!smaller.<span class="built_in">empty</span>() &amp;&amp; val &lt;= smaller.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            --balance;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++balance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++delay[val]; <span class="comment">// 在 delay 中紀錄 val</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeBalance</span><span class="params">(<span class="type">int</span>&amp; balance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            larger.<span class="built_in">emplace</span>(smaller.<span class="built_in">top</span>());</span><br><span class="line">            smaller.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (balance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            smaller.<span class="built_in">emplace</span>(larger.<span class="built_in">top</span>());</span><br><span class="line">            larger.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">prune</span><span class="params">(T&amp; heap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>() &amp;&amp; delay[heap.<span class="built_in">top</span>()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            --delay[heap.<span class="built_in">top</span>()];</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ 每次 insert &#x2F; delete 皆須 $log(n)$, worse case：應被刪除的數皆不為 top, 導致 <code>smaller + larger</code> 為 <code>n</code> 個數</li><li><strong>space：</strong>$O(n)$ ➔ <code>smaller + larger</code> 和 <code>delay</code>, 長度皆不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>745. Prefix and Suffix Search</title>
      <link href="/post/prefix-and-suffix-search/"/>
      <url>/post/prefix-and-suffix-search/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/prefix-and-suffix-search/">https://leetcode.cn/problems/prefix-and-suffix-search/</a></strong></p><p><strong>題意</strong>：設計一個可以透過 prefix 和 suffix 來搜尋單字的特殊字典。</p><p>請實現 <code>WordFilter</code> class：</p><ul><li><code>WordFilter(string[] words)</code>：使用 <code>word</code> 來初始化 <code>WordFilter</code></li><li><code>f(string pref, string suff)</code>：返回字典中具有前綴 <code>prefix</code> 和後綴 <code>suffix</code> 單字的 index。若不只一個 index 滿足要求, 則返回<strong>最大的 index</strong>。若不存在這樣的單字, 則返回 <code>1</code>。</li></ul><p>其中, <code>words[i]</code>、<code>pref</code>、<code>suff</code> 僅由<strong>小寫</strong>字母所組成。</p></blockquote><p><img src="https://i.imgur.com/qzovP08.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table 去儲存每個單字所有可能的 <code>prefix_suffix</code> 組合, 並對應到該單字的 index。若有單字有相同的 <code>prefix_suffix</code> 組合, 則後面的單字會覆蓋掉前面的單字之 index</strong></p><ul><li><p>紀錄該單字的 <code>prefixes</code>、<code>suffixes</code> 長度為 <code>n + 1</code>, 其中 <code>n</code> 為該單字的長度, 因為要加上 <strong>empty string</strong></p><p>  e.g. <code>word = [&quot;abc&quot;]</code>, 可得到：</p><ul><li><code>prefixes = [&quot;&quot;, &quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;]</code></li><li><code>suffixes = [&quot;&quot;, &quot;c&quot;, &quot;bc&quot;, &quot;abc&quot;]</code></li><li>所有的 <code>prefix_suffix</code> 組合總共有 <code>(3+1) x (3+1) = 16</code> 種</li></ul></li><li><p>建立 <code>prefixes</code>、<code>suffixes</code> 需 $O(n^2)$ time, 因為 string <code>c = a + b</code>, 需 $O(a.size() + b.size())$<br>➔ 建立 <code>prefix = suffix = 1 + 2 + ... + n</code> &#x3D; $O(n^2)$</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordFilter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordFilter</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> n = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;string&gt; <span class="title">prefixes</span><span class="params">(n + <span class="number">1</span>, <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">            <span class="function">vector&lt;string&gt; <span class="title">suffixes</span><span class="params">(n + <span class="number">1</span>, <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 需 O(n^2) time, 因為 string c = a + b, 需 O(a.size() + b.size()) time</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                prefixes[i + <span class="number">1</span>] = prefixes[i] + word[i];</span><br><span class="line">                suffixes[i + <span class="number">1</span>] = word[n - <span class="number">1</span> - i] + suffixes[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若有相同的 prefix_suffix, 則後面的 word 會覆蓋掉前面的 word 之 idx</span></span><br><span class="line">            <span class="comment">// 建立所有的 prefix_suffix 組合需 O(n^3) time</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; prefix : prefixes) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; suffix : suffixes) &#123;</span><br><span class="line">                    filter[prefix + <span class="string">&quot;_&quot;</span> + suffix] = idx; <span class="comment">// 需 O(n) time</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++idx; <span class="comment">// 下一個 word 之 idx 要加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string pref, string suff)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> string key = pref + <span class="string">&quot;_&quot;</span> + suff;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> it = filter.<span class="built_in">find</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it != filter.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second; <span class="comment">// 返回 idx</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; filter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>WordFilter()</code>：$O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i^3})$, 其中 $w_i$ 為單字長度, 總共有 $n$ 個單字<ul><li>每個單字建立 <code>prefixes</code>, <code>suffixes</code> 需 $O(w_i^2)$, 總共需花 $O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i^2})$</li><li>每個單字總共有 $O(w_i^2)$ 種 <code>prefix_suffix</code> 組合, 而每一種組合需花 $O(w_i)$ 建立對應的 <code>key</code>, 也就是 <code>prefix + &quot;_&quot; + suffix</code>。因此每個單字需花 $O(w_i^3)$ 建立所有的 <code>prefix_suffix</code> 組合, 總共需花 $O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i^3})$</li></ul></li><li><code>f()</code>：$O(p + s)$, 建立 key 的時間複雜度, 其中 $p$ 為 <code>pref</code> 長度, $s$ 為 <code>suff</code> 長度</li></ul></li><li><strong>space：</strong>$O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i^3})$ ➔ <code>filter</code>, 每個單字有 $O(w_i^2)$ 種 <code>prefix_suffix</code> 組合, 而每一種又有長度為 $O(w_i)$ 的 <code>key</code>, 因此每個單字需 $O(w_i^3)$, 總共需 $O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i^3})$</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Trie, 本題最大的困難點在於不知如何搜尋以 <code>suffix</code> 結尾的單字, 對於每個單字 word, 我們把所有可能的 <code>suffixes_word</code> 組合 insert 到 trie 中(因為 word 本身滿足 prefix 順序)。最後, 用 <code>suff_pref</code> 來做搜尋</strong></p><p>e.g. <code>word = [&quot;apple&quot;]</code> 可產生以下 <code>suffixes_word</code> 組合：<br><code>[&quot;_apple&quot;, &quot;e_apple&quot;, &quot;le_apple&quot;, &quot;ple_apple&quot;, &quot;pple_apple&quot;, &quot;apple_apple&quot;]</code></p><p>另外, 使用 <code>&#123;</code> 作為分隔符, 用來隔開 <code>prefix</code> 和 <code>suffix</code>, 因為 <code>&#123;</code> 在 ASCII 中恰好是 <code>z</code> 的下一個, 這樣就不用額外寫判斷式</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">27</span>] = &#123;<span class="literal">nullptr</span>&#125;; <span class="comment">// 多一個分割符號 &quot;&#123;&quot;</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">-1</span>; <span class="comment">// 要記錄該 word 在 words 中的 idx</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word, <span class="type">int</span>&amp; idx)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                node-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">            node-&gt;idx = idx; <span class="comment">// 紀錄 idx</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若存在 prefix, 則返回 idx。否則, 返回 -1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">startsWith</span><span class="params">(<span class="type">const</span> string&amp; prefix)</span></span>&#123;</span><br><span class="line">        TrieNode *node = <span class="built_in">find</span>(prefix);</span><br><span class="line">        <span class="keyword">return</span> (node != <span class="literal">nullptr</span>) ? node-&gt;idx : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若 prefix 不在 trie 中, 則返回 nullptr; 否則, 返回 end node 之 ptr</span></span><br><span class="line">    <span class="function">TrieNode* <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; prefix)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : prefix) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordFilter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordFilter</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = words[i].<span class="built_in">size</span>();</span><br><span class="line">            string key = <span class="string">&quot;&#123;&quot;</span> + words[i]; <span class="comment">// &#123; 作為分割符</span></span><br><span class="line">            trie.<span class="built_in">insert</span>(key, i); <span class="comment">// suffix 為空的組合</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將所有 suffixes_word 組合 insert 到 trie 中(suffix 非空)</span></span><br><span class="line">            <span class="comment">// 需花 O(len^2) time</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">                key = words[i][len - <span class="number">1</span> - j] + key;</span><br><span class="line">                trie.<span class="built_in">insert</span>(key, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string pref, string suff)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// trie 中搜尋 suff + &quot;&#123;&quot; + pref</span></span><br><span class="line">        <span class="keyword">return</span> trie.<span class="built_in">startsWith</span>(suff + <span class="string">&quot;&#123;&quot;</span> + pref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>WordFilter()</code>：$O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i^2})$, 其中 $w_i$ 為單字長度, 總共有 $n$ 個單字<ul><li>每個單字建立所有的 <code>suffixes_word</code> 組合需 $O({w_i}^2)$, 總共需 $O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i^2})$</li></ul></li><li><code>f()</code>：$O(p + s)$, 其中 $p$ 為 <code>pref</code> 的長度, $s$ 為 <code>suff</code> 的長度<ul><li>建立 string <code>suff_pref</code></li><li>在 <code>trie</code> 中搜尋 <code>suff_pref</code></li></ul></li></ul></li><li><strong>space：</strong>$O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i}^2)$ ➔ <code>trie</code>, 每個單字有 $O(w_i)$ 種 <code>suffixes_word</code> 組合, 而每一種長度為 $O(w_i)$。因此 在 worse case 中(沒有任何共用 prefix 的情況下)每個單字建立所有的 <code>suffixes_word</code> 組合需 $O(w_i^2)$, 總共需 $O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i^2})$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>472. Concatenated Words</title>
      <link href="/post/concatenated-words/"/>
      <url>/post/concatenated-words/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/concatenated-words/">https://leetcode.cn/problems/concatenated-words/</a></strong></p><p><strong>題意</strong>：給一 string array <code>words</code> (<strong>沒有重複單字</strong>), 找出並返回 <code>words</code> 中所有的<strong>連接詞</strong>。</p><p><strong>連接詞</strong>：一個完全由 <code>words</code> 中至少兩個單字所組成的 string。</p></blockquote><p><img src="https://i.imgur.com/1DB5Tko.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS + Trie, 同 <a href="https://zako945.github.io/post/word-break/">139. Word Break</a>, 先對 <code>words</code> 根據 string 的長度進行排序, 因為排序後 <code>word[i]</code> 只會由比它短的單字所組成, 因此我們先把較短的單字 insert 到 trie 中後, 再來搜尋 <code>word[i]</code> 是否能由 trie 中的單字所組成</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                node-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)&#123;</span><br><span class="line">           <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(word, <span class="number">0</span>)) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">            &#125;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; word, <span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == word.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TrieNode *node = trie.root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur; i &lt; word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idx = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx]) &#123;</span><br><span class="line">                node = node-&gt;children[idx];</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;isEnd &amp;&amp; <span class="built_in">dfs</span>(word, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>time：</strong>$O(n \cdot log(n) + \sum\limits_{i &#x3D; 0}^{n-1} + \sum\limits_{i &#x3D; 0}^{n-1}{2^{w_i}})$, 其中 $n$ 為 <code>words</code> 中的單字個數, $w_i$ 為 <code>words[i]</code> 的長度</p><ul><li>$O(n \cdot log(n))$：sorting</li><li>$O(\sum\limits_{i &#x3D; 0}^{n-1})$：insert 單字到 trie 中</li><li>$O(\sum\limits_{i &#x3D; 0}^{n-1}{2^{w_i}})$：判斷每個 <code>words[i]</code> 是否為連接詞需 $O(2^{w_i})$<ul><li><p>$O(2^{n})：T(n) &#x3D; T(n - 1) + T(n - 2) + … + T(1)$</p><p>  <img src="https://i.imgur.com/DLpKESz.png"></p></li></ul></li></ul></li><li><p><strong>space：</strong>$O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i})$ ➔ $O(26 \cdot \sum\limits_{i &#x3D; 0}^{n-1}{w_i})$, worse case：trie 中所有單字都沒有重複的 prefix</p></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS + Trie + Memorization, 同 <a href="https://zako945.github.io/post/word-break/">139. Word Break</a>, 改進 Solution 1, 若 word 中 <code>idx = cur</code> 為開頭往後的 substring 無法由若干個 <code>words[i]</code> 所組成, 則透過 <code>visited</code> 紀錄起來, 藉此來進行剪枝, 避免重複走失敗的道路</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                node-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)&#123;</span><br><span class="line">           <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">exist</span>(word, <span class="number">0</span>)) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">            &#125;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(string&amp; word, <span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 每個 word 都要重新初始化 visited</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(word.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(word, idx, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(string&amp; word, <span class="type">int</span> cur, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == word.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若已經被標記為失敗, 則直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (visited[cur] == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TrieNode *node = trie.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur; i &lt; word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idx = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx]) &#123;</span><br><span class="line">                node = node-&gt;children[idx];</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;isEnd &amp;&amp; <span class="built_in">dfs</span>(word, i + <span class="number">1</span>, visited)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[cur] = <span class="literal">true</span>; <span class="comment">// 標記為失敗</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n) + \sum\limits_{i &#x3D; 0}^{n-1} + \sum\limits_{i &#x3D; 0}^{n-1}{w_i^2})$ ➔ $T(n) &#x3D; T(n - 1) + O(n)$<ul><li>$O(n \cdot log(n))$：sorting</li><li>$O(\sum\limits_{i &#x3D; 0}^{n-1})$：insert 單字到 trie 中</li><li>$O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i^2})$：判斷每個 <code>words[i]</code> 是否為連接詞需 $O(w_i^2)$<ul><li>$O(n^2)：T(n) &#x3D; T(n - 1) +$ $O(n)$, 因為有用 <code>visited</code> 記憶, 所以呼叫 <code>T(n-1)</code> 即可, <code>T(n-1)</code> 會再往下呼叫 <code>T(n-2)</code>, 依此類推 …, 每個 <code>T(n-i)</code> 只要呼叫一次即可(因為會記住結果)。</li><li>$O(n)$ 是因為呼叫一次 <code>T(n-1)</code> 後, 剩下 <code>T(n-2), ..., T(1)</code> 都會計算出來。原本 $O(n)$ 應寫作 <code>T(n-2) + T(n-3) + ... + T(1)</code>, 但是除了 <code>T(n-1)</code>, 剩下的 <code>T(n-i)</code> 都只需 $O(1)$, 故 <code>T(n-2) + T(n-3) + ... + T(1)</code> 可直接寫成 $O(n)$</li></ul></li></ul></li><li><strong>space：</strong>$O(\sum\limits_{i &#x3D; 0}^{n-1}{w_i} + L)$ ➔ $O(26 \cdot \sum\limits_{i &#x3D; 0}^{n-1}{w_i}) + O(L)$<ul><li>$O(26 \cdot \sum\limits_{i &#x3D; 0}^{n-1}{w_i})$：worse case : trie 中所有單字都沒有重複的 prefix</li><li>$O(L)$：<code>visited</code>, 其中 $L$ 為 <code>words</code> 中最長單字的長度</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>336. Palindrome Pairs</title>
      <link href="/post/palindrome-pairs/"/>
      <url>/post/palindrome-pairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindrome-pairs/">https://leetcode.cn/problems/palindrome-pairs/</a></strong></p><p><strong>題意</strong>：給一單字互不相同的 string list <code>words</code>, 找出所有不同的 index pair <code>(i, j)</code>, 使得 <code>word[i] + word[j]</code> 為迴文。</p></blockquote><p><img src="https://i.imgur.com/YSuiTJw.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 Trie</strong></p><ul><li><p>首先, 我們把所有 <code>words[i]</code> 給 insert 到 trie 中</p></li><li><p>若 string <code>words[i]</code> 存在迴文 pair, 則可以先將 <code>words[i]</code> 拆成 <code>s1</code> 和 <code>s2</code>, 也就是說 <code>words[i] = s1 + s2</code></p><ul><li>若 <code>s1</code> 的部分為迴文, 假設 <code>words[i] = XXXXabc</code>, 其中 <code>s1 = XXXX</code> 表示為迴文, <code>s2 = abc</code>。若存在迴文, 則應存在 <code>left = reverse(s2) = cba</code>, 使得 <code>left + words[i] = cbaXXXXabc</code> 為迴文, 得到迴文 pair 為 <code>&#123;leftIdx, i&#125;</code></li><li>若 <code>s2</code> 的部分為迴文, 假設 <code>words[i] = abcXXXX</code>, 其中 <code>s2 = XXXX</code> 表示為迴文, <code>s1 = abc</code>。若存在迴文, 則應存在 <code>right = reverse(s1) = cba</code>, 使得 <code>words[i] + right = abcXXXXcba</code> 為迴文, 得到迴文 pair 為 <code>&#123;i, rightIdx&#125;</code></li></ul></li><li><p>若有一 <code>word[i] = &quot;aaa&quot;</code>, 當 <code>s1 = &quot;&quot;</code>, <code>s2 = &quot;aaa&quot; = reverse(s2)</code>, 到 trie 中找到的 <code>idx</code> 會是自己的 idx <code>i</code>, 因此要滿足 <code>idx != -1 &amp;&amp; idx != i</code> 才能新增迴文 pair</p></li><li><p>當 <code>words[i] = [&quot;a&quot;, &quot;&quot;]</code>, for loop 中 <code>0 ≤ j ≤ words[i].size()</code>, 這樣 <code>&quot;&quot;</code> 才會被 insert 到 trie 中</p><p>  <img src="https://i.imgur.com/zIHmt1H.png"></p></li><li><p>若 <code>words = [&quot;abcd&quot;, &quot;dcba&quot;]</code>, <code>words[i]</code> 恰存在 <code>words[j]</code>, 使得 <code>words[i] == reverse(words[j])</code>, 會得到重複的迴文 pair, 也就 <code>0 ≤ j ≤ words[i].size()</code> 中等號只取一次, 否則會有重複的答案, 這邊我們設 <code>j == 0</code> 時不判斷 <code>s1</code> 是否為迴文</p><p>  <img src="https://i.imgur.com/HRNaeem.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">-1</span>; <span class="comment">// 每個 word 的 end node 會紀錄 word 在 words 中的 idx</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果為 empty string, 則會修改 root-&gt;idx</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word, <span class="type">const</span> <span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                node-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;idx = idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 trie 中存在 s, 則返回 end node 之 idx</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node-&gt;idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">palindromePairs</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(words[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; w = words[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// j 是 &lt;= words[i], 因為 empty string 也算迴文</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 若 s1 為迴文, 則到 trie 中尋找是否有 reverse(s2)</span></span><br><span class="line">                <span class="comment">// 0 &lt;= j &lt;= w.size() 只取一次, 否則會有重複的答案</span></span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; <span class="built_in">isPalindrome</span>(w, <span class="number">0</span>, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> s2 = w.<span class="built_in">substr</span>(j);</span><br><span class="line">                    <span class="built_in">reverse</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>());</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> leftIdx = trie.<span class="built_in">find</span>(s2);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (leftIdx != <span class="number">-1</span> &amp;&amp; leftIdx != i) &#123;</span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;leftIdx, i&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 s2 為迴文, 則到 trie 中尋找是否有 reverse(s1)</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(w, j, w.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> s1 = w.<span class="built_in">substr</span>(<span class="number">0</span>, j);</span><br><span class="line">                    <span class="built_in">reverse</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>());</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> rightIdx = trie.<span class="built_in">find</span>(s1);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rightIdx != <span class="number">-1</span> &amp;&amp; rightIdx != i) &#123;</span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;i, rightIdx&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left++] != s[right--]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot m^2)$ ➔ 其中 $n$ 為 word 的個數, $m$ 是 word 的平均長度<ul><li>$O(m^2)$：判斷一個 word 中所有的 <code>s1</code> 和 <code>s2</code> 是否為迴文, 總共有 $m$ 種不同的 <code>s1</code> 和 <code>s2</code>, 每判斷一種 <code>s1</code> 和 <code>s2</code> 是否為迴文、到 <code>trie</code> 查找皆需花 $O(m)$</li></ul></li><li><strong>space：</strong>$O(n \cdot m)$ ➔ <code>trie</code>, worse case：每個 word 的 prefix 皆不重複</li></ul><hr><h2 id="Solution-2：（TLE-無法通過）"><a href="#Solution-2：（TLE-無法通過）" class="headerlink" title="Solution 2：（TLE 無法通過）"></a><strong>Solution 2：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 hash table, 同 Solution 1, 只是存到 hash table 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">palindromePairs</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; idx;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            idx[words[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; w = words[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// j 是 &lt;= words[i], 因為 empty string 也算迴文</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 若 s1 為迴文, 則到 hast table 中尋找是否有 reverse(s2)</span></span><br><span class="line">                <span class="comment">// 0 &lt;= j &lt;= w.size() 只取一次, 否則會有重複的答案</span></span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; <span class="built_in">isPalindrome</span>(w, <span class="number">0</span>, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> s2 = w.<span class="built_in">substr</span>(j);</span><br><span class="line">                    <span class="built_in">reverse</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>());</span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> left = idx.<span class="built_in">find</span>(s2);</span><br><span class="line">                    <span class="keyword">if</span> (left != idx.<span class="built_in">end</span>() &amp;&amp; left-&gt;second != i) &#123;</span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;left-&gt;second, idx[w]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 s2 為迴文, 則到 hash table 中尋找是否有 reverse(s1)</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(w, j, w.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> s1 = w.<span class="built_in">substr</span>(<span class="number">0</span>, j);</span><br><span class="line">                    <span class="built_in">reverse</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>());</span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> right = idx.<span class="built_in">find</span>(s1);</span><br><span class="line">                    <span class="keyword">if</span> (right != idx.<span class="built_in">end</span>() &amp;&amp; right-&gt;second != i) &#123;</span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;idx[w], right-&gt;second&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left++] != s[right--]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot m^2)$ ➔ 其中 $n$ 為 word 的個數, $m$ 是 word 的平均長度<ul><li>$O(m^2)$：判斷一個 word 中所有的 <code>s1</code> 和 <code>s2</code> 是否為迴文, 總共有 <code>m</code> 種不同的 <code>s1</code> 和 <code>s2</code>, 每判斷一種 <code>s1</code> 和 <code>s2</code> 是否為迴文需花 $O(m)$</li></ul></li><li><strong>space：</strong>$O(n \cdot m)$ ➔ hash table 需保存 string 和對應的 idx, 總共 <code>n</code> 個 word, 每個 word 平均長度為 <code>m</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>642. Design Search Autocomplete System</title>
      <link href="/post/design-search-autocomplete-system/"/>
      <url>/post/design-search-autocomplete-system/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/design-search-autocomplete-system/">https://leetcode.cn/problems/design-search-autocomplete-system/</a></strong></p><p><strong>題意</strong>：為搜尋引擎設計一個自動補全系統, 用戶會輸入一個句子(最少包含一個 char, 並以 <code>&#39;#&#39;</code> 結尾)。</p><p>給一 string list <code>sentence</code> 和一整數 <code>times</code>, 長度皆為 <code>n</code>, 其中 <code>sentence[i]</code> 為之前輸入的句子, 而 <code>times[i]</code> 為該句子輸入的相應次數。對於 <code>&#39;#&#39;</code> 以外的每個輸入 char, 返回前 <code>3</code> 個熱門句子, 這些句子的 prefix 和已經輸入的句子的部分相同。</p><p><strong>以下是詳細規則：</strong></p><ul><li>一個句子的熱度定義為歷史上用戶輸入該句子的總次數。</li><li>返回前 <code>3</code> 個熱門句子需依照熱度由高到低排序。若有多條熱度相同的句子, 則按照 ASCII 碼的順序輸出(ASCII 碼越小越前面)。</li><li>如果滿足條件的句子個數 &lt; 3, 則將它們全部輸出。</li><li>如果輸入特殊 char <code>&#39;#&#39;</code>, 則代表句子結束了, 請返回 empty list <code>[]</code>。</li></ul><p><strong>實現 <code>AutocompleteSystem</code> class：</strong></p><ul><li><code>AutocompleteSystem(String[] sentences, int[] times)</code>：使用 <code>sentence</code> 和 <code>times</code> 進行初始化。</li><li><code>List&lt;String&gt; input(char c)</code> : 代表用戶輸入了 char <code>c</code><ul><li>如果 <code>c == &#39;#&#39;</code>, 則返回 empty list <code>[]</code>。</li><li>返回前 <code>3</code> 個熱門句子, 這些句子的 prefix 和已經輸入的句子的部分相同。如果滿足條件的句子個數 &lt; 3, 則將它們全部輸出。</li></ul></li></ul><p>char <code>c</code> 要麼為<strong>小寫</strong>字母, 要麼為 <code>&#39; &#39;</code> 或 <code>&#39;#&#39;</code>。</p></blockquote><p><img src="https://i.imgur.com/zJdt10s.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Trie + hash table + DFS, 其中 hash table 用來記錄所有滿足以 <code>prefix</code> 為開頭的所有句子、以及對應的次數, 而 <code>res</code> 負責儲存滿足以 prefix 為開頭的所有句子, 然後 <code>res</code> 會根據 hash table 中紀錄的次數和 ASCII 碼進行排序, 然後輸出前 3 高的句子</strong></p><ul><li><p><strong>值得注意的是使用者輸入的句子也要 insert 到 trie 中</strong></p><p>  e.g. <code>[&#39;i&#39;, &#39; &#39;, &#39;a&#39;, &#39;#&#39;, &#39;a&#39;, &#39;#&#39;]</code>, 當搜尋完 <code>i a</code> 的句子後, 要把使用者輸入的 <code>&#39;i a&#39;</code> 也 insert 到 trie 中。同理 <code>a</code> 也是</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">27</span>] = &#123;<span class="literal">nullptr</span>&#125;; <span class="comment">// 多一個紀錄 &#x27; &#x27;</span></span><br><span class="line">    <span class="type">int</span> times = <span class="number">0</span>; <span class="comment">// end node 紀錄該句子的次數</span></span><br><span class="line">    string sentence; <span class="comment">// end node 紀錄整個句子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; sentence, <span class="type">const</span> <span class="type">int</span> times)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : sentence) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = (ch == <span class="string">&#x27; &#x27;</span>) ? <span class="number">26</span> : ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                node-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;times += times; <span class="comment">// end node 紀錄 times</span></span><br><span class="line">        node-&gt;sentence = sentence; <span class="comment">// end node 紀錄整個句子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getHotSentences</span><span class="params">(<span class="type">const</span> string&amp; prefix)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; times; <span class="comment">// 紀錄滿足以 prefix 開頭的所有句子之次數</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// node =  prefix 的 end node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : prefix) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = (ch == <span class="string">&#x27; &#x27;</span>) ? <span class="number">26</span> : ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 node 為 root 做 dfs, 找到以 prefix 為開頭的所有 sentence</span></span><br><span class="line">        <span class="built_in">dfs</span>(node, res, times);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有 sentences 根據 times 和 ASCII 碼做排序</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), [&amp;times](<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (times[s1] != times[s2]) &#123;</span><br><span class="line">                <span class="keyword">return</span> times[s1] &gt; times[s2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s1 &lt; s2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 res.size() &lt; 3, 則直接返回 res; 否則, 返回 res 前三個</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出所有符合 prefix 的 sentence</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> TrieNode* node, vector&lt;string&gt;&amp; res, unordered_map&lt;string, <span class="type">int</span>&gt;&amp; times)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 句子結尾, 在 hash table 中記錄, 等等 sorting 會用到</span></span><br><span class="line">        <span class="comment">// 找到不直接 return, 而是要繼續往下嘗試</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;times != <span class="number">0</span>) &#123;</span><br><span class="line">            times[node-&gt;sentence] = node-&gt;times;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(node-&gt;sentence);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 繼續往下嘗試</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(node-&gt;children[i], res, times);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutocompleteSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AutocompleteSystem</span>(vector&lt;string&gt;&amp; sentences, vector&lt;<span class="type">int</span>&gt;&amp; times) &#123;</span><br><span class="line">        <span class="comment">// 把所有的 sentence insert 到 trie 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sentences.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(sentences[i], times[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">input</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(prefix, <span class="number">1</span>); <span class="comment">// 把 &#x27;#&#x27; 之前輸入的句子 insert 到 trie 中</span></span><br><span class="line">            prefix.<span class="built_in">clear</span>(); <span class="comment">// 清空當前句子</span></span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prefix.<span class="built_in">push_back</span>(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> trie.<span class="built_in">getHotSentences</span>(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line">    string prefix;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>AutocompleteSystem()</code>：$O(n \cdot m)$, 其中 <code>n</code> 為句子的個數, <code>m</code> 為句子的平均長度</li><li><code>input()</code>：$O(s + p + k \cdot log(k))$, 其中 <code>s</code> 為當前已輸入的句子, <code>p</code> 為 <code>trie</code> 中搜尋的 node 數, $O(k \cdot log(k))$ 為對長度為 <code>k</code> 的 list 做 sorting</li></ul></li><li><strong>space：</strong>$O(n \cdot m)$ ➔ <code>trie</code>, 其中 <code>n</code> 為句子的個數, <code>m</code> 為句子的平均長度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>425. Word Squares</title>
      <link href="/post/word-squares/"/>
      <url>/post/word-squares/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/word-squares/">https://leetcode.cn/problems/word-squares/</a></strong></p><p><strong>題意</strong>：給一不重複的 string set <code>words</code>, 返回其中所有的 <strong>word square</strong>。<code>words</code> 中的同一個單字可以被<strong>多次</strong>使用, 以任意順序返回答案。</p><p><strong>word square</strong> 的定義：從第 <code>k</code> 列和第 <code>k</code> 行來看都是相同的 string, 其中 <code>0 ≤ k ≤ max(numRows, numColumns)</code>。</p><p>e.g. <code>words = [&quot;ball&quot;,&quot;area&quot;,&quot;lead&quot;,&quot;lady&quot;]</code> 為 word square, 因為每個單字從水平和垂直方向上來看都是相同的。</p><p><img src="https://i.imgur.com/ghi0aT5.png"></p></blockquote><p><img src="https://i.imgur.com/H8K1jIU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Trie + DFS + Backtracking, 逐列填入單字, 新的一列填入的單字可由前面的單字得到, 其中第 <code>idx</code> 列的單字之 prefix 可由前面每個單字的第 <code>idx + 1</code> 個字母所串連</strong></p><p>e.g. <code>words = [&quot;wall&quot;,&quot;able&quot;,&quot;area&quot;,&quot;lead&quot;,&quot;lady&quot;]</code></p><ul><li><p>從 <code>wall</code> 開始, 作為第一列的單字</p></li><li><p>根據 word square 的對稱性, 我們知道第二列的單字應以 <code>a</code> 為 prefix 開頭(因為第一列第二行的字母為 <code>a</code>)</p><p>  <img src="https://i.imgur.com/G0SPA39.png"></p></li><li><p>在 <code>words</code> 中, 有兩個 prefix 為 <code>a</code> 的單字(即 <code>able</code>, <code>area</code>)。因此下一步我們要對兩個單字依次進行嘗試</p></li><li><p>選擇 <code>able</code> 作為第二列的單字。根據對稱性, 我們知道第三列的元素應以 <code>ll</code> 作為開頭。但是, <code>words</code> 中並沒有這樣的單字, 因此我們要放棄此次的嘗試, 並回到上一個狀態(第一列已填入)</p><p>  <img src="https://i.imgur.com/kZLwYYN.png"></p></li><li><p>選擇 <code>area</code> 作為第二列的單字。根據對稱性, 我們知道第三列的元素應以 <code>le</code> 作為開頭。這次我們可以在 <code>words</code> 找到符合的單字, 即 <code>lead</code></p><p>  <img src="https://i.imgur.com/KaB34gF.png"></p></li><li><p>選擇 <code>lead</code> 作為第三列的單字。根據對稱性, 我們知道第四列的元素應以 <code>lad</code> 作為開頭, 我們可以在 <code>words</code> 找到符合的單字, 即 <code>lady</code></p><p>  <img src="https://i.imgur.com/rySwTPe.png"></p></li><li><p>得到 <code>[&quot;ball&quot;,&quot;area&quot;,&quot;lead&quot;,&quot;lady&quot;]</code> 一組解</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">-1</span>; <span class="comment">// end node 紀錄該 word 在 words 中的 idx</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word, <span class="type">int</span>&amp; idx)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                node-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;idx = idx; <span class="comment">// end node 之 idx 為非 -1 之值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 prefix 的 end node</span></span><br><span class="line">    <span class="function">TrieNode* <span class="title">search</span><span class="params">(<span class="type">const</span> string&amp; prefix)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : prefix) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得以 node 為 root 的 subtree 中所有的 word(也就是以 prefix 為開頭的所有 word)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">const</span> TrieNode* node, vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; prefixWords)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遇到 end node of a word, 則加入到 prefixWords 中, 並繼續往下遍歷</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;idx != <span class="number">-1</span>) &#123;</span><br><span class="line">            prefixWords.<span class="built_in">emplace_back</span>(words[node-&gt;idx]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往下遍歷</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">get</span>(node-&gt;children[i], words, prefixWords);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">wordSquares</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        n = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build trie</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(words[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍歷每個單字為第0列的情況</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">0</span>, words);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    Trie trie;</span><br><span class="line">    vector&lt;string&gt; cur; <span class="comment">// 當前 word square 填入的情況</span></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表第 idx 列已被填入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> idx, vector&lt;string&gt;&amp; words)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 代表第 0 ~ (n - 1) 列都可以填入, 找到一組解</span></span><br><span class="line">        <span class="keyword">if</span> (idx == n - <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到下一列應填入單字的 prefix</span></span><br><span class="line">        string prefix;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; ++i) &#123;</span><br><span class="line">            prefix.<span class="built_in">push_back</span>(cur[i][idx + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到 prefix 之 end node(也就是所有以 prefix 開頭的 word 之 root)</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> node = trie.<span class="built_in">search</span>(prefix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到所有以 prefix 開頭的 word</span></span><br><span class="line">        vector&lt;string&gt; prefixWords;</span><br><span class="line">        trie.<span class="built_in">get</span>(node, words, prefixWords);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在下一列嘗試所有符合的 word</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : prefixWords) &#123;</span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">            <span class="built_in">dfs</span>(idx + <span class="number">1</span>, words);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot L + n \cdot 26 ^ L)$ ➔ <code>n</code> 是 <code>words</code> 中單字的個數, <code>L</code> 是單字的平均長度<ul><li>$O(n \cdot L)$：build trie</li><li>$O(n \cdot 26 ^ L)$：<code>dfs(0, words[i])</code> 以 <code>words[i]</code> 做第一列的單字嘗試所有的可能需花 $(26^L)$, 因為 trie 中每個 node 有 <code>26</code> 個分支, 所以 trie 中最多有 $O(26^L)$ 個 node 要嘗試。總共有 $n$ 個 <code>words[i]</code> 要嘗試作為第一列的單字。</li></ul></li><li><strong>space：</strong>$O(n \cdot L)$ ➔ <code>trie</code>, worse case：<code>trie</code> 中的單字都沒有重複的 prefix</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1203. Sort Items by Groups Respecting Dependencies</title>
      <link href="/post/sort-items-by-groups-respecting-dependencies/"/>
      <url>/post/sort-items-by-groups-respecting-dependencies/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/">https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/</a></strong></p><p><strong>題意</strong>：有 <code>n</code> 個 item, 其中每個 item 可以不屬於任何 group, 或者屬於 <code>m</code> 個 group 中的其中一個。<code>group[i]</code> 代表第 <code>i</code> 個 item 所屬的 group, 如果第 <code>i</code> 個 item <strong>不屬於</strong>任何 group, 則 <code>group[i] = -1</code>。item 和 <code>group</code> 都從 0 開始編號的。可能存在 group 不負責任何 item。</p><p>返回 sorted list 滿足:</p><ul><li>同一 group 的 item 排序後應彼此相鄰</li><li>item 之間存在一定的依賴關係 <code>beforeItems</code>, 其中 <code>beforeItems[i]</code> 代表進行第 <code>i</code> 個 item 前應完成的所有 item</li></ul><p>如果存在多個解, 返回其中一個即可。若沒有解, 則返回 empty list。</p><p><strong>注意</strong>：<code>beforeItems[i]</code> 沒有重複的元素。</p></blockquote><p><img src="https://i.imgur.com/E07VViA.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + BFS, 首先我們需要找出同一 group 內的 item 順序, 然後再找出不同 group 之間的順序, 最後遍歷 group 順序和 group 內的 item 順序即可。需要注意的是, <code>group[i] == -1</code> 的 items 並不屬於同一個 group, 不必滿足相鄰條件, 因此我們要對那些 <code>group[i] == -1</code> 的 items 重新編號, 讓他們每個都擁有一個屬於自己的 group id</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortItems</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; group, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; beforeItems)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 對 group 進行前處理 : 賦予 groupId == -1 的 item 一個屬於自己的 new group id</span></span><br><span class="line">        <span class="type">int</span> newGroupId = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (group[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                group[i] = newGroupId++;</span><br><span class="line">            &#125;</span><br><span class="line">            groupItems[group[i]].<span class="built_in">emplace</span>(i); <span class="comment">// 紀錄每個 group 所擁有的 item</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立同一個 group 內的 graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// j -&gt; i (j 指向 i)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>&amp; j : beforeItems[i]) &#123;</span><br><span class="line">                <span class="comment">// 不同 group 跳過</span></span><br><span class="line">                <span class="keyword">if</span> (group[i] != group[j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 題目保證 beforeItems[i] 沒有重複元素</span></span><br><span class="line">                adj[j].<span class="built_in">emplace</span>(i);</span><br><span class="line">                ++inDegree[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 對同一 group 內的 item 進行 sorting</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; groupItemOrder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [groupId, items] : groupItems) &#123;</span><br><span class="line">            groupItemOrder[groupId] = <span class="built_in">topologySort</span>(items);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// group 內的 item 順序無解</span></span><br><span class="line">            <span class="keyword">if</span> (groupItemOrder[groupId].<span class="built_in">size</span>() != items.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立不同 group 之間的 graph</span></span><br><span class="line">        adj.<span class="built_in">clear</span>();</span><br><span class="line">        inDegree.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// group[j] -&gt; group[i] (group[j] 指向 group[i])</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; j : beforeItems[i]) &#123;</span><br><span class="line">                <span class="comment">// 同一 group 跳過</span></span><br><span class="line">                <span class="keyword">if</span> (group[i] == group[j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// group 之間有可能會有重複</span></span><br><span class="line">                <span class="comment">// e.g. 同一 group 內的 node 同時指向另外一個 group 的 node</span></span><br><span class="line">                <span class="keyword">if</span> (adj[group[j]].<span class="built_in">find</span>(group[i]) == adj[group[j]].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    adj[group[j]].<span class="built_in">emplace</span>(group[i]);</span><br><span class="line">                    ++inDegree[group[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到所有 group</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; groups;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            groups.<span class="built_in">emplace</span>(group[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 對不同 group 進行排序</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; groupOrder = <span class="built_in">topologySort</span>(groups);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; groupId : groupOrder) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : groupItemOrder[groupId]) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; inDegree;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; adj; <span class="comment">// adjacency list</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; groupItems; <span class="comment">// 紀錄每個 group 所有的 item</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topologySort</span><span class="params">(unordered_set&lt;<span class="type">int</span>&gt;&amp; nodes)</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; node : nodes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[node] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// size 不同代表有 cycle, 無解</span></span><br><span class="line">        <span class="keyword">return</span> (res.<span class="built_in">size</span>() != nodes.<span class="built_in">size</span>()) ? <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;() : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n^2 + E_{group} + E_{item})$ ➔ $E_{group}$、$E_{item}$ 代表 <code>group</code>、<code>item</code> 在 graph 中的 edge<ul><li>$O(m)$：對 <code>group</code> 進行前處理</li><li>$O(n)$ ：建立 <code>item</code> 的 <code>inDegree</code></li><li>$O(n^2)$：建構 <code>item</code> 的 adjacency list。worse case：第 <code>1</code> 個頂點指向所有剩餘 <code>n − 1</code> 個頂點，第 <code>2</code> 個頂點指向所有剩餘 <code>n - 2</code> 個頂點, 依此類推…</li><li>$O(n + E_{item})$：$O(V + E)$, 對 <code>item</code> 進行 topological sort</li><li>$O(m)$：建構 <code>group</code> 的 adjacency list、建立 <code>group</code> 的 <code>inDegree</code></li><li>$O(m + E_{group})$：$O(V + E)$, 對 <code>group</code> 進行 topological sort</li><li>$O(m + n)$：得到 <code>res</code></li></ul></li><li><strong>space：</strong>$O(m + n^2)$<ul><li>$O(m)$：<code>group</code> 的 adjacency lis</li><li>$O(n^2)$：<code>item</code> 的 adjacency list</li><li>$O(m)$：<code>group</code> 的 <code>inDegree</code></li><li>$O(n)$：<code>item</code> 的 <code>inDegree</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>278. First Bad Version</title>
      <link href="/post/first-bad-version/"/>
      <url>/post/first-bad-version/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/first-bad-version/">https://leetcode.cn/problems/first-bad-version/</a></strong></p><p><strong>題意</strong>：假設你有 <code>n</code> 個版本 <code>[1, 2, ..., n]</code>, 請找出導致之後所有版本出錯的第一個錯誤的版本。</p><p>你可以通過調用 <code>bool isBadVersion(version)</code> API 來判斷 <code>version</code> 是否出錯。</p><p>盡量減少調用 API 的次數。</p></blockquote><p><img src="https://i.imgur.com/C5erJBr.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69. Sqrt(x)</title>
      <link href="/post/sqrtx/"/>
      <url>/post/sqrtx/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sqrtx/">https://leetcode.cn/problems/sqrtx/</a></strong></p><p><strong>題意</strong>：給一非負整數 <code>x</code>, 計算並返回 <code>x</code> 的平方根 。</p><p>由於返回類型是整數, 因此答案只保留<strong>整數部分</strong>, 小數部分將被<strong>捨棄</strong>。</p><p><strong>注意</strong>：禁止使用 <code>pow(x, 0.5)</code> or <code>x ** 0.5</code> 運算。</p></blockquote><p><img src="https://i.imgur.com/33duEZL.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 左閉右開容易導致 overflow。當 <code>x = INT_MAX</code> 時, <code>x + 1</code> 會 overflow, 故要先將 <code>x</code> 轉成 long</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// mid 轉成 long, 避免 mid * mid 出現 overflow</span></span><br><span class="line">            <span class="type">const</span> <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mid * mid &gt; <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(x)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// left 的平方 &gt; mid, 所以 left - 1 的平方 ≤ mid</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(x))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. Intersection of Two Linked Lists</title>
      <link href="/post/intersection-of-two-linked-lists/"/>
      <url>/post/intersection-of-two-linked-lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></strong></p><p><strong>題意</strong>：給兩個 linked list 的 head <code>headA</code> 和 <code>headB</code>, 返回兩個 linked list 相交的起始點。若不存在相交, 則返回 <code>null</code>。</p><p>題目保證 linked list 中不存在 cycle。</p><p><strong>注意</strong>：函數返回後, linked list 必須保持原先的結構。</p><p><strong>進階</strong>：設計 $O(m + n)$ time 且 $O(1)$ space 的演算法。</p></blockquote><p><img src="https://i.imgur.com/kDo6Xjx.png"></p><p><img src="https://i.imgur.com/88exZqc.png"></p><p><img src="https://i.imgur.com/0BB1vrF.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash set, 先將 <code>headA</code> 中的每個點 insert 到 <code>visited</code> 中, 然後再遍歷 <code>headB</code> 中的每個點, 一旦發現 <code>visited</code> 已存在, 則返回該點。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; visited;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = headA;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            visited.<span class="built_in">emplace</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = headB;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(cur) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 遍歷兩個 linked list, <code>m</code> 為 <code>headA</code> 的長度, <code>n</code> 為 <code>headB</code> 的長度</li><li><strong>space：</strong>$O(m)$ ➔ <code>visited</code> 儲存 <code>headA</code> 中的所有 node</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers, 先計算兩條 linked list 的長度, 先讓長度較長者走 <code>abs(lenA - lenB)</code> 步, 然後再和長度較短者同時前進, 這樣兩者就能在相交起點相遇。若兩者不存在相交, 則最後兩者會同時為 <code>null</code></strong></p><ul><li><p><strong>相交</strong></p><p>  <img src="https://i.imgur.com/F6YKm8j.png"></p></li><li><p><strong>不相交</strong></p><p>  <img src="https://i.imgur.com/HOoefhB.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> lenA = <span class="built_in">getLen</span>(headA);</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> lenB = <span class="built_in">getLen</span>(headB);</span><br><span class="line">        ListNode *longer, *shorter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lenA &gt;= lenB) &#123;</span><br><span class="line">            longer = headA;</span><br><span class="line">            shorter = headB;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            longer = headB;</span><br><span class="line">            shorter = headA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>(lenA - lenB); ++i) &#123;</span><br><span class="line">            longer = longer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (longer != shorter) &#123;</span><br><span class="line">            longer = longer-&gt;next;</span><br><span class="line">            shorter = shorter-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLen</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 遍歷兩個 linked list, <code>m</code> 為 <code>headA</code> 的長度, <code>n</code> 為 <code>headB</code> 的長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：Two Pointers, 令 <code>headA</code> 的長度為 <code>m</code>, <code>headB</code> 的長度為 <code>n</code></strong></p><p>假設兩個 linked list 相交的部分有 <code>c</code> 個 node, 則 <code>headA</code> 中不相交的部分有 <code>m - c</code> 個 node, <code>headB</code> 中不相交的部分有 <code>n - c</code> 個 node</p><p>若要 <code>l1</code>、<code>l2</code> 同時在相交的起始點 <code>node</code> 相遇, 則要做以下操作 :</p><ul><li><p><code>l1</code> 遍歷完 <code>headA</code> 後, 接著遍歷 <code>headB</code>, 當走到 <code>node</code> 時 ➔ <code>l1</code> 走了 <code>m + (n - c)</code> 步</p></li><li><p><code>l2</code> 遍歷完 <code>headB</code> 後, 接著遍歷 <code>headA</code>, 當走到 <code>node</code> 時 ➔ <code>l2</code> 走了 <code>n + (n - c)</code> 步</p></li><li><p>此時 <code>l1</code>、 <code>l2</code> 在 <code>node</code> 相遇, 因為 <code>m + (n - c) = n + (m - c)</code></p></li><li><p>若 <code>c == 0</code>, 也就是兩個 linked list 不相交, 則 <code>l1</code>、<code>l2</code> 將同時變為 <code>null</code></p><p>  <img src="https://i.imgur.com/Z1UU4jY.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *l1 = headA, *l2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">            l1 = (l1 == <span class="literal">nullptr</span>) ? headB : l1-&gt;next;</span><br><span class="line">            l2 = (l2 == <span class="literal">nullptr</span>) ? headA : l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 遍歷兩個 linked list, <code>m</code> 為 <code>headA</code> 的長度, <code>n</code> 為 <code>headB</code> 的長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27. Remove Element</title>
      <link href="/post/remove-element/"/>
      <url>/post/remove-element/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>nums</code> 和一整數 <code>val</code>，請 <strong>in-place</strong> 移除所有數值等於 <code>val</code> 的元素, 並返回移除後 <code>nums</code> 的新長度。</p><p>不要使用額外的空間, 設計 $O(1)$ space 的演算法, 並原地修改 <code>nums</code>。</p><p>元素的順序可以改變, 不需要考慮 <code>nums</code> 中超出新長度後面的元素。</p></blockquote><p><img src="https://i.imgur.com/p04ZaQw.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers, 先初始化 <code>slow = fast = 0</code>, 用 <code>fast</code> 來遍歷 <code>nums</code>, 而 <code>slow</code> 用來指向新 array 下一個要填入的元素的 index。一旦 <code>nums[fast] != val</code>, 則 <code>nums[slow] = nums[fast]</code>, 然後 <code>slow += 1</code></strong></p><p>e.g. <code>nums = [3, 2, 2, 3]</code>, <code>val = 3</code></p><ul><li><code>slow = 0</code>, <code>fast = 0</code>, 此時 <code>nums[fast] = 3 = val</code> 跳過</li><li><code>slow = 0</code>, <code>fast = 1</code>, 此時 <code>nums[fast] = 2</code>, <code>nums[slow] = 2</code> ➔ <code>slow = 1</code></li><li><code>slow = 1</code>, <code>fast = 2</code>, 此時 <code>nums[fast] = 2</code>, <code>nums[slow] = 2</code> ➔ <code>slow = 2</code></li><li><code>slow = 2</code>, <code>fast = 3</code>, 此時 <code>nums[fast] = 3 = val</code> 跳過</li><li>做完後 <code>nums = [2, 2, 2, 3]</code>, <code>slow = 2</code> ➔ <code>slow</code> 記錄著新 array 的元素個數, 故新 array 實際上 &#x3D; <code>[2, 2]</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; n; ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] == val) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1049. Last Stone Weight II</title>
      <link href="/post/last-stone-weight-ii/"/>
      <url>/post/last-stone-weight-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/last-stone-weight-ii/">https://leetcode.cn/problems/last-stone-weight-ii/</a></strong></p><p><strong>題意</strong>：有一堆石頭, 用整數 array <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 塊石頭的重量。</p><p>每一回合, 從中選出任意兩塊石頭, 然後將它們一起粉碎。假設石頭的重量分別為 <code>x</code> 和 <code>y</code>, 且 <code>x ≤ y</code>。粉碎的可能結果如下：</p><ul><li>若 <code>x == y</code>, 則兩塊石頭都會被完全粉碎</li><li>若 <code>x != y</code>, 則重量為 <code>x</code> 的石頭將會完全粉碎, 而重量為 <code>y</code> 的石頭新重量為 <code>y - x</code></li></ul><p>最後, 最多只會剩下一塊石頭。返回此石頭最小的可能重量, 如果沒有石頭剩下, 則返回 <code>0</code>。</p></blockquote><p><img src="https://i.imgur.com/B9pMfKy.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：假設 <code>stones = [a, b, c, d]</code>, 每次取出兩顆來粉碎, 可以想成每次取出兩數, 然後在這兩數前面分別加上 <code>+/-</code> 號, e.g. 其中一種可能的解為 <code>a - b + c - d</code>（類似 <a href="https://zako945.github.io/post/target-sum/">494. Target Sum</a>）。因此, 利用 hash set <code>s</code> 保存前 <code>i - 1</code> 個石頭所產生的和, 然後一一取出這些和, 並加上第 <code>i</code> 個數分別取 <code>+/-</code> 號之值</strong></p><p><code>e.g. stones = [1, 2]</code></p><ul><li>初始值：<code>s = &#123;0&#125;</code></li><li>第一輪：<code>s = &#123;0 + 1, 0 - 1&#125; = &#123;1, - 1&#125;</code></li><li>第二輪：<code>s = &#123;1 + 2, 1 - 2, -1 + 2, -1 - 2&#125; = &#123;-3, -1, 1, -3&#125;</code></li></ul><p>➔ <code>≥ 0</code> 的最小值為 <code>1 = +2 - 1</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(&#123;<span class="number">0</span>&#125;)</span></span>; <span class="comment">// 初始為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; cur : stones) &#123;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; prevSet = s;</span><br><span class="line">            s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; prevSum : prevSet) &#123;</span><br><span class="line">                s.<span class="built_in">emplace</span>(prevSum + cur);</span><br><span class="line">                s.<span class="built_in">emplace</span>(prevSum - cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出 ≥ 0 的最小和</span></span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; sum : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">0</span> &amp;&amp; sum &lt; res) &#123;</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(\sum\limits_{i &#x3D; 1}^n{(i \cdot 2^{i})})$ ➔ for loop, 當到第 <code>i</code> 顆石頭時, <code>s</code> 中最多有 $2^i$ 個數（每個石頭有兩種選擇）, 其中 <code>n</code> 為 <code>stones</code> 的長度</li><li><strong>space：</strong>$O(2^n)$ ➔ <code>s</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li><code>dp[i][j]</code>：<code>stones[1:i]</code> 是否能湊出 <code>j</code></li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>dp[i][j] = dp[i - 1][j - stones[i]] || dp[i - 1][j + stones[i]]</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li>首先, 會在 <code>stones</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[0][0] = 1</code>：代表沒有元素時, 什麼都不取可以湊出 <code>0</code></li></ul><p><strong>4. 注意事項：</strong></p><ul><li>本題 <code>dp[i][j]</code> 的 <code>j</code> 之範圍為 <code>[-sum, sum]</code>, 但 index 不允許<strong>負數</strong>, 因此統一加上 <code>offset = sum</code>, 將其 mapping 到範圍 <code>[0, 2 * abs(sum)]</code></li><li>最後取的答案是 <code>≥ 0</code> 的正整數, 因此是從 <code>0</code> 開始算, 而非 <code>sum</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(<span class="number">2</span> * <span class="built_in">abs</span>(sum) + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        stones.<span class="built_in">emplace</span>(stones.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> offset = sum; <span class="comment">// sum 必為正整數</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span> + offset] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = -sum; j &lt;= sum; ++j) &#123;</span><br><span class="line">                <span class="comment">// 避免越界</span></span><br><span class="line">                <span class="keyword">if</span> (j - stones[i] &gt;= -sum &amp;&amp; j - stones[i] &lt;= sum) &#123;</span><br><span class="line">                    dp[i][j + offset] = dp[i][j + offset] || dp[i - <span class="number">1</span>][j - stones[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j + stones[i] &gt;= -sum &amp;&amp; j + stones[i] &lt;= sum) &#123;</span><br><span class="line">                    dp[i][j + offset] = dp[i][j + offset] || dp[i - <span class="number">1</span>][j + stones[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只考慮 ≥ 0 之和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sum; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[n][i + offset]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(sum \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(sum \cdot n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 DP, Solution 2 的改進, 實際上 <code>dp[i][j + offset]</code> 只會用到上一列 <code>dp[i - 1][X]</code>, 故不需要開到 $O(sum \cdot n)$ 的空間, 只需 $O(sum)$ 的空間即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span> * abs(sum) + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        stones.<span class="built_in">emplace</span>(stones.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> offset = sum; <span class="comment">// sum 必為正整數</span></span><br><span class="line">        dp[<span class="number">0</span> + offset] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">nextRow</span><span class="params">(<span class="number">2</span> * sum + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = -sum; j &lt;= sum; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - stones[i] &gt;= -sum &amp;&amp; j - stones[i] &lt;= sum) &#123;</span><br><span class="line">                    nextRow[j + offset] = nextRow[j + offset] || dp[j - stones[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j + stones[i] &gt;= -sum &amp;&amp; j + stones[i] &lt;= sum) &#123;</span><br><span class="line">                    nextRow[j + offset] = nextRow[j + offset] || dp[j + stones[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sum; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i + offset]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(sum \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(sum)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>409. Longest Palindrome</title>
      <link href="/post/longest-palindrome/"/>
      <url>/post/longest-palindrome/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-palindrome/">https://leetcode.cn/problems/longest-palindrome/</a></strong></p><p><strong>題意</strong>：給一只由大、小寫字母所組成的 string <code>s</code>, 返回這些字母所能組成的最長迴文 string 之長度。</p><p>須區分大、小寫, 比如 <code>&quot;Aa&quot;</code> 不能當作一個迴文 string。</p></blockquote><p><img src="https://i.imgur.com/XKmA4nt.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy。在一個迴文 string 中, 最多只有一個 char 能出現奇數次, 其餘的 char 皆須出現偶數次。我們可以將每個 char 使用偶數次, 使得它們根據迴文中心對稱。在這之後, 如果有剩餘的 char，我們可以再從中取出一個, 作為迴文中心。</strong></p><p><img src="https://i.imgur.com/rnBBx3y.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freqs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freqs[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ch, freq] : freqs) &#123;</span><br><span class="line">            res += freq / <span class="number">2</span> * <span class="number">2</span>; <span class="comment">// 取出該 char 偶數的長度</span></span><br><span class="line">            <span class="keyword">if</span> (freq &amp; <span class="number">1</span>) &#123; <span class="comment">// 如果該 char 為奇數, 則把 odd 標記為 1</span></span><br><span class="line">                odd = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res += odd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>freqs</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>47. Permutations II</title>
      <link href="/post/permutations-ii/"/>
      <url>/post/permutations-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></strong></p><p><strong>題意：</strong>給一含重複數的 array <code>nums</code>, 按<strong>任意順序</strong>返回所有不重複的排列。</p></blockquote><p><img src="https://i.imgur.com/mrbT2DO.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：類似 <a href="https://zako945.github.io/post/permutations/">46. Permutations</a>, 只是要排除掉相同數當頭<br>e.g. [1, 1, 2]</strong></p><ul><li>1 當頭 : [1, <strong>1</strong>, 2], [1, 2, <strong>1</strong>]</li><li><strong>1</strong> 當頭 : [<strong>1</strong>, 1, 2], [1, <strong>1</strong>, 2]<br>➔ 重複排列, 故要記住哪些數當過開頭, 若後面遇到做過開頭的數則不做 swap, 直接跳過</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(nums[j]) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 避免重複排列</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s.<span class="built_in">emplace</span>(nums[j]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n);</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot n!)$ ➔ 總共 $n!$ 種排列, 每一種要 $O(n)$</li><li><strong>space：</strong>$O(n \cdot n!)$ ➔ $O(n) + O(n \cdot n!)$<ul><li>$O(n)$：<code>dfs()</code> 遞迴最大深度</li><li>$O(n \cdot n!)$：最多 $n!$ 種排列, 每種排列的長度都為 <code>n</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>77. Combinations</title>
      <link href="/post/combinations/"/>
      <url>/post/combinations/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></strong></p><p><strong>題意：</strong>給兩個整數 <code>n</code> 和 <code>k</code>, 以<strong>任意順序</strong>返回 <code>[1, n]</code> 中所有可能的 <code>k</code> 個數<strong>組合</strong>。</p></blockquote><p><img src="https://i.imgur.com/YrPe1tx.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：取每個 <code>i</code> 輪流當開頭, 其中 <code>i</code> 的範圍是 <code>[1, n]</code>, 並從 <code>[i + 1, n]</code> 取 <code>k - 1</code> 個（從 <code>i + 1</code> 取必不會重複到前面）。<code>dfs()</code> 中的 for loop 是取 <code>j + 1</code>, 因為若取 <code>i + 1</code>, 則當 <code>j &gt; i + 1</code> 後, 便會取到重複的組合。</strong><br>e.g. <code>n = 3, k = 2</code>,  其中 <code>[1, 2]</code>, <code>[2, 1]</code> 不能同時出現</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++j) &#123;</span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">            <span class="built_in">dfs</span>(j + <span class="number">1</span>, n, k - <span class="number">1</span>);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot \binom{n}{k})$ ➔ $\binom{n}{k}$ 種組合, 每種組合需 $O(k)$ time</li><li><strong>space：</strong>$O(k \cdot \binom{n}{k})$ ➔ $O(k) + O(k \cdot \binom{n}{k}) + O(k)$<ul><li>$O(k)$：<code>dfs()</code> 最大遞迴深度</li><li>$O(k \cdot \binom{n}{k})$：$\binom{n}{k}$ 種組合, 每種組合長度為 <code>k</code></li><li>$O(k)$：<code>cur</code> 最大長度</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>216. Combination Sum III</title>
      <link href="/post/combination-sum-iii/"/>
      <url>/post/combination-sum-iii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a></strong></p><p><strong>題意：</strong>找出所有相加之和為 <code>n</code> 的 <code>k</code> 個數的組合，且滿足下列條件：</p><ul><li>只使用數字 <code>1</code> 到 <code>9</code></li><li>每个數字<strong>最多使用一次</strong></li></ul><p>以<strong>任意順序</strong>返回所有可能的組合, 組合不能重複。</p></blockquote><p><img src="https://i.imgur.com/mF7XnYg.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> k, <span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; n) &#123; <span class="comment">// 剪枝</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取 j</span></span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">            <span class="built_in">dfs</span>(k - <span class="number">1</span>, n - j, j + <span class="number">1</span>);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot \binom{M}{k})$ ➔ 其中 <code>M</code> 為集合的大小，本題中 <code>M</code> 固定為 <code>9</code><ul><li>共 $\binom{M}{k}$ 種組合, 每建一種需判斷 <code>k</code> 次</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ $O(k) + O(k)$<ul><li>$O(k)$：<code>cur</code> 最大長度為 <code>k</code></li><li>$O(k)$：遞迴最大深度為 <code>k</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>320. Generalized Abbreviation</title>
      <link href="/post/generalized-abbreviation/"/>
      <url>/post/generalized-abbreviation/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/generalized-abbreviation/">https://leetcode.cn/problems/generalized-abbreviation/</a></strong></p><p><strong>題意：</strong>寫一函式來生成一個單字的通用縮寫, 以<strong>任意順序</strong>返回。</p></blockquote><p><img src="https://i.imgur.com/jvA4EsG.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：每個 char 都有「取縮寫 or 不取縮寫」兩種選擇, 其中用 <code>num</code> 代表在 <code>word[i]</code> 前面取縮寫的連續 char 數</strong></p><ul><li><strong>取縮寫</strong>：<code>i + 1</code>, 且 <code>num + 1</code>, 並進入下一輪遞迴</li><li><strong>不取縮寫</strong>：<ul><li>若 <code>num != 0</code>：<ul><li>將 <code>num</code> 加入到 <code>cur</code> 中, 並將 <code>num</code> 歸零</li><li>將 <code>word[i]</code> 加入到 <code>cur</code> 中, 並進入下一輪遞迴</li></ul></li><li>若 <code>num == 0</code>：<ul><li>將 <code>num</code> 歸零</li><li>將 <code>word[i]</code> 加入到 <code>cur</code> 中, 並進入下一輪遞迴</li></ul></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateAbbreviations</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        string cur;</span><br><span class="line">        <span class="built_in">dfs</span>(word, <span class="number">0</span>, word.<span class="built_in">size</span>(), cur, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; word, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n, string cur, <span class="type">const</span> <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                cur += <span class="built_in">to_string</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// word[i] 取縮寫</span></span><br><span class="line">        <span class="built_in">dfs</span>(word, i + <span class="number">1</span>, n, cur, num + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// word[i] 不取縮寫（共通點：word[i] 加入到 cur 中, 故將 word[i] 提出）</span></span><br><span class="line">        cur += (num == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : <span class="built_in">to_string</span>(num)) + word[i];</span><br><span class="line">        <span class="built_in">dfs</span>(word, i + <span class="number">1</span>, n, cur, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$<ul><li>每個 char 都有兩種選擇 ➔ 總共 $2^n$ 種</li><li>建構每一種需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array <code>res</code>, 則取決於遞迴深度, 最大遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 由於本題不需剪枝, 且每個 char 都有「取縮寫 or 不取縮寫」兩種選擇, 故用 Bit Manipulation 比較方便（狀態壓縮）。</strong></p><ul><li>首先, 遍歷 <code>00...0</code> 到 <code>11...1</code> 所有 <code>n</code> 位的二進位狀態（所有 char 的選擇總共有 $2^n$ 種）, 並定義：<ul><li>若某 bit 為 <code>0</code>, 就代表對應位置的 char 不取縮寫</li><li>若某 bit 為 <code>1</code>, 就代表對應位置的 char 取縮寫</li></ul></li><li><strong>若第 <code>i</code> 個 bit 要取縮寫</strong>：<ul><li>往後遍歷也要縮寫的連續 char, 直到遇到不縮寫的 char（假設其 <code>index = j</code>）</li><li>將縮寫的長度加入到 <code>cur</code> 中</li><li>將 <code>i</code> 設為 <code>j - 1</code> ➔ 下一輪循環, <code>i</code> 將從 <code>j</code> 開始往後遍歷</li></ul></li><li><strong>若第 <code>i</code> 個 bit 不取縮寫</strong>：<ul><li>將 <code>word[i]</code> 加入到 <code>cur</code> 中, 並進入下一輪遞迴</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateAbbreviations</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = word.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> state = <span class="number">0</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); ++state) &#123; <span class="comment">// 遍歷所有二進位狀態</span></span><br><span class="line">            string cur;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 遍歷該狀態所有 char 是否要縮寫</span></span><br><span class="line">                <span class="function">i <span class="title">f</span><span class="params">((state &gt;&gt; i) &amp; <span class="number">1</span>)</span> </span>&#123; <span class="comment">// 若第 i 個 char 要縮寫</span></span><br><span class="line">                    <span class="comment">// 往後遍歷也要縮寫的連續 char, 直到遇到不縮寫的 char</span></span><br><span class="line">                    <span class="type">int</span> j = i;</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; (state &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        ++j;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> len = j - i; <span class="comment">// 縮寫的長度</span></span><br><span class="line">                    cur += <span class="built_in">to_string</span>(len);</span><br><span class="line">                    i = j - <span class="number">1</span>; <span class="comment">// 下一輪 i 從 j 開始繼續往後遍歷 char</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur += word[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$<ul><li>每個 char 都有兩種選擇 ➔ 總共 $2^n$ 種</li><li>建構每一種需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array <code>res</code>, 則取決於 <code>cur</code> 的長度（<code>cur</code> 長度不超過 <code>n</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>377. Combination Sum IV</title>
      <link href="/post/combination-sum-iv/"/>
      <url>/post/combination-sum-iv/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/combination-sum-iv/">https://leetcode.cn/problems/combination-sum-iv/</a></strong></p><p><strong>題意：</strong>給一<strong>元素皆不同</strong>的array <code>nums</code> 和一整數 <code>target</code>, 返回總合為 <code>target</code> 的元素<strong>排列</strong>個數。</p><p>答案保證符合 32-bit 整數範圍（而非 32-bit 有號整數）</p><p><strong>進階：</strong>如果 <code>nums</code> 中允許有負數, 需要向題目中添加哪些限制條件?</p></blockquote><p><img src="https://i.imgur.com/qYgtgMl.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 DFS, 類似 <a href="https://zako945.github.io/post/combination-sum/">39. Combination Sum</a></strong></p><p><img src="https://i.imgur.com/LSY5gOu.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, target, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span>&amp; target, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            target -= num;</span><br><span class="line">            <span class="built_in">dfs</span>(nums, target, res);</span><br><span class="line">            target += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ 最差情況應為 $O(n \cdot 2^n)$, 但是遞迴時會用 <strong><code>num &gt; target</code></strong> 來進行<strong>剪枝(pruning)</strong>, 所以實際運行情況是<strong>遠小於</strong> $O(n \cdot 2^n)$ 的</li><li><strong>space：</strong>$O(target)$ ➔ 取決於遞迴深度, 最大遞迴深度為 <code>target</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 來避免重複計算, 其中 <code>dp[i]</code> 表示 <code>nums</code> 中加總為 <code>i</code> 之排列數, e.g. 下圖中紅框部分 <code>dp[2]</code> 重複計算, 故用 <code>dp</code> 保存計算過的結果</strong></p><p><img src="https://i.imgur.com/eKgssGQ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 總和為 0, 也就是任何元素都不取, 方法數為 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= target; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= num) &#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(target \cdot n)$ ➔ for loop, 其中 <code>n</code> 為 <code>nums</code> 的長度</li><li><strong>space：</strong>$O(target)$ ➔ <code>dp</code></li></ul><hr><h2 id="進階問題"><a href="#進階問題" class="headerlink" title="進階問題"></a><strong>進階問題</strong></h2><p>Q：如果 <code>nums</code> 中允許有負數, 需要向題目中添加哪些限制條件?</p><p>A：假設 <code>nums</code> 為 [a, -b] (其中 a &gt; 0, b &gt; 0), 且 <code>target</code> 為 0 ➔ a * (-b) + (-b) * a &#x3D; 0<br>在該排列的後面添加 b 個 a 和 a 個 -b 後, 得到的新排列的元素之和仍然等於 <code>target</code><br>➔ 如果允許負數出現, 則必須<strong>限制排列的最大長度</strong>, 避免出現無限長度的排列, 這樣才能計算排列數</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>673. Number of Longest Increasing Subsequence</title>
      <link href="/post/number-of-longest-increasing-subsequence/"/>
      <url>/post/number-of-longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">https://leetcode.cn/problems/number-of-longest-increasing-subsequence/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 返回最長<strong>嚴格遞增</strong> subsequence 的個數。</p></blockquote><p><img src="https://i.imgur.com/BcNceHo.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：可看到下圖 5 的部分重複計算, 故利用 DP, <code>dp[i]</code> 代表 <code>nums[i]</code> 開頭的最大 LIS 長度</strong></p></blockquote><p><img src="https://i.imgur.com/MaJFevy.png"></p><p><img src="https://i.imgur.com/8CZhrRR.png"></p><ul><li><strong>特殊情況: 最長的 LIS 不只一個, 則 cnt 要相加</strong></li></ul><p><img src="https://i.imgur.com/1s86oUw.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span> , <span class="title">cnt</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> maxLis = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i] &lt; dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        cnt[i] = cnt[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                        cnt[i] += cnt[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; maxLis) &#123;</span><br><span class="line">                maxLis = dp[i];</span><br><span class="line">                res = cnt[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == maxLis) &#123;</span><br><span class="line">                res += cnt[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code> 和 <code>cnt</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>698. Partition to K Equal Sum Subsets</title>
      <link href="/post/partition-to-k-equal-sum-subsets/"/>
      <url>/post/partition-to-k-equal-sum-subsets/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code> 和一正整數 <code>k</code>, 返回是否能把 <code>nums</code> 拆分成 <code>k</code> 的非空 subset, 且每個 subset 元素總和皆相等。</p><p><strong>注意</strong>：<code>nums.length ≤ 16</code></p></blockquote><p><img src="https://i.imgur.com/8BFDcbQ.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：總共有 <code>n</code> 顆球、<code>k</code> 個桶子, 以「球」為視角, 每顆球都有 <code>k</code> 個桶子可以選擇, 每個桶子的容量為 <code>target = sum / k</code>。</strong></p><p>e.g. <code>nums = [1, 2, 2, 4, 3, 3], k = 3</code></p><p><img src="https://i.imgur.com/pUMHQhG.png"></p><p><img src="https://i.imgur.com/TXUKjNx.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123; <span class="comment">// 無法分成 k 個相同的 subset</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(k, target)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nums 由大到小排序, 大的先做有利於剪枝</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>(), buckets, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; buckets, <span class="type">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 代表 n 顆球都能放入桶內, 不需用 for loop 檢查每個桶是否為 0</span></span><br><span class="line">        <span class="comment">// 因為前面已經判斷過 (sum % k) 是否為 0</span></span><br><span class="line">        <span class="comment">// 所以只要 n 顆球都能放入桶內, 每個桶之元素和必為 target</span></span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每顆球都有 k 個選擇</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; buckets[j]) &#123; <span class="comment">// buckets[i] 剩餘容量不足, 則跳過</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果當前桶和上一個桶內的元素和相等, 則跳過</span></span><br><span class="line">            <span class="comment">// 因為當前這顆球放在當前桶和上一個桶都是一樣的, 對後面的球如何擺放沒有影響</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; buckets[j - <span class="number">1</span>] == buckets[j]) &#123; <span class="comment">// 剪枝</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buckets[j] -= nums[i]; <span class="comment">// 將球放入桶中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遞迴窮舉下一顆球的所有情況, 返回是否能將所有球放入桶中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n, buckets, k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buckets[j] += nums[i]; <span class="comment">// 若不行, 則撤銷, 往下一個桶嘗試</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// nums[i] 無法放入任何桶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k^n)$ ➔ 每個顆都有 <code>k</code> 個桶子可以選擇桶子, 所以組合出的結果為 $k^n$ 種</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, stack 中每一層代表第 <code>i</code> 顆球選擇哪個桶子, 總共 <code>n</code> 層</li></ul><h2 id="Solution-2：（TLE-無法通過）"><a href="#Solution-2：（TLE-無法通過）" class="headerlink" title="Solution 2：（TLE 無法通過）"></a><strong>Solution 2：</strong>（<strong>TLE 無法通過）</strong></h2><blockquote><p><strong>想法：</strong>總共有 <code>n</code> 顆球、<code>k</code> 個桶子, 以「桶子」為視角（每個桶子都會遍歷所有球）, 每顆球有 <code>2</code> 種選擇（選 or 不選）, 每個桶子都有 $O(2^n)$ 種選擇。</p><p>e.g. <code>nums = [1, 2, 2, 4, 3, 3], k = 3</code></p><p><img src="https://i.imgur.com/d19Byj6.png"></p><p><img src="https://i.imgur.com/tMshhhb.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123; <span class="comment">// 無法分成 k 個相同的 subset</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(k, target)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>; <span class="comment">// 紀錄第 i 顆球是否已被使用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, used, <span class="number">0</span>, buckets, k - <span class="number">1</span>); <span class="comment">// 從最後一個桶開始放球</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; buckets, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 因為前面已經判斷過 (sum % k) 是否為 0</span></span><br><span class="line">        <span class="comment">// 若 k - 1 個桶子已放滿, 則剩下的球之和必為 target, 必能放入最後一個桶</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// buckets[k] 已被填滿, 故從下一個桶子開始放（i 設 0 是因為下一桶要遍歷所有球）</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, used, <span class="number">0</span>, buckets, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="comment">// 球已放入別的桶子 or 當前桶的容量不足, 則跳過</span></span><br><span class="line">            <span class="keyword">if</span> (used[j] || nums[j] &gt; buckets[k]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將球放入當前桶</span></span><br><span class="line">            buckets[k] -= nums[j];</span><br><span class="line">            used[j] = <span class="literal">true</span>; <span class="comment">// 將球標記為已用過</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// 遞迴窮舉下一顆球的所有情況, 下一顆球仍是從第 k 個桶開始放</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(nums, used, j + <span class="number">1</span>, buckets, k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將球從當前桶取出</span></span><br><span class="line">            buckets[k] += nums[j];</span><br><span class="line">            used[j] = <span class="literal">false</span>; <span class="comment">// 將球標記為未使用過</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// buckets[k] 無法放入任何球</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot 2^n)$<ul><li>每個桶要遍歷 <code>n</code> 顆球, 每顆球都有 2 種選擇(選 or 不選), 所以組合的結果有 $2^n$ 種</li><li>總共有 <code>k</code> 個桶, 故為 $O(k \cdot 2^n)$</li></ul></li><li><strong>space：</strong>$O(k \cdot n)$ ➔ 取決於遞迴深度, 每個桶子最多有 <code>n</code> 次選擇（<code>n</code> 層）, 總共 <code>k</code> 個桶, 故為 $O(k \cdot n)$</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, 之所以會 TLE 是因為會重複計算, 必須儲存已使用球的狀態來進行剪枝</strong></p><p><img src="https://i.imgur.com/GkJCeuG.png"></p><p><img src="https://i.imgur.com/ORVu1Yz.png"></p><ul><li>剪枝<ul><li><code>used array</code> 可以認為一 backtracking 過程中的狀態。可以用一個 <code>memo</code> 來記錄每種情況的 <code>used</code> 返回 <code>true</code> 或 <code>false</code>。如果當前的 <code>used</code> 狀態是曾經出現過的, 那就不用再繼續窮舉了</li><li>根據題目給的 <code>nums.length ≤ 16</code>, 所以我們可以用「<strong>狀態壓縮</strong>」的技巧, 用 <strong><code>int</code></strong> 類型的 used 來<strong>替代 used array</strong>, 其中 <code>used</code> 中最右邊的編號為 <code>0</code>（e.g. <code>used = 3 = 00...0011</code>, 代表 <code>nums[0]</code> 和 <code>nums[1]</code> 已被使用）</li><li>為了方便查找, 我們利用 hash map 來記錄每一種 <code>used</code> 狀態返回的是 <code>true</code> 還是 <code>false</code></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123; <span class="comment">// 無法分成 k 個相同的 subset</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(k, target)</span></span>;</span><br><span class="line">        <span class="type">int</span> used = <span class="number">0</span>;  <span class="comment">// 紀錄每個數字是否被拜訪過</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, used, <span class="number">0</span>, buckets, k - <span class="number">1</span>); <span class="comment">// 從最後一個桶開始放球</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; memo; <span class="comment">// memo 儲存每一種 used 狀態</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span>&amp; used, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; buckets, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 因為前面已經判斷過 (sum % k) 是否為 0</span></span><br><span class="line">        <span class="comment">// 若 k - 1 個桶子已放滿, 則剩下的球之和必為 target, 必能放入最後一個桶</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// buckets[k] 已被填滿, 故從下一個桶子開始放, 且必須儲存球的狀態</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">bool</span> res = <span class="built_in">dfs</span>(nums, used, <span class="number">0</span>, buckets, k - <span class="number">1</span>);</span><br><span class="line">            memo[used] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果出現過 used 這種情況, 則直接返回結果</span></span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">find</span>(used) != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[used];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((used &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 球已放入別的桶子, 則跳過</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; buckets[k]) &#123; <span class="comment">// 當前桶的容量不足, 則跳過</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將球放入當前桶</span></span><br><span class="line">            buckets[k] -= nums[j];</span><br><span class="line">            used |= (<span class="number">1</span> &lt;&lt; j); <span class="comment">// 用 OR 將球標記為已用過</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// 遞迴窮舉下一顆球的所有情況, 下一顆球仍是從第 k 個桶開始放</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(nums, used, j + <span class="number">1</span>, buckets, k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將球從當前桶取出</span></span><br><span class="line">            buckets[k] += nums[j];</span><br><span class="line">            used ^= (<span class="number">1</span> &lt;&lt; j); <span class="comment">// 用 XOR 將球標記為未使用過</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// buckets[k] 無法放入任何球</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot 2^n)$<ul><li>每個桶要遍歷 <code>n</code> 顆球, 每顆球都有 2 種選擇(選 or 不選), 所以組合的結果有 $2^n$ 種</li><li>總共有 <code>k</code> 個桶, 故為 $O(k \cdot 2^n)$</li></ul></li><li><strong>space：</strong>$O(2^n)$ ➔ <code>memo</code> 最大長度為 $2^n$, 因為最多 $2^n$ 種狀態</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>142. Linked List Cycle II</title>
      <link href="/post/linked-list-cycle-ii/"/>
      <url>/post/linked-list-cycle-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></strong></p><p><strong>題意</strong>：給一 linked list 的 <code>head</code>, 返回 cycle 的起點。若無 cycle, 則返回 <code>null</code>。</p><p><strong>進階</strong>：設計 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/zAmBxdg.png"></p><p><img src="https://i.imgur.com/viHTrL4.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：定義以下變數</strong></p><ul><li><code>L</code> 是起始點和 cycle head 的距離</li><li><code>x</code> 是 cycle head 到第一次相遇的距離</li><li><code>C</code> 是整個 cycle 的長度</li></ul><p><strong>第一次相遇可以寫成一個等式：<code>2(L + x) = L + nC + x</code><br>其中, <code>L + x</code> 為烏龜走的步數, <code>L + nC + x</code> 為兔子走的步數<br><code>nC</code> 代表兔子率先進入 cycle, 在和烏龜第一次相遇之前可能已經繞 cycle 好幾圈了</strong></p><p><strong><code>2(L + x) = L + nC + x</code> 可化簡成 <code>L + x = nC</code></strong></p><ul><li><p>讓烏龜<strong>回到原點, 然後走 <code>L</code> 步抵達 cycle head</strong></p></li><li><p>兔子則在<strong>第一次相遇的地方 <code>(L+x)</code> 走 <code>L</code> 步</strong><br>此時兔子的新位置在 <code>(L + x) + L = nC + L</code> 也就是在 cycle head<br>(<code>nC + L</code> 可看成從起點走 <code>L</code> 步到達 cycle head, 然後繞了 cycle <code>n</code> 圈, 位置仍在 cycle head)</p><p>  <img src="https://i.imgur.com/ytJsHG3.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ cycle 長度不超過 <code>n</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148. Sort List</title>
      <link href="/post/sort-list/"/>
      <url>/post/sort-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></strong></p><p><strong>題意</strong>：給一 linked list 的起始節點 <code>head</code>, 返回以<strong>升序</strong>排列過的 linked list。</p><p><strong>進階</strong>：設計 $O(n \cdot log(n))$ time 且 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/VoWQGBl.png"></p><p><img src="https://i.imgur.com/Tl9nO6Y.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Merge Sort (top-down)</strong></p><p><img src="https://i.imgur.com/3c0dx5l.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0 或 1 個 node</span></span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 讓 slow 指向中點; 若 n 為偶數, 則指向第一個中點</span></span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *mid = slow-&gt;next; <span class="comment">// 右半部分</span></span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 左半部分的結尾設為 NULL</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head), <span class="built_in">sortList</span>(mid));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *tail = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="comment">// 讓 l1 始終指向較小的 node</span></span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(l1, l2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 這邊可寫成 tail-&gt;next = l2; 因為 l1, l2 一開始一定皆不為 NULL</span></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ Merge Sort 的時間複雜度, $T(n) &#x3D; 2 \cdot T(\dfrac{n}{2}) + O(n)$<ul><li>每回合的合併需要花：$O(n)$</li><li>回合數：$O(log(n))$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ $O(n + log(n))$<ul><li>$O(n)$：merge 後的 linked list 長度最多為 <code>n</code></li><li>$O(log(n))$：取決於遞迴深度, 最大遞迴深度為 log(n)</li></ul></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Merge Sort (bottom-up)</strong></p><p><img src="https://i.imgur.com/nJ0XunR.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0 或 1 個 node</span></span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = <span class="built_in">getLen</span>(head);</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// log(n) 回合 : 2^0 ~ 2^(log(n)-1) =&gt; (log(n) - 1) - 0 + 1 = log(n)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt; len; n &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 不能寫 cur = head, 因為 dummy-&gt;next 會因 tail 而改變</span></span><br><span class="line">            ListNode *cur = dummy-&gt;next;</span><br><span class="line">            ListNode *tail = dummy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">                ListNode *left = cur;</span><br><span class="line">                ListNode *right = <span class="built_in">split</span>(left, n);</span><br><span class="line">                cur = <span class="built_in">split</span>(right, n);</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> merged = <span class="built_in">merge</span>(left, right);</span><br><span class="line">                tail-&gt;next = merged.first;</span><br><span class="line">                tail = merged.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLen</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (--n &amp;&amp; head) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *rest = head ? head-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head) &#123; <span class="comment">// 將左半部分的結尾設為 NULL</span></span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ListNode*, ListNode*&gt; <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="comment">// 讓 l1 始終指向較小的 node</span></span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(l1, l2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 當 list 只有一個元素時, l1 不為 NULL, 但 l2 為 NULL, 並不會進入 while loop</span></span><br><span class="line"><span class="comment">         * e.g. [1, 2, 3] =&gt; left = [1, 2], right = [3] = cur</span></span><br><span class="line"><span class="comment">         * cur 不為 null, 進入第二個 while loop</span></span><br><span class="line"><span class="comment">         * 此時 left = [3], right = null, 並不會進入 merge 的 while loop</span></span><br><span class="line"><span class="comment">         * 這邊不可寫成 tail-&gt;next = l2; 因為不保證一定進 while loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tail 到達 merged list 的最後一個非 null 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (tail-&gt;next) &#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;dummy-&gt;next, tail&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ Merge Sort 的時間複雜度</li><li><strong>space：</strong>$O(1)$ ➔ 用 loop 模擬 recursive, 因此只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>92. Reverse Linked List II</title>
      <link href="/post/reverse-linked-list-ii/"/>
      <url>/post/reverse-linked-list-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></strong></p><p><strong>題意</strong>：給一 single linked list 的 <code>head</code> 和兩整數 <code>left</code> 和 <code>right</code>, 其中 <code>left ≤ right</code>, 反轉位置 <code>left</code> 到位置 <code>right</code> 的 node, 並返回反轉後的 linked list。</p></blockquote><p><img src="https://i.imgur.com/cSX6dz4.png"></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a><strong>Solution:</strong></h2><blockquote><p><strong>想法：分成三步驟</strong></p><ul><li><p>將待反轉的區域反轉</p></li><li><p>將 <code>left</code> (leftPrev-&gt;next) 的 <code>next</code> 指向 <code>cur</code></p></li><li><p>將 <code>leftPre</code> 的 <code>next</code> 指向 <code>reverseHead</code></p><p>  <img src="https://i.imgur.com/4i8EkA0.png"></p><p>  <img src="https://i.imgur.com/ao66TLu.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *leftPrev = dummy, *cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop 做完後, leftPrev 指向 left 前一個 node, cur 則指向 left</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            leftPrev = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做完 reverse 後, cur 會指向 right 後一個 node</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> reverseHead = <span class="built_in">reverse</span>(cur, left, right);</span><br><span class="line">        leftPrev-&gt;next-&gt;next = cur; <span class="comment">// 將 reverse 前的 head 指向 right 後一個 node</span></span><br><span class="line">        leftPrev-&gt;next = reverseHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode*&amp; head, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            nxt = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = nxt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>61. Rotate List</title>
      <link href="/post/rotate-list/"/>
      <url>/post/rotate-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/</a></strong></p><p><strong>題意</strong>：給一 linked list 的 <code>head</code> 和一整數 <code>k</code>, 將 linked list 每個 node 向右移 <code>k</code> 個位置。</p></blockquote><p><img src="https://i.imgur.com/XJmxH4H.png"></p><p><img src="https://i.imgur.com/8gLkYNv.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將 linked list 分成兩個部分, 倒數 <code>k</code> 個 node(藍色部分)、剩餘部分(綠色部分)</strong></p><ul><li><strong>先將 <code>tail-&gt;next</code> 設為藍色部分的 head, 並把綠色部分的 <code>tail-&gt;next</code> 指向 <code>null</code></strong></li><li><strong>再將藍色部分的 <code>tail</code> 指向綠色部分的 head, 並把藍色部分的 head 設為 <code>newHead</code></strong></li></ul><p><img src="https://i.imgur.com/YeOM2tF.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || !head) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ListNode *tail = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到 len &amp; 藍色部分的 tail</span></span><br><span class="line">        <span class="keyword">while</span> (tail-&gt;next) &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因為 k 有可能會大於 len(如 example 2), 所以要 k % len(循環)</span></span><br><span class="line">        k %= len; <span class="comment">// 藍色部分的長度</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="comment">// cur 為綠色部分的 tail</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *newHead = cur-&gt;next; <span class="comment">// 藍色部分的 head</span></span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 綠色部分的 tail 指向 null</span></span><br><span class="line">        tail-&gt;next = head; <span class="comment">// 藍色部分的 tail 指向綠色部分的 head</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24. Swap Nodes in Pairs</title>
      <link href="/post/swap-nodes-in-pairs/"/>
      <url>/post/swap-nodes-in-pairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></strong></p><p><strong>題意</strong>：給一 linked list, 兩兩交換相鄰的 node, 並返回交換後 linked list。</p><p><strong>注意</strong>：必須在不修改 node 值的情況下完成（只能進行 node swap）</p></blockquote><p><img src="https://i.imgur.com/FgC5y0Z.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 dummy node, 讓 <code>prev</code> 永遠指向當前 pair 的前一個 node, 分為三步驟</strong></p><ul><li><strong>1. 取得下一個 pair 的 head, 和當前 pair 的 tail</strong></li><li><strong>2. reverse 當前 pair, 並將 <code>prev</code> 指向當前 pair 的 head(更新前的 tail)</strong></li><li><strong>3. 更新 pointers</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *prev = dummy, *cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// save ptrs</span></span><br><span class="line">            ListNode *nxtPair = cur-&gt;next-&gt;next; <span class="comment">// 下一個 pair 的 head</span></span><br><span class="line">            ListNode *second = cur-&gt;next; <span class="comment">// 當前 pair 的 tail</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// reverse current pairs</span></span><br><span class="line">            second-&gt;next = cur; <span class="comment">// second 成為當前 pair 的 head, cur 則成為 tail</span></span><br><span class="line">            cur-&gt;next = nxtPair; <span class="comment">// 當前 pair 的 tail 指向下一個 pair</span></span><br><span class="line">            prev-&gt;next = second; <span class="comment">// prev 指向當前 pair 的 head</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// update ptrs</span></span><br><span class="line">            prev = cur; <span class="comment">// prev 指向下一個 pair 的前一個 node(當前 pair 的 tail)</span></span><br><span class="line">            cur = nxtPair; <span class="comment">// 移動到下一個 pair</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>328. Odd Even Linked List</title>
      <link href="/post/odd-even-linked-list/"/>
      <url>/post/odd-even-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/odd-even-linked-list/">https://leetcode.cn/problems/odd-even-linked-list/</a></strong></p><p><strong>題意</strong>：給一 single linked list 的 <code>head</code>, 將奇數位置的 node 分組在一起, 然後是偶數位置的 node 分組在一起, 然後將偶數組 linked list 串接在奇數組 linked list 後面。</p><p><strong>注意</strong>：奇數組和偶數組內的相對順序應和輸入中的順序相同。</p><p>設計 $O(n)$ time 且 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/fk4XkgO.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：用兩個奇偶 pointers 分別指向奇偶 linked list 的起始位置, 另外需要一個單獨的 pointer evenHead 來保存偶數組 linked list 的起點位置</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *evenHead = head-&gt;next;</span><br><span class="line">        ListNode *odd = head, *even = evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷是否有偶奇節點</span></span><br><span class="line">        <span class="keyword">while</span> (odd-&gt;next &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">            odd-&gt;next = odd-&gt;next-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = even-&gt;next-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        odd-&gt;next = evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>378. Kth Smallest Element in a Sorted Matrix</title>
      <link href="/post/kth-smallest-element-in-a-sorted-matrix/"/>
      <url>/post/kth-smallest-element-in-a-sorted-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/</a></strong></p><p><strong>題意</strong>：給一 <code>n x n</code> matrix, 其中每行、每列各自按照<strong>升序</strong>排序, 返回 matrix 中第 <code>k</code> 小的元素。</p><p><strong>注意</strong>：它是<strong>排序</strong>後第 <code>k</code> 小的元素, 而不是第 <code>k</code> 個不同的元素</p><p>e.g. matrix &#x3D; <code>[[1,2], [2,3]]</code>, k &#x3D; <code>3</code>, 答案是 2</p><p>➔ 因為排序後 <code>[1, 2, 2, 3]</code> 中第 3 小的是 2, 重複數不能只算一次（不能看做 <code>[1, 2, 3]</code>）</p><p>設計 $O(n^2)$ time 的演算法</p><p><strong>進階</strong>：設計 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/iY11wGp.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Heap, 由於 matrix 是已排序好的, 所以 <code>(i, j)</code> 的值一定比 <code>(i + 1, j)</code> 和 <code>(i, j + 1)</code> 的值小, 演算法可參考此影片, 簡單來說分成以下步驟：</strong></p><ol><li>取出 min heap 的 top, 也就是當前最小</li><li>insert top 的右方和下方到 heap 中 (同位置不能重複 insert)</li><li>從 heap 中取出 <code>k - 1</code> 個 top 後, 剩餘 heap 中的 top 即為第 <code>k</code> 小的數</li></ol><p><img src="https://i.imgur.com/TB2A0PC.png"></p><p><strong>min Heap 定義</strong>：任意 parent 的值一定比 children 的都小</p><p><img src="https://i.imgur.com/knIJ15m.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coord</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> r, c, val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Coord</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val) : <span class="built_in">r</span>(i), <span class="built_in">c</span>(j), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Coord&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &gt; a.val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>)); <span class="comment">// 避免重複 insert</span></span><br><span class="line">        priority_queue&lt;Coord, vector&lt;Coord&gt;, greater&lt;Coord&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(<span class="number">0</span>, <span class="number">0</span>, matrix[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pop 掉前 k - 1 小的數, 則 pq.top() 即為第 k 小的數</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [r, c, val] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 top 下方 insert 到 pq 中</span></span><br><span class="line">            <span class="keyword">if</span> (r + <span class="number">1</span> &lt; n &amp;&amp; !visited[r + <span class="number">1</span>][c]) &#123;</span><br><span class="line">                visited[r + <span class="number">1</span>][c] = <span class="literal">true</span>;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(r + <span class="number">1</span>, c, matrix[r + <span class="number">1</span>][c]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 top 右方 insert 到 pq 中</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; n &amp;&amp; !visited[r][c + <span class="number">1</span>]) &#123;</span><br><span class="line">                visited[r][c + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(r, c + <span class="number">1</span>, matrix[r][c + <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot log(n))$<ul><li>$O(k)$：for loop, 其中 worse case 為 $k &#x3D; n^2$</li><li>$O(log(n))$：insertion of heap（因為 heap 是 balanced tree, <code>swap()</code> 最多為樹高 $log(n)$ 次）</li></ul></li><li><strong>space：</strong>$O(n^2)$ ➔ <code>visited</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：Solution 1 的改進, 藍色數字代表 minHeap 中元素(初始為第一行的元素), 彈出 minHeap 最小的後, 將該元素右邊一格加入到 heap 中成為下一個候選人</strong></p><p><img src="https://i.imgur.com/WX4nfyA.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coord</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> r, c, val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Coord</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val) : <span class="built_in">r</span>(i), <span class="built_in">c</span>(j), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Coord&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &gt; a.val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;Coord, vector&lt;Coord&gt;, greater&lt;Coord&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將第一行元素加到 minHeap 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            minHeap.<span class="built_in">emplace</span>(r, <span class="number">0</span>, matrix[r][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [r, c, val] = minHeap.<span class="built_in">top</span>();</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 top 右邊一格還沒越界, 則將其加入到 heap 中</span></span><br><span class="line">            <span class="keyword">if</span> (c != n - <span class="number">1</span>) &#123;</span><br><span class="line">                minHeap.<span class="built_in">emplace</span>(r, c + <span class="number">1</span>, matrix[r][c + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minHeap.<span class="built_in">top</span>().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot log(n))$<ul><li>$O(k)$：for loop, 其中 worse case 為 $k &#x3D; n^2$</li><li>$O(log(n))$：insertion of heap（因為 heap 是 balanced tree, <code>swap()</code> 最多為樹高 $log(n)$ 次）</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>minHeap</code> 中最多 <code>n</code> 個元素</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 其中 <code>left = matrix[0][0]</code>, <code>right = matrix[n - 1][n - 1] + 1</code>, 得出 <code>mid</code> 後, 計算 <code>matrix</code> 中 <code>≤ mid</code> 的個數 <code>cnt</code> (可參考 240. Search a 2D Matrix II 的 Z 字形搜索), 希望找到一個 <code>mid</code> 使得 <code>matrix</code> 中剛好有 <code>k</code> 個數 <code>≤ mid</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>], right = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">count_less_equal</span>(n, matrix, mid) &gt;= k) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// left 為第一個有 k 個數 &gt;= 自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 計算 matrix 中 ≤ mid 的元素個數, 此處也可以改成用 binary search 實作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_less_equal</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">const</span> <span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; n &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] &lt;= mid) &#123;</span><br><span class="line">                cnt += (col + <span class="number">1</span>);</span><br><span class="line">                ++row;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --col;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(r-l))$ ➔ <code>r</code> 代表 <code>right</code>, <code>l</code> 代表 <code>left</code><ul><li>$O(log(r-l))$：Binary Search 的次數</li><li>$O(n)$：計算 <code>cnt</code> 的時間 $O(n+n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>986. Interval List Intersections</title>
      <link href="/post/interval-list-intersections/"/>
      <url>/post/interval-list-intersections/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/</a></strong></p><p><strong>題意</strong>：給一 <code>n x n</code> matrix, 其中每行、每列各自按照<strong>升序</strong>排序, 返回 matrix 中第 <code>k</code> 小的元素。</p><p><strong>注意</strong>：它是<strong>排序</strong>後第 <code>k</code> 小的元素, 而不是第 <code>k</code> 個不同的元素</p><p>e.g. matrix &#x3D; <code>[[1,2], [2,3]]</code>, <code>k = 3</code>, 答案是 2</p><p>➔ 因為排序後 <code>[1, 2, 2, 3]</code> 中第 3 小的是 2, 重複數不能只算一次（不能看做 <code>[1, 2, 3]</code>）</p><p>設計 $O(n^2)$ time 的演算法</p><p><strong>進階</strong>：設計 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/iY11wGp.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Heap, 由於 matrix 是已排序好的, 所以 (i, j) 的值一定比 (i + 1, j) 和 (i, j + 1) 的值小, 演算法可參考此影片, 簡單來說分成以下步驟：</strong></p><ol><li>取出 min heap 的 top, 也就是當前最小</li><li>insert top 的右方和下方到 heap 中 (同位置不能重複 insert)</li><li>從 heap 中取出 <code>k - 1</code> 個 top 後, 剩餘 heap 中的 top 即為第 <code>k</code> 小的數</li></ol><p><img src="https://i.imgur.com/TB2A0PC.png"></p><p><strong>min Heap 定義</strong>：任意 parent 的值一定比 children 的都小</p><p><img src="https://i.imgur.com/knIJ15m.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coord</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> r, c, val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Coord</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val) : <span class="built_in">r</span>(i), <span class="built_in">c</span>(j), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Coord&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &gt; a.val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>)); <span class="comment">// 避免重複 insert</span></span><br><span class="line">        priority_queue&lt;Coord, vector&lt;Coord&gt;, greater&lt;Coord&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(<span class="number">0</span>, <span class="number">0</span>, matrix[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pop 掉前 k - 1 小的數, 則 pq.top() 即為第 k 小的數</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [r, c, val] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 top 下方 insert 到 pq 中</span></span><br><span class="line">            <span class="keyword">if</span> (r + <span class="number">1</span> &lt; n &amp;&amp; !visited[r + <span class="number">1</span>][c]) &#123;</span><br><span class="line">                visited[r + <span class="number">1</span>][c] = <span class="literal">true</span>;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(r + <span class="number">1</span>, c, matrix[r + <span class="number">1</span>][c]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 top 右方 insert 到 pq 中</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; n &amp;&amp; !visited[r][c + <span class="number">1</span>]) &#123;</span><br><span class="line">                visited[r][c + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(r, c + <span class="number">1</span>, matrix[r][c + <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot log(n))$<ul><li>$O(k)$：for loop, 其中 worse case 為 $k &#x3D; n^2$</li><li>$O(log(n))$：insertion of heap(因為 heap 是 balanced tree, <code>swap()</code> 最多為樹高 $log(n)$ 次)</li></ul></li><li><strong>space：</strong>$O(n^2)$ ➔ <code>visited</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：Solution 1 的改進, 藍色數字代表 minHeap 中元素(初始為第一行的元素), 彈出 minHeap 最小的後, 將該元素右邊一格加入到 heap 中成為下一個候選人</strong></p><p><img src="https://i.imgur.com/WX4nfyA.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coord</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> r, c, val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Coord</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val) : <span class="built_in">r</span>(i), <span class="built_in">c</span>(j), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Coord&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &gt; a.val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;Coord, vector&lt;Coord&gt;, greater&lt;Coord&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將第一行元素加到 minHeap 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            minHeap.<span class="built_in">emplace</span>(r, <span class="number">0</span>, matrix[r][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [r, c, val] = minHeap.<span class="built_in">top</span>();</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 top 右邊一格還沒越界, 則將其加入到 heap 中</span></span><br><span class="line">            <span class="keyword">if</span> (c != n - <span class="number">1</span>) &#123;</span><br><span class="line">                minHeap.<span class="built_in">emplace</span>(r, c + <span class="number">1</span>, matrix[r][c + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minHeap.<span class="built_in">top</span>().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot log(n))$<ul><li>$O(k)$：for loop, 其中 worse case 為 $k &#x3D; n^2$</li><li>$O(log(n))$：insertion of heap(因為 heap 是 balanced tree, <code>swap()</code> 最多為樹高 $log(n)$ 次)</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>minHeap</code> 中最多 <code>n</code> 個元素</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 其中 <code>left = matrix[0][0]</code>, <code>right = matrix[n - 1][n - 1] + 1</code>, 得出 <code>mid</code> 後, 計算 <code>matrix</code> 中 <code>≤ mid</code> 的個數 <code>cnt</code> (可參考 240. Search a 2D Matrix II 的 Z 字形搜索), 希望找到一個 <code>mid</code> 使得 <code>matrix</code> 中剛好有 <code>k</code> 個數 <code>≤ mid</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>], right = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">count_less_equal</span>(n, matrix, mid) &gt;= k) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// left 為第一個有 k 個數 &gt;= 自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 計算 matrix 中 ≤ mid 的元素個數, 此處也可以改成用 binary search 實作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_less_equal</span><span class="params">(<span class="type">int</span>&amp; n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span>&amp; mid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; n &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] &lt;= mid) &#123;</span><br><span class="line">                cnt += (col + <span class="number">1</span>);</span><br><span class="line">                ++row;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --col;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(r-l))$ ➔ <code>r</code> 代表 <code>right</code>, <code>l</code> 代表 <code>left</code><ul><li>$O(log(r-l))$：Binary Search 的次數</li><li>$O(n)$：計算 <code>cnt</code> 的時間 $O(n+n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>373. Find K Pairs with Smallest Sums</title>
      <link href="/post/find-k-pairs-with-smallest-sums/"/>
      <url>/post/find-k-pairs-with-smallest-sums/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/</a></strong></p><p><strong>題意</strong>：給兩個<strong>升序排列</strong>的 array <code>nums1</code> 和 <code>nums2</code>。</p><p>定義 pair <code>(u, v)</code>, 其中 <code>u</code> 來自 <code>nums1</code>, <code>v</code> 來自 <code>nums2</code></p><p>求和最小的 <code>k</code> 個 pair</p></blockquote><p><img src="https://i.imgur.com/UPRj530.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Heap, 解法同 <a href="https://zako945.github.io/post/kth-smallest-element-in-a-sorted-matrix/">378. Kth Smallest Element in a Sorted Matrix</a>, <code>pair</code> 分別存 <code>nums1</code> 第 <code>i</code> 個元素、<code>nums2</code> 第 <code>j</code> 個元素 (只存 index, 不存 val), 然後用 <code>minHeap</code> 取最小的 <code>sum(nums1[i], nums2[j])</code></strong></p><p><img src="https://i.imgur.com/txLwhgc.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 重要: 將 nums1, nums2 傳入 cmp 中</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重要: 自定義 priority_queue 的 cmp 函數, 請牢記 heap 預設為 !cmp</span></span><br><span class="line">        <span class="comment">// 故 minHeap 要用 greater&lt;T&gt;, 且 cmp 裡面是判斷第一個 &gt; 第二個</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將第一行元素加到 minHeap 中, k 的個數有可能小於 m</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(k, m); i++) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [i, j] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot log(k))$<ul><li>$O(k)$：while loop, 其中 worse case 為 <code>k = mn</code></li><li>$O(log(k))$：insertion of heap(因為 heap 是 balanced tree, <code>swap()</code> 最多為樹高 $log(k)$ 次)</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ <code>minHeap</code> 最多 <code>k</code> 個元素</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 解法同 <a href="https://zako945.github.io/post/kth-smallest-element-in-a-sorted-matrix/">378. Kth Smallest Element in a Sorted Matrix</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">count</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span>&amp; mid)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 只需 O(m+n) time, 因為 nums1 遞增, 若 i 變大, 則 j 變小</span></span><br><span class="line">        <span class="comment">// 假設 i = 0 做完, j = 10</span></span><br><span class="line">        <span class="comment">// 則 i = 1 時, j 從 10 繼續(pos 不用重設成 nums2.size() - 1)</span></span><br><span class="line">        <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = nums2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums1[i] + nums2[j] &gt; mid) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt += (j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">long</span> left = nums1[<span class="number">0</span>] + nums2[<span class="number">0</span>];</span><br><span class="line">        <span class="type">long</span> right = nums1.<span class="built_in">back</span>() + nums2.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">count</span>(nums1, nums2, mid) &lt; k) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> pairSum = left;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res1, res2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>() &amp;&amp; nums1[i] + nums2[j] &lt;= pairSum; ++j) &#123;</span><br><span class="line">                <span class="comment">// sum &lt; pairSum 的 pair 一定會取</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[i] + nums2[j] &lt; pairSum) &#123;</span><br><span class="line">                    res1.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// sum == pairSum 的 pair 不一定會取(有可能很多個, 導致最後超過 k 個)</span></span><br><span class="line">                    <span class="comment">// 故用另一個 vector 存</span></span><br><span class="line">                    res2.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 從 res2 中取 k - res1.size() 個</span></span><br><span class="line">        <span class="comment">// 也有可能 res2 沒那麼多個給你取(k取太大, 沒那麼多pair), 故要取 min</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> remain = <span class="built_in">min</span>(k - res1.<span class="built_in">size</span>(), res2.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; remain; ++i) &#123;</span><br><span class="line">            res1.<span class="built_in">emplace_back</span>(res2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O((m+n) \cdot log(r-l) + m \cdot n)$ ➔ <code>m</code> 為 <code>nums1.size()</code>, <code>n</code> 為 <code>nums2.size()</code><ul><li>$O(log(r-l))$：Binary Search 次數</li><li>$O(m+n)$：<code>count()</code> 所需時間</li><li>$O(m \cdot n)$：for loop, 有用 <code>nums1[i] + nums2[j] ≤ pairSum</code> 做 pruning, 實際遠小於 <code>mn</code> 次</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 扣除要返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>452. Minimum Number of Arrows to Burst Balloons</title>
      <link href="/post/minimum-number-of-arrows-to-burst-balloons/"/>
      <url>/post/minimum-number-of-arrows-to-burst-balloons/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/</a></strong></p><p><strong>題意</strong>：有一些氣球貼在 XY 平面上, 給一 array <code>points</code>, 其中 <code>points[i] = [x_start, x_end]</code> 代表氣球水平直徑在 <code>x_start</code> 和 <code>x_end</code> 的氣球。</p><p>一支弓箭可沿著 <code>x</code> 軸<strong>完全垂直</strong>地射出。在座標 <code>x</code> 射出弓箭, 若有一個氣球的直徑滿足 <code>x_start **≤** x **≤** x_end</code>, 則該氣球會被<strong>引爆</strong>。弓箭被射出後, 可以無限地前進。</p><p>返回引爆所有氣球的<strong>最小</strong>弓箭數。</p></blockquote><p><img src="https://i.imgur.com/CcoEOgh.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p>想法：利用 Greedy, 每增加一支箭, 想辦法讓那支箭盡可能地引爆多一點的氣球。每一支箭的射出位置為「所有氣球中右邊界位置最靠左的」可以引爆最多氣球。如果某個氣球的起始點大於 end, 說明前面的箭無法覆蓋到當前的氣球, 那麼就得再來一支箭</p><p>e.g. <code>points = [[1, 10], [2, 7], [8, 11]]</code>+</p><ul><li>當只有 <code>[[1, 10]</code>, <code>[2, 7]]</code> 時, 此時弓箭射在 <code>x = 7</code> 的位置可同時引爆這兩個氣球, 而下一個氣球的 start 必須 <code>≤ 7</code> 才能用同一支箭引爆</li><li>但下一個為 <code>[8, 11]</code>, 所以必須要新增一支箭</li></ul><p><img src="https://i.imgur.com/f4j4N7B.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort by start</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= end) &#123; <span class="comment">// 若有重疊, 則縮小右邊界, 必須考慮到先前的氣球</span></span><br><span class="line">                end = <span class="built_in">min</span>(end, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若無重疊, 則更新右邊界, 換下一支箭</span></span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p>想法：同 Solution 1, 只是 sort by end</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort by end</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 若無重疊, 則更新右邊界, 換下一支箭</span></span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; end) &#123;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>852. Peak Index in a Mountain Array</title>
      <link href="/post/peak-index-in-a-mountain-array/"/>
      <url>/post/peak-index-in-a-mountain-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/">https://leetcode.cn/problems/peak-index-in-a-mountain-array/</a></strong></p><p><strong>題意</strong>：如果以下屬性成立，我們就稱 <code>arr</code> 為山。</p><ul><li><code>arr.length &gt;= 3</code></li><li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i]</code></li><li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul><p>找到 <code>arr</code> 的山峰 <code>idx = i</code>, 滿足<code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></p></blockquote><p><img src="https://i.imgur.com/8Yv9RHU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 不斷找中點, 並和後面一數比較, 判斷要往左邊還右邊來縮小範圍</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt;= arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>162. Find Peak Element</title>
      <link href="/post/find-peak-element/"/>
      <url>/post/find-peak-element/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>nums</code>, 找到峰值並返回其 index。<code>nums</code> 中可能有多個峰值, 返回<strong>任何一個</strong>峰值的 index 即可。</p><p>假設 <code>nums[-1] = nums[n] = -∞</code></p><p>設計 $O(log(n))$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/vyhitL2.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 從一個位置開始, 不斷地向高處走, 那麼最終一定可以到達一個峰值位置, 根據比較 <code>nums[i − 1]</code>, <code>nums[i]</code>, <code>nums[i + 1]</code> 三個位置的值來縮小左邊界 or 右邊界, 有以下幾種情況：</strong></p><ol><li><code>nums[i − 1] &lt; nums[i] &gt; nums[i + 1]</code> : <code>i</code> 即為峰值</li><li><code>nums[i − 1] &lt; nums[i] &lt; nums[i + 1]</code> : <code>i</code> 處於上坡, 峰值在右半邊, 故縮小<strong>左</strong>邊界</li><li><code>nums[i − 1] &gt; nums[i] &gt; nums[i + 1]</code> : <code>i</code> 處於下坡, 峰值在左半邊, 故縮小<strong>右</strong>邊界</li><li><code>nums[i − 1] &gt; nums[i] &lt; nums[i + 1]</code> : <code>i</code> 處於山谷, 兩側都是上坡, 可以朝任意方向走(這邊我們選擇往右走, 故縮小<strong>左</strong>邊界)</li></ol><p>分析前面四種可能的情況, 我們選擇比較 <strong><code>nums[i]</code>、 <code>nums[i + 1]</code></strong><br>➔ <strong>因為這樣可將情況 1、3 是視作一類, 而情況 2、4 視作另一類</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>81. Search in Rotated Sorted Array II</title>
      <link href="/post/search-in-rotated-sorted-array-ii/"/>
      <url>/post/search-in-rotated-sorted-array-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/</a></strong></p><p><strong>題意</strong>：存在一整數 array <code>nums</code>, 按非降序排列, <code>nums</code> 中的數值有可能會重複。</p><p>給一<strong>旋轉後</strong>的 <code>nums</code> 和一整數 <code>target</code>, 如果 <code>nums</code> 中存在 <code>target</code>, 則返回其 <code>true</code>; 否則, 返回 <code>false</code>。</p><p>盡可能地減少操作步驟。</p></blockquote><p><img src="https://i.imgur.com/yL9ycmg.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：類似 <a href="https://zako945.github.io/post/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a>, 差別在本題的 <code>nums</code> 可能會有重複數, 導致 <code>nums[left] == nums[mid]</code> 時, 無法判斷 <code>[left, mid]</code> 和 <code>[mid + 1, right]</code> 哪個才是有序的</strong></p><p>e.g. <code>nums = [1,1,1,0,1]</code>, <code>target = 0</code><br>無法判斷 <code>[0,2]</code> 和 <code>[3,4]</code> 哪個才是有序的。</p><p>對於這種情況, 將 <code>left + 1</code>, 然後在新區間繼續做 Binary Search</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ worse case：元素均相等, 且不為 <code>target</code>, 則需拜訪所有位置才能得出結果</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>240. Search a 2D Matrix II</title>
      <link href="/post/search-a-2d-matrix-ii/"/>
      <url>/post/search-a-2d-matrix-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">https://leetcode.cn/problems/search-a-2d-matrix-ii/</a></strong></p><p><strong>題意</strong>：設計一高效演算法來搜索 <code>m x n</code> matrix 中是否存在整數 <code>target</code>, matrix 滿足以下特性:</p><ul><li>每行的元素由上到下按升序排列</li><li>每列的元素由左到右按升序排列</li></ul></blockquote><p><img src="https://i.imgur.com/rhxdVz1.png"></p><p><img src="https://i.imgur.com/wply250.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：對每一列做 Binary Search, 判斷 <code>target</code> 是否在該列中，從而判斷 <code>target</code> 是否出現</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; m; ++row) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (matrix[row][mid] &gt;= target) &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 當 matrix 中所有的元素都比 target 小 (target 不存在), left 會越界</span></span><br><span class="line">            <span class="comment">// 所以在存取 matrix[row][left] 前, 要先判斷 left 是否越界, 否則存取會出錯</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; n &amp;&amp; matrix[row][left] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// not found</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot log(n))$ ➔ 對每一列做 Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Z 字形搜索, 從 <code>matrix</code> 右上角(左下角也行)開始</strong></p><ul><li><p><strong>若 <code>matrix[row][col] == target</code> : 則 return <code>true</code></strong></p></li><li><p><strong>若 <code>matrix[row][col] &gt; target</code> : 則代表 <code>matrix[row ~ m][col]</code> 都比 <code>target</code> 大, 故 <code>col - 1</code></strong></p><p>  <img src="https://i.imgur.com/oouaKHO.png"></p></li><li><p><strong>若 <code>matrix[row][col] &lt; target</code> : 則代表 <code>matrix[row][col ~ n]</code> 都比 <code>target</code> 小, 故 <code>row + 1</code></strong></p><p>  <img src="https://i.imgur.com/fjttTzY.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target) &#123;</span><br><span class="line">                ++row;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --col;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// not found</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 在搜索的過程中，如果我們沒有找到<code>target</code>, 那麼我們要馬將 <code>y - 1</code>, 要馬將 <code>x + 1</code>。由於 <code>(x, y)</code> 的初始值為 <code>(0, n - 1)</code>, 因此是 <code>y</code> 最多能被減少 <code>n</code> 次, <code>x</code> 最多能被增加 <code>m</code> 次, 總搜索次數為 <code>m + n</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>658. Find K Closest Elements</title>
      <link href="/post/find-k-closest-elements/"/>
      <url>/post/find-k-closest-elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-k-closest-elements/">https://leetcode.cn/problems/find-k-closest-elements/</a></strong></p><p><strong>題意</strong>：給一已排序的 array <code>arr</code> 以及兩整數 <code>k</code> 和 <code>x</code>, 從 <code>arr</code> 中找到最接近 <code>x</code> 的 <code>k</code> 個數。返回的 array 必須是已排序好的。</p><p>整數 <code>a</code> 比整數 <code>b</code> 更接近 <code>x</code> 須滿足：</p><ul><li><code>|a - x| &lt; |b - x|</code>（<code>a</code> 比 <code>b</code> 更靠近 <code>x</code>） 或</li><li><code>|a - x| == |b - x|</code> 且 <code>a &lt; b</code>（兩者到 <code>x</code> 的距離相等, 但 <code>a</code> 比 <code>b</code> 小）</li></ul></blockquote><p><img src="https://i.imgur.com/FbefD1n.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：由於 <code>arr</code> 是有序的, 所以最後返回的 <code>k</code> 個元素也一定是有序的, 其實就是返回了原 array 中的一個長度為 <code>k</code> 的 subarray。實際上相當於在長度為 <code>n</code> 的 array 中去掉 <code>n - k</code> 個數字, 而且去掉的順序肯定是從兩頭開始, 因為距離 <code>x</code> 最遠的數字肯定在首尾出現。</strong></p><p>➔ <strong>每次比較首尾兩個數字跟 <code>x</code> 的距離, 並刪除距離較大的數字, 直到剩餘的 array 長度為 k 為止</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (arr.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x - arr.<span class="built_in">front</span>() &lt;= arr.<span class="built_in">back</span>() - x) &#123;</span><br><span class="line">                arr.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr.<span class="built_in">erase</span>(arr.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n-k)$ ➔ while loop, 其中 <code>n</code> 為 <code>arr.size()</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除要返回的 array, 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用移動 window, 從位置 <code>i</code> 開始延伸出去的長度為 <code>k</code> 的 window(其中 <code>0 ≤ i ≤ n-k</code>)</strong></p><p><strong>以下圖為例, <code>nums = [1,2,3,4,5]</code>, 其中每個不同顏色的框代表不同的 window</strong></p><p><img src="https://i.imgur.com/kqNglvc.png"></p><p>➔ <strong>利用 Binary Search, 算出 mid 後, 先看最左邊元素為 mid 的 window, 然後其右邊一個的 window 進行比較</strong></p><p>e.g. 圖中, <code>mid = 2</code>, 故當前 window 為藍框的 <code>[3,4]</code>, 右邊一個的 window 為紫框的 <code>[4,5]</code></p><p>透過比較 <code>arr[mid]</code> 及右邊一個的 window 中最右的元素 <code>arr[mid + k]</code> 來決定要往哪繼續做 Binary Search</p><p>e.g. 透過上例, 比較 <code>3</code> 和 <code>5</code> 來決定要縮小左邊界 or 右邊界</p><p>由於 5 比較接近 <code>x = 5</code>, 故往右走(右半邊剩下的 window 繼續做 Binray Search)</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>() - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比較 arr[mid] 和右邊一個 window 中最右的元素哪個比較接近 x</span></span><br><span class="line">            <span class="keyword">if</span> (x - arr[mid] &gt; arr[mid + k] - x) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(arr.<span class="built_in">begin</span>() + left, arr.<span class="built_in">begin</span>() + left + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n) + k)$<ul><li>$O(log(n))$：binary search</li><li>$O(k)$：建立返回的 array</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 扣除要返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>209. Minimum Size Subarray Sum</title>
      <link href="/post/minimum-size-subarray-sum/"/>
      <url>/post/minimum-size-subarray-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></strong></p><p><strong>題意</strong>：給一正整數 array <code>nums</code> 和一正整數 <code>target</code>, 返回滿足元素和  <code>≥ target</code> 的長度最小的<strong>連續 subarray</strong>, 如果不存在這樣的 subarray 則返回 <code>0</code>。</p><p><strong>進階</strong>：設計 $O(n \cdot log(n))$ time 和 $O(n)$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/llcfQcb.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window</strong></p><ul><li>先擴大窗口, 直到窗口裡的元素總和 <code>sum ≥ target</code></li><li>此時, 開始縮小窗口, 並同時更新 <code>res</code>, 直到 <code>sum &lt; target</code></li><li>重複上述步驟, 直到 <code>right</code> 到 <code>nums</code> 的結尾</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n + <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, right - left); <span class="comment">// 此時, sum 是符合要求的, 故在此更新 res</span></span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res == n + <span class="number">1</span>) ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>nums</code> 中的元素每個最多被遍歷 2 次(<code>left</code>, <code>right</code>)</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>904. Fruit Into Baskets</title>
      <link href="/post/fruit-into-baskets/"/>
      <url>/post/fruit-into-baskets/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/fruit-into-baskets/">https://leetcode.cn/problems/fruit-into-baskets/</a></strong></p><p><strong>題意</strong>：有一農場種植了一排果樹, 用 <code>fruits</code> 表示, 其中 <code>fruits[i]</code> 代表第 <code>i</code> 棵樹的水果<strong>種類</strong>。</p><p>農場主人設立了一些規矩, 你必須按照規矩採收:</p><ul><li>你只有<strong>兩個</strong>籃子, 每個籃子只能裝<strong>單一種類</strong>的水果。每個籃子能裝的水果總量沒有限制。</li><li>可以選擇任一棵樹開始採收, 你必須從<strong>每棵</strong>樹上<strong>恰摘一個水果</strong>。採收的水果須符合籃子中的水果種類。每採一次, 就要往右移動到下一棵樹繼續採收。</li><li>一旦某棵樹的水果不符合籃子中的種類, 就必須停止採收。</li></ul><p>返回可以採收的水果的<strong>最大</strong>數目。</p></blockquote><p><img src="https://i.imgur.com/6BqvwxT.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法: 利用 Sliding Window</strong></p><ul><li>先擴大窗口, 直到 <code>window</code> 中的種類超過 2 種（<code>window.size() &gt; 2</code>）</li><li>此時, 開始縮小窗口, 直到 <code>window.size() == 2</code>。注意：<strong>當某個種類的個數為 <code>0</code> 時, 要將其從 <code>window</code> 中移除</strong>, 不然 <code>window.size()</code> 無法減少</li><li>跳出內層 while loop 時, 代表 <code>window.size() == 2</code>, 故在此處更新 <code>res</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; fruits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ++window[fruits[right]];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (window.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--window[fruits[left]] == <span class="number">0</span>) &#123; <span class="comment">// 數量為 0 時, 要將其從 window 中移除</span></span><br><span class="line">                    window.<span class="built_in">erase</span>(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>fruits</code> 中的元素每個最多被遍歷 2 次（<code>left</code>, <code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code> 的長度不會超過 2, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>767. Reorganize String</title>
      <link href="/post/reorganize-string/"/>
      <url>/post/reorganize-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reorganize-string/">https://leetcode.cn/problems/reorganize-string/</a></strong></p><p><strong>題意</strong>：給一 string <code>s</code>, 重新建構 <code>s</code> 使得相鄰的 char 不同。</p><p>返回 <code>s</code> 任何可能的排列。若不可行, 則返回 <code>&quot;&quot;</code>。</p></blockquote><p><img src="https://i.imgur.com/TBHoTku.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap, 若有 char 的出現次數超過 $\dfrac{n+1}{2}$, 則不可能存在相鄰 char 不同的 string</strong></p><ul><li>建立 max heap</li><li>每次從 heap 中取兩個 top, 保證這兩個 char 必不相同</li><li>取出 top 後, 其 <code>count - 1</code> 若 <code>&gt; 0</code>, 將其 push 回 heap 中</li><li>跳出 while loop 是因為 <code>pq.size() &lt; 2</code><ul><li>若 <code>pq.size() == 1</code>：<code>s</code> 要加上 <code>pq.top()</code></li><li>若 <code>pq.size() == 0</code>：直接返回 <code>s</code></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reorganizeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freq[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt; pq; <span class="comment">// max heap</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> half = (s.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ch, num] : freq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; half) &#123; <span class="comment">// 若超過 (n+1) / 2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(num, ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> top1 = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> top2 = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            s += top1.second;</span><br><span class="line">            s += top2.second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--top1.first &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(top1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--top2.first &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(top2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s += pq.<span class="built_in">top</span>().second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(n) + O(26 \cdot log(n))$<ul><li>$O(n)$：第一個 for loop, 和 while loop 中重構 <code>s</code></li><li>$O(26 \cdot log(n))$：第二個 for loop 最多 insert <code>26</code> 次</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>freq</code> 和 <code>pq</code> 最多 <code>26</code> 個元素, 且 <code>s</code> 為 input string, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>451. Sort Characters By Frequency</title>
      <link href="/post/sort-characters-by-frequency/"/>
      <url>/post/sort-characters-by-frequency/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sort-characters-by-frequency/">https://leetcode.cn/problems/sort-characters-by-frequency/</a></strong></p><p><strong>題意</strong>：給一 string <code>s</code>, 根據每個 char 出現的<strong>頻率</strong>對其進行降序排列。</p><p>返回已排序過的 string, 若有多個答案, 則返回其中任意一個。</p></blockquote><p><img src="https://i.imgur.com/kOcMCTl.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap</strong></p><ul><li>計算 <code>s</code> 中每個元素的出現頻率</li><li>將 <code>&#123;char, cnt&#125;</code> push 到 max heap 中</li><li>不斷取出 top 直到 heap 為空, s<code>.append(cnt, char)</code> 代表 <code>s</code> 一次新增 <code>cnt</code> 個 char</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt; q; <span class="comment">// max heap</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freq[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ch, cnt] : freq) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(cnt, ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [cnt, ch] = q.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">append</span>(cnt, ch);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(n) + O(26 \cdot log(n))$<ul><li>$O(n)$：第一個 for loop 和 while loop 的 <code>s.append()</code></li><li>$O(26 \cdot log(n))$：第二個 for loop 和 while loop, 因為 char 最多 <code>26</code> 種, 因此 <code>q</code> 的元素不超過 <code>26</code> 個</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 因為 <code>freq</code> 和 <code>q</code> 最多 <code>26</code> 個元素, 且 <code>s</code> 為 input string, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>310. Minimum Height Trees</title>
      <link href="/post/minimum-height-trees/"/>
      <url>/post/minimum-height-trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-height-trees/">https://leetcode.cn/problems/minimum-height-trees/</a></strong></p><p><strong>題意</strong>：給一數字 <code>n</code> 和 <code>n - 1</code> 條無向邊的 <code>edges</code> list, 代表一包含 <code>n</code> 個 node 編號從 <code>0</code> 到 <code>n - 1</code> 的 tree。</p><p>可選擇 tree 中任意 node 作為 root。在所有可能的 tree 中, 具有<strong>最小高度</strong>的 tree 被稱為<strong>最小高度樹</strong>。</p><p>找到所有最小高度樹的 root 並按<strong>任意順序</strong>返回。</p></blockquote><p><img src="https://i.imgur.com/BuWJ3tx.png"></p><p><img src="https://i.imgur.com/dFTerX5.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + BFS, 我們發現若希望高度越小, 則 root 應選 degree 越大的。</strong></p><p><strong>下圖中, 紅圈以外的是 leaf, 若將這些點作為 root, 其樹高不可能為最小的, 原因如下:</strong></p><ul><li><p>若將 leaf 作為 root, 其樹高的路徑必「走進」紅圈, 再「走出」紅圈</p></li><li><p>若將 non-leaf 為 root, 其樹高的路徑只需「走出」紅圈</p><p>  <img src="https://i.imgur.com/Ri0pdIh.png"></p></li></ul><p>➔ <strong>故可透過「剝洋蔥」的方式, 一層一層剝掉 degree &#x3D; 1 的 node, 直到剩下 ≤ 兩個 node。</strong></p><p><strong>思考: 為何不是三個 node 就停呢? 因為三個 node 可以繼續剝下去</strong></p><p><img src="https://i.imgur.com/fzbebcY.png"></p><p><strong>特殊情況：當 tree 只有一個 node 時, 則答案即為該 node 本身</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="comment">// 特殊情況</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n); <span class="comment">// adjacency list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj[i].<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> k = q.<span class="built_in">size</span>();</span><br><span class="line">            n -= k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 讓 adjacent node 的 degree - 1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                    adj[v].<span class="built_in">erase</span>(cur);</span><br><span class="line">                    <span class="keyword">if</span> (adj[v].<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>time：</strong>$O(n)$ ➔ $O(n+(n-1))$, 其實就是對圖進行 BFS 所需之時間複雜度 $O(V+E)$</p><ul><li>$O(V)$：<code>n</code> 個 node</li><li>$O(E)$：<code>n - 1</code> 條 edge, 因為 tree 是 acyclic</li></ul></li><li><p><strong>space：</strong>$O(n)$ ➔ $O(n+(n-1))$, 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</p><p>  <img src="https://i.imgur.com/qdZwrCz.png"></p></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS, tree 中最長 path 的兩端點皆必為 leaf, 否則 path 可繼續拓展, 我們的目標就是找出最長 path 之中點</strong></p><ul><li>先隨機選取一個 node（可能不為 leaf）, 並對其進行 dfs 取得離它最遠的點 <code>n1</code>（第一個 leaf）</li><li>對 <code>n1</code> 進行 dfs 取得離它最遠的點 <code>n2</code>（第二個 leaf）</li><li>此時, <code>n1 -&gt; n2</code> 為 tree 中<strong>最長的 path</strong>, 其 path 之中點即為答案<ul><li>若 path 長度為奇數, 則取 <code>&#123;path[len / 2]&#125;</code></li><li>若 path 長度為偶數, 則取 <code>&#123;path[(len / 2) - 1], path[len / 2]&#125;</code></li></ul></li></ul><p>e.g. 下圖中</p><ul><li><p>首先選取 <code>1</code> 並做 dfs 取得 <code>n1 = 6</code></p></li><li><p>再對 <code>n1</code> 做 dfs 得 <code>n2 = 7</code>。 <code>n1 -&gt; n2</code> 之 path 長度為 5（<code>6 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 7</code>）</p></li><li><p>取 path 中點 1 會得到最小高度樹</p><p>  <img src="https://i.imgur.com/zTAGRzt.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n); <span class="comment">// adjacency list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n1 = <span class="built_in">findFarestNode</span>(<span class="number">0</span>, parent, adj, n);</span><br><span class="line">        <span class="type">int</span> n2 = <span class="built_in">findFarestNode</span>(n1, parent, adj, n);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        parent[n1] = <span class="number">-1</span>; <span class="comment">// 將 n1 的 parent 設為 -1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="number">-1</span>) &#123; <span class="comment">// 從 n2 往 n1 走, 並把 node 加到 path 中</span></span><br><span class="line">            path.<span class="built_in">emplace_back</span>(n2);</span><br><span class="line">            n2 = parent[n2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> k = path.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;path[k / <span class="number">2</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;path[(k / <span class="number">2</span>) - <span class="number">1</span>], path[k / <span class="number">2</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFarestNode</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">const</span> vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt;&amp; adj, <span class="type">int</span>&amp; n)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        dis[cur] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(cur, dis, adj, parent);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> node = <span class="number">0</span>; <span class="comment">// farest node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            node = (dis[i] &gt; dis[node]) ? i : node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; dis, <span class="type">const</span> vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt;&amp; adj, vector&lt;<span class="type">int</span>&gt;&amp; parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dis[v] = dis[cur] + <span class="number">1</span>;</span><br><span class="line">                parent[v] = cur;</span><br><span class="line">                <span class="built_in">dfs</span>(v, dis, adj, parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(n+(n-1))$, 其實就是對圖進行 DFS 所需之時間複雜度 $O(V+E)$<ul><li>$O(V)$：<code>n</code> 個 node</li><li>$O(E)$：<code>n - 1</code> 條 edge, 因為 tree 是 acyclic</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ $O(n+(n-1))$, 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>444. Sequence Reconstruction</title>
      <link href="/post/sequence-reconstruction/"/>
      <url>/post/sequence-reconstruction/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sequence-reconstruction/">https://leetcode.cn/problems/sequence-reconstruction/</a></strong></p><p><strong>題意</strong>：給一 <code>[1, n]</code> 長度為 <code>n</code> 的整數 array <code>nums</code>, 以及一些 2d 整數 array <code>sequences</code>, 其中 <code>sequences[i]</code> 是 <code>nums</code> 的 subsequence。</p><p>返回 <code>sequences</code> 是否能唯一重建出 <code>nums</code>。</p><p>e.g. <code>nums = [1,2,3]</code>, <code>sequences = [[1,2], [1,3]]</code></p><ul><li><code>sequences</code> 可重建出 <code>[1,2,3]</code> 和 <code>[1,3,2]</code> 並不唯一, 故返回 <code>false</code>。因為 1 必須在 2、3 的前面, 但 2 和 3 間並沒有唯一的順序</li><li>但若更改 <code>sequences = [[1,2], [1,3], [2,3]]</code>, 則可唯一重建出 <code>[1,2,3]</code>, 故返回 <code>true</code>。因為 1 必須在 2、3 的前面, 且 2 必須在 3 的前面, 故只能重建出 <code>[1,2,3]</code></li></ul></blockquote><p><img src="https://i.imgur.com/MiIRJjn.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + BFS, 將 <code>sequences</code> 轉成有向圖, 給定的順序 <code>nums</code> 等價於有向圖的 Topological Sort</strong></p><ul><li>首先, 計算每個點的 <code>inDegree</code></li><li>將所有 <code>inDegree = 0</code> 的 node 加到 <code>queue</code> 中, 並進行 Topological Sort</li><li><code>queue</code> 中的元素個數表示可以作為下一個數字的元素個數<ul><li>若 <code>queue</code> 中的元素個數 <code>&gt; 1</code>, 則下一個數字並不唯一, 應返回 <code>false</code></li><li>若 <code>queue</code> 中的元素個數 <code>= 1</code>, 則下一個數字是唯一的數字。並將該數字從 <code>queue</code> 取出, 且該數字指向的每個數字的 <code>inDegree - 1</code>, 並將 <code>inDegree</code> 變成 <code>0</code> 的數字加到 <code>queue</code> 中</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; sequences)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// nums 由 [1, n] 組成, 而非 [0, n-1]</span></span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>); <span class="comment">// adjacency list</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; seq : sequences) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; seq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> pre = seq[i - <span class="number">1</span>], cur = seq[i];</span><br><span class="line">                adj[pre].<span class="built_in">emplace</span>(cur);</span><br><span class="line">                ++inDegree[cur];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 遍歷 node 1 ~ n</span></span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 下一個數字的選擇不唯一</span></span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把 cur 給 pop 掉後, 將 cur 的 adjacent vertex 之 in degree - 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n+m)$ ➔ <code>bfs()</code> 所需的時間複雜度 $O(V+E)$<ul><li><code>n</code> 為 <code>nums</code> 的個數(即為 vertex 數)</li><li><code>m</code> 為 <code>sequences</code> 的個數(即為 edge 數)</li></ul></li><li><strong>space：</strong>$O(n+m)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>107. Binary Tree Level Order Traversal II</title>
      <link href="/post/binary-tree-level-order-traversal-ii/"/>
      <url>/post/binary-tree-level-order-traversal-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></strong></p><p><strong>題意</strong>：給一 BT 的 <code>root</code>, 返回 <code>node.val</code> <strong>由下往上的 level order</strong>（由下層往上層, 每層由左至右）。</p></blockquote><p><img src="https://i.imgur.com/xU5BDit.png"></p><p><img src="https://i.imgur.com/eAyKwcZ.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS, 同 <a href="https://zako945.github.io/post/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a>, 只是多了 reverse</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i ) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 <code>res</code>, 在 while loop 迭代的過程中, <code>q</code> 的元素個數不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS, 同 <a href="https://zako945.github.io/post/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a>, 只是多了 reverse</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, res);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">const</span> <span class="type">int</span> depth, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &lt;= depth) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[depth].<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, depth + <span class="number">1</span>, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, depth + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>103. Binary Tree Zigzag Level Order Traversal</title>
      <link href="/post/binary-tree-zigzag-level-order-traversal/"/>
      <url>/post/binary-tree-zigzag-level-order-traversal/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></strong></p><p><strong>題意</strong>：給一 BT 的 <code>root</code>, 返回 <code>node.val</code> 的 zigzag（鋸齒形）level order（先從左往右, 而下一層從右往左遍歷, 依此類推, 層與層之間交替進行）。</p></blockquote><p><img src="https://i.imgur.com/MpDtXeS.png"></p><p><img src="https://i.imgur.com/08Ryign.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (depth % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(level.<span class="built_in">begin</span>(), level.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            depth++;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 <code>res</code>, 在 while loop 迭代的過程中, <code>q</code> 的元素個數不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; res.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(res[i].<span class="built_in">begin</span>(), res[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> depth, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &lt;= depth) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[depth].<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, depth + <span class="number">1</span>, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, depth + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>116. Populating Next Right Pointers in Each Node</title>
      <link href="/post/populating-next-right-pointers-in-each-node/"/>
      <url>/post/populating-next-right-pointers-in-each-node/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/</a></strong></p><p><strong>題意</strong>：給一 perfect BT, 其所有 leaf 皆在同一層, 且每個 non-leaf 皆有兩個 child。BT 定義如下:</p><p><img src="https://i.imgur.com/Fd8JsoK.png"></p><p>填充每個 node 的 <code>next</code>, 讓 <code>next</code> 指向其右邊的 node。<br>若右邊沒有 node, 則指向 <code>NULL</code>。所有 <code>next</code> 預設皆為 <code>NULL</code>。</p><p><strong>進階</strong>：</p><ul><li>設計 $O(1)$ space 的演算法</li><li>可以使用遞迴解題, 遞迴所用到的 stack space 不算做額外的 space</li></ul></blockquote><p><img src="https://i.imgur.com/F9TQnGD.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i &lt; len - <span class="number">1</span>) &#123; <span class="comment">// 每層最後一個的 next 不用改(因為預設為 NULL)</span></span><br><span class="line">                    cur-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 <code>res</code>, 在 while loop 迭代的過程中, <code>q</code> 的元素個數不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS, 使用 pre-order</strong></p><ul><li>先將 <code>root-&gt;left-&gt;next</code> 指向 <code>root-&gt;right</code></li><li>再將 <code>root-&gt;right-&gt;next</code> 指向 <code>root-&gt;next-&gt;left</code>(因為先前已經將 root-&gt;next 指向其右邊的 node)</li><li>然後使用遞迴呼叫 <code>left</code>, <code>right</code> child</li></ul><p>e.g. 下圖中</p><ul><li><p>第一次 <code>dfs(root)</code> 的時候已經將 <code>a-&gt;next</code> 指向 <code>d</code></p></li><li><p>第二次 <code>dfs(a)</code> 時, <code>b</code> 透過 <code>a</code> 指向 <code>c</code>, 且 <code>c</code> 透過 <code>a-&gt;next = d</code> 指向 <code>e</code></p><p>  <img src="https://i.imgur.com/1X9o0Gb.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不判斷 root-&gt;right 是因為 perfect BT 中若 root 沒有 left child</span></span><br><span class="line">        <span class="comment">// 則 root 一定不會有 right child</span></span><br><span class="line">        <span class="comment">// 因為下面需存取 root-&gt;left-&gt;next, 所以必須保證 root-&gt;left 不為 null</span></span><br><span class="line">        <span class="keyword">if</span> (!root || !root-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next) &#123; <span class="comment">// 執行到這行, root-&gt;right 必定不為 null(因為是 perfect BT)</span></span><br><span class="line">            root-&gt;right-&gt;next = root-&gt;next-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(log(n))$ ➔ perfect BT 的深度為 $log(n)$</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3</strong>：</h2><blockquote><p><strong>想法：改進 Solution 2, 用 iterative 的方式將 space 降到 $O(1)$</strong></p><ul><li><code>cur</code> 由左至右遍歷第 <code>N</code> 層, 而 <code>nxt</code> 指向第 <code>N + 1</code> 層的第一個 node</li><li>while loop 中, <code>cur</code> 會將其 child 的 <code>next</code> 指向正確的 node</li><li>若 <code>cur</code> 走到第 <code>N</code> 層的結尾, 則 <code>cur</code> 移動到下一層(也就是 <code>nxt</code>)</li></ul><p>當 <code>cur</code> 遍歷第 <code>N</code> 層的時候, <code>nxt</code> 會一邊串接起第 <code>N + 1</code> 層的 <code>next</code> pointer。遍歷完第 <code>N</code> 層的時候, 意味著第 <code>N + 1</code> 層也已經透過 <code>next</code> pointer 串接起來了, 這時候 <code>cur</code> 再往第 <code>N + 1</code> 層移動</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node *cur = root, *nxt = root-&gt;left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; nxt) &#123;</span><br><span class="line">            cur-&gt;left-&gt;next = cur-&gt;right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next) &#123;</span><br><span class="line">                cur-&gt;right-&gt;next = cur-&gt;next-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cur 的 child 已經做完, 移動到下一個 node (cur 右邊的 node)</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cur 走到第 N 層的 end, 則 cur 指向第 N + 1 層</span></span><br><span class="line">            <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">                cur = nxt;</span><br><span class="line">                nxt = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>117. Populating Next Right Pointers in Each Node II</title>
      <link href="/post/populating-next-right-pointers-in-each-node-ii/"/>
      <url>/post/populating-next-right-pointers-in-each-node-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/</a></strong></p><p><strong>題意</strong>：給一 BT, 其中每一個 node 的定義如下:</p><p><img src="https://i.imgur.com/O65DPXo.png"></p><p>將每個 node 的 <code>next</code> 指向其右邊的 node。若不存在右邊的 node, 則 <code>next</code> 應指向 <code>NULL</code>。<br>所有 <code>next</code> 預設皆為 <code>NULL</code>。</p><p><strong>進階</strong>：</p><ul><li>設計 $O(1)$ space 的演算法</li><li>可以使用遞迴解題, 遞迴所用到的 stack space 不算做額外的 space</li></ul></blockquote><p><img src="https://i.imgur.com/pn8enM5.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">                    cur-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 <code>res</code>, 在 while loop 迭代的過程中, <code>q</code> 的元素個數不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：用 iterative + pointer 的方式將 space 降到 $O(1)$</strong></p><ul><li><code>dummy</code> 永遠指向第 <code>N + 1</code> 的第一個 node</li><li><code>cur</code> 由左至右遍歷第 <code>N</code> 層, 而 <code>nxt</code> 拜訪第 <code>N + 1</code> 層 node 的前一個 node</li></ul><p>當 <code>cur</code> 遍歷第 <code>N</code> 層的時候, <code>nxt</code> 會一邊串接起第 <code>N + 1</code> 層的 <code>next</code> pointer。遍歷完第 <code>N</code> 層的時候, 意味著第 <code>N + 1</code> 層也已經透過 <code>next</code> pointer 串接起來了, 這時候 <code>cur</code> 再往第 <code>N + 1</code> 層移動</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node *dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line">        Node *cur = root, *nxt = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                nxt-&gt;next = cur-&gt;left;</span><br><span class="line">                nxt = nxt-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                nxt-&gt;next = cur-&gt;right;</span><br><span class="line">                nxt = nxt-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cur 的 child 已經做完, 移動到下一個 node (cur 右邊的 node)</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cur 走到第 N 層的 end, 則 cur 指向第 N + 1 層</span></span><br><span class="line">            <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">                cur = dummy-&gt;next;</span><br><span class="line">                nxt = dummy; <span class="comment">// 重置 nxt</span></span><br><span class="line">                dummy-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 重置 dummy-&gt;next</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 被遍歷一次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>863. All Nodes Distance K in Binary Tree</title>
      <link href="/post/all-nodes-distance-k-in-binary-tree/"/>
      <url>/post/all-nodes-distance-k-in-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/">https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/</a></strong></p><p><strong>題意</strong>：給一 BT 的 <code>root</code>, 和一目標點 <code>target</code>, 以及一整數 <code>k</code>。</p><p>返回所有距離目標點 <code>target</code> 為 <code>k</code> 的 node, 可以用<strong>任何順序</strong>返回。</p><p>tree 中每個 <code>node.val</code> 都不同。</p></blockquote><p><img src="https://i.imgur.com/iLmNwNU.png"></p><p><img src="https://i.imgur.com/s6Yg9n4.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + BFS</strong></p><ul><li>先用 DFS 建立無向圖</li><li>再以 <code>target</code> 為<strong>中心</strong>向外做 BFS</li></ul><p>e.g. <code>target = 5</code>, <code>k = 2</code></p><p><img src="https://i.imgur.com/v9l3yfz.png"></p><ul><li>以 <code>5</code> 為中心, 首先取出 3, 6, 2</li><li>然後 3 會取出 5, 1</li><li>依此類推…</li></ul><p>這邊必須小心, 因為我們建立的是無向圖, <strong>child 的 adj list 中是會有 parent 的</strong><br>以上面的為例, 3 向外擴散取出 5 跟 1。其中 1 是答案, 但 5 不是<br>因此, 得用一個 <code>visited</code> 來記錄拜訪過的 node</p><ul><li>若已經在 <code>visited</code> 裡則跳過</li><li>否則, 將其加入 <code>visited</code> 中</li></ul><p>這樣一來, 5 最一開始就會被加入到 <code>visited</code> 中<br>就算後面的 node 有跟 5 相鄰, 也不會把 5 加入到 res 中</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* root, TreeNode* target, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">buildGraph</span>(root);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        unordered_set&lt;TreeNode*&gt; visited;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出當前 level</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若已經拜訪過, 則跳過</span></span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">find</span>(cur) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 否則, 將 cur 設為已拜訪</span></span><br><span class="line">                visited.<span class="built_in">emplace</span>(cur);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 為距離 target 的第 k 層</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否則, 將其 adjacent node 加入到下一層</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            --k; <span class="comment">// 做完一層, 層數減一</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;TreeNode*, vector&lt;TreeNode*&gt;&gt; adj; <span class="comment">// adjacency list</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildGraph</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            adj[root].<span class="built_in">emplace_back</span>(root-&gt;left);</span><br><span class="line">            adj[root-&gt;left].<span class="built_in">emplace_back</span>(root);</span><br><span class="line">            <span class="built_in">buildGraph</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            adj[root].<span class="built_in">emplace_back</span>(root-&gt;right);</span><br><span class="line">            adj[root-&gt;right].<span class="built_in">emplace_back</span>(root);</span><br><span class="line">            <span class="built_in">buildGraph</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷常數次</li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 <code>res</code>, 在 while loop 迭代的過程中, <code>q</code> 的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>113. Path Sum II</title>
      <link href="/post/path-sum-ii/"/>
      <url>/post/path-sum-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/path-sum-ii/">https://leetcode.cn/problems/path-sum-ii/</a></strong></p><p><strong>題意</strong>：給一 BT 的 <code>root</code> 和一整數 <code>targetSum</code>, 返回所有 <strong>root-to-leaf</strong> 之路徑總和為 <code>targetSum</code> 的 path。</p></blockquote><p><img src="https://i.imgur.com/52MSlUK.png"></p><p><img src="https://i.imgur.com/dgqNYGb.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若為 leaf node</span></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val == targetSum) &#123;</span><br><span class="line">                cur.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">                cur.<span class="built_in">pop_back</span>(); <span class="comment">// 返回上一步時要拿掉當前 node</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不為 leaf node</span></span><br><span class="line">        cur.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>(); <span class="comment">// 返回上一步時要拿掉當前 node</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 概念同 <a href="https://zako945.github.io/post/path-sum/">112. Path Sum</a>, 只是要用 parent 紀錄每個 node 的 parent, 這樣找到符合的 path 時, 才能得到一條從 leaf to root 的 path, 將其反轉過後便是 root to leaf 的 path</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> pti = pair&lt;TreeNode*, <span class="type">int</span>&gt;;</span><br><span class="line">        queue&lt;pti&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(pti&#123;root, <span class="number">0</span>&#125;); <span class="comment">// sum 初始設 0, 而非 root-&gt;val, 因為等等會加上 root-&gt;val</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            TreeNode* curNode = front.first;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> curSum = front.second + curNode-&gt;val;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若為 leaf</span></span><br><span class="line">            <span class="keyword">if</span> (!curNode-&gt;left &amp;&amp; !curNode-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curSum == targetSum) &#123;</span><br><span class="line">                    <span class="comment">// curNode 的 parent 必不為 leaf, 故 curNode 的 parent 已被記錄</span></span><br><span class="line">                    <span class="built_in">getPath</span>(curNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;left) &#123;</span><br><span class="line">                    parent[curNode-&gt;left] = curNode; <span class="comment">// 紀錄 child 的 parent</span></span><br><span class="line">                    q.<span class="built_in">emplace</span>(pti&#123;curNode-&gt;left, curSum&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;right) &#123;</span><br><span class="line">                    parent[curNode-&gt;right] = curNode; <span class="comment">// 紀錄 child 的 parent</span></span><br><span class="line">                    q.<span class="built_in">emplace</span>(pti&#123;curNode-&gt;right, curSum&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    unordered_map&lt;TreeNode*, TreeNode*&gt; parent; <span class="comment">// &#123;cur_node : parent&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getPath</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get path from leaf to root</span></span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">            node = parent[node];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>()); <span class="comment">// get path from root to leaf</span></span><br><span class="line">        res.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 和 <code>parent</code> 的元素不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="/post/lowest-common-ancestor-of-a-binary-tree/"/>
      <url>/post/lowest-common-ancestor-of-a-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></strong></p><p><strong>題意</strong>：給一 BT 和兩 node <code>p</code> 和 <code>q</code>, 找出他們的 lowest common ancestor（LCA）<code>T</code>。</p></blockquote><p><img src="https://i.imgur.com/uf3aeCO.png"></p><p><img src="https://i.imgur.com/3MOWkHn.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 主要分成以三種情形：</strong></p><ul><li>無法在左子樹找到任何 target node, 代表 LCA 不可能在左子樹中, 因此 return 右子樹的結果。</li><li>無法在右子樹找到任何 target node, 代表 LCA 不可能在右子樹中, 因此 return 左子樹的結果。</li><li>若可分別在左右子樹中找到 target node, 代表 current root 為所求</li></ul><p>e.g. 下圖中, <code>root = 1</code>, <code>p = 4</code>, <code>q = 10</code></p><ul><li>以 <code>2</code> 為 root 時進行遞迴:<ul><li>left：return 4</li><li>right：return 10</li></ul></li><li>以 <code>1</code> 為 root 時進行遞迴:<ul><li>left：return 2 (因為其 left, right 皆非 null)</li><li>right：return null</li></ul></li></ul><p>➔ 故最後答案為 2</p><p><img src="https://i.imgur.com/GGCILZZ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!left) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// left, right 皆非 null, 返回 current root</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>437. Path Sum III</title>
      <link href="/post/path-sum-iii/"/>
      <url>/post/path-sum-iii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/path-sum-iii/">https://leetcode.cn/problems/path-sum-iii/</a></strong></p><p><strong>題意</strong>：給一 BT 的 <code>root</code> 和一整數 <code>targetSum</code>,　返回路徑總和等於 <code>targetSum</code> 的 path 個數。</p><p>path 不需從 <code>root</code> 開始, 也不需在 leaf 結束, 但 path 方向須是向下的（只能從父節點到子節點）。</p></blockquote><p><img src="https://i.imgur.com/uSnldfb.png"></p><p><img src="https://i.imgur.com/jlZJrqq.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p><ul><li><code>traverse()</code> 負責 DFS 遍歷整個 BT</li><li><code>countPath(root)</code> 負責計算在 <code>root</code> 為 root 的 BT 中, 以 <code>root</code> 為開頭，且和為 <code>targetSum</code> 的 path 個數</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root, targetSum, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 遍歷整個 BT</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="type">long</span> targetSum, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">countPath</span>(node, targetSum, res);</span><br><span class="line">        <span class="built_in">traverse</span>(node-&gt;left, targetSum, res);</span><br><span class="line">        <span class="built_in">traverse</span>(node-&gt;right, targetSum, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 計算以 node 為開頭, 且和為 targetSum 的 path 個數</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">countPath</span><span class="params">(TreeNode* node, <span class="type">const</span> <span class="type">long</span> targetSum, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val == targetSum) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// node-&gt;val 可以為負數, 所以繼續遍歷其左右子樹</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">countPath</span>(node-&gt;left, targetSum - node-&gt;val, res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">countPath</span>(node-&gt;right, targetSum - node-&gt;val, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$<ul><li>$O(n)$：<code>traverse()</code> 遍歷 BT 中所有 node</li><li>$O(n)$：每個 node 呼叫 <code>countPath()</code> 需 $O(n)$, 因為 worse case 為 skew tree</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS + Prefix Sum + Backtracking</strong></p><p><strong>prefix sum 的定義：root 到該點的 path 之和</strong></p><ul><li>node <code>4</code> 的 prefix sum 為：<code>1 + 2 + 4</code></li><li>node <code>8</code> 的 prefix sum 為：<code>1 + 2 + 4 + 8</code></li></ul><p><img src="https://i.imgur.com/6UXQf9n.png"></p><p><strong>prefix sum 的用途：兩節點之間的 path 和 &#x3D; 兩節點的 prefix sum 之差</strong></p><p>e.g. 以下圖為例</p><ul><li>node <code>1</code> 之 prefix sum：<code>1</code></li><li>node <code>3</code> 之 prefix sum：<code>1 + 2 + 3 = 6</code></li><li><code>prefix(3) - prefix(1) = 5</code>, 代表 node <code>1</code> 和 node <code>3</code> 之間存在一條和 &#x3D; 5 的 path (2 ➔ 3)</li></ul><p><img src="https://i.imgur.com/mSNMofG.png"></p><p>➔ 我們只需遍歷整棵 tree 一次, 記錄每個 node 的 prefix sum, 並查詢該 node 的 ancestor 中符合條件的個數, 將這些數量加到 res 上</p><p><strong>hash table 儲存的是什麼?</strong><br>hash table 的 key 是 prefix sum, 而 value 是該 prefix sum 的 node 數量, 記錄數量是因為有可能多個 node 擁有一樣的 prefix sum。</p><p>e.g. 下圖中, prefix sum &#x3D; 1 的 node 有兩個 (1, 0)</p><p><img src="https://i.imgur.com/yeSH9nm.png"></p><p>➔ hash table <strong>初始化為 <code>&#123;0, 1&#125;</code></strong> 代表 <strong>prefix sum &#x3D; 0 的 path 為一條</strong>, 因為當 tree 中只有一個 node 時, 且該 <code>node.val</code> 恰為 <code>targetSum</code> 時, res 應返回 <code>1</code>。</p><p><strong>恢復狀態的意義?</strong><br>因為題目要求只能<font color="#f00"><strong>從父節點到子節點</strong></font>, <strong>一個 node 的 prefix sum</strong> 加入到 hash table 裡時, <strong>只應對其 child node 有效</strong>。因此當遍歷完一個 node 的所有 child node, 並要返回其 parent node 時, 應恢復原先的狀態。</p><p>e.g. 下圖中, 假設 <code>targetSum = 8</code>, 當我們遍歷到最右方的 6 時, 此時的符合的 path 只應有 <code>0 ➔ B ➔ 6</code> 和 <code>B ➔ 6</code> 這兩條, 因為從 A 向下到不了 6。</p><p>如果我們不做狀態恢復, 當遍歷右子樹時, 左子樹中 A 的 perfix sum 仍會保留在 hash table 中, 此時 6 就會認為 A 和 B 都是可追溯到的 node, 而把 A ➔ 0 ➔ B ➔ 6 也當成合法路徑, 從而產生錯誤。</p><p><img src="https://i.imgur.com/QDG3xZx.png"></p><p>e.g. 下圖中, 假設 <code>targetSum = 2</code>, 當遍歷到 2 時, 此時 prefix &#x3D; {1, 2}<br>➔ 其 ancestor 中 prefix sum &#x3D; 1 的 node 有兩個(1, 0)<br>計算 prefix(2) &#x3D;  curSum &#x3D; 1 + node.val &#x3D; 3<br>res &#x3D; 0 + prefix[3-2] &#x3D; prefix[1] &#x3D; 2, 代表有兩個 node 到 2 之間的 path 為 <code>targetSum</code><br>➔ 1, 0 之間分別存在一條 path 到 2 為 <code>targetSum</code> (分別是 0 ➔ 2, 2)</p><p><img src="https://i.imgur.com/yeSH9nm.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        prefix[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化 prefix sum = 0 的 path 為一條</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, <span class="number">0</span>, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">long</span>, <span class="type">int</span>&gt; prefix; <span class="comment">// &#123;prefix_sum : path_num&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">long</span> curSum, <span class="type">const</span> <span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        curSum += node-&gt;val;</span><br><span class="line">        res += prefix[curSum - targetSum];</span><br><span class="line"></span><br><span class="line">        ++prefix[curSum];</span><br><span class="line">        res += <span class="built_in">dfs</span>(node-&gt;left, curSum, targetSum);</span><br><span class="line">        res += <span class="built_in">dfs</span>(node-&gt;right, curSum, targetSum);</span><br><span class="line">        --prefix[curSum];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ prefix 和遞迴深度皆不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>654. Maximum Binary Tree</title>
      <link href="/post/maximum-binary-tree/"/>
      <url>/post/maximum-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-binary-tree/">https://leetcode.cn/problems/maximum-binary-tree/</a></strong></p><p><strong>題意</strong>：給一不重複的的整數 array <code>nums</code>, 利用下面的演算法遞迴建構 Maximum BT：</p><ul><li>創建一個 root, 其值為 <code>nums</code> 中最大值</li><li>用最大值左邊的 subarray 遞迴建構左子樹</li><li>用最大值右邊的 subarray 遞迴建構右子樹</li></ul><p>返回 <code>nums</code> 建構的 Maximum BT。</p></blockquote><p><img src="https://i.imgur.com/HLNKBiH.png"></p><p><img src="https://i.imgur.com/H1oewr7.png"></p><p><img src="https://i.imgur.com/eaJtMYU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxIdx = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[maxIdx] &lt; nums[i]) &#123;</span><br><span class="line">                maxIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxIdx]);</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(left, maxIdx - <span class="number">1</span>, nums);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(maxIdx + <span class="number">1</span>, right, nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop 被呼叫 <code>n</code> 次<ul><li>best case：每次 $O(log(n))$, 每次取出 maxIdx 恰好將 array 切分成兩個長度一樣的 subarray<br>  e.g. <code>[1,3,2]</code> ➔ 取出 3, 得到兩個 subarray : <code>[1]</code> 和 <code>[2]</code></li><li>worse case：每次 $O(n)$, 其中 <code>nums</code> 由小到大, 每次取出 <code>maxIdx</code> 都為最右邊的 idx, 導致其中一個 subarray 為 empty array<br>  e.g. <code>[1,2,3]</code> ➔ 取出 3, 得到兩個 subarray : <code>[1,2]</code> 和 <code>[]</code></li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>662. Maximum Width of Binary Tree</title>
      <link href="/post/maximum-width-of-binary-tree/"/>
      <url>/post/maximum-width-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">https://leetcode.cn/problems/maximum-width-of-binary-tree/</a></strong></p><p><strong>題意</strong>：給一 BT 的 <code>root</code>, 返回該 tree 的<strong>最大寬度</strong>。</p><p>每一層的<strong>寬度</strong>被定義為兩個端點之間的長度（該層最左和最右的非空節點, 兩端點之間的 <code>null</code> 也計入長度）。</p><p>答案可用 32-bit 有號整數表示。</p></blockquote><p><img src="https://i.imgur.com/46jPNZ9.png"></p><p><img src="https://i.imgur.com/TIzTFG3.png"></p><p><img src="https://i.imgur.com/SqyND1h.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p><p>我們可以 assign idx 給每個 node, 然後計算出每層的寬度</p><ul><li>root &#x3D; 1</li><li>left &#x3D; 2 * parent</li><li>right &#x3D; 2 * parent + 1</li></ul><p><img src="https://i.imgur.com/gg6ujiQ.png"></p><p>但是一旦遇到高度 <code>&gt; 64</code> 的 skew tree, <strong>32-bit</strong> 的有號整數便無法表達</p><p><img src="https://i.imgur.com/kWtjZXl.png"></p><p>➔ 因此紀錄每層<strong>最左邊的非空節點的 idx</strong>, 把它當作該層所有節點 idx 的 offset, 因此新的 idx 為原先 idx 扣掉該層的 offset, 然後再用新的 idx 來對 child 進行遞迴</p><p><img src="https://i.imgur.com/iRdDWvP.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    vector&lt;<span class="type">long</span>&gt; left_most; <span class="comment">// 紀錄每一層最左非空節點的 idx</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">long</span> idx, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth == left_most.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            left_most.<span class="built_in">emplace_back</span>(idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, idx - left_most[depth] + <span class="number">1</span>); <span class="comment">// 維護最大寬度</span></span><br><span class="line">        idx -= left_most[depth]; <span class="comment">// 統一扣掉該層最左非空節點的 idx, 避免下面 * 2 超出 long</span></span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left, <span class="number">2</span> * idx, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right, <span class="number">2</span> * idx + <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 道理同 Solution 1, 一樣要記錄每層最左非空節點的 idx 並把它當成該層的 offset</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;TreeNode*, <span class="type">long</span>&gt;&gt; q; <span class="comment">// &#123;node : idx&#125;</span></span><br><span class="line">        q.<span class="built_in">emplace</span>(root, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> offset = q.<span class="built_in">front</span>().second; <span class="comment">// 該層最左非空節點的 idx</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(q.<span class="built_in">back</span>().second - offset + <span class="number">1</span>));  <span class="comment">// 維護最大寬度</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [node, idx] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 統一扣掉該層最左非空節點的 idx, 避免下面 * 2 超出 long</span></span><br><span class="line">                idx -= offset;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(node-&gt;left, <span class="number">2</span> * idx);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(node-&gt;right, <span class="number">2</span> * idx + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16. 3Sum Closest</title>
      <link href="/post/3sum-closest/"/>
      <url>/post/3sum-closest/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/3sum-closest/">https://leetcode.cn/problems/3sum-closest/</a></strong></p><p><strong>題意</strong>：給一長度為 <code>n</code> 的整數 array <code>nums</code> 和一整數 <code>target</code>, 從 <code>nums</code> 選出三個整數, 使其 sum 最接近 <code>target</code>, 返回這三個數之 sum。</p><p>假設每個輸入恰只存在一個解。</p></blockquote><p><img src="https://i.imgur.com/srsS3Pb.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers</strong></p><ul><li>首先, 將 <code>nums</code> 由小到大做<strong>排序</strong>, 用 <code>res</code> 來記錄當前最接近 <code>target</code> 之 sum</li><li>用 <code>i</code> 遍歷 <code>[0 , n]</code>, 每一次 <code>i</code> 遍歷一元素<ul><li>使用 Two pointer 尋找：<code>left = i + 1</code>, <code>right = n - 1</code>, 並用 <code>sum</code> 紀錄當前三數之和</li><li>若 <code>sum</code> 比 <code>res</code> 還更接近 <code>target</code>, 則 <code>res = sum</code></li><li>否則, 代表 <code>sum</code> 比 <code>res</code> 離 <code>target</code> 更遠, 則可細分成兩種情形：<ul><li><code>sum &lt; target</code>：<code>left + 1</code></li><li><code>sum ≥ target</code>：<code>right - 1</code></li></ul></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(sum - target) &lt; <span class="built_in">abs</span>(res - target)) &#123;</span><br><span class="line">                    res = sum;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ $O(n \cdot log(n)) + O(n^2)$<ul><li>$O(n \cdot log(n))$：排序 <code>nums</code></li><li>$O(n^2)$：for loop 需 $O(n)$, 其中每一個元素用 two pointer 遍歷剩餘元素需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 撇除要返回的 <code>res</code>, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>713. Subarray Product Less Than K</title>
      <link href="/post/subarray-product-less-than-k/"/>
      <url>/post/subarray-product-less-than-k/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/subarray-product-less-than-k/">https://leetcode.cn/problems/subarray-product-less-than-k/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>nums</code> 和一整數 <code>k</code>, 返回所有 subarray 中所有乘積小於 <code>k</code> 的連續 subarray 個數。</p></blockquote><p><img src="https://i.imgur.com/9obRgoe.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers + Sliding Window</strong></p><ul><li>用 <code>prod</code> 紀錄 <code>left ~ right</code> 之連續數乘積</li><li>若 <code>prod &gt; k</code> : 則 <code>prod /= nums[left]</code>, 且 left 要不斷右移, 直到 prod &lt; k</li><li>新增的連續 subarray 總共有 <code>right - left + 1</code> 個（以 right 為結尾的連續 subarray）<br>e.g. <code>nums = [10, 5, 2, 6]</code>, <code>k = 100</code><ul><li><code>left = 0 = right</code>, 取 <code>10 &lt; 100</code> ➔ <code>res = 1</code></li><li><code>left = 0</code>, <code>right = 1</code>, 取 <code>10 * 5 &lt; 100</code> ➔ <code>res = 1 + 2 = 3</code><br>  因為除了原本的 <code>[10]</code> 之外新增了 <code>[5], [10, 5]</code> 這兩個以 <code>5</code> 為結尾的連續 subarray</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, res = <span class="number">0</span>, prod = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            prod *= nums[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; prod &gt;= k) &#123;</span><br><span class="line">                prod /= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            res += right - left + <span class="number">1</span>; <span class="comment">// 因為是連續 subarray</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 撇除要返回的 <code>res</code>, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. Sort Colors</title>
      <link href="/post/sort-colors/"/>
      <url>/post/sort-colors/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sort-colors/">https://leetcode.cn/problems/sort-colors/</a></strong></p><p><strong>題意</strong>：給一包含紅色、白色和藍色, 總共 <code>n</code> 個元素的 array <code>nums</code>, 原地對 <code>nums</code> 進行排序, 使得相同顏色的元素相鄰, 並按照紅、白、藍的順序排列。</p><p>分別使用 <code>0</code>、<code>1</code>、<code>2</code> 代表紅、白、藍。</p><p><strong>注意</strong>：不能使用 library 中的 sort 函式。</p><p><strong>進階</strong>：設計 $O(1)$ space 的一次掃描演算法。</p></blockquote><p><img src="https://i.imgur.com/5HZYA8J.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：第一次掃描先計算 <code>0</code>、<code>1</code>、<code>2</code> 的個數, 第二次掃描則按照個數填充 <code>nums</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">colors</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            ++colors[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; colors[i]; ++j) &#123;</span><br><span class="line">                nums[cur++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(2n)$, 因為有 <code>2</code> 次掃描</li><li><strong>space：</strong>$O(1)$ ➔ 撇除要返回的 <code>res</code>, 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers + Partition, 用 ptr <code>i</code> 來遍歷 <code>nums</code>, 定義並維護以下三個區間：</strong></p><ul><li><code>[0, left - 1]</code> 皆為 <code>0</code>：所有在 <code>left</code> 以左的元素皆為 <code>0</code></li><li><code>[left, i - 1]</code> 皆為 <code>1</code>：<code>left ~ i - 1</code> 之間的元素皆為 <code>1</code></li><li><code>[right + 1, n - 1]</code> 皆為 <code>2</code>：所有在 <code>right</code> 以右的元素皆為 <code>2</code></li></ul><p><strong>特殊情況：</strong>當 <strong><code>nums[i] == 2</code></strong>, <code>nums[i]</code> 要和 <code>nums[right]</code> 做 <code>swap()</code>, 但我們<strong>不知道 <code>swap()</code> 前原本 <code>nums[right]</code> 的元素</strong>是什麼, 因此 <code>swap()</code> 後不能直接將 <code>i</code> 往下一位移動, 而是應該在下一輪繼續判斷 <code>nums[i]</code></p><ul><li><p><code>swap()</code> 前：</p><p>  <img src="https://i.imgur.com/D7xMYIa.png"></p></li><li><p><code>swap()</code> 後：假設原先 <code>nums[right]</code> 為 <code>0</code>, 則 swap 後 <code>nums[i] = 0</code>, 若此時將 <code>i</code> 往下一位移動, 則那個 swap 的 <code>0</code> 不會被擺在正確的位置上</p><p>  <img src="https://i.imgur.com/s3B1OYs.png"></p></li></ul><p><strong>為什麼 <code>nums[i] == 0</code> 不是特殊情況：</strong>因為我們維護區間 <strong><code>[left, i - 1]</code></strong> 皆為 <code>1</code>, 也就是說 <code>nums[left]</code> 會指著 <code>1</code>, 和 <code>nums[left]</code> 做 <code>swap()</code> 後 <code>nums[i]</code> 變成 <code>1</code>, <strong><code>i + 1</code> 後在下一輪中仍滿足 <code>[left, i - 1]</code></strong>, 因此可以直接往後一位</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因為維護 right 以右皆為 2, 所以當 i &gt; right 時結束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[left++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i--], nums[right--]); <span class="comment">// i-- : 不讓 i 往下一位移動</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>421. Maximum XOR of Two Numbers in an Array</title>
      <link href="/post/maximum-xor-of-two-numbers-in-an-array/"/>
      <url>/post/maximum-xor-of-two-numbers-in-an-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>nums</code>, 返回 <code>nums[i] XOR nums[j]</code> 的最大值, 其中 <code>0 ≤ i ≤ j &lt; n</code>。</p><p><strong>進階</strong>：設計 $O(n)$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/m2Dxru3.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy + Trie</strong></p><ul><li><p>Greedy：若今天有一數 <code>x = 5</code>, 其 binary 形式為 <code>0101</code></p><ul><li>若跟其 bit 完全相反的 <code>1010</code> 存在, 則 XOR 值最大</li><li>若 <code>1010</code> 不存在, 我們也希望能挑選最左 bit &#x3D; 1 (因為此時 5 的最左 bit &#x3D; 0)的數, 並將最左 bit &#x3D; 0 的數給剔除掉, 然後往下一個 bit 重複此步驟</li><li>透過逐步篩選, 最後挑出所有數中 XOR 值最大的數</li></ul></li><li><p>首先, 將所有 <code>num</code> 的 binary 形式(由左至右) insert 到 trie 中</p><p>  e.g. <code>num = 4</code> 則 insert 到 trie 中會是下圖的樣子</p><p>  <img src="https://i.imgur.com/OSUl63r.png"></p></li><li><p>然後根據每一個 <code>num</code> 去找其 XOR 最大的數, 每次需花費 $O(32*2)$</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">2</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將 num 的 binary bit, 由左至右一個一個 insert 到 trie 中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>&amp; num)</span></span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[bit]) &#123;</span><br><span class="line">                p-&gt;children[bit] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            TrieNode *p = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>; <span class="comment">// 當前的 bit</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 flip_bit 存在</span></span><br><span class="line">                <span class="keyword">if</span> (p-&gt;children[<span class="number">1</span> - bit]) &#123;</span><br><span class="line">                    <span class="comment">// 2 * cur 是因為每做一個 bit 就要往左一位</span></span><br><span class="line">                    <span class="comment">// + 1 是因為 flip_bit 存在, 當前 bit XOR 完必為 1</span></span><br><span class="line">                    cur = <span class="number">2</span> * cur + <span class="number">1</span>;</span><br><span class="line">                    p = p-&gt;children[<span class="number">1</span> - bit];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若 flip_bit 不存在</span></span><br><span class="line">                    <span class="comment">// 因為 flip_bit 不存在, 當前 bit XOR 完必為 0</span></span><br><span class="line">                    cur *= <span class="number">2</span>;</span><br><span class="line">                    p = p-&gt;children[bit];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(res, cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaximumXOR</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        Trie trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trie.<span class="built_in">search</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(64n)$<ul><li>search 一個 32-bit 的數, 每一個 bit 最多需 $O(2)$, 因為若 flip bit 不存在, 則要拜訪另一個</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ $O(64n)$<ul><li>每 insert 一個數(32 bit), trie 最多產生 <code>32</code> 個 node, 而每個 node 又有 <code>2</code> 個 child</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>720. Longest Word in Dictionary</title>
      <link href="/post/longest-word-in-dictionary/"/>
      <url>/post/longest-word-in-dictionary/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-word-in-dictionary/">https://leetcode.cn/problems/longest-word-in-dictionary/</a></strong></p><p><strong>題意</strong>：給一 string array <code>words</code> 組成的字典。返回 <code>words</code> 中最長的單字, 且該單字是由字典中其他單字逐步添加一個 char 而成的。</p><p>若其中有多個可行的答案, 則返回答案中順序最小的單字。若無答案, 則返回 empty string。</p><p><strong>注意</strong>：<code>words[i]</code> 僅由<strong>小寫</strong>字母所組成。</p></blockquote><p><img src="https://i.imgur.com/Tok6mrL.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sorting + Trie</strong></p><ul><li>首先, 對 <code>words</code> 進行 sorting, 分成兩種情況:<ul><li>string <strong>越長的放越前面</strong></li><li>若兩 string 長度相同, 則將<strong>字母順序小的放前面</strong><br>  e.g. <code>&quot;apple&quot;</code> 和 <code>&quot;apply&quot;</code>：兩者都有 <code>&quot;appl&quot;</code>, 但是因為 <code>&quot;e&quot;</code> 在字母的順序中比 <code>&quot;y&quot;</code> 前面, 故 <code>&quot;apple&quot;</code> 應排在 <code>&quot;apply&quot;</code> 前面</li></ul></li><li>建立 Trie, 並將 <code>words</code> 中的每個單字 insert 到 Trie 中</li><li>根據<strong>排序後的順序</strong>遍歷 <code>words</code>, 若 <code>words[i]</code> 中所有 prefix 都存在, 則直接返回 <code>words[i]</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>; <span class="comment">// 預設每個 char 不為 end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;children[i]) &#123;</span><br><span class="line">                cur-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur-&gt;isEnd = <span class="literal">true</span>; <span class="comment">// 將最後一個 char 設為 end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasAllPrefix</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// prefix 不存在 || prefix 存在, 但在 trie 中不為 end</span></span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;children[i] || !cur-&gt;children[i]-&gt;isEnd) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestWord</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>()) &#123; <span class="comment">// 長度不同時, 長度較長者放在前面</span></span><br><span class="line">                <span class="keyword">return</span> s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s1 &lt; s2; <span class="comment">// 長度相同時, 字母順序較小者放在前面</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Trie trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trie.<span class="built_in">hasAllPrefix</span>(word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令總共有 <code>n</code> 個 word</p><ul><li><strong>time：</strong>$O(n \cdot log(n) + \displaystyle\sum_{i&#x3D;1}^{n}w_i)$<ul><li>$O(n \cdot log(n))$：sorting</li><li>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$：<ul><li>每次插入 <code>word[i]</code> 需 $O(w_i)$, 其中 $w_i$ 為 <code>word[i]</code> 之長度</li><li>每次查找 <code>word[i]</code> 其所有 prefix 需 $O(w_i)$, 其中 $w_i$ 為 <code>word[i]</code> 之長度</li></ul></li></ul></li><li><strong>space：</strong>$O(26 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ worse case：每個 word 的 prefix 皆不重覆<ul><li>總共 <code>n</code> 個 word, 每一個 word 有 $w_i$ 個 node, 而每個 node 又有 26 個 children</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>76. Minimum Window Substring</title>
      <link href="/post/minimum-window-substring/"/>
      <url>/post/minimum-window-substring/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-window-substring/">https://leetcode.cn/problems/minimum-window-substring/</a></strong></p><p><strong>題意：</strong>給兩 string <code>s</code> 和 <code>t</code>, 返回 <code>s</code> 中包含 <code>t</code> 所有 character 的<strong>最小 substring</strong>。若不存在這樣的 substring, 則返回 empty string <code>&quot;&quot;</code>。</p><p><code>s</code> 和 <code>t</code> 由英文字母組成。</p><p><strong>進階：</strong>設計 $O(n)$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/JXnzf9I.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 用兩個 pointer <code>left</code> 和 <code>right</code>, 其中 <code>right</code> 用來擴充 window, 而 <code>left</code> 用來收縮 window</strong></p><ul><li>若 <code>window</code> 中的元素不包含 <code>t</code>, 則 <code>right</code> 不斷向右移動, 直到 <code>window</code> 中每種元素的個數 ≥ <code>t</code> 中對應元素的個數</li><li><code>left</code> 會不斷收縮, 並更新 res, 直到當 <code>window</code> 中某種元素的個數 &lt; <code>t</code> 中該種元素的個數<ul><li><code>have</code> 用來記錄符合 <code>window 中某一種元素的個數 == t 中該種元素的個數</code> 之元素個數</li><li><code>need</code> 則是記錄 <code>t</code> 中有多少種元素</li><li>若 <code>have == need</code> 代表 <code>window</code> 中每種元素的個數 ≥ <code>t</code> 中對應元素的個數</li></ul></li></ul><p>e.g. <code>s = &quot;ADOBECODEBANC&quot;</code>, <code>t = &quot;ABC&quot;</code></p><ul><li><code>s</code> 第一次包含 <code>t</code> 之 substring 為 <code>ADOBEC</code> ➔ left &#x3D; 0, right &#x3D; 5, curLen &#x3D; 6, <strong>resLen &#x3D; 6</strong></li><li>將左邊之 <code>A</code> pop 掉後, <strong><code>DOBEC</code> 並不包含 <code>t</code>, 因此跳出 while loop, 讓 <code>right</code> 繼續右移</strong>, 直到 substring 為 <code>DOBECODEBA</code> ➔ left &#x3D; 1, right &#x3D; 10, curLen &#x3D; 10, resLen &#x3D; 6</li><li>將左邊之 <code>D</code>、<code>O</code>、<code>B</code>、<code>E</code> pop 掉後, 此時 substring 為 <code>CODEBA</code> ➔ left &#x3D; 5, right &#x3D; 10, curLen &#x3D; 6, resLen &#x3D; 6</li><li>將左邊之 <code>C</code> pop 掉後, <code>ODEBA</code> 並不包含 <code>t</code>, <strong>因此跳出 while loop, 讓 <code>right</code> 繼續右移</strong>, 直到 substring 為 <code>ODEBANC</code> ➔ left &#x3D; 6, right &#x3D; 12, curLen &#x3D; 7, resLen &#x3D; 6</li><li>將左邊之 <code>O</code>、<code>D</code>、<code>E</code> pop 掉後, substring 為 <code>BANC</code> ➔ left &#x3D; 9, right &#x3D; 12, curLen &#x3D; 4, <strong>resLen &#x3D; 4</strong></li><li>將左邊之 <code>B</code> pop 掉後, <strong><code>ANC</code> 並不包含 <code>t</code>, 因此跳出 while loop, 但 <code>right</code> 已到結尾, 無法再右移</strong>, 故返回 <code>BANC</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window, cntT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : t) &#123;</span><br><span class="line">            ++cntT[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, resLen = INT_MAX;</span><br><span class="line">        <span class="type">int</span> have = <span class="number">0</span>, need = cntT.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); ++right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> rightChar = s[right];</span><br><span class="line">            ++window[rightChar];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在 t 中存在, 且 window 中該元素的個數 &gt;= t 中的個數</span></span><br><span class="line">            <span class="keyword">if</span> (cntT.<span class="built_in">find</span>(rightChar) != cnt.<span class="built_in">end</span>() &amp;&amp; window[rightChar] == cntT[rightChar]) &#123;</span><br><span class="line">                ++have;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一旦 window 中某種元素的個數 &lt; t 中該種元素的個數, 則跳出 while loop</span></span><br><span class="line">            <span class="keyword">while</span> (have == need) &#123;</span><br><span class="line">                <span class="comment">// 更新 res</span></span><br><span class="line">                <span class="type">int</span> curLen = right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (curLen &lt; resLen) &#123;</span><br><span class="line">                    resLen = curLen;</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(left, resLen);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// left 收縮</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> leftChar = s[left];</span><br><span class="line">                --window[leftChar];</span><br><span class="line">                <span class="keyword">if</span> (cntT.<span class="built_in">find</span>(leftChar) != cnt.<span class="built_in">end</span>() &amp;&amp; window[leftChar] &lt; cntT[leftChar]) &#123;</span><br><span class="line">                    --have;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 char 最多被拜訪兩次（<code>left</code>, <code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code>、<code>cntT</code> 長度不超過 <code>52</code>（大、小寫各 <code>26</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>239. Sliding Window Maximum</title>
      <link href="/post/sliding-window-maximum/"/>
      <url>/post/sliding-window-maximum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 有一個大小為 <code>k</code> 的 sliding window 從 <code>nums</code> 的最左側移動到最右側。你只能看到 sliding window 中的 <code>k</code> 個數字, 且 sliding window 每次只向右移一位, 返回 sliding window 中的最大值。</p></blockquote><p><img src="https://i.imgur.com/2H2GTpm.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 deque。因為 <code>window</code> 移除元素後, 有可能會改變最大值, 故也要記錄最大值之外的值。</strong></p><p><strong>首先, 建立遞減 Queue（Monotonic Queue）, 把當前 <code>window</code> 中最大值的 index 放在 <code>deque</code> 的最前面。</strong></p><ul><li><code>nums[i]</code> 加入前, 要先不斷地和 <code>deque.back()</code> 比較<ul><li>若 <code>nums[i] &gt; nums[deque.back()]</code>, 則 <code>deque.pop_back()</code></li><li>若 <code>nums[i] ≤ nums[deque.back()]</code>, 則將 <code>i</code> 放入 <code>deque</code> 最後面</li></ul></li><li>若 <code>window</code> 的起始位置 <code>≥ deque.front()</code>, 代表在下一輪 <code>deque.front()</code> 超出 <code>window</code> 所涵蓋的範圍, 故要 pop 掉</li></ul><p><img src="https://i.imgur.com/2nWylkr.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; index;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// nums[i] 加入前, 要先不斷地和 deque.back() 比較</span></span><br><span class="line">            <span class="keyword">while</span> (!index.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[index.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">                index.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            index.<span class="built_in">emplace_back</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i - k + 1 為當前 window 的起始位置</span></span><br><span class="line">            <span class="comment">// 當 window 中有足夠元素, 則將最大值 push 到 res 中</span></span><br><span class="line">            <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(nums[index.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 當前 window 的起始位置, 若 ≥ index.front()</span></span><br><span class="line">            <span class="comment">// 則在下一輪時, index.front() 會被移除(因為超出 window)</span></span><br><span class="line">            <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= index.<span class="built_in">front</span>()) &#123;</span><br><span class="line">                index.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個元素最多被 push／pop 一次</li><li><strong>space：</strong>$O(k)$ ➔ deque 的元素個數不超過 <code>k</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84. Largest Rectangle in Histogram</title>
      <link href="/post/largest-rectangle-in-histogram/"/>
      <url>/post/largest-rectangle-in-histogram/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></strong></p><p><strong>題意：</strong>給 <code>n</code> 個非負整數, 用來表示柱狀圖中各個柱子的<strong>高度</strong>。每個柱子彼此相鄰, 且寬度為 <code>1</code>。</p><p>返回柱狀圖中最大矩形的面積。</p></blockquote><p><img src="https://i.imgur.com/HTr1nzZ.png"></p><p><img src="https://i.imgur.com/oreUpcy.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 Brute Force, 對於每一個 <code>heights[i]</code> 的寬度即為左、右邊第一個 <code>&lt; heights[i]</code> 的位置, 其寬度為 <code>right - left - 1</code> （<code>left</code>、<code>right</code> 都不包含在寬度中, 故要減一）</strong></p><p><img src="https://i.imgur.com/nOAmhFY.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = heights.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 找到左邊第一個 &lt; heights[i] 的位置</span></span><br><span class="line">            <span class="type">int</span> left = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i]) &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到右邊第一個 &lt; heights[i] 的位置</span></span><br><span class="line">            <span class="type">int</span> right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; heights[right] &gt;= heights[i]) &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 中間的部分就是 area</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, heights[i] * (right - left - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop 中每一個 <code>i</code> 皆需 $O(n)$ 去找到左、右邊第一個 <code>&lt; heights[i]</code> 的位置</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：概念同 Solution 1, 利用 Monotonic Stack 來儲存 index, 維護一個遞增的 stack。一旦下一個元素 <code>i</code> 的高度比 <code>stk.top()</code> 的高度要小, 則可以知道 <code>idx = stk.top()</code> 的右邊高度比它小的第一個位置是 <code>i</code>, 而左邊高度比它小的第一個位置是把當前 <code>stk.top()</code> 給 pop 掉後的 <code>stk.top()</code>。<code>stk</code> 會不斷計算 <code>idx = stk.top()</code> 的 area, 並將 <code>stk.top()</code> 給 pop 掉, 直到 <code>heights[stk.top()] &lt; heights[i]</code>, 詳情請看<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/">這篇</a>的方法二</strong></p><p>e.g. <code>stk = [1, 3]</code></p><ul><li>假設 <code>idx = 4</code> 的高度比當前 <code>idx = stk.top() = 3</code> 的高度要小, 則可以知道右邊第一個高度 <code>&lt; height[3]</code> 的位置是 <code>idx = 4</code></li><li>此時我們想知道左邊第一個 <code>&lt; height[3]</code> 的位置為何, 因此我們先將當前的 <code>stk.top()</code> 給 pop 掉, 此時 <code>stk = [1]</code>, 然後取出 <code>stk.top() = 1</code> 為左邊第一個 <code>&lt; height[3]</code> 的位置, 因為 <code>stk</code> 是遞增的, 所以將自己 pop 掉後的 <code>stk.top()</code> 必為左邊第一個比當前高度小的</li><li>得到左、右邊第一個 <code>&lt; heights[stk.top()]</code> 的位置後, 即可計算 <code>idx = stk.top()</code> 的面積</li></ul><p><strong>還要考慮 edge case 的情況：</strong></p><ul><li>因為我們在取完當前 <code>stk.top()</code> 後將其 pop 掉後, 又取了一次 <code>stk.top()</code>。若 <code>heights.size() = 1</code>, 則 <code>stk.size() = 1</code> 會導致第二次取 <code>stk.top()</code> 時會出錯, 因此我們一定要有一個最低點在 <code>heights</code> 的起點, 這樣才能確保 <code>stk.size() &gt; 1</code></li><li>除此之外, 我們還要保證 while loop 定會被執行, 因此我們一定要有一個最低點在 <code>heights</code> 的終點。否則, 當 <code>heights</code> 為遞增的, e.g. <code>heights = [2, 4]</code>, 則 while loop 的條件 <code>heights[stk.top()] &gt; heights[i]</code> 永遠不會成立, 會導致 <code>res</code> 不會被計算到</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 考慮 edge case, 在 heights 前後加上高度為 0 的元素(最低點)</span></span><br><span class="line">        heights.<span class="built_in">emplace</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        heights.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; heights[stk.<span class="built_in">top</span>()] &gt; heights[i]) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> height = heights[stk.<span class="built_in">top</span>()];</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                res = <span class="built_in">max</span>(res, height * (i - stk.<span class="built_in">top</span>() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ stack 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. Median of Two Sorted Arrays</title>
      <link href="/post/median-of-two-sorted-arrays/"/>
      <url>/post/median-of-two-sorted-arrays/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">https://leetcode.cn/problems/median-of-two-sorted-arrays/</a></strong></p><p><strong>題意：</strong>給兩個排序過的 array <code>nums1</code> 和 <code>nums2</code>, 其大小分別為 <code>m</code> 和 <code>n</code>, 返回這兩個 array 排序過的中位數。</p><p>設計 $O(log(m+n))$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/sJH6Sfh.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 我們可以用分隔線將兩個 sorted array 分割成兩邊, 而中位數只與紅線兩側的元素有關。因為是 sorted array, 所以我們用 Binary Search 找出正確的分割線位置, 需滿足以下條件：</strong></p><ul><li><p>當 <code>m + n</code> 為<strong>偶數</strong>時, 紅線左邊的元素個素和右邊的元素個數相等。中位數為分割線左邊最大元素、分割線右邊最小元素之平均</p></li><li><p>當 <code>m + n</code> 為<strong>奇數</strong>時, 紅線左邊的元素個素比右邊的元素個數<strong>多 1</strong>(這樣方便我們計算中位數)</p><p>  e.g. <code>nums1 = [1]</code>, <code>nums2 = [2, 3]</code> ➔ <code>紅線左邊元素 = [1,2]</code>, <code>紅線右邊元素 = [3]</code></p><p>  ➔ 我們可直接取紅線左邊元素值最大的數為中位數</p></li><li><p>紅線左邊元素的值 ≤ 紅線右邊元素的值, 也就是 <code>nums1[cutA-1] ≤ nums2[cutB] &amp;&amp; nums2[cutB-1] ≤ nums1[cutA]</code></p></li></ul><p><img src="https://i.imgur.com/u8VZiQb.png"></p><p><strong>分隔線的定義 :</strong></p><ul><li><p><code>cutA</code> &#x3D; <code>nums1</code> 分隔線右邊的第一個元素 idx &#x3D; <code>nums1</code> 分隔線左邊的元素個數</p></li><li><p><code>cutB</code> &#x3D; <code>nums2</code> 分隔線右邊的第一個元素 idx &#x3D; <code>nums2</code> 分隔線左邊的元素個數</p></li><li><p>滿足 <code>cutA + cutB = half = (m + n + 1) / 2</code></p><p>  <img src="https://i.imgur.com/PXgnlUT.png"></p></li></ul><p><strong>為什麼是選較短的 array 做 Binary Search, 而不是較長的 array ?</strong></p><p>因為這樣時間複雜度比較低</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 確保 m &lt;= n</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割線左側的元素個數 = (m + n + 1) / 2</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> half = m + (n - m + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 避免 overflow 的寫法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 Binary Search 找出正確分割線的位置</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = m;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> cutA = left + (right - left) / <span class="number">2</span>; <span class="comment">// 避免 overflow 的寫法</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> cutB = half - cutA;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 代表 nums1 左邊元素太小, 因此往右邊繼續找</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[cutA] &lt; nums2[cutB - <span class="number">1</span>]) &#123;</span><br><span class="line">                left = cutA + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 代表 nums1 左邊元素太大, 因此往左邊繼續找</span></span><br><span class="line">                right = cutA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到正確分割線的位置</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> cutA = left, cutB = half - cutA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左中位數 = 左側元素值最大的, 也就是 nums1[cutA-1] 和 nums2[cutB-1] 中取較大者</span></span><br><span class="line">        <span class="comment">// 若有超出邊界的, 則把它設成最小值, 這樣必然取沒超出邊界的</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> leftMax = <span class="built_in">max</span>((cutA == <span class="number">0</span>) ? INT_MIN : nums1[cutA - <span class="number">1</span>],</span><br><span class="line">                                (cutB == <span class="number">0</span>) ? INT_MIN : nums2[cutB - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若為奇數, 中位數即為分割線左邊元素值最大的數</span></span><br><span class="line">        <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右中位數 = 右側元素值最小的, 也就是 nums1[cutA] 和 nums2[cutB] 中取較小者</span></span><br><span class="line">        <span class="comment">// 若有超出邊界的, 則把它設成最大值, 這樣必然取沒超出邊界的</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> rightMin = <span class="built_in">min</span>((cutA == m) ? INT_MAX : nums1[cutA],</span><br><span class="line">                                 (cutB == n) ? INT_MAX : nums2[cutB]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若為偶數, 中位數即為左中位數和右中位數之平均</span></span><br><span class="line">        <span class="keyword">return</span> leftMax * <span class="number">0.5</span> + rightMin * <span class="number">0.5</span>; <span class="comment">// 避免 overflow 的寫法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(m))$ ➔ 對 <code>nums1</code> 做 Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 只是改變 <code>nums1</code> 做 Binary Search 的寫法, 判斷式改成 <code>nums1[cutA - 1] &gt; nums2[cutB]</code>, 但有邊界條件須考慮, 也就是當 <code>nums1[cutA - 1] ≤ nums2[cutB]</code> 時, 此時 <code>left = cutA</code>。若 <code>nums1</code> 中只有兩個元素, e.g. <code>nums1 = [0, 1]</code>, 此時 <code>left = 0</code>, <code>right = 1</code> ➔ <code>cutA = 0</code>, 更新完後的 <code>left</code> 仍為 <code>0</code>, 會導致陷入無窮迴圈中。因此要把計算 <code>cutA</code> 的公式改成 <code>left + (right - left + 1) / 2</code>, 新增 <code>+ 1</code> 的部分是為了避免陷入無窮迴圈中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 確保 m &lt;= n</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割線左側的元素個數 = (m + n + 1) / 2</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> half = m + (n - m + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 避免 overflow 的寫法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 Binary Search 找出正確分割線的位置</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = m;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> cutA = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// + 1  是為了避免陷入無窮迴圈中</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> cutB = half - cutA;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 代表 nums1 左邊元素太大, 因此往右邊繼續找</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[cutA - <span class="number">1</span>] &gt; nums2[cutB]) &#123;</span><br><span class="line">                right = cutA - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 代表 nums1 左邊元素太小, 因此往左邊繼續找</span></span><br><span class="line">                <span class="comment">// 當 nums1 只有兩個元素時會陷入無窮迴圈中</span></span><br><span class="line">                left = cutA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到正確分割線的位置</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> cutA = left, cutB = half - cutA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左中位數 = 左側元素值最大的, 也就是 nums1[mid1-1] 和 nums2[mid2-1] 中取較大者</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> leftMax = <span class="built_in">max</span>((cutA == <span class="number">0</span>) ? INT_MIN : nums1[cutA - <span class="number">1</span>],</span><br><span class="line">                                (cutB == <span class="number">0</span>) ? INT_MIN : nums2[cutB - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若為奇數, 中位數即為分割線左邊元素值最大的數</span></span><br><span class="line">        <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右中位數 = 右側元素值最小的, 也就是 nums1[mid1] 和 nums2[mid2] 中取較小者</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> rightMin = <span class="built_in">min</span>((cutA == m) ? INT_MAX : nums1[cutA],</span><br><span class="line">                                 (cutB == n) ? INT_MAX : nums2[cutB]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若為偶數, 中位數即為左中位數和右中位數之平均</span></span><br><span class="line">        <span class="keyword">return</span> leftMax * <span class="number">0.5</span> + rightMin * <span class="number">0.5</span>; <span class="comment">// 避免 overflow 的寫法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(m))$ ➔ 對 <code>nums1</code> 做 Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>435. Non-overlapping Intervals</title>
      <link href="/post/non-overlapping-intervals/"/>
      <url>/post/non-overlapping-intervals/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/non-overlapping-intervals/">https://leetcode.cn/problems/non-overlapping-intervals/</a></strong></p><p><strong>題意：</strong>給一區間集合 <code>intervals</code>, 其中 <code>intervals[i] = [start_i, end_i]</code>, 返回需要移除的最小區間個數, 使得剩下的區間互不重疊。</p></blockquote><p><img src="https://i.imgur.com/479NCdI.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：首先, 先將 <code>intervals</code> 做排序, 然後紀錄前一天的 <code>end</code>, 當有兩天 <code>start</code> 相同時, <code>end</code> 會取較小的那一個, 這樣才能最大化避免重疊</strong></p><p><strong>以下圖為例, sorting 後的 <code>intervals = [[1,2], [1,3], [2,3], [3,4]</code>, 最一開始 <code>[1,2]</code> 和 <code>[1,3]</code> 我們會選擇捨棄 <code>[1,3]</code>, 因為 <code>[1,2]</code> 的 <code>end</code> 較小, 若保留 <code>[1,3]</code> 則會和後面的 <code>[2,3]</code> 重疊</strong></p><p><img src="https://i.imgur.com/Dmj8LLZ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, prevEnd = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// prevEnd &gt; current start, 代表有重疊, 捨棄其中一個, 且 prevEnd 要更新</span></span><br><span class="line">            <span class="keyword">if</span> (prevEnd &gt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                prevEnd = <span class="built_in">min</span>(prevEnd, intervals[i][<span class="number">1</span>]);</span><br><span class="line">                ++res;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 沒重疊, 則 prevEnd 更新為當前 interval 的 end</span></span><br><span class="line">                prevEnd = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>253. Meeting Rooms II</title>
      <link href="/post/meeting-rooms-ii/"/>
      <url>/post/meeting-rooms-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/meeting-rooms-ii/">https://leetcode.cn/problems/meeting-rooms-ii/</a></strong></p><p><strong>題意：</strong>給一 array <code>intervals</code>, 其中 <code>intervals[i] = [start_i, end_i]</code>, 返回所需的最小會議室數量。</p><p><strong>注意：</strong><code>(0, 8)</code> 和 <code>(8, 10)</code> 並不衝突</p></blockquote><p><img src="https://i.imgur.com/Cl83cfU.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 heap 來紀錄所有會議室的 <code>end</code>, 並每次取 heap 中最小的, 來確認跟當前 interval 是否有衝突</strong></p><ul><li>若有, 則將當前 <code>interval.end</code> 加入到 heap 中</li><li>若沒有, 則把 <code>top</code> 取代為當前 <code>interval.end</code>（先 <code>pop()</code>, 再 <code>push(newEnd)</code>）</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;Interval&gt; &amp;intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="type">const</span> Interval&amp; i1, <span class="type">const</span> Interval&amp; i2) &#123;</span><br><span class="line">            <span class="keyword">return</span> i1.start &lt; i2.start;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        pq.<span class="built_in">emplace</span>(intervals[<span class="number">0</span>].end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> minEnd = pq.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有重疊, 要加開會議室</span></span><br><span class="line">            <span class="keyword">if</span> (minEnd &gt; intervals[i].start) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 沒重疊</span></span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">emplace</span>(intervals[i].end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$<ul><li>$O(n \cdot log(n))$ : sorting</li><li>$O(n \cdot log(n))$ : <code>n</code> 次從 minHeap 中取 <code>top</code>, 每次取完後會調整 heap, 需 $O(log(n))$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ heap size 最大為 <code>n</code> 個</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：占用資源問題可看做是上下車問題, 則問題可轉化成車上最多有幾人</strong></p><p>e.g. <code>intervals = [[0,30], [5,10], [15,20]]</code></p><p>可想成：</p><ul><li>第一個人從 <code>0</code> 上車, 從 <code>30</code> 下車</li><li>第二個人從 <code>5</code> 上車, 從 <code>10</code> 下車</li><li>第三個人從 <code>15</code> 上車, 從 <code>20</code> 下車</li></ul><p>問題可轉化成車上最多有幾人（最多有幾間會議室）</p><p><strong>顯然：上車, 車上人數+1；下車, 車上人數-1</strong></p><p>先把 <code>intervals</code> 拆解成：</p><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">上車 : <span class="comment">[0, 1]</span>, <span class="comment">[5, 1]</span>, <span class="comment">[15, 1]</span></span><br><span class="line">下車 : <span class="comment">[10, -1]</span>, <span class="comment">[20, -1]</span>, <span class="comment">[30, -1]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>時間</th><th>0</th><th>5</th><th>10</th><th>15</th><th>20</th><th>30</th></tr></thead><tbody><tr><td>變化</td><td>+1</td><td>+1</td><td>-1</td><td>+1</td><td>-1</td><td>-1</td></tr><tr><td>人數</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td><td>0</td></tr></tbody></table><p>➔ <strong>車上最多 <code>2</code> 人</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; meetings;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; iv : intervals) &#123;</span><br><span class="line">            meetings.<span class="built_in">emplace_back</span>(iv[<span class="number">0</span>], <span class="number">1</span>); <span class="comment">// 上車, cnt + 1</span></span><br><span class="line">            meetings.<span class="built_in">emplace_back</span>(iv[<span class="number">1</span>], <span class="number">-1</span>); <span class="comment">// 下車, cnt - 1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(meetings.<span class="built_in">begin</span>(), meetings.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; m : meetings) &#123;</span><br><span class="line">            cnt += m.second;</span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal, cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(n)$ ➔ <code>meetings</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48. Rotate Image</title>
      <link href="/post/rotate-image/"/>
      <url>/post/rotate-image/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/rotate-image/">https://leetcode.cn/problems/rotate-image/</a></strong></p><p><strong>題意：</strong>給一 <code>n x n</code> 的 2D array 表示一個 image, 請將 image <strong>順時針旋轉 90 度</strong>。</p><p><strong>注意：</strong>請使用 <strong>in-place</strong> 演算法</p></blockquote><p><img src="https://i.imgur.com/9501ib1.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：將 <code>matrix</code> 由外而內分成好幾層, 每一層依序交換以完成旋轉</strong></p><p><img src="https://i.imgur.com/BBcgX0W.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想像從 (0, 0) 沿著對角線往中心點前進(n為奇數時中心不用旋轉, 故為 i &lt; n / 2)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 每層共 n-2*(i+1) 個元素, 每往內一層元素個數就會減2, 減掉最左、最右兩個數</span></span><br><span class="line">            <span class="comment">// i 為起始 idx, 則 i+n-2*(i+1) = n-i-2 為結束 idx</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - i - <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i];</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i];</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 遍歷 <code>matrix</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2：（進階）"><a href="#Solution-2：（進階）" class="headerlink" title="Solution 2：（進階）"></a><strong>Solution 2：（進階）</strong></h2><blockquote><p><strong>想法：先將 <code>matrix</code> 做轉置（將同 row 的元素變成同 col）, 然後再每列做水平翻轉（reverse）<br>（水平翻轉：原本左邊 $1^{st}$ col 變成右邊 $1^{st}$ col, 左邊 $2^{nd}$ col 變成右邊 $2^{nd}$ col, 依此類推）</strong></p></blockquote><p><img src="https://i.imgur.com/XOzokhE.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 轉置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一列做 reverse</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(matrix[i].<span class="built_in">begin</span>(), matrix[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 遍歷 <code>matrix</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54. Spiral Matrix</title>
      <link href="/post/spiral-matrix/"/>
      <url>/post/spiral-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的 matrix, 按照 <strong>順時針螺旋</strong> 順序, 返回 matrix 中所有元素。</p></blockquote><p><img src="https://i.imgur.com/cbrZA9Z.png"></p><p><img src="https://i.imgur.com/K9q2pnS.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法： 將 <code>matrix</code> 由外而內分成好幾層, 每層都有四個方向要走, 依序是</strong></p><ul><li>由左至右</li><li>由上至下</li><li>由右至左</li><li>由下至上</li></ul><p><img src="https://i.imgur.com/4pVqcBW.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, bottom = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> direction = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">            <span class="keyword">if</span> (direction == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 top row 的元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; ++i) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(matrix[top][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++top;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 right col 的元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt; bottom; ++i) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(matrix[i][right - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                --right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 bottom row 的元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = right - <span class="number">1</span>; i &gt;= left; --i) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(matrix[bottom - <span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                --bottom;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 left col 的元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = bottom - <span class="number">1</span>; i &gt;= top; --i) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            direction = (direction + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>matrix</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73. Set Matrix Zeroes</title>
      <link href="/post/set-matrix-zeroes/"/>
      <url>/post/set-matrix-zeroes/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/set-matrix-zeroes/">https://leetcode.cn/problems/set-matrix-zeroes/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的 matrix, 若其中一元素為<code>0</code>, 將其所在列和行的所有元素都設為<code>0</code>。</p><p><strong>注意：</strong>請使用 <strong>in-place</strong> 演算法</p><p><strong>進階：</strong></p><ul><li>用 <code>O(mn)</code> space 的直覺作法似乎是個壞主意</li><li>設計 <code>O(m + n)</code> space 的演算法，但這仍然不是最好的解決方案</li><li>設計 <code>O(1)</code> space 的演算法</li></ul></blockquote><p><img src="https://i.imgur.com/oxqB8Bh.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：分別用 <code>rows</code>, <code>cols</code> 來記錄哪些 row, col 上的元素要設為 <code>0</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rows</span><span class="params">(m, <span class="number">0</span>)</span>, <span class="title">cols</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    rows[i] = cols[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rows[i] || cols[j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>matrix</code></li><li><strong>space：</strong>$O(m + n)$ ➔ <code>rows</code> 和 <code>cols</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：用 <code>col0</code>, <code>row0</code> 分別記錄第一行、第一列是否有元素為 <code>0</code>, 然後用 <code>matrix</code> 中的第一行、第一列分別紀錄該行、列是否有元素為 <code>0</code><br>（用 <code>matrix</code> 中的第一行、第一列取代 Solution 1 的 <code>rows</code>、<code>cols</code> ）</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> row0 = <span class="literal">false</span>, col0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 記錄第一行是否有元素為0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                col0 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 記錄第一列是否有元素為0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                row0 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 matrix 中的第一行、第一列分別紀錄該行、列是否有元素為0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根據 matrix[i][0]、matrix[0][j] 是否為0, 來決定是否把 matrix[i][j] 設為0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷 matrix 的第一行是否要設0</span></span><br><span class="line">        <span class="keyword">if</span> (col0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷 matrix 的第一列是否要設0</span></span><br><span class="line">        <span class="keyword">if</span> (row0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>matrix</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50. Pow(x, n)</title>
      <link href="/post/powx-n/"/>
      <url>/post/powx-n/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/powx-n/">https://leetcode.cn/problems/powx-n/</a></strong></p><p><strong>題意：</strong>給一 double <code>x</code> 和一整數 <code>n</code>, 返回 <code>x</code> 的 <code>n</code> 次方。</p></blockquote><p><img src="https://i.imgur.com/idwSS22.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Divide and Conquer, 比如 $2^{10}$ 可拆成 $2^5 * 2^5$, 而 $2^5$ 又可拆成 $2(2^2 * 2^2)$, 依此類推。透過這樣的方法可以避免重複計算, 而不用一直乘 <code>x</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意 res 要宣告成 double (容易粗心)</span></span><br><span class="line">        <span class="type">double</span> res = <span class="built_in">quickPow</span>(x, <span class="built_in">abs</span>(n)); <span class="comment">// 計算 x^n, 其中 n 取正</span></span><br><span class="line">        <span class="keyword">return</span> (n &gt;= <span class="number">0</span>) ? res : (<span class="number">1</span> / res); <span class="comment">// 若 n &lt; 0, 則取倒數 1 / (x^n)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 0^n = 0</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x != 0, 則 x^0 = 1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> half = <span class="built_in">quickPow</span>(x, n / <span class="number">2</span>); <span class="comment">// 計算 x^(n / 2), 注意 half 的 data type</span></span><br><span class="line">        <span class="comment">// 若 n 為奇數, 則前面還要再多乘一次 x</span></span><br><span class="line">        <span class="keyword">return</span> (n % <span class="number">2</span>) ? (x * half * half) : (half * half);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ $T(n)$ &#x3D; $2 \cdot T(\dfrac{n}{2})$ + $O(1)$</li><li><strong>space：</strong>$O(log(n))$ ➔ 取決於遞迴深度, 遞迴深度不超過 $log(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>43. Multiply Strings</title>
      <link href="/post/multiply-strings/"/>
      <url>/post/multiply-strings/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/multiply-strings/">https://leetcode.cn/problems/multiply-strings/</a></strong></p><p><strong>題意：</strong>給兩個以 string 表示的非負整數 <code>num1</code> 和 <code>num2</code>, 返回 <code>num1</code> 和 <code>num2</code> 的乘積 (以 string 表示)。</p><p><strong>注意：</strong>不得使用任何內建的 BigInteger library 或是 直接將 input string 轉換為整數。</p></blockquote><p><img src="https://i.imgur.com/jdW4xux.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用大數乘法, 用整數 array <code>digits</code> 來儲存乘積</strong></p><p>e.g. <code>num1 = &quot;123&quot;</code>, <code>num2 = &quot;45&quot;</code></p><ul><li>令每個數最左邊的數 <code>idx = 0</code>, 每往右一位 <code>idx + 1</code>, <code>digits</code> 最左邊的 idx 也為 0<ul><li><code>num1</code> 中 <code>2</code> 的 <code>idx = 1</code></li><li><code>num2</code> 中 <code>4</code> 的 <code>idx = 0</code></li></ul></li><li>若 <code>num1.size() = m</code>, <code>num2.size() = n</code>, 則 <code>digits.size() = m + n</code><ul><li>若 <code>num1</code> 和 <code>num2</code> 都取最小值, 則 <code>num1</code> 為 $10^{m-1}$, <code>num2</code> 為 $10^{n-1}$<br>  ➔ <code>num1 x num2</code> 為 $10^{m + n - 2}$, 因此乘積的長度 &#x3D; <code>m + n - 1</code></li><li>若 <code>num1</code> 和 <code>num2</code> 都取最大值, 則 <code>num1</code> 為 $10^m-1$, <code>num2</code> 為 $10^n-1$<br>  ➔ <code>num1 x num2</code> 為 $10^{m + n} - 10^m - 10^n + 1$<br>  ➔ $10^{m + n - 1}$ &lt; 乘積 &lt; $10^{m + n}$, 因此乘積的長度 &#x3D; <code>m + n</code></li></ul></li><li>由上述得知 <code>num1 x num2</code> 的長度最多為 <code>m + n</code></li><li><code>num1</code> 中 <code>2</code> 的 <code>idx = 1</code>, 和 <code>num2</code> 中 <code>4</code> 的 <code>idx = 0</code>, 計算出來的 <code>08</code> 會在 <code>digits</code> 的 index 為 <code>[i + j, i + j + 1]</code> 的區間</li><li>計算 <code>digits</code> 是先計算 <code>idx = i + j + 1</code>, 因為 <code>i + j + 1</code> 較靠右 (平時我們做乘法加總時的順序), 然後才讓靠左的 <code>i + j</code> 加總 <code>carry</code></li><li>下圖 <code>123 x 45</code> 會得出 <code>digits</code> 為 <code>05535</code><ul><li>要先<strong>去掉</strong>左邊<strong>開頭為 0 的部分</strong> (leading zero)</li><li>再把剩餘的部分轉成 string, 得到 <code>5535</code></li></ul></li></ul><p><img src="https://i.imgur.com/jEO8iMS.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = num1.<span class="built_in">size</span>(), n = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">digits</span><span class="params">(m + n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                digits[i + j + <span class="number">1</span>] += (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                digits[i + j] += (digits[i + j + <span class="number">1</span>] / <span class="number">10</span>);</span><br><span class="line">                digits[i + j + <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        string res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉開頭的 0(leading zero)</span></span><br><span class="line">        <span class="keyword">while</span> (digits[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res += <span class="built_in">to_string</span>(digits[i++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m + n)$ ➔ <code>digits</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2013. Detect Squares</title>
      <link href="/post/detect-squares/"/>
      <url>/post/detect-squares/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/detect-squares/">https://leetcode.cn/problems/detect-squares/</a></strong></p><p><strong>題意：</strong>給一在 <code>X-Y</code> 平面上的點所構成的 data stream。設計一個滿足下述要求的算法：</p><ul><li><strong>新增</strong>一個在 data stream 中的新點到某個資料結構中。可以新增<strong>重覆</strong>的點, 並且會被視作不同的點</li><li>給一查詢點, 從資料結構中選出三個點, 使這三點、查詢點構成一個<strong>面積為正</strong>的 <strong>axis-aligned square</strong>, <strong>統計</strong>滿足該要求的方法數。</li></ul><p><strong>axis-aligned square</strong> 是一個正方形, 除了四條邊的長度相同外, 還滿足每條邊皆與 <code>X軸</code> or <code>Y軸</code> 平行或垂直。</p><p>實現 <code>DetectSquares</code> class：</p><ul><li><code>DetectSquares()</code>：初始化 <code>DetectSquares</code> instance</li><li><code>void add(int[] point)</code>：向資料結構新增一個新的點 <code>point = [x, y]</code></li><li><code>int count(int[] point)</code>：按上述方式統計與點 <code>point = [x, y]</code> 共同構成 <strong>axis-aligned square</strong> 的方法數</li></ul></blockquote><p><img src="https://i.imgur.com/0Mthla4.png"></p><p><img src="https://i.imgur.com/uPdqbcf.png"></p><p><img src="https://i.imgur.com/MoAYuMS.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：若要建構一正方形, 要先找出 query node 的對角線上的點 <code>(x3, y3)</code>, 便能形成正方形 <code>[(x1, y1), (x1, y3), (x3, y3), (x3, y1)]</code>。首先一一遍歷所有 node, 然後找出滿足符合條件的 query node 的對角線上的點 <code>(x3, y3)</code>, 並計算其方法數</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DetectSquares</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DetectSquares</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; point)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">        ++points[x][y]; <span class="comment">// 新增重覆的點, 會被視作不同的點</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(vector&lt;<span class="type">int</span>&gt; point)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> x1 = point[<span class="number">0</span>], y1 = point[<span class="number">1</span>], res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x = points.<span class="built_in">begin</span>(); x != points.<span class="built_in">end</span>(); ++x) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> yPoints = x-&gt;second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> y = yPoints.<span class="built_in">begin</span>(); y != yPoints.<span class="built_in">end</span>(); ++y) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> x3 = x-&gt;first;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> y3 = y-&gt;first;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 (x3, y3) 不與 (x1, y1) 在同一 X軸 or Y軸上, 且邊的長度相同</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(x3 - x1) != <span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(x3 - x1) == <span class="built_in">abs</span>(y3 - y1)) &#123;</span><br><span class="line">                    res += (points[x3][y3] * points[x3][y1] * points[x1][y3]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 一個 x 對應多個 y 點, e.g. (1, 3), (1, 4) 都會存在 x = 1  umap 中</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; points; <span class="comment">// &#123;x, &#123;y, count&#125;&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>DetectSquares()</code>：$O(1)$</li><li><code>add()</code>：$O(1)$</li><li><code>count()</code>：$O(n^2)$ ➔ for loop 遍歷所有點, 其中 <code>n</code> 為點的個數</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>points</code> 紀錄每個點, 其中 <code>n</code> 為點的個數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>371. Sum of Two Integers</title>
      <link href="/post/sum-of-two-integers/"/>
      <url>/post/sum-of-two-integers/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sum-of-two-integers/">https://leetcode.cn/problems/sum-of-two-integers/</a></strong></p><p><strong>題意：</strong>給兩整數 <code>a</code> 和 <code>b</code>, 在不使用 <code>+</code>、 <code>-</code> 運算的情況下, 返回兩整數之和。</p></blockquote><p><img src="https://i.imgur.com/630CQnM.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將加法拆分成無進位加法、進位這兩個部分</strong></p><ul><li><p><strong>XOR：</strong>為無進位的加法, 透過 <code>a ^ b</code> 得到無進位的加法結果, 還需要找到進位的數, 並把這兩者相加才能得到答案</p><p>  <img src="https://i.imgur.com/OlkwphC.png"></p></li><li><p><strong>&amp;、shift：</strong><code>a &amp; b</code> 把 <code>a</code>、<code>b</code> 中相同位置皆為 1 的 bit 設為 1, 最後再將 <code>a &amp; b</code> 左移一位即可得到進位的數<br>e.g. <code>a = 5</code>, <code>b = 4</code>, 則進位數 &#x3D; <code>a &amp; b</code> &#x3D; <code>0100</code>, 但 <code>0100</code> 並非進位的數, <code>1000</code> 才是真正進位的數</p><p>  <img src="https://i.imgur.com/SXlAFRd.png"></p></li></ul><p><strong>因此, 我們的步驟如下：</strong></p><ul><li>得到 <code>a</code> 和 <code>b</code> 的進位數</li><li>得到無進位加法</li><li>循環此過程, 直到 <code>carry = 0</code></li></ul><p>e.g. <code>a = 5</code>, <code>b = 4</code></p><ul><li>得到 carry <code>b = (a &amp; b) &lt;&lt; 1 = 1000</code>、無進位加法 <code>a = (a ^ b) = 0001</code></li><li>得到 carry <code>b = (a &amp; b) &lt;&lt; 1 = 0000</code>、無進位加法 <code>a = (a ^ b) = 1001</code></li><li><code>b = 0</code> 表示 <code>carry = 0</code> 要結束循環, 得到答案 <code>a = 1001 = 9</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a ^= b;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 最多計算 32 次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. Reverse Integer</title>
      <link href="/post/reverse-integer/"/>
      <url>/post/reverse-integer/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-integer/">https://leetcode.cn/problems/reverse-integer/</a></strong></p><p><strong>題意：</strong>給一 32-bit 的有號整數 <code>x</code>, 返回將 <code>x</code> 中的數字部分反轉後的結果。</p><p>如果反轉後的整數超過 32-bit 的有號整數的範圍 <code>[−$2^&#123;31&#125;$,  $2^&#123;31&#125;$ − 1]</code>, 則返回 <code>0</code>。</p><p>假設不允許儲存 64-bit 整數（有號 or 無號）, 也就是說結果只能用 int 來儲存, 不允許用 long 之類的 data type。</p></blockquote><p><img src="https://i.imgur.com/0QQMzp9.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：int 的範圍是 <code>[-2147483648, 2147483647]</code>, 因此在執行 <code>res = (10 * res) + (x % 10)</code> 前, 要先判斷這樣做是否會 overflow</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="comment">// 避免下面 (10 * res) + (x % 10) 時, 正整數會 overflow</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX / <span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; x % <span class="number">10</span> &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 避免下面 (10 * res) + (x % 10) 時, 負整數會 overflow</span></span><br><span class="line">            <span class="keyword">if</span> (res &lt; INT_MIN / <span class="number">10</span> || (res == INT_MIN / <span class="number">10</span> &amp;&amp; x % <span class="number">10</span> &lt; <span class="number">-8</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = (<span class="number">10</span> * res) + (x % <span class="number">10</span>);</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(x))$ ➔ $\dfrac{x}{10^k} &#x3D; 1$, 得 $k &#x3D; log(x)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>442. Find All Duplicates in an Array</title>
      <link href="/post/find-all-duplicates-in-an-array/"/>
      <url>/post/find-all-duplicates-in-an-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/">https://leetcode.cn/problems/find-all-duplicates-in-an-array/</a></strong></p><p><strong>題意：</strong>給一有 <code>n</code> 個數的 array <code>nums</code>, 每個元素值皆在 <code>[1, n]</code>, 且每個元素可能出現 <strong>一次</strong> or <strong>兩次</strong>, 求所有出現<strong>兩次</strong>的數。</p><p><strong>注意：</strong>使用 $O(n)$ time 和 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/e8xqQOb.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將數字乘以負號來標記我們看到的數字的 index, 然後遍歷 <code>nums</code> 元素, 若 <code>nums[i] &gt; 0</code>, 代表數字 <code>i + 1</code> 出現過兩次(類似 <a href="https://zako945.github.io/post/find-all-numbers-disappeared-in-an-array/">448. Find All Numbers Disappeared in an Array</a>)</strong></p><p>e.g. <code>[1, 1, 2]</code> ➔ <code>[1, -1, 2]</code>, <strong><code>nums[i - 1]</code> 決定數字 <code>i</code> 出現的次數</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(<span class="built_in">abs</span>(num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>784. Letter Case Permutation</title>
      <link href="/post/letter-case-permutation/"/>
      <url>/post/letter-case-permutation/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/letter-case-permutation/">https://leetcode.cn/problems/letter-case-permutation/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 將 <code>s</code> 中的每個字母轉變大小寫, 可得到新的 string。求所有可能的 string, 可以按<strong>順序任意</strong>排列。</p></blockquote><p><img src="https://i.imgur.com/yCztlFW.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p><ul><li>若 <code>s[i]</code> 為數字, 則 <code>s[i]</code> 不變繼續往後走</li><li>若 <code>s[i]</code> 為字母, 則有兩種情況：<ul><li><p><code>s[i]</code> 不變繼續往後走</p></li><li><p><code>s[i]</code> 轉變大小寫後, 繼續往後走</p><p>  <img src="https://i.imgur.com/AOrMtJP.png"></p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCasePermutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string&amp; s, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不論是字母還是數字, 都先自己不變, 並往下一個走</span></span><br><span class="line">        <span class="built_in">dfs</span>(s, i + <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">            <span class="comment">// 因為 &#x27;a&#x27; - &#x27;A&#x27; = 32 = 2^5</span></span><br><span class="line">            <span class="comment">// 在 s[i] 為字母的條件下, 對右邊數來第5個 bit 跟 1 做 XOR</span></span><br><span class="line">            <span class="comment">// 因為 XOR: (0, 1) = 1, (1, 1) = 0</span></span><br><span class="line">            s[i] ^= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); <span class="comment">// 等同於 s[i] 根據大小寫 +/- 32</span></span><br><span class="line">            <span class="built_in">dfs</span>(s, i + <span class="number">1</span>, n);</span><br><span class="line">            s[i] ^= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); <span class="comment">// XOR 做兩次相同運算 = 還原</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$<ul><li>最多 $2^n$ 種狀態（<code>n</code> 個都字母）</li><li>建每一種狀態的需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(n \cdot 2^n)$ ➔ $O(n) + O(n \cdot 2^n)$<ul><li>$O(n)$ : <code>dfs()</code> 遞迴最大深度</li><li>$O(n \cdot 2^n)$ : 最多 $2^n$ 種狀態（<code>n</code> 個都字母）, 每種狀態的 string 長度都為 <code>n</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>647. Palindromic Substrings</title>
      <link href="/post/palindromic-substrings/"/>
      <url>/post/palindromic-substrings/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 返回迴文 substring 數量。</p></blockquote><p><img src="https://i.imgur.com/RPEOQB5.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用DP, 可參考 <a href="https://zako945.github.io/post/longest-palindromic-substring/">5. Longest Palindromic Substring</a></strong></p><p><img src="https://i.imgur.com/hNq2e4T.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n; <span class="comment">// 每個 char 自己本身(對角線)為回文</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; ++i) &#123;</span><br><span class="line">                dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用中心擴散法</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">expand</span>(s, i, i, n, res); <span class="comment">// odd string</span></span><br><span class="line">            <span class="built_in">expand</span>(s, i, i + <span class="number">1</span>, n, res); <span class="comment">// even string</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">const</span> <span class="type">int</span> n, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 遍歷每個 char, 每個 char 為中心最多往外擴散 $\dfrac{n}{2}$ 次, 得 $2 \cdot O(\dfrac{n}{2}) \cdot n$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-3：（不會也沒差-會前兩種方法就足夠了）"><a href="#Solution-3：（不會也沒差-會前兩種方法就足夠了）" class="headerlink" title="Solution 3：（不會也沒差, 會前兩種方法就足夠了）"></a><strong>Solution 3：（不會也沒差, 會前兩種方法就足夠了）</strong></h2><blockquote><p><strong>想法：利用 Manacher 演算法, 可參考 <a href="https://zako945.github.io/post/longest-palindromic-substring/">5. Longest Palindromic Substring</a>, <code>res += (p[i] + 1) / 2</code> 的原因為以下兩種：</strong></p><ul><li><strong>若 <code>p[i] = 1</code>：<code>&quot;abc&quot;</code> 擴充後 a, b, c 之 <code>p[i]</code> 皆為 1, 擴充半徑為 1, 代表回文只有自己, 但這也算一種回文</strong></li><li><strong>若 <code>p[i] &gt; 1</code>：<code>&quot;aba&quot;</code> 擴充後 b 之 <code>p[i] = 3</code>, 從 b 為中心得到的回文 substring 有：<code>&quot;b&quot;</code>（擴充半徑 &#x3D; 0）和 <code>&quot;aba&quot;</code>（擴充半徑 &#x3D; 1）, 也就是擴充半徑 <code>[0, (p[i] / 2)]</code>, 共 <code>(p[i] / 2) + 1</code> 種, 也可寫作 <code>(p[i] + 1) / 2</code> 種（奇偶都符合）</strong></li></ul><p>➔ <strong>公式：<code>(p[i] + 1) / 2</code> 滿足上述兩種情況</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string tmp = <span class="built_in">preProcess</span>(s);</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = tmp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n - <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 最後一個 $ 不用算</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>, center = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idxMirror = <span class="number">2</span> * center - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 防止超出 right</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; right) &#123;</span><br><span class="line">                p[i] = <span class="built_in">min</span>(p[idxMirror], right - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// i &gt;= right 的時候</span></span><br><span class="line">                p[i] = <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 有三種情況, 需使用中心擴散法</span></span><br><span class="line"><span class="comment">             * 1. i + p[idxMirror] &gt; right</span></span><br><span class="line"><span class="comment">             * 2. i &gt;= right 的時候</span></span><br><span class="line"><span class="comment">             * 3. p[idxMirror] 遇到左邊界</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (tmp.<span class="built_in">at</span>(i - <span class="number">1</span> - p[i]) == tmp.<span class="built_in">at</span>(i + <span class="number">1</span> + p[i])) &#123;</span><br><span class="line">                ++p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判斷是否超出右邊界, 是的話要更新右邊界和中心</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; right) &#123;</span><br><span class="line">                center = i;</span><br><span class="line">                right = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res += (p[i] + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">string <span class="title">preProcess</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        string tmp = <span class="string">&quot;^&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            tmp += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            tmp += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 透過不斷拓展 <code>right</code>, 且 <code>right</code> 只增不減, 故只看 for loop, 因為 while loop 拜訪過的 char 不會再進 while loop（可透過 DP 快速得到）</li><li><strong>space：</strong>$O(n)$ ➔ <code>tmp</code>, <code>p</code> 的長度 &#x3D; <code>2 * s.size() + 3</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. Decode Ways</title>
      <link href="/post/decode-ways/"/>
      <url>/post/decode-ways/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/decode-ways/">https://leetcode.cn/problems/decode-ways/</a></strong></p><p><strong>題意：</strong>給一只含數字的<strong>非空</strong> string <code>s</code>，計算並返回解碼的方法數</p><p>一則包含字母 <code>A-Z</code> 的訊息透過以下 mapping 進行編碼:</p><p><img src="https://i.imgur.com/8r5NyQR.png"></p><p>要<strong>解碼</strong>已編碼的訊息, 其所有數字必須基於上述 mapping 的方法，反向 mapping 回字母（可能有多種方法）。例如 : “11106” 可以 mapping 為：</p><ul><li><code>AAJF</code> 將訊息分組為 <code>(1 1 10 6)</code></li><li><code>KJF</code> 將訊息分組為 <code>(11 10 6)</code></li></ul><p><strong>注意：</strong>訊息並不能分組為 <code>(1 11 06)</code>, 因為 <code>06</code> 並不能 mapping 為 <code>F</code>, 這是因為 <code>6</code> 和 <code>06</code> 在 mapping 中並不等價</p><p>答案保證符合 32-bit 整數的範圍</p></blockquote><p><img src="https://i.imgur.com/4qpRXdo.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 DFS, 其中每個 char 都有兩種選擇：</strong></p><ul><li>自己一組, 前提是自己不能為 <code>&#39;0&#39;</code>。若為 <code>&#39;0&#39;</code>, 則一定要跟其他 char 一組</li><li>自己 + 後面一個 char 一組, 前提是 <code>&quot;10&quot; &lt;= substring &lt;=&quot;26&quot;</code></li></ul><p><img src="https://i.imgur.com/WpThPOV.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能自己一組</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不為 &#x27;0&#x27;, 則可自己一組</span></span><br><span class="line">        <span class="built_in">dfs</span>(s, i + <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 兩個 char 一組, 則必須介於 10 ~ 26 之間</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span> || (s[i] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(s, i + <span class="number">2</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$<ul><li>$O(2^n)$ : 每一個 char 有兩種選擇, 一種是自己一組, 另外是和後面一個 char 一組, 總共 $2^n$ 種</li><li>建構每一種狀況需花 $O(n)$ time</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, 最大遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i]</code> 代表 <code>s[0~(i-1)]</code> 的解碼方法數</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// empty string 不需解碼, 方法數為 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 若不為 0, 則可以自己一組</span></span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 前一個 char + 自己一組, 則 dp[i] += dp[i-2]</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span> || (s[i - <span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">                    dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, <code>dp[i]</code> 最多用到 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code>, 因此不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">1</span>, two = <span class="number">1</span>; <span class="comment">// [two, one, cur]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 若不為 0, 則可以自己一組</span></span><br><span class="line">            <span class="type">int</span> cur = (s[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) ? <span class="number">0</span> : one;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span> || (s[i - <span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">                    cur += two;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            two = one;</span><br><span class="line">            one = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322. Coin Change</title>
      <link href="/post/coin-change/"/>
      <url>/post/coin-change/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>coins</code>, 表示不同面額的零錢, 和一整數 <code>amount</code> 代表總金額。</p><p>計算可以湊成 <code>amount</code> 的<strong>最少硬幣數</strong>。如果無法湊成, 則返回 <code>-1</code>。</p><p>每種硬幣的數量都是無限的。</p></blockquote><p><img src="https://i.imgur.com/gYnZ7qR.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p><p><img src="https://i.imgur.com/OkYazSi.png"></p></blockquote><ul><li><p><strong>普通版</strong>：DFS</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = amount + <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(coins, amount, count, res);</span><br><span class="line">        <span class="keyword">return</span> (res == amount + <span class="number">1</span>) ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">const</span> <span class="type">int</span> amount, <span class="type">const</span> <span class="type">int</span> count, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(count, res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt;= coin) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(coins, amount - coin, count + <span class="number">1</span>, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>進階版</strong>：DFS + greedy（每次取最大面額）+ pruning</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort coins in descending order</span></span><br><span class="line">        <span class="built_in">sort</span>(coins.<span class="built_in">rbegin</span>(), coins.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="type">int</span> res = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(coins, <span class="number">0</span>, amount, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> (res == amount + <span class="number">1</span>) ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">const</span> <span class="type">int</span> idx, <span class="type">const</span> <span class="type">int</span> amount, <span class="type">const</span> <span class="type">int</span> count, <span class="type">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, count);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx == coins.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> coin = coins[idx]; <span class="comment">// 每次取最大面額的硬幣</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = amount / coin; k &gt;= <span class="number">0</span> &amp;&amp; count + k &lt; res; --k) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(coins, idx + <span class="number">1</span>, amount - k * coin, count + k, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 利用 DP 來避免重複計算（圖中綠色圈起來的部分）, 其中 <code>dp[i]</code> 為湊齊金額 <code>i</code> 的最少硬幣數</strong></p><p><img src="https://i.imgur.com/OkYazSi.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 金額範圍 : 0 ~ amount (amount + 1 種), 每種金額的最少硬幣數初始為 amount + 1</span></span><br><span class="line"><span class="comment">         * 若 coins 中的硬幣面額能湊齊金額 i, 則 dp[i] 一定小於 amount (因為面額最小為 1)</span></span><br><span class="line"><span class="comment">         * 故初始值故意設成大於 amount 的數 (amount + 1), 用一個不可能的數代表無法湊齊</span></span><br><span class="line"><span class="comment">         * 這樣當 dp[i] == amount + 1 時, 代表無法用 coins 中的硬幣面額湊齊金額 i</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 湊齊金額 0 的最少硬幣數為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(amount \cdot n)$ ➔ for loop, 其中 <code>n</code> 為硬幣的種類</li><li><strong>space：</strong>$O(amount)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>152. Maximum Product Subarray</title>
      <link href="/post/maximum-product-subarray/"/>
      <url>/post/maximum-product-subarray/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-product-subarray/">https://leetcode.cn/problems/maximum-product-subarray/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 找出乘積最大的非空<strong>連續</strong> subarray, 並返回該乘積。</p></blockquote><p><img src="https://i.imgur.com/rN6QfDI.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：定義乘積為區間 <code>[0, i]</code> 中的最大 or 最小乘積。為何乘積必須同時記錄 <code>curMax</code> 和 <code>curMin</code>？因為 array 中可能會有負數, 且負負得正。當 <code>nums[i]</code> 為負數時, 之前紀錄的 <code>curMax</code> 乘它之後變最小值, 也有可能之前紀錄的 <code>curMin</code> 乘它之後變比之前的 <code>curMax</code> 還大。所以當 <code>nums[i]</code> 為負數時, 要將 <code>curMax</code> 和 <code>curMin</code> 做 swap, 這樣才不會出錯</strong></p><p><img src="https://i.imgur.com/gsvOAgs.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curMax = <span class="number">1</span>, curMin = <span class="number">1</span>, res = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(curMax, curMin);</span><br><span class="line">            &#125;</span><br><span class="line">            curMax = <span class="built_in">max</span>(num * curMax, num);</span><br><span class="line">            curMin = <span class="built_in">min</span>(num * curMin, num);</span><br><span class="line">            res = <span class="built_in">max</span>(res, curMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>139. Word Break</title>
      <link href="/post/word-break/"/>
      <url>/post/word-break/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/word-break/">https://leetcode.cn/problems/word-break/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code> 和一 string list <code>wordDict</code>, 若 <code>wordDict</code> 中的單字能組出 <code>s</code> 則返回 <code>true</code>。</p><p><strong>注意：</strong><code>wordDict</code> 中的 string 互不相同, 且 <code>s.length ≤ 300</code></p></blockquote><p><img src="https://i.imgur.com/Vb1Qrdx.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i]</code> 代表 <code>s[0~(i-1)]</code> 是否能被拆分成若干個出現在 <code>wordDict</code> 中的單字, 我們要枚舉 <code>s[0~(i-1)]</code> 中的切割點 <code>j</code>, 使得 <code>s[0~(j-1)]</code> 和 <code>s[j~(i-1)]</code> 皆在 <code>wordDict</code> 中, 由於 <code>j &lt; i</code>, 所以要計算 <code>dp[i]</code> 時可透過先前計算過的 <code>d[j]</code> 知道 <code>s[0~j]</code> 是否能被拆分, 然後再判斷 <code>s[j~(i-1)]</code> 是否在 <code>wordDict</code> 中即可, 故得到以下公式：</strong></p><ul><li><strong><code>dp[i] = dp[j] &amp;&amp; check(s[j~(i-1)])</code></strong></li><li><strong><code>check(s[j~(i-1)])</code> 代表檢查 <code>s[j~(i-1)]</code> 是否在 <code>wordDict</code> 中</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 空字串一定在 wordDict 中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(j, i - j)) != wordSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2：（TLE-無法通過）"><a href="#Solution-2：（TLE-無法通過）" class="headerlink" title="Solution 2：（TLE 無法通過）"></a><strong>Solution 2：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 DFS + Trie</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                node-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : wordDict) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> <span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TrieNode *node = trie.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idx = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx]) &#123;</span><br><span class="line">                node = node-&gt;children[idx];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// s[cur~i] 為 word, 則以 i + 1 為開頭繼續遞迴拆分</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;isEnd &amp;&amp; <span class="built_in">dfs</span>(s, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>time：</strong>$O(\sum_{i &#x3D; 0}^{m-1}{w_i} + 2^n)$, 其中 $m$ 為 <code>wordDict</code> 中單字的個數, $w_i$ 為 <code>wordDict[i]</code> 的長度, $n$ 為 <code>s</code> 的長度</p><ul><li><p>$O(\sum_{i &#x3D; 0}^{m-1}{w_i})$：將 <code>wordDict</code> 中每個單字 insert 到 trie 中</p></li><li><p>$O(2^{n})$：判斷長度為 <code>n</code> 的 <code>s</code> 能否拆分成其他單字。$T(n) &#x3D; T(n - 1) + T(n - 2) + … + T(1)$</p><p>  <img src="https://i.imgur.com/DLpKESz.png"></p></li></ul></li><li><p><strong>space：</strong>$O(\sum_{i &#x3D; 0}^{m-1}{w_i})$ ➔ $O(26 \cdot \sum_{i &#x3D; 0}^{m-1}{w_i})$, worse case：trie 中所有單字都沒有重複的 prefix</p></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 DFS + Trie + DP, 改進 Solution 2, 若 <code>s</code> 中 <code>idx = cur</code> 為開頭往後的 substring 無法由若干個 <code>wordDict[i]</code> 所組成, 則透過 <code>memo</code> 紀錄起來, 藉此來進行 pruning, 避免重複走失敗的道路</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                node-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : wordDict) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line">    <span class="type">bool</span> memo[<span class="number">300</span>] = &#123;<span class="literal">false</span>&#125;; <span class="comment">// 紀錄 s 中以 idx 為開頭是否能分割出 word, true 代表不行</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> <span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若已經被標記為失敗, 則直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (memo[cur] == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TrieNode *node = trie.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idx = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx]) &#123;</span><br><span class="line">                node = node-&gt;children[idx];</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;isEnd &amp;&amp; <span class="built_in">dfs</span>(s, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo[cur] = <span class="literal">true</span>; <span class="comment">// 標記為失敗</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(\sum_{i &#x3D; 0}^{m-1}{w_i} + n^2)$, 其中 $m$ 為 <code>wordDict</code> 中單字的個數, $w_i$ 為 <code>wordDict[i]</code> 的長度, $n$ 為 <code>s</code> 的長度<ul><li>$O(\sum_{i &#x3D; 0}^{m-1}{w_i})$：將 <code>wordDict</code> 中每個單字 insert 到 trie 中</li><li>$O(n^2)$：判斷長度為 <code>n</code> 的 <code>s</code> 能否拆分成其他單字<ul><li>$O(n^2)$ : $T(n) &#x3D; T(n - 1) + O(n)$, 因為有用 <code>memo</code> 記憶, 所以呼叫 $T(n-1)$ 即可, 因為 $T(n-1)$ 會再往下呼叫 $T(n-2)$, 依此類推 …, 每個 $T(n-i)$ 只要呼叫一次即可（因為會記住結果）。</li><li>$O(n)$ 是因為呼叫一次 $T(n-1)$ 後, 剩下 $T(n-2), …, T(1)$ 都會計算出來。原本 $O(n)$ 應寫作 $T(n-2) + T(n-3) + … +T(1)$, 但是除了 $T(n-1)$, 剩下的 $T(n-i)$ 都只需 $O(1)$, 故 $T(n-2) + T(n-3) + … +T(1)$ 可直接寫成 $O(n)$。</li></ul></li></ul></li><li><strong>space：</strong>$O(\sum_{i &#x3D; 0}^{m-1}{w_i})$ ➔ $O(26 \cdot \sum_{i &#x3D; 0}^{m-1}{w_i})$ + $O(1)$<ul><li>$O(26 \cdot \sum_{i &#x3D; 0}^{m-1}{w_i})$：worse case：trie 中所有單字都沒有重複的 prefix</li><li>$O(1)$：<code>memo</code> 為常數空間</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>300. Longest Increasing Subsequence</title>
      <link href="/post/longest-increasing-subsequence/"/>
      <url>/post/longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 找出其中最長的<strong>嚴格遞增</strong> subarray 之長度。</p><p><strong>進階：</strong>設計 $O(n \cdot log(n))$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/lpfOr7e.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>nums</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i]</code>：<code>nums[1:i]</code> 中 LIS 的長度</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>dp[i] = max(dp[i], dp[j] + 1)</code>, for <code>1 ≤ j &lt; i</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0]</code>：當沒有元素時, LIS 的長度為 <code>0</code></li><li><code>dp[i]</code>：至少一個元素時, LIS 的長度最小為 <code>1</code>, 其中 <code>1 ≤ i ≤ n</code></li><li><code>res</code>：至少一個元素時, LIS 的長度最小為 <code>1</code></li></ul><p><img src="https://i.imgur.com/lUEZXzy.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>; <span class="comment">// 題目給定 nums 不為空</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：使用 DP + Greedy + Binary Search, 我們在乎只當前 subarray 的結尾</strong></p><p><img src="https://i.imgur.com/iJkD0sg.png"></p><p><img src="https://i.imgur.com/sbioTED.png"></p><p><strong>每當有一新數字 <code>num</code> 進來之後, 判斷 <code>num</code> 是否比現在 <code>dp.back()</code> 的數值大</strong></p><ul><li>若 <code>num &gt; dp.back()</code>, 那就直接放到 <code>dp.back()</code> 的後面, 成為新的結尾</li><li>否則, 用 Binary Search 找到 <code>dp</code> 中從左數來第一個大於 <code>num</code> 的數字, 並將其替換掉。<br>（<strong>因為 <code>dp</code> 結尾變小, 將來可能可以接得更長</strong>）<br>e.g. 下圖中紅框部分, 用 <code>5</code> 取代 <code>8</code>, 使 <code>dp</code> 結尾變小, 讓之後的 <code>6</code> 能加入</li></ul><p>e.g. <code>nums = [3, 4, 1, 2, 8, 5, 6]</code></p><p><img src="https://i.imgur.com/SHbfXNJ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">        dp.<span class="built_in">emplace_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp.<span class="built_in">back</span>() &lt; nums[i]) &#123;</span><br><span class="line">                dp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *<span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), nums[i]) = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ for loop, 其中 <code>lower_bound()</code> 是使用 Binary Search 實作的</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>416. Partition Equal Subset Sum</title>
      <link href="/post/partition-equal-subset-sum/"/>
      <url>/post/partition-equal-subset-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></strong></p><p><strong>題意：</strong>給一<strong>只含正整數</strong>的非空 array <code>nums</code>, 返回是否能將 <code>nums</code> 切割成兩個 subset, 使得兩個 subset 的元素和相等。</p></blockquote><p><img src="https://i.imgur.com/MpRRg9c.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 因為此題可看作是 0-1 背包問題, 從前 <code>i</code> 個數中取出一些數, 使這些數之和為 <code>target</code>, 其中 <code>dp[i][j]</code> 代表前 <code>i</code> 個數是否能取出一些數, 使得這些數和為 <code>j</code>, 可得以下公式：</strong></p><ul><li><strong>不選擇 <code>nums[i]</code>：<code>dp[i][j] = dp[i - 1][j]</code></strong></li><li><strong>選擇 <code>nums[i]</code>：<code>dp[i][j] = dp[i - 1][j - nums[i]]</code>, 其中 <code>j &gt;= nums[i]</code></strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(target + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][0] 皆為 true, 因為前 i 個數都不取, 必滿足 sum = 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= target; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot sum)$ ➔ for loop, 因為 target &#x3D; $\dfrac{sum}{2}$</li><li><strong>space：</strong>$O(n \cdot sum)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>dp[i][j]</code> 只會用到上一列的元素, 故不需要開到</strong> $O(n \cdot sum)$ <strong>空間, 只需記住上一列的狀態即可, 這樣只需要 $O(2 \cdot sum)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// dp[0] 為 true, 因為前 i 個數都不取, 必滿足 sum = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="type">bool</span>&gt; nextRow = dp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= target; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    nextRow[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextRow[j] = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot sum)$ ➔ for loop, 因為 target &#x3D; $\dfrac{sum}{2}$</li><li><strong>space：</strong>$O(sum)$ ➔ <code>dp</code> 和 <code>nextRow</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, 將空間從 2 * sum 降到 sum, 其中 <code>j</code> 的 for loop 必須從後面來, 這樣才不會在同一次 loop 中用到剛賦值的</strong></p><p>e.g. <code>nums = [2, 2, 3, 5]</code>, <code>target = 6</code>, 沒解</p><ul><li>順著來：<code>i = 1</code><ul><li><p><code>j = 2</code> 時, <code>dp[i][2] = true</code></p></li><li><p><code>j = 4</code> 時, <code>dp[i][4] = dp[i][2] = true</code></p></li><li><p><code>j = 6</code> 時, <code>dp[i][6] = dp[i][4] = true</code>, 不符答案</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>T</td><td>F</td><td>T</td><td>F</td><td>T</td><td>F</td><td>T</td></tr></tbody></table></li></ul></li><li>倒著來：<code>i = 1</code><ul><li><p><code>j = 6</code> 時, <code>dp[i][6] = dp[i][4] = false</code></p></li><li><p><code>j = 4</code> 時, <code>dp[i][4] = dp[i][2] = false</code></p></li><li><p><code>j = 2</code> 時, <code>dp[i][2] = dp[i][0] = true</code></p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>T</td><td>F</td><td>T</td><td>F</td><td>F</td><td>F</td><td>F</td></tr></tbody></table></li><li><p>最終輸出為：下表, 得到答案為 false</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>T</td><td>F</td><td>T</td><td>T(i&#x3D;3)</td><td>T(i&#x3D;2)</td><td>T(i&#x3D;4)</td><td>F</td></tr></tbody></table></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 倒著才不會用到在同一個 j loop 中剛賦值完的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot sum)$ ➔ for loop, 因為 target &#x3D; $\dfrac{sum}{2}$</li><li><strong>space：</strong>$O(sum)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62. Unique Paths</title>
      <link href="/post/unique-paths/"/>
      <url>/post/unique-paths/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></strong></p><p><strong>題意</strong>：有一機器人位於 <code>m x n</code> 網格的<strong>左上角</strong>, 機器人每次只能往下 or 往右一步, 機器人試圖抵達網格的<strong>右下角</strong>, 求總共幾條不同的路徑。</p></blockquote><p><img src="https://i.imgur.com/ZTNi2hP.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 定義 <code>dp[i][j]</code> 為從起點到 <code>(i, j)</code> 的方法數, 其中第一列和第一行方法數皆初始化為 <code>1</code>（因為只能往下、右移動）。要避免重複計算（圖中橘色圈起來的部分）, <code>dp[i][j]  = 其左邊格子的方法數 + 上方格子的方法數</code></strong><br>➔ 得到 <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p><p><img src="https://i.imgur.com/2W7qu0D.png"></p><p><img src="https://i.imgur.com/uWIclvR.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>dp[i][j]</code> 只會用到同一列的 <code>dp[i][j - 1]</code> 和上一列 <code>dp[i - 1][j]</code>, 故不需要開到 $O(m \cdot n)$ space, 只需開到 $O(n)$</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; nextRow = dp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                nextRow[j] = nextRow[j - <span class="number">1</span>] + dp[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code> 和 <code>nextRow</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：用到排列組合數學, 總共要走 <code>m - 1</code> 個 <code>⇩</code> 和 <code>n - 1</code> 個 <code>⇨</code>, 可看成不盡相異物排列</strong></p><p>$\binom{(m-1)+(n-1)}{m-1} &#x3D; \binom{m+n-2}{m-1} &#x3D; \dfrac{(m+n-2)(m+n-3) … n}{(m-1)(m-2) … 1}$</p><p>$&#x3D; \dfrac{n}{1} \cdot \dfrac{n + 1}{2} … \dfrac{m+n-3}{m-2} \cdot \dfrac{m+n-2}{m-1}$</p><p><strong>其中，$\binom{m+n-2}{m-1} &#x3D; \binom{m+n-2}{n-1}$，故可以取 <code>r = min(m, n)</code> 來簡化計算</strong></p><ul><li>若 <code>r</code> 取 <code>m</code>，則 <code>分子 - 分母 = n - 1</code></li><li>若 <code>r</code> 取 <code>n</code>，則 <code>分子 - 分母 = m - 1</code></li></ul><p>令 <code>分母 = i = [0, r - 1]</code>，<code>k = m + n - 2</code>，則 <code>分子 = k - r + i</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> k = m + n - <span class="number">2</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> r = <span class="built_in">min</span>(m, n) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> diff = k - r;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1.0</span>; <span class="comment">// 要用 float 或 double</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">            res *= ((diff + i) / i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(min(m, n))$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1143. Longest Common Subsequence</title>
      <link href="/post/longest-common-subsequence/"/>
      <url>/post/longest-common-subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></strong></p><p><strong>題意：</strong>給兩 string <code>text1</code>、<code>text2</code>, 返回最長<strong>共同 subsequence</strong> 的長度。若不存在最長<strong>共同 subsequence</strong>, 則返回 <code>0</code>。</p><p><strong>注意：</strong></p><ul><li>substring 指的是 string 中<strong>連續的</strong> subset</li><li>subsequence 則是 string 的 subset</li><li><code>text1</code>、<code>text2</code> 只由<strong>小寫</strong>字母所組成</li></ul></blockquote><p><img src="https://i.imgur.com/rJbnkDq.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>text1</code>、<code>text2</code> 前先加上一個 <code>#</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code>：<code>text1[1:i]</code>、<code>text2[1:j]</code> 的 LCS 之長度</li></ul><p><strong>2. 得到轉移方程：</strong></p><p>令 <code>text1[1:i] = XXXXi</code>, <code>text2[1:j] = YYYj</code></p><ul><li><p>若 <code>text1[i] == text2[j]</code>, 則 <code>[XXXX]</code>、<code>[YYY]</code> 之 LCS 再加上 <code>text1[i]</code> 即可<br>➔ <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p></li><li><p>否則, LCS 為以下兩種中取較大者</p><ul><li><code>[XXXXi]</code>、<code>[YYY]</code>：<code>dp[i][j - 1]</code></li><li><code>[XXXX]</code>、<code>[YYYj]</code>：<code>dp[i - 1][j]</code></li></ul><p>  ➔ <code>dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</code></p></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：當 <code>text1</code>、<code>text2</code> 皆為 <code>&quot;&quot;</code> 時, LCS 必為 <code>&quot;&quot;</code><br>➔ <code>dp[0][0] = 0</code></li><li><code>dp[i][0]</code>：當 <code>text2</code> 為 <code>&quot;&quot;</code> 時, LCS 必為 <code>&quot;&quot;</code><br>➔ <code>dp[i][0] = 0</code></li><li><code>dp[0][j]</code>：當 <code>text1</code> 為 <code>&quot;&quot;</code> 時, LCS 必為 <code>&quot;&quot;</code><br>➔ <code>dp[0][j] = 0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = text1.<span class="built_in">size</span>(), n = text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        text1 = <span class="string">&#x27;#&#x27;</span> + text1;</span><br><span class="line">        text2 = <span class="string">&#x27;#&#x27;</span> + text2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 發現其實計算 <code>dp[i][j]</code> 只需用到當前列的 <code>dp[i][j - 1]</code> 和上一列的 <code>dp[i - 1][j]</code>, 因此只需紀錄當前列和上一列的計算結果即可, 而不用紀錄整個 <code>m x n</code> matrix, 這樣就能將 $O(m \cdot n)$ space 降至 $O(n)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = text1.<span class="built_in">size</span>(), n = text2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 讓 n 為較短的 string 長度</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">longestCommonSubsequence</span>(text2, text1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        text1 = <span class="string">&#x27;#&#x27;</span> + text1;</span><br><span class="line">        text2 = <span class="string">&#x27;#&#x27;</span> + text2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; nextRow = dp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]) &#123;</span><br><span class="line">                    nextRow[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextRow[j] = <span class="built_in">max</span>(nextRow[j - <span class="number">1</span>], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow); <span class="comment">// 更新 dp, 下一輪中這輪所計算的會變成上一輪</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(min(m, n))$ ➔ <code>dp</code>, <code>nextRow</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>309. Best Time to Buy and Sell Stock with Cooldown</title>
      <link href="/post/best-time-to-buy-and-sell-stock-with-cooldown/"/>
      <url>/post/best-time-to-buy-and-sell-stock-with-cooldown/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></strong></p><p><strong>題意：</strong>給一 array <code>prices</code>, 其中 <code>prices[i]</code> 代表第 i 天的股票價格, 在滿足下列條件的前提下, 盡可能地完成更多的交易, 計算出最大利潤。</p><ul><li>賣出股票後, 你沒辦法在下一天買入股票(冷凍期為一天)</li><li>不能同時參與多筆交易, 必須在再次購買前出售掉之前的股票</li></ul></blockquote><p><img src="https://i.imgur.com/Q4znRVs.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>prices</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>rest[i]</code> 代表第 <code>i</code> 天手上<strong>未持有</strong>股票, 且狀態為 <code>rest</code> 的最大收益</li><li><code>hold[i]</code> 代表第 <code>i</code> 天手上<strong>持有</strong>股票, 且狀態為 <code>hold</code> 的最大收益<br>（手上持有股票然後休息, 其狀態仍是 <code>hold</code>。<code>rest</code> 狀態必須在未持有股票時）</li><li><code>sold[i]</code> 代表第 <code>i</code> 天手上<strong>未持有</strong>股票, 且狀態為 <code>sold</code> 的最大收益</li></ul><p><strong>2. 根據下圖, 可得狀態轉移方程：</strong></p><ul><li><p><code>rest[i] = max(rest[i - 1], sold[i - 1])</code></p></li><li><p><code>hold[i] = max(hold[i - 1], rest[i - 1] - prices[i])</code></p></li><li><p><code>sold[i] = hold[i - 1] + prices[i]</code></p><p>  <img src="https://i.imgur.com/arUNmnP.png"></p></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>hold[0]</code>、<code>sold[0]</code>、<code>rest[0]</code>：沒有股票時, 最大利潤為 <code>0</code></li><li><code>hold[1]</code>：第一天買入 ➔ 此時最大利潤為 <code>prices[1]</code></li><li><code>sold[1]</code>：第一天買入, 並且賣出 ➔ 此時最大利潤為 <code>0</code></li><li><code>rest[1]</code>：第一天不操作 ➔ 此時最大利潤為 <code>0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hold</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">sold</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">rest</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        prices.<span class="built_in">emplace</span>(prices.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        hold[<span class="number">1</span>] = -prices[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            rest[i] = <span class="built_in">max</span>(sold[i - <span class="number">1</span>], rest[i - <span class="number">1</span>]);</span><br><span class="line">            hold[i] = <span class="built_in">max</span>(hold[i - <span class="number">1</span>], rest[i - <span class="number">1</span>] - prices[i]); <span class="comment">// 買入股票, 收益減少</span></span><br><span class="line">            sold[i] = hold[i - <span class="number">1</span>] + prices[i]; <span class="comment">// 賣出股票, 收益增加</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大利潤不可能出現在 buy 而未 sell 的時候, 所以不考慮最後一天為 hold 的狀態</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rest.<span class="built_in">back</span>(), sold.<span class="built_in">back</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>hold</code>, <code>sell</code> 和 <code>rest</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>hold[i]</code>、<code>sold[i]</code>、<code>rest[i]</code> 只會用到 <code>i - 1</code> 的狀態, 因此只要儲存 <code>i - 1</code> 的狀態即可, 根本不需要開到 $O(n)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        prices.<span class="built_in">emplace</span>(prices.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hold = -prices[<span class="number">1</span>], sold = <span class="number">0</span>, rest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> prevHold = hold, prevSold = sold, prevRest = rest;</span><br><span class="line">            rest = <span class="built_in">max</span>(prevRest, prevSold);</span><br><span class="line">            hold = <span class="built_in">max</span>(prevHold, prevRest - prices[i]);</span><br><span class="line">            sold = prevHold + prices[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rest, sold);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>518. Coin Change II</title>
      <link href="/post/coin-change-ii/"/>
      <url>/post/coin-change-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>coins</code> 表示不同面額的硬幣, 和一整數 <code>amount</code> 表示總金額。</p><p>返回可以湊成 <code>amount</code> 的硬幣組合數。如果任何硬幣組合都無法湊出總金額, 則返回 <code>0</code>。</p><p>假設每一種面額的硬幣有無限個。</p><p>題目保證結果符合 32-bit 有號整數。</p></blockquote><p><img src="https://i.imgur.com/VMktizM.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>coins</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code>：前 <code>i</code> 種硬幣湊齊金額 <code>j</code> 的組合數</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>coins[i]</code> 有「選 or 不選」兩種可能：<ul><li><code>rods[i]</code> 不選, 則 <code>dp[i][j] = dp[i - 1][j]</code></li><li><code>rods[i]</code> 要選, 則 <code>dp[i][j] = dp[i][j - coins[i]]</code>（每一種面額可無限取, 故為 <code>i</code> 而非 <code>i - 1</code>）</li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：當沒有任何硬幣時, 湊齊金額 <code>0</code> 的組合數為 <code>1</code>（什麼都不選也是一種方案）<br>➔ <code>dp[0][0] = 1</code></li><li><code>dp[i][0]</code>：當 <code>amount = 0</code> 時, 前 <code>i</code> 種硬幣湊齊金額 <code>j</code> 的組合數為 <code>1</code>（什麼都不選也是一種方案）, 其中 <code>1 ≤ i ≤ n</code><br>➔ <code>dp[i][0] = 1</code></li><li><code>dp[0][j]</code>：當沒有任何硬幣時, 湊齊金額 <code>j</code> 的組合數為 <code>0</code>, 其中 <code>1 ≤ j ≤ amount</code><br>➔ <code>dp[0][j] = 0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        coins.<span class="built_in">emplace</span>(coins.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每種硬幣湊齊金額 0 的組合數皆只有一種</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123; <span class="comment">// 若金額 ≥ 硬幣面額, 則該種硬幣有取 or 不取兩種選擇</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若金額 &lt; 硬幣面額, 則該種硬幣只有不取這一選擇</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot amount)$ ➔ for loop, 其中 <code>n</code> 是硬幣種類</li><li><strong>space：</strong>$O(n \cdot amount)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>dp[i][j]</code> 只會用到上一列的狀態, 故只需記住上一列的狀態即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        coins.<span class="built_in">emplace</span>(coins.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> prevRow = dp; <span class="comment">// 記住上一列的狀態</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123; <span class="comment">// 若金額 ≥ 硬幣面額, 則該種硬幣有取 or 不取兩種選擇</span></span><br><span class="line">                    dp[j] = prevRow[j] + dp[j - coins[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若金額 &lt; 硬幣面額, 則該種硬幣只有不取這一選擇</span></span><br><span class="line">                    dp[j] = prevRow[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot amount)$ ➔ for loop, 其中 <code>n</code> 是硬幣種類</li><li><strong>space：</strong>$O(amount)$ ➔ <code>dp</code>, <code>prevRow</code></li></ul><h2 id="延伸問題："><a href="#延伸問題：" class="headerlink" title="延伸問題："></a>延伸問題：</h2><ul><li><p><strong>for loop 內、外層能否對調？</strong></p><p>  <strong>不能, 因為這裡定義的 subproblem 是「選擇第 <code>i</code> 種硬幣時, 湊齊金額 <code>j</code> 的方案（組合數）」。如果對調了, 則 subproblem 就會變成「對於金額 <code>j</code>, 選擇硬幣的方案（排列數）」</strong></p><p>  e.g. <code>amount = 3</code>, <code>coins = [1, 2]</code></p><ul><li>內、外層對調後, 會有 1 + 2、2 + 1 這兩種方案</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>494. Target Sum</title>
      <link href="/post/target-sum/"/>
      <url>/post/target-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/target-sum/">https://leetcode.cn/problems/target-sum/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和整數 <code>target</code>, 在 <code>nums</code> 中每個整前添加 <code>+</code> 或 <code>-</code>, 然後串聯整個 <code>nums</code> 形成一個表達式：</p><ul><li>e.g. <code>nums = [2, 1]</code> 可以在 <code>2</code> 前添加 <code>+</code>, 在 <code>1</code> 前添加 <code>-</code>, 形成表達式 <code>+2-1</code></li></ul><p>求運算結果等於 <code>target</code> 的不同表達式數目。</p></blockquote><p><img src="https://i.imgur.com/vfEoALs.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用暴力法, 遞迴下去做（速度極慢）</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &gt; <span class="built_in">abs</span>(sum) || target &lt; -<span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>(), target, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> target, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n, target + nums[i], res);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n, target - nums[i], res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(2^n)$ ➔ <code>nums</code> 中每個數有兩種選擇</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴的深度, 遞迴最大深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 可把這題看做是背包問題, 每一個 <code>nums[i]</code> 都有取正 or 取負兩種選擇</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li><code>dp[i][j]</code>：<code>nums[1:i]</code> 湊出 <code>j</code> 的方法數</li></ul><p><strong>2. 得到狀態轉移方程：</strong></p><ul><li><code>dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li>首先, 會在 <code>nums</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[0][0] = 1</code>：代表沒有元素時, 湊出 <code>0</code> 的方案為 <code>1</code> 種</li></ul><p><strong>4. 注意事項：</strong></p><ul><li><p>本題 <code>dp[i][j]</code> 的 <code>j</code> 之範圍為 <code>[-abs(sum), abs(sum)]</code>, 但 index 不允許<strong>負數</strong>, 因此統一加上 <code>offset = abs(sum)</code>, 將其 mapping 到範圍 <code>[0, 2 * abs(sum)]</code></p><p>  <img src="https://i.imgur.com/Mzxqnbm.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &gt; <span class="built_in">abs</span>(sum) || target &lt; -<span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">// nums 前面補 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// range：[-abs(sum), abs(sum)], 要 mapping 到 idx：[0, abs(sum)], 要加 offset</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * <span class="built_in">abs</span>(sum) + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> offset = <span class="built_in">abs</span>(sum), n = nums.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span> + offset] = <span class="number">1</span>; <span class="comment">// j = 0 被 mapping 到 0 + offset</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = -<span class="built_in">abs</span>(sum); j &lt;= <span class="built_in">abs</span>(sum); ++j) &#123;</span><br><span class="line">                <span class="comment">// 避免越界</span></span><br><span class="line">                <span class="keyword">if</span> (j - nums[i] &gt;= -<span class="built_in">abs</span>(sum) &amp;&amp; j - nums[i] &lt;= <span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">                    dp[i][j + offset] += dp[i - <span class="number">1</span>][j - nums[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j + nums[i] &gt;= -<span class="built_in">abs</span>(sum) &amp;&amp; j + nums[i] &lt;= <span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">                    dp[i][j + offset] += dp[i - <span class="number">1</span>][j + nums[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][target + offset];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(sum \cdot n)$ ➔ for loop, 其中 <code>sum</code> 為 <code>nums</code> 元素之和</li><li><strong>space：</strong>$O(sum \cdot n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：Solution 2 的改進, 實際上 <code>dp[i][j + offset]</code> 只會用到上一列 <code>dp[i - 1][X]</code>, 故不需要開到 $O(sum \cdot n)$ 的空間, 只需 $O(sum)$ 的空間即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &gt; <span class="built_in">abs</span>(sum) || target &lt; -<span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">// nums 前面補 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// range：[-abs(sum), abs(sum)], 要 mapping 到 idx [0, abs(sum)], 要加 offset</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span> * abs(sum) + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> offset = <span class="built_in">abs</span>(sum), n = nums.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span> + offset] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextRow</span><span class="params">(<span class="number">2</span> * abs(sum) + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = -<span class="built_in">abs</span>(sum); j &lt;= <span class="built_in">abs</span>(sum); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i] &gt;= -<span class="built_in">abs</span>(sum) &amp;&amp; j - nums[i] &lt;= <span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">                    nextRow[j + offset] += dp[j - nums[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j + nums[i] &gt;= -<span class="built_in">abs</span>(sum) &amp;&amp; j + nums[i] &lt;= <span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">                    nextRow[j + offset] += dp[j + nums[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target + offset];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(sum \cdot n)$ ➔ for loop, 其中 <code>sum</code> 為 <code>nums</code> 元素之和</li><li><strong>space：</strong>$O(sum)$ ➔ <code>dp</code>, <code>nextRow</code> 皆只需 $O(2 \cdot sum + 1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>97. Interleaving String</title>
      <link href="/post/interleaving-string/"/>
      <url>/post/interleaving-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/interleaving-string/">https://leetcode.cn/problems/interleaving-string/</a></strong></p><p><strong>題意：</strong>給三個 string <code>s1</code>、<code>s2</code>、<code>s3</code>, 返回 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> 交錯組成的。</p><p>兩個 sting <code>s</code>、<code>t</code> 交錯的定義與過程如下, 其中每個 string 都會被分割成若干個 <strong>non-empty</strong> substring：</p><ul><li><code>s = s1 + s2 + ... + sn</code></li><li><code>t = t1 + t2 + ... + tm</code></li><li><code>|n - m| &lt;= 1</code></li><li>交錯是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li></ul><p><strong>注意：</strong><code>a + b</code> 代表 string <code>a</code> 和 <code>b</code> 串接。</p></blockquote><p><img src="https://i.imgur.com/UAhxyXi.png"></p><p><img src="https://i.imgur.com/OFat657.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i][j]</code> 表示 <code>s1</code> 前 <code>i</code> 個 char 和 <code>s2</code> 前 <code>j</code> 個 char 能否構成 <code>s3</code> 前 <code>i + j</code> 個 char</strong></p><p><strong><code>dp[i][j]</code> 為 <code>true</code> 有兩種情況：</strong></p><ul><li><strong><code>s1[i - 1] == s3[i + j - 1] &amp;&amp; dp[i - 1][j]</code></strong><ul><li>當 <code>s1</code> 的最後一個 char 等於 <code>s3</code> 最後一個 char</li><li>且 <code>s1</code> 前 <code>i - 1</code> 個 char、<code>s2</code> 前 <code>j</code> 個 char 能構成 <code>s3</code> 前 <code>i + j - 1</code> 個 char</li></ul></li><li><strong><code>s2[j - 1] == s3[i + j - 1] &amp;&amp; dp[i][j - 1]</code></strong><ul><li>當 <code>s2</code> 的最後一個 char 等於 <code>s3</code> 最後一個 char</li><li>且 <code>s1</code> 前 <code>i</code> 個 char、<code>s2</code> 前 <code>j - 1</code> 個 char 能構成 <code>s3</code> 前 <code>i + j - 1</code> 個 char</li></ul></li></ul><p><strong>滿足上面公式的 <code>i</code>、<code>j</code> 必須 <code>≥ 1</code>, 否則 <code>dp[i - 1][j]</code>、<code>dp[i][j - 1]</code> 會越界</strong></p><p><strong>也就是說 <code>dp[i][j]</code> 只考慮了 <code>i, j ≥ 1</code> 的情況, 並沒有考慮到：</strong></p><ul><li><strong><code>i = 0, j = 0</code></strong> : 也就是 <code>s1</code>、<code>s2</code> 皆為 <code>&quot;&quot;</code> 時, 能否組成 <code>s3 = &quot;&quot;</code></li><li><strong><code>i = 0 ~ m, j = 0</code></strong> : 也就是 <code>s2</code> 為 <code>&quot;&quot;</code> 時, 僅靠 <code>s1</code> 能否構成 <code>s3</code></li><li><strong><code>i = 0, j = 0 ~ n</code></strong> : 也就是 <code>s1</code> 為 <code>&quot;&quot;</code> 時, 僅靠 <code>s2</code> 能否構成 <code>s3</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m + n != s3.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// m + 1、n + 1 是因為要考慮 s1、s2 為空的情況</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 當 s1、s2 皆為 &quot;&quot; 時, 能構成 s3 = &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2 皆為 &quot;&quot; 時, 僅靠 s1 能否構成 s3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = (s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]) &amp;&amp; dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s1 皆為 &quot;&quot; 時, 僅靠 s2 能否構成 s3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = (s2[j - <span class="number">1</span>] == s3[j - <span class="number">1</span>]) &amp;&amp; dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i, j 皆 ≥ 1 的狀態轉移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                dp[i][j] = (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j]) ||</span><br><span class="line">                           (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>312. Burst Balloons</title>
      <link href="/post/burst-balloons/"/>
      <url>/post/burst-balloons/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/burst-balloons/">https://leetcode.cn/problems/burst-balloons/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code> 表示所有氣球上的編號。</p><p>戳破第 <code>i</code> 個氣球, 可以獲得 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬幣。其中 <code>i - 1</code> 和 <code>i + 1</code> 代表與 <code>i</code> 相鄰的兩個氣球之編號。若 <code>i - 1</code> 或 <code>i + 1</code> 超出了 <code>nums</code> 的邊界, 則將其看作是編號為 <code>1</code> 的氣球。</p><p>返回戳破所有氣球所能獲得的最大硬幣數。</p><p><strong>注意：</strong><code>1 ≤ nums[i] ≤ 300</code></p></blockquote><p><img src="https://i.imgur.com/p3m3onY.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>本題重點：</strong></p><ul><li>與其考慮先射爆哪個氣球, 不如<strong>考慮最後射爆哪個氣球</strong>。因為如果是考慮先射爆哪個氣球, 這種方式無法確定當前左、右邊的氣球編號。</li><li>若是考慮最後射爆哪個氣球, 則可以確定該氣球的左、右邊編號</li></ul><p><strong>1. 定義狀態：</strong></p><ul><li><code>dp[i][j]</code>：在 <code>nums[i:j]</code> 中最後射爆 <code>index = k</code> 的氣球</li><li>在射爆 <code>idx = k</code> 的氣球前, 必須先射爆 <code>nums[i:(k-1)]</code>、<code>nums[(k+1):j]</code> 區間中的氣球</li></ul><p><strong>2. 得到狀態轉移方程：</strong></p><ul><li>由於 <code>dp[i][j]</code> 只保證 <code>nums[i:j]</code> 區間的氣球會被射爆, 且 <code>idx = k</code> 的氣球最後才會被射爆。也就是說, 當射爆 <code>nums[k]</code> 時, 它左邊氣球的 idx 必為 <code>i - 1</code>, 且右邊氣球的 idx 必為 <code>j + 1</code> （區間外的沒被射爆, 故 k 之左、右邊為區間外的 idx）。因為 <code>nums[i:(k-1)]</code>、<code>nums[(k+1):j]</code> 區間的氣球都已經先被射爆</li><li>狀態轉移方程：<ul><li><code>last = nums[i - 1] * nums[k] * nums[j + 1]</code></li><li><code>dp[i][j] = max(dp[i][j], dp[i][k - 1] + dp[k + 1][j] + last)</code></li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：沒有氣球時, 所能獲得的最大硬幣數為 <code>0</code></li><li><code>dp[i][0]</code>：沒有氣球時, 所能獲得的最大硬幣數為 <code>0</code>。其中, <code>1 ≤ i ≤ n + 1</code></li><li><code>dp[0][j]</code>：由於要求最大值, 且 <code>nums[i] &gt; 0</code>, 乘積一定 <code>&gt; 0</code>, 故都先初始化成 <code>0</code>。其中, <code>1 ≤ j ≤ n + 1</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前、後各 insert 一個元素避免超出邊界</span></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">        nums.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; ++len) &#123; <span class="comment">// len 為區間的長度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; ++i) &#123; <span class="comment">// i 為區間的起始點</span></span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> j = i + len - <span class="number">1</span>; <span class="comment">// j 為區間的終點</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; ++k) &#123; <span class="comment">// k 用來遍歷區間 [i, j] 中的元素</span></span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> last = nums[i - <span class="number">1</span>] * nums[k] * nums[j + <span class="number">1</span>];</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k - <span class="number">1</span>] + dp[k + <span class="number">1</span>][j] + last);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^3)$ ➔ for loop, 其中 <code>n</code> 為氣球的數量</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53. Maximum Subarray</title>
      <link href="/post/maximum-subarray/"/>
      <url>/post/maximum-subarray/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 找到一 subarray, 其元素和為所有 subarray 中最大的。</p><p><strong>注意：</strong>subarray 必須是連續的（index 不可中斷）</p></blockquote><p><img src="https://i.imgur.com/m7Xl6vL.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 每個元素都有加入 or 不加入 subarray 兩種選擇。若不加入, 則該元素成為新的 subarray 的開頭繼續往後尋找, 其中 <code>dp[i]</code> 代表 <code>[0, i]</code> 這個區間中擁有最大和的 subarray 之和</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, nums[<span class="number">0</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code> 中的元素</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 由於 <code>dp[i]</code> 只需紀錄 <code>dp[i - 1]</code> 就好, 因此不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>], cur = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cur = <span class="built_in">max</span>(nums[i], cur + nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/post/jump-game/"/>
      <url>/post/jump-game/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></strong></p><p><strong>題意：</strong>給一非負整數 array <code>nums</code>, 最初位置在 <code>nums[0]</code>, 其中 <code>nums</code> 中的每個元素代表該位置可以跳躍的最大長度, 返回是否能從起點抵達最後一個 index。</p></blockquote><p><img src="https://i.imgur.com/2AvbHul.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i]</code> 代表第 <code>i</code> 個點能否被抵達, 條件是 <code>i</code> 前面的任意點 <code>j</code> 能被抵達 （<code>dp[j] = true</code>）, 且能從 <code>j</code> 跳到 <code>i</code> （<code>j + nums[j] &gt;= i</code> ）, 故得到狀態轉移方程：</strong></p><ul><li><strong><code>dp[i] = (dp[j] == true) &amp;&amp; (j + nums[j] &gt;= i)</code>, 其中 <code>0 ≤ j &lt; i</code></strong></li></ul><p><strong>從下圖中可看到, 從 <code>idx = 2</code> 開始往後走的有重複, 故用 cache 把結果存起來, 避免重複計算</strong></p><p><img src="https://i.imgur.com/F6EXZXZ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 起點一定能抵達</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="comment">// 第 j 個點能被抵達 &amp;&amp; 能從 j 跳到 i</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; j + nums[j] &gt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 從終點往回推, 只要有某點能到達終點, 就把該點設為終點（因為其他點只要能到達該點, 就一定能抵達終點）。若最後終點等於 <code>0</code>, 則代表能從起點能走到終點</strong></p><p><img src="https://i.imgur.com/OnUEHiO.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> goal = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = goal - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= goal) &#123;</span><br><span class="line">                goal = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> goal == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45. Jump Game II</title>
      <link href="/post/jump-game-ii/"/>
      <url>/post/jump-game-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></strong></p><p><strong>題意：</strong>給一非負整數 array <code>nums</code>, 你最初位於 <code>nums</code> 的第一個位置。</p><p><code>nums</code> 中的每個元素代表你在該位置可以跳躍的最大長度。</p><p>假設你總是可以到達 <code>nums</code> 的最後一個位置。</p><p>返回到達 <code>nums</code> 的最後一個位置所需的<strong>最少的跳躍次數</strong>。</p></blockquote><p><img src="https://i.imgur.com/KsGAy5K.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 用 <code>[start, end]</code> 來記錄每次跳躍的區間, 而 <code>maxPos</code> 則是用來紀錄 <code>[start, end]</code> 中所能跳躍的最遠 index。若 <code>end ≥ nums.size() - 1</code> 代表上一次跳躍已能抵達 <code>nums</code> 的終點, 因此結束循環</strong></p><p><img src="https://i.imgur.com/FnqWVHE.png"></p><p><img src="https://i.imgur.com/UgNxMDV.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxPos = <span class="number">0</span>; <span class="comment">// 所能跳躍的最遠 index</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, res = <span class="number">0</span>; <span class="comment">// 起始區間 [start, end]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 只要 end ≥ nums 的最後一個 index 就終止</span></span><br><span class="line">            <span class="comment">// 計算下一次跳躍所能到的最遠 idx</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">                maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            start = end + <span class="number">1</span>; <span class="comment">// 下一次跳躍的起點</span></span><br><span class="line">            end = maxPos; <span class="comment">// 下一次跳躍的終點</span></span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134. Gas Station</title>
      <link href="/post/gas-station/"/>
      <url>/post/gas-station/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/gas-station/">https://leetcode.cn/problems/gas-station/</a></strong></p><p><strong>題意：</strong>在一條環路上有 <code>n</code> 個加油站, 其中第 <code>i</code> 個加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一輛油箱容量無限的的汽車, 從第 <code>i</code> 個加油站開往第 <code>i + 1</code> 個加油站需要消耗 <code>cost[i]</code> 升汽油。你從其中的一個加油站出發, 開始時油箱為空。</p><p>給定兩個整數 array <code>gas</code> 和 <code>cost</code>, 如果可以繞環路行駛一圈, 則返回出發時加油站的 index, 否則返回 <code>-1</code>。如果存在解, 則<strong>保證</strong>它是<strong>唯一的</strong>。</p></blockquote><p><img src="https://i.imgur.com/MB2PiS5.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 首先判斷總油量是否小於總消耗量。如果是, 那肯定不能走完一圈。否則, 肯定能走完一圈。接下來就是遍歷 <code>nums</code>, 從第一站開始, 計算每一站剩餘的油量, 如果當走到第 <code>i</code> 站時油量為負, 則以第 <code>i + 1</code> 站作為起點重新計算。若抵達某一站時油量為負, 說明從起點到該站中間的所有站都不能到達該點</strong></p><p>e.g. <code>gas = [1, 2, 3, 4, 5]</code>, <code>cost = [3, 4, 5, 1, 2]</code> (見下圖)</p><ul><li><p>假設從 <code>i = 4</code> 出發, 此時的 <code>gas[i] = 5</code>, <code>cost[i] = 2</code></p><ul><li><code>i = 4</code> 做完, 此時 <code>curGas = 5 - 2 = 3 ≥ 0</code></li><li><code>i = 0</code> 做完, 此時 <code>curGas = 3 + 1 - 3 = 1 ≥ 0</code></li><li><code>i = 1</code> 做完, 此時 <code>curGas = 1 + 2 - 4 = -1 &lt; 0</code></li></ul><p>  ➔ 下一輪會從 <code>i = 2</code> 重新計算, 因為以 <code>i = 4、0、1</code> 為起點都無法抵達 <code>i = 2</code></p><ul><li>這是因為以 <code>i = 4</code> 為起點出發, 抵達 <code>i = 0</code> 時的油量必須 <code>≥ 0</code> 才行</li><li>若直接以 <code>i = 0</code> 為起點出發, 則起始油量會為 <code>0</code><br>  ➔ 等同從上一站抵達 <code>i = 0</code> 時的剩餘油量 &#x3D; 0 ( <code>≥ 0</code> 中的 worse case)</li><li>若從 <code>i = 4</code> 都無法抵達 <code>i = 2</code>, 則從 <code>i = 0、1</code> 更不可能抵達。</li></ul><p>  <img src="https://i.imgur.com/hRhTuVl.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 總油量 &lt; 總消耗量, 肯定無法走完一圈</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sum</span>(gas) &lt; <span class="built_in">sum</span>(cost)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, curGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            curGas += (gas[i] - cost[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curGas &lt; <span class="number">0</span>) &#123; <span class="comment">// 若抵達第 i 站時油量 &lt; 0, 則以第 (i + 1) 站為起點重新計算</span></span><br><span class="line">                curGas = <span class="number">0</span>;</span><br><span class="line">                res = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>846. Hand of Straights</title>
      <link href="/post/hand-of-straights/"/>
      <url>/post/hand-of-straights/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/hand-of-straights/">https://leetcode.cn/problems/hand-of-straights/</a></strong></p><p><strong>題意：</strong>Alice 手中有一堆牌, 她想要重新排列這些牌, 將其分成若干組, 使每一組的牌數都是 <code>groupSize</code>, 並且由 <code>groupSize</code> 張<strong>連續</strong>的牌組成。</p><p>給一整數 array <code>hand</code> 和一整數 <code>groupSize</code>, 其中 <code>hand[i]</code> 代表第 <code>i</code> 張牌。如果她可以重新排列這些牌, 返回 <code>true</code>；否則, 返回 <code>false</code>。</p></blockquote><p><img src="https://i.imgur.com/v90S1cr.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 首先判斷 <code>hand.size()</code> 能否被 <code>groupSize</code> 所整除, 若不行則返回 <code>false</code>。否則, 用 map 統計每張牌出現的次數, 並且根據 card value 由小到大排序。每個 group 每次都先從 map 中取出最小的 card value <code>start</code>, 則該 group 的數字範圍為 <code>[start, start + groupSize - 1]</code>, 只要缺少一個便直接返回 <code>false</code></strong></p><p>取出數字後, 要將其出現次數減一, 然後判斷是否為 <code>0</code>。若是的話, 要將其移除, 否則 <code>start</code> 會一直取到同一個數</p><p>e.g. <code>freqs = &#123;&#123;1, 1&#125;, &#123;2, 1&#125;&#125;</code>, <code>groupSize = 1</code></p><ul><li>若不移除 <code>cnt = 0</code> 的元素, 則取完第一個 group 後, <code>freqs = &#123;&#123;1, 0&#125;, &#123;2, 1&#125;&#125;</code></li><li>第二個 group 的 <code>start</code> 仍會取到 <code>1</code>, 而非 <code>2</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNStraightHand</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; hand, <span class="type">int</span> groupSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hand.<span class="built_in">size</span>() % groupSize != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freqs; <span class="comment">// &#123;card value, cnt&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; card : hand) &#123;</span><br><span class="line">            ++freqs[card];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!freqs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> start = freqs.<span class="built_in">begin</span>()-&gt;first; <span class="comment">// group 開頭數字</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// group range : [start, start + groupSize - 1]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; groupSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (freqs[start + i] == <span class="number">0</span>) &#123; <span class="comment">// 該 group 內有數字不存在</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取出該數字, 並將其出現次數減一, 然後判斷是否為 0</span></span><br><span class="line">                <span class="comment">// 若是的話, 要將其移除, 否則 start 會一直取到同一個數</span></span><br><span class="line">                <span class="keyword">if</span> (--freqs[start + i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    freqs.<span class="built_in">erase</span>(start + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ map 移除元素需花 $O(log(n))$, worse case：每個 <code>hand[i]</code> 都是 unique</li><li><strong>space：</strong>$O(n)$ ➔ <code>freqs</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1899. Merge Triplets to Form Target Triplet</title>
      <link href="/post/merge-triplets-to-form-target-triplet/"/>
      <url>/post/merge-triplets-to-form-target-triplet/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/">https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/</a></strong></p><p><strong>題意：triplet</strong> 是由三個整數所組成的 array。給一 2D 整數 array <code>triplets</code>, 其中 <code>triplets[i] = [ai, bi, ci]</code> 表示第 <code>i</code> 個 triplet。並給一整數 array <code>target = [x, y, z]</code>, 表示你想要得到的 triplet。</p><p>為了得到 <code>target</code>, 你需要對 <code>triplets</code> 進行下面的操作<strong>任意次</strong>（也可能是 <code>0</code> 次）：</p><ul><li>選出兩個 index（index 從 <code>0</code> 開始）<code>i</code> 和 <code>j</code>（<code>i != j</code>）, 並更新 <code>triplets[j]</code> 為 <code>[max(ai, aj), max(bi, bj), max(ci, cj)]</code></li></ul><p>e.g. <code>triplets[i] = [2, 5, 3]</code> 且 <code>triplets[j] = [1, 7, 5]</code></p><p>➔ 則 <code>triplets[j]</code> 將會更新為 <code>[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]</code>。</p><p>若透過上述操作可使得 <code>target</code> 成為 <code>triplets</code> 中的元素, 則返回 <code>true</code>；否則, 返回 <code>false</code>。</p></blockquote><p><img src="https://i.imgur.com/EuddNK2.png"></p><p><img src="https://i.imgur.com/c5eJ7vA.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 令 <code>x = target[0]</code>, <code>y = target[1]</code>, <code>z = target[2]</code>, 且 <code>ai = triplet[0]</code>, <code>bi = triplet[1]</code>, <code>ci = triplet[2]</code>。若 <code>ai &gt; x</code> 或 <code>bi &gt; y</code> 或 <code>ci &gt; z</code>, 則跳過該 triplet, 因為若拿該 triplet 做運算 <code>(a, b, c)</code> 一定不等於 <code>(x, y, z)</code>。否則, 更新 <code>a, b, c</code>。最後判斷 <code>(a, b, c)</code> 是否等於 <code>(x, y, z)</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">mergeTriplets</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triplets, vector&lt;<span class="type">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> x = target[<span class="number">0</span>], y = target[<span class="number">1</span>], z = target[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; triplet : triplets) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> ai = triplet[<span class="number">0</span>], bi = triplet[<span class="number">1</span>], ci = triplet[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 ai &gt; x 或 bi &gt; y 或 ci &gt; z, 則跳過該 triplet</span></span><br><span class="line">            <span class="keyword">if</span> (ai &lt;= x &amp;&amp; bi &lt;= y &amp;&amp; ci &lt;= z) &#123;</span><br><span class="line">                a = <span class="built_in">max</span>(a, ai);</span><br><span class="line">                b = <span class="built_in">max</span>(b, bi);</span><br><span class="line">                c = <span class="built_in">max</span>(c, ci);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tie 可用於比較 struct</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tie</span>(a, b, c) == <span class="built_in">tie</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>triplets</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>763. Partition Labels</title>
      <link href="/post/partition-labels/"/>
      <url>/post/partition-labels/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/partition-labels/">https://leetcode.cn/problems/partition-labels/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code> 由<strong>小寫</strong>字母所組成。我們要把 <code>s</code> 劃分為盡可能多的 partition, 同一字母只能出現在同一個 partition 中。返回一個表示每個 partition 的長度之 array。</p></blockquote><p><img src="https://i.imgur.com/VsVJiwl.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 首先遍歷 <code>s</code>, 並用 <code>lastIdx</code> 紀錄每個字母的最後一個 index, 然後從頭開始遍歷 <code>s</code>, 並不斷更新當前 partition 的結尾。若 <code>i == idx</code> 代表已走到 partition 結尾, 即可確定當前 partition 的 size, 因為該 partition 中的 char 都沒有出現在更後面的位置</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; lastIdx; <span class="comment">// &#123;char, last index&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            lastIdx[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> curSize = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++curSize;</span><br><span class="line">            end = <span class="built_in">max</span>(end, lastIdx[s[i]]); <span class="comment">// 更新當前 partition 的結尾</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 抵達該 partition 的結尾</span></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(curSize);</span><br><span class="line">                curSize = <span class="number">0</span>; <span class="comment">// 下一個 partition 的長度從 0 開始算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ <code>lastIdx</code> 中的元素不超過 26 個</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>678. Valid Parenthesis String</title>
      <link href="/post/valid-parenthesis-string/"/>
      <url>/post/valid-parenthesis-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-parenthesis-string/">https://leetcode.cn/problems/valid-parenthesis-string/</a></strong></p><p><strong>題意：</strong>給一只包含三種 char <code>（</code> 、<code>）</code> 和 <code>*</code> 的 string <code>s</code>, 判斷 <code>s</code> 是否為<strong>有效</strong>的 string。有效的 string 具有如下規則：</p><ul><li>任何左括號 <code>(</code> 必須有相應的右括號 <code>)</code></li><li>任何右括號 <code>)</code> 必須有相應的左括號 <code>(</code></li><li>左括號 <code>(</code> 必須在對應的右括號之前 <code>)</code></li><li><code>*</code> 可以被視為單個右括號 <code>)</code> or 單個左括號 <code>(</code> or 一個 empty string <code>&quot;&quot;</code></li></ul><p>empty string <code>&quot;&quot;</code> 也被視為有效的 string。</p></blockquote><p><img src="https://i.imgur.com/MeGfxoM.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 由於 <code>*</code> 有三種可能, 因此我們需要用 <code>leftMin</code>、<code>leftMax</code> 來記錄未匹配左括號的範圍</strong></p><ul><li><code>leftMax</code> 代表未匹配左括號的最大數量, 也就是將所有 <strong><code>*</code></strong> 都變成 <code>(</code></li><li><code>leftMin</code> 代表未匹配左括號的最小數量, 也就是將所有 <strong><code>*</code></strong> 都變成 <code>)</code></li></ul><p>一旦 <code>leftMax &lt; 0</code>, 代表 <code>s</code> 中 <code>)</code> 太多, 將所有 <code>*</code> 都變成 <code>(</code> 也無法匹配, 直接返回 <code>false</code></p><p>一旦 <code>leftMin &lt; 0</code>, 此時的 <code>leftMin</code> 為 <code>-1</code>, 代表不應把所有 <code>*</code> 都設為 <code>)</code></p><p>➔ 而是應該把其中一個 <code>*</code> 設為 <code>&quot;&quot;</code>, 以確保 <code>leftMin == 0</code></p><ul><li>將其中一個 <code> </code> 從 <code>)</code> 改為 <code>&quot;&quot;</code>, 也就是讓 <code>leftMin + 1</code></li></ul><p>e.g. <code>s = (*)</code></p><ul><li><code>leftMin = -1</code>, 因為 <code>(*)</code> ➔ <code>())</code>, 但其實可以將 <strong><code>*</code></strong> 從 <code>)</code> 改為 <code>&quot;&quot;</code>, 使得 <code>(*)</code> 變成 <code>()</code></li><li><code>leftMin = 1</code>, 因為 <code>(*)</code> ➔ <code>(()</code></li></ul><p>遍歷結束時, 所有的左括號都應和右括號匹配。因此只有當 <code>leftMin == 0</code> 時, <code>s</code> 才是有效的</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>; <span class="comment">// 未匹配左括號的最大數量, 將所有 * 都變成 (</span></span><br><span class="line">        <span class="type">int</span> leftMin = <span class="number">0</span>; <span class="comment">// 未匹配左括號的最小數量, 將所有 * 都變成 )</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++leftMax;</span><br><span class="line">                ++leftMin;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                --leftMax;</span><br><span class="line">                --leftMin;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++leftMax;</span><br><span class="line">                --leftMin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftMin &lt; <span class="number">0</span>) &#123;<span class="comment">// (*) -&gt; leftMin = -1, leftMax = 1</span></span><br><span class="line">                leftMin = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftMin == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code>, 其中 <code>n</code> 為 <code>s</code> 的長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>57. Insert Interval</title>
      <link href="/post/insert-interval/"/>
      <url>/post/insert-interval/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/insert-interval/">https://leetcode.cn/problems/insert-interval/</a></strong></p><p><strong>題意：</strong>給一無重疊的 interval array <code>intervals</code>, 且 <code>intervals</code> 已根據 <code>intervals[i][0]</code> 做<strong>升序</strong>排列。</p><p>今插入一區間 <code>newInterval</code>, 必須確保插入後 <code>intervals</code> 仍升序排列且不重疊 (如果有必要的話, 可以合併區間)</p></blockquote><p><img src="https://i.imgur.com/g1p0WiU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：先將 <code>newInterval</code> 插入 <code>intervals</code> 中的正確位置, 然後再利用 <a href="https://zako945.github.io/post/merge-intervals/">56. Merge Intervals</a> 進行 merge</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = intervals.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根據 start 將 newInterval 插入到 intervals 中</span></span><br><span class="line">        <span class="keyword">while</span> (it != intervals.<span class="built_in">end</span>() &amp;&amp; newInterval[<span class="number">0</span>] &gt; (*it)[<span class="number">0</span>]) &#123;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        intervals.<span class="built_in">insert</span>(it, newInterval);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res&#123;intervals[<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 取出前一個 interval 的 end</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> lastEnd = res.<span class="built_in">back</span>()[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 interval[i].start &lt;= interval[i-1].end, 則重設新的 end(合併)</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= lastEnd) &#123;</span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(lastEnd, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>intervals</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>res</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. Merge Intervals</title>
      <link href="/post/merge-intervals/"/>
      <url>/post/merge-intervals/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></strong></p><p><strong>題意：</strong>給一 array <code>intervals</code>, 其中 <code>intervals[i] = [start_i, end_i]</code>, 合併所有重疊的區間, 並返回一個不重疊區間 array。</p></blockquote><p><img src="https://i.imgur.com/hPbh5w5.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：類似 <a href="https://zako945.github.io/post/meeting-rooms/">252. Meeting Rooms</a>, 先根據 <code>intervals[i].start</code> 做排序, 若 <code>interval[i].start ≤ res.back().end</code> 的話代表有重疊, 則將當前的 <code>interval.end</code> 設為兩者 <code>end</code> 中較大的（合併）; 若無重疊, 則將 <code>interval[i]</code> 加入到 <code>res</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res&#123;intervals[<span class="number">0</span>]&#125;; <span class="comment">// 將第一個區間放入到 res</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 取出當前 interval 的 end</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> lastEnd = res.<span class="built_in">back</span>()[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 interval[i].start &lt;= res.back().end, 則重設新的 end (合併)</span></span><br><span class="line">            <span class="comment">// e.g. [[1,4], [2,3]] -&gt; [1,4]</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= lastEnd) &#123;</span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(lastEnd, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要返回 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1584. Min Cost to Connect All Points</title>
      <link href="/post/min-cost-to-connect-all-points/"/>
      <url>/post/min-cost-to-connect-all-points/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">https://leetcode.cn/problems/min-cost-to-connect-all-points/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>points</code>, 表示 2D 平面上的一些點, 其中 <code>points[i] = [x_i, y_i]</code> 。</p><p>連接點 <code>[x_i, y_i]</code> 和點 <code>[x_j, y_j]</code> 的費用為它們之間的<strong>曼哈頓距離</strong>：</p><ul><li><code>|x_i - x_j| + |y_i - y_j|</code></li></ul><p>其中 <code>|val|</code> 表示 <code>val</code> 的絕對值。</p><p>返回將所有點連接的最小總費用。</p></blockquote><p><img src="https://i.imgur.com/YzINIJl.png"></p><p><img src="https://i.imgur.com/g2Ul9DI.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：本題其實就是在求 MST (Minimum Spaning Tree), 故利用 Kruskal 演算法, 每次選擇 cost 最小的邊 <code>e</code>, 若加入 <code>e</code> 會導致 graph 中有 cycle（用 Union Find 判斷）, 則跳過 <code>e</code>, 直到 graph 中有 <code>n - 1</code> 條邊</strong></p><p><img src="https://i.imgur.com/K9LvcJZ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; t3i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parents</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">ranks</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;t3i&gt; edges; <span class="comment">// &#123;dist, u, v&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 總共有 O(n^2) 條邊</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> dist = <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">                edges.<span class="built_in">emplace_back</span>(t3i&#123;dist, i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根據每條邊的 dist 由小到大做排序</span></span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dist, i, j] : edges) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(parents, i); <span class="comment">// root of i</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(parents, j); <span class="comment">// root of j</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 i, j 不為同一個 set, 代表加入 edge 後不會形成 cycle</span></span><br><span class="line">            <span class="keyword">if</span> (r1 != r2) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                res += dist;</span><br><span class="line">                <span class="built_in">union_</span>(parents, ranks, r1, r2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到 n - 1 條邊就結束</span></span><br><span class="line">            <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]]; <span class="comment">// path compression</span></span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">const</span> <span class="type">int</span> r1, <span class="type">const</span> <span class="type">int</span> r2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[r2] &gt; ranks[r1]) &#123;</span><br><span class="line">            parents[r1] = r2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">            ++ranks[r1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2 \cdot log(n))$ ➔ Dijkstra 演算法的時間複雜度為 $O(E \cdot log(E))$, 因為要對所有邊做排序, 而 E &#x3D; $\binom{n}{2}$ &#x3D; $O(n^2)$</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>edges</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Prim 演算法</strong></p><p><img src="https://i.imgur.com/x2PiAb2.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>; <span class="comment">// 紀錄哪些點在 MST 中</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDis</span><span class="params">(n, INT_MAX)</span></span>; <span class="comment">// 尚未加入 MST 的點距離 MST 中的點之最小距離</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 0 為起點 (任意點開始)</span></span><br><span class="line">        minDis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123; <span class="comment">// 取 n 個點便結束</span></span><br><span class="line">            <span class="type">int</span> curMinEdge = INT_MAX;</span><br><span class="line">            <span class="type">int</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 cost 最小的邊 (一開始會取 0 -&gt; 0, 因為 minDis[0] = 0 &lt; curMinEdge)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i] &amp;&amp; minDis[i] &lt; curMinEdge) &#123;</span><br><span class="line">                    curMinEdge = minDis[i];</span><br><span class="line">                    cur = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[cur] = <span class="literal">true</span>;</span><br><span class="line">            res += curMinEdge;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新距離</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> dist = <span class="built_in">abs</span>(points[cur][<span class="number">0</span>] - points[i][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[cur][<span class="number">1</span>] - points[i][<span class="number">1</span>]);</span><br><span class="line">                    minDis[i] = <span class="built_in">min</span>(minDis[i], dist);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>visited</code>, <code>minDis</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Advanced Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>743. Network Delay Time</title>
      <link href="/post/network-delay-time/"/>
      <url>/post/network-delay-time/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/network-delay-time/">https://leetcode.cn/problems/network-delay-time/</a></strong></p><p><strong>題意：</strong>有 <code>n</code> 個網路節點, 標記為 <code>1</code> 到 <code>n</code>。</p><p>給一 list <code>times</code>, 表示訊號經過<strong>有向邊</strong>的傳遞時間。<code>times[i] = (ui, vi, wi)</code>, 其中 <code>ui</code> 是起點、<code>vi</code> 是終點, 而 <code>wi</code> 是一個訊號從起點傳遞到終點的時間。</p><p>從某個節點 <code>k</code> 發出一個訊號, 返回需要多久才能使所有節點都收到訊號？如果不能使所有節點都收到訊號, 則返回 <code>-1</code> 。</p></blockquote><p><img src="https://i.imgur.com/vPEe1d5.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Dijkstra 演算法（BFS + Heap）, 而非單純 BFS, 因為 <code>weight</code> 有可能不為 <code>1</code>, 這樣會導致 BFS 所得出之答案未必為解答。步驟如下：</strong></p><ul><li>建立 adjacent lit</li><li>建立 min heap</li><li>執行 BFS</li></ul><p>➔ BFS 中得到未拜訪過的點 <code>cur</code> , 則 <code>dis</code> 必為起點 <code>k</code> 到 <code>cur</code> 的最短路徑</p><p><strong>e.g. 下圖中, 求 1 到 2 的時間</strong></p><ul><li>若用 BFS 求解, 則 path 為 1 ➔ 2, 得出 4</li><li>正確的 path 應為 1 ➔ 3 ➔ 4 ➔ 2, 得出 3</li></ul><p><img src="https://i.imgur.com/c2l1eb1.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii; <span class="comment">// &#123;weight, next&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">networkDelayTime</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; times, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>); <span class="comment">// adjacent list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; t : times) &#123;</span><br><span class="line">            adj[t[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(pii&#123;t[<span class="number">2</span>], t[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; visited;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        pq.<span class="built_in">emplace</span>(pii&#123;<span class="number">0</span>, k&#125;); <span class="comment">// 起點為 k, 則 k -&gt; k 的 weight = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = pq.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="comment">// 每次取出最小的邊</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [dis, cur] = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (visited[cur]) &#123; <span class="comment">// 已拜訪則跳過</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 設為已拜訪, 並更新時間</span></span><br><span class="line">                visited[cur] = <span class="literal">true</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dis);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 將 cur 延伸出去的所有邊加入到 pq 中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [weight, next] : adj[cur]) &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(pii&#123;dis + weight, next&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (visited.<span class="built_in">size</span>() == n) ? res : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(E \cdot log(E))$ ➔ Dijkstra 的時間複雜度, 因為 <code>pq</code> 中最多有 <code>E</code> 條邊, 每次 push &#x2F; pop 元素需花 $O(log(E))$</li><li><strong>space：</strong>$O(V + E)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Advanced Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>787. Cheapest Flights Within K Stops</title>
      <link href="/post/cheapest-flights-within-k-stops/"/>
      <url>/post/cheapest-flights-within-k-stops/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/cheapest-flights-within-k-stops/">https://leetcode.cn/problems/cheapest-flights-within-k-stops/</a></strong></p><p><strong>題意：</strong>有 <code>n</code> 個城市通過一些航班連接。給一整數 array <code>flights</code>, 其中 <code>flights[i] = [from_i, to_i, price_i]</code> , 表示該航班都從城市 <code>from_i</code> 開始, 以價格 <code>price_i</code> 抵達 <code>to_i</code>。</p><p>給定所有的城市和航班, 以及起點 <code>src</code> 和終點 <code>dst</code>, 找出一條最多經過 <code>k</code> 站中轉的 path, 使得從 <code>src</code> 到 <code>dst</code> 的價格最便宜, 並返回該價格。 如果不存在這樣的 path, 則返回 <code>-1</code>。</p></blockquote><p><img src="https://i.imgur.com/0tyy3zs.png"></p><p><img src="https://i.imgur.com/0IuBr8q.png"></p><p><img src="https://i.imgur.com/Gv0b0YR.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Dijkstra 演算法</strong></p><ul><li>建立 adjacent lit</li><li>建立 min heap</li><li>執行 BFS</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii; <span class="comment">// &#123;weight, next&#125;</span></span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; t3i; <span class="comment">// &#123;cost, cur, times&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">adj</span>(n); <span class="comment">// adjacent list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : flights) &#123;</span><br><span class="line">            adj[f[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(pii&#123;f[<span class="number">2</span>], f[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">calculated</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(k + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        priority_queue&lt;t3i, vector&lt;t3i&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// max heap</span></span><br><span class="line">        pq.<span class="built_in">emplace</span>(t3i&#123;<span class="number">0</span>, src, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = pq.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [cost, cur, times] = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 抵達終點, 返回 cost</span></span><br><span class="line">                <span class="keyword">if</span> (cur == dst) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cost;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若不為終點, 且已中轉 k + 1 次, 代表 cur 不可能到終點, 故跳過</span></span><br><span class="line">                <span class="keyword">if</span> (times == k + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若中轉 times 次抵達 cur 的 cost 已計算過, 則跳過</span></span><br><span class="line">                <span class="comment">// 因為中轉 times 次抵達 cur 的 cost 為最佳解, 其延伸出去的邊已加到 pq 中</span></span><br><span class="line">                <span class="keyword">if</span> (calculated[cur][times]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 cur 還未計算中轉 times 次的 cost</span></span><br><span class="line">                calculated[cur][times] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 將 cur 所延伸出去的邊加入到 pq 中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [price, next] : adj[cur]) &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(t3i&#123;cost + price, next, times + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(E \cdot log(E))$ ➔ Dijkstra 的時間複雜度, 因為 <code>pq</code> 中最多有 <code>E</code> 條邊, 每次 push &#x2F; pop 元素需花 $O(log(E))$</li><li><strong>space：</strong>$O(V + E)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：「不超過 k 個中繼點」等價於「不超過 <code>k + 1</code> 個航班 (邊)」, 利用 Bellman-Ford 演算法, 用 <code>dist[i][j]</code> 表示飛不超過 <code>i</code> 次航班抵達 <code>j</code> 的最少價格</strong></p><ul><li>path &#x3D; 0 ➔ 2 中間沒有任何中繼點</li><li>path &#x3D; 0 ➔ 1 ➔ 2 中間有 1 個中繼點 <code>1</code></li></ul><p><img src="https://i.imgur.com/Who9QoZ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(k + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        dist[<span class="number">0</span>][src] = <span class="number">0</span>; <span class="comment">// 飛 0 次, 在起點的價格為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            dist[i][src] = <span class="number">0</span>; <span class="comment">// 每次 dist[i][src] 都初始化為 0, 因為在起點的價格為 0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : flights) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> u = f[<span class="number">0</span>], v = f[<span class="number">1</span>], price = f[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 u 目前無法直接抵達, 則跳過</span></span><br><span class="line">                <span class="comment">// 若不處理, 下面 dis[i - 1][u] + price 會 overflow</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i - <span class="number">1</span>][u] == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// u 可直接抵達, 則更新 u -&gt; v 的 shortest path</span></span><br><span class="line">                dist[i][v] = <span class="built_in">min</span>(dist[i][v], dist[i - <span class="number">1</span>][u] + price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dist[k + <span class="number">1</span>][dst] == INT_MAX) ? <span class="number">-1</span> : dist[k + <span class="number">1</span>][dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot E)$ ➔ for loop</li><li><strong>space：</strong>$O(k \cdot n)$ ➔ <code>dist</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, 因為 <code>dist[i][v]</code> 只會使用到 <code>dist[i - 1][u]</code>, 因此不需要保存每一次的狀態, 只需保存上一次的狀態即可。用 <code>prev</code> 紀錄不超過 <code>i - 1</code> 個中繼點的狀態, 而 <code>dist</code> 紀錄不超過 <code>i</code> 個中繼點的狀態</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; prev = dist; <span class="comment">// prev 初始化為不超過 (i - 1) 個中繼點的狀態</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : flights) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> u = f[<span class="number">0</span>], v = f[<span class="number">1</span>], price = f[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 u 無法直接抵達, 則跳過</span></span><br><span class="line">                <span class="comment">// 若不處理, 下面 prev[u] + price 會 overflow</span></span><br><span class="line">                <span class="keyword">if</span> (prev[u] == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// u 可直接抵達, 則更新 u -&gt; v 的 shortest path</span></span><br><span class="line">                dist[v] = <span class="built_in">min</span>(dist[v], prev[u] + price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此時的 dist 為不超過 k 個中繼點的狀態</span></span><br><span class="line">        <span class="keyword">return</span> (dist[dst] == INT_MAX) ? <span class="number">-1</span> : dist[dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot E)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>prev</code>, <code>dist</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Advanced Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>198. House Robber</title>
      <link href="/post/house-robber/"/>
      <url>/post/house-robber/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></strong></p><p><strong>題意：</strong>你是一名專業的強盜, 計劃搶劫沿路的房子。每棟房子都藏有一定數量的金錢, 唯一阻止你搶劫的限制是相鄰的房子都連接了安全系統, 如果闖入<strong>兩棟相鄰</strong>的房子，它會自動報警。</p><p>給一整數 array <code>nums</code>, 表示每棟房子所藏有的金額, 返回<strong>在不報警的情況下</strong>能搶劫的最大金額。</p></blockquote><p><img src="https://i.imgur.com/iWD2myc.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i]</code> 代表 index 位於區間 <code>[0, i]</code> 這 <code>i + 1</code> 間房子中可搶劫的最大金額。接著，我們考慮單一一間房子的情況，對於 <code>index = i</code> 的房子我們有兩種選擇，要搶 or 不搶</strong></p><ul><li>若 <code>index = i</code> 的房子<strong>不搶</strong>, 此時的最大金額 &#x3D; 區間 <code>[0, i - 1]</code> 的最大金額 &#x3D; <code>dp[i - 1]</code></li><li>若 <code>index = i</code> 的房子<strong>要搶</strong>, 此時的最大金額 &#x3D; 區間 <code>[0, i - 2]</code> 的最大金額 + <code>index = i</code> 的金額 &#x3D; <code>dp[i - 2] + nums[i]</code></li></ul><p>➔ 因此 <code>dp[i]</code> 就為這兩種可能中取較大者, <code>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</code></p><p>此外，由於我們的 index 是從 <code>0</code> 開始取的，因此要考慮 <code>dp[i - 1]</code>、<code>dp[i - 2]</code> 越界的情況, 根據 <code>dp[i]</code> 的定義, <code>dp[-1]</code> 代表在 <code>nums</code> 中的 index 區間 <code>[0, -1]</code> 可搶劫的最大金額，但 <code>nums</code> 中 index 區間 <code>[0, -1]</code> 中根本沒有任何數，所以可搶劫的最大金額可視為 <code>0</code>。所以一旦要存取的 index 越界我們就取 <code>0</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>((i &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] : <span class="number">0</span>),</span><br><span class="line">                        (i &gt; <span class="number">1</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：Solution 1 的改進, 計算 <code>dp[i]</code> 只需用到 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code>, 不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>; <span class="comment">// two, one, [n1, n2, ...]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> curMax = <span class="built_in">max</span>(one, two + num);</span><br><span class="line">            two = one;</span><br><span class="line">            one = curMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>213. House Robber II</title>
      <link href="/post/house-robber-ii/"/>
      <url>/post/house-robber-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/house-robber-ii/">https://leetcode.cn/problems/house-robber-ii/</a></strong></p><p><strong>題意：</strong>你是一名專業的強盜, 計劃搶劫沿街的房屋。每棟房子都藏有一定數量的錢。所有的房子都<strong>排成一圈</strong>。這意味著第一棟房子是最後一棟的鄰居。同時, 相鄰的房屋都連接了安全系統, 如果同一晚上有兩間相鄰的房屋被闖入，它會自動報警。</p><p>給定一個整數 array <code>nums</code>, 表示每棟房子的金額, 返回<strong>在不報警的情況下</strong>搶劫的最大金額。</p></blockquote><p><img src="https://i.imgur.com/vQM49da.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：跟 <a href="https://zako945.github.io/post/house-robber/">198. House Robber</a> 類似, 只是首尾相連, 如果搶了第一家，就不能搶最後一家, 所以第一家和最後一家只能搶其中的一家, 或者都不搶。 所以把第一家和最後一家分別去掉, 各算一遍能搶的最大值, 然後比較兩個值取其中較大的一個即為所求</strong></p><p><img src="https://i.imgur.com/uQhIUXD.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">empty</span>() ? <span class="number">0</span> : nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">helper</span>(nums, <span class="number">0</span>, n - <span class="number">2</span>), <span class="built_in">helper</span>(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> curMax = <span class="built_in">max</span>(one, two + nums[i]);</span><br><span class="line">            two = one;</span><br><span class="line">            one = curMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. Longest Palindromic Substring</title>
      <link href="/post/longest-palindromic-substring/"/>
      <url>/post/longest-palindromic-substring/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-palindromic-substring/">https://leetcode.cn/problems/longest-palindromic-substring/</a></strong></p><p><strong>題意</strong>：給一 string <code>s</code>, 找出 <code>s</code> 中最長的迴文 substring。</p><p><strong>注意：</strong></p><ul><li>substring 指的是 string 中 <strong>連續的</strong> subset</li><li>subsequence 則是 string 的 subset</li></ul></blockquote><p><img src="https://i.imgur.com/u8DdxNS.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 因為我們發現「一個迴文去掉兩頭後, 剩下的部分仍為迴文」, 我們用 <code>dp[i][j]</code> 代表 <code>substring s[i~j]</code> 是否迴文, 則可得到下列公式：</strong></p><ul><li><strong><code>dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + 1][j - 1]</code></strong></li></ul><p><code>dp[i + 1][j - 1]</code> 在 <code>dp[i][j]</code> 的<strong>左下方</strong>, 故順序為<strong>由左至右, 一行一行的填</strong>, 其中對角線為 <code>true</code></p><p><img src="https://i.imgur.com/hNq2e4T.png"></p><p>e.g. <code>&quot;abba&quot;</code> 中已知 <code>&quot;bb&quot;</code> 為迴文, 所以 <code>dp[1][2] = true</code></p><p>➔ 則 <code>dp[0][3]</code> 則因為 <code>&quot;a&quot; == &quot;a&quot;</code> 且 <code>dp[1][2] = true</code>, 故 <code>dp[0][3] = true</code>, 代表 <code>&quot;abba&quot;</code> 為迴文</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 當長度為 2 時, e.g. &quot;ac&quot;, dp[0][1] = false, 但 &quot;a&quot; 為回文, 故 maxLen 設 1</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (n, <span class="literal">true</span>)); <span class="comment">// 對角線以下皆為 true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; ++i) &#123;</span><br><span class="line">                dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop：$1+2+…+(n-1) &#x3D; \dfrac{n(n-1)}{2}$  $&#x3D; O(n^2)$</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用中心擴散法, 也就是枚舉所有 substring 的中心位置, 總共枚舉 2n 個 substring, 因為每個位置 <code>i</code> 皆要考慮以其為中心的偶數 substring 和奇數 substring</strong></p><p>更新 <code>start</code> 時, 之所以為 <code>start = i - (maxLen - 1) / 2</code>, 是因為我們的 <code>i</code> 是左中點, 而非右中點, 故 <code>maxLen</code> 要先減一再除 2</p><p><code>expand(s, left, right, n)</code> 跳出迴圈時, 有兩種可能：</p><ul><li><p><code>s[left] != s[right]</code>：代表 <code>s</code> 中的 <code>[left + 1, right - 1]</code> 區間是回文 substring, 此時的回文substring 長度為 <code>(right - 1) - (left + 1) - 1 = right - left - 1</code></p></li><li><p>第二種狀況是 <code>left</code> 或 <code>right</code> 越界, e.g. <code>left = -1</code> 且 <code>right = n</code>, 此時代表整個 <code>s</code> 為回文, 故回文長度為 <code>n</code><br>➔ 第一種狀況得到的公式 <code>right - left - 1 = n - (-1) - 1 = n</code> 仍然滿足第二種狀況</p><p>  <img src="https://i.imgur.com/5JyaT34.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> curLen = <span class="built_in">max</span>(<span class="built_in">expand</span>(s, i, i, n), <span class="comment">// odd substring</span></span><br><span class="line">                                   <span class="built_in">expand</span>(s, i, i + <span class="number">1</span>, n)); <span class="comment">// even substring</span></span><br><span class="line">            <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen = curLen;</span><br><span class="line">                start = i - (maxLen - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// i 是中心, 要倒推回起點</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">expand</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 跳出 loop 時, 第一種狀況是 s[left] != s[right]</span></span><br><span class="line"><span class="comment">         * 代表 s[(left+1)~(right-1)] 是回文substring</span></span><br><span class="line"><span class="comment">         * 此時 substring 長度為 (right-1) - (left+1) + 1 = right - left - 1</span></span><br><span class="line"><span class="comment">         * 第二種狀況是越界, left = -1 且 right = n</span></span><br><span class="line"><span class="comment">         * 此時代表整個 string 為回文, 故回文長度為 n</span></span><br><span class="line"><span class="comment">         * 第一種狀況得到的公式 right - left - 1 = n - (-1) - 1 = n 仍然滿足第二種狀況</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 遍歷每個 char, 每個 char 為中心最多往外擴散 $\dfrac{n}{2}$ 次, 得 $2 \cdot O(\dfrac{n}{2}) \cdot n$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-3：（不會也沒差-會前兩種方法就足夠了）"><a href="#Solution-3：（不會也沒差-會前兩種方法就足夠了）" class="headerlink" title="Solution 3：（不會也沒差, 會前兩種方法就足夠了）"></a><strong>Solution 3：（不會也沒差, 會前兩種方法就足夠了）</strong></h2><blockquote><p><strong>想法：利用 Manacher 演算法（可參考<a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/">這篇</a>）, 其核心思想是結合 DP（回文特性）+ 中心擴散</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string tmp = <span class="built_in">preProcess</span>(s);</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = tmp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n - <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 最後一個 $ 不用算</span></span><br><span class="line">        <span class="type">int</span> center = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 右邊界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> i_mirror = <span class="number">2</span> * center - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 防止超出 right</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; right) &#123;</span><br><span class="line">                p[i] = <span class="built_in">min</span>(p[i_mirror], right - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p[i] = <span class="number">0</span>; <span class="comment">// i &gt;= right 的時候</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 有三種情況, 需使用中心擴散法</span></span><br><span class="line"><span class="comment">             * 1. i + p[i_mirror] &gt; right</span></span><br><span class="line"><span class="comment">             * 2. i &gt;= right 的時候</span></span><br><span class="line"><span class="comment">             * 3. p[i_mirror] 遇到左邊界</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (tmp.<span class="built_in">at</span>(i - <span class="number">1</span> - p[i]) == tmp.<span class="built_in">at</span>(i + <span class="number">1</span> + p[i])) &#123;</span><br><span class="line">                ++p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判斷是否超出右邊界, 是的話要更新右邊界和中心</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; right) &#123;</span><br><span class="line">                center = i;</span><br><span class="line">                right = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 p 的最大值</span></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>, centerIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                centerIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> start = (centerIndex - maxLen) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">string <span class="title">preProcess</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        string tmp = <span class="string">&quot;^&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            tmp += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            tmp += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 透過不斷拓展 <code>right</code>, 且 <code>right</code> 只增不減, 故只看 for loop, 因為 while loop 拜訪過的 char 不會再進 while loop（可透過 DP 快速得到）</li><li><strong>space：</strong>$O(n)$ ➔ <code>tmp</code>, <code>p</code> 的長度 &#x3D; <code>2 * s.size() + 3</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102. Binary Tree Level Order Traversal</title>
      <link href="/post/binary-tree-level-order-traversal/"/>
      <url>/post/binary-tree-level-order-traversal/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></strong></p><p><strong>題意：</strong>給一 BT <code>root</code>, 返回 <code>node.val</code> 之 level-order（由上層往下層, 每層由左至右）。</p></blockquote><p><img src="https://i.imgur.com/RV7JAy9.png"></p><p><img src="https://i.imgur.com/f9wxlhh.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array, <code>q</code> 的元素個數不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> depth, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &lt;= depth) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[depth].<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, depth + <span class="number">1</span>, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, depth + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>199. Binary Tree Right Side View</title>
      <link href="/post/binary-tree-right-side-view/"/>
      <url>/post/binary-tree-right-side-view/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-tree-right-side-view/">https://leetcode.cn/problems/binary-tree-right-side-view/</a></strong></p><p><strong>題意：</strong>給一 BT 的 <code>root</code>, 想像你站在 BT 的右側, 按照從頂部到底部的順序, 返回你從右側所能看到的 <code>node.val</code>。</p></blockquote><p><img src="https://i.imgur.com/xxrR9lV.png"></p><p><img src="https://i.imgur.com/Z0PWxXR.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把每層最後一個 node 給 push 到 res 中</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 array, 在 while loop 迭代的過程中, <code>q</code> 的元素個數不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS, 遍歷順序為 <code>root -&gt; right -&gt; left</code>, 並用 <code>depth</code> 紀錄當前 <code>root</code> 的深度, 而 <code>maxDepth</code> 紀錄當前拜訪到的最大深度。</strong></p><ul><li>若遞迴拜訪的 <code>root</code> 滿足 <code>depth &gt; maxDepth</code>, 代表這是下一層最靠右的 node, 則把該 node 加入到 res 中, 並更新 <code>maxDepth</code></li></ul><p><img src="https://i.imgur.com/nRLDwxG.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> maxDepth = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, maxDepth, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> depth, <span class="type">int</span>&amp; maxDepth, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先拜訪 right, 再拜訪 left</span></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, depth + <span class="number">1</span>, maxDepth, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, depth + <span class="number">1</span>, maxDepth, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1448. Count Good Nodes in Binary Tree</title>
      <link href="/post/count-good-nodes-in-binary-tree/"/>
      <url>/post/count-good-nodes-in-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/">https://leetcode.cn/problems/count-good-nodes-in-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT 的 <code>root</code>, 返回 BT 中 <strong>Good node</strong> 的個數。</p><p><strong>Good node <code>x</code> 的定義：</strong>從 <code>root</code> 到 <code>x</code> 所經過的 node 中, 沒有任何 <code>node.val</code> 大於 <code>x.val</code>。</p></blockquote><p><img src="https://i.imgur.com/kV85ofD.png"></p><p><img src="https://i.imgur.com/D6kkvFh.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 在 DFS 過程中維護當前路徑的最大值 <code>curMax</code>。若 <code>node-&gt;val ≥ curMax</code>, 則更新 <code>maxCur</code>, 並返回 <code>1 + 左子樹的 good node 數 + 右子樹的 good node 數</code>, 那個 1 是把當前 node 視為 good node</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// dfs(root, curMax) 返回 root 到 node 的 path 上總共有幾個 good node</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">int</span> curMax)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &gt;= curMax) &#123;</span><br><span class="line">            curMax = <span class="built_in">max</span>(curMax, node-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(node-&gt;left, curMax) + <span class="built_in">dfs</span>(node-&gt;right, curMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(node-&gt;left, curMax) + <span class="built_in">dfs</span>(node-&gt;right, curMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case：skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98. Validate Binary Search Tree</title>
      <link href="/post/validate-binary-search-tree/"/>
      <url>/post/validate-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></strong></p><p><strong>題意：</strong>給一 BT 的 <code>root</code>, 返回其是否為 BST。</p></blockquote><p><img src="https://i.imgur.com/hCHWtfq.png"></p><p><img src="https://i.imgur.com/9gNOLMq.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 當前 node 必須判斷是否在目前的上、下界中, 因此要不斷維護當前的上、下界。若 node-&gt;val 滿足當前上下界：</strong></p><ul><li>遞迴遍歷 <code>node-&gt;left</code>, 並把 <code>node-&gt;val</code> 設為上界</li><li>遞迴遍歷 <code>node-&gt;right</code>, 並把 <code>node-&gt;val</code> 設為下界</li></ul><p>下圖中雖然 <code>7  &gt; 4</code>, 但它卻位於 <code>5</code> 的左子樹中（此時的 <code>lower = 4</code>, <code>upper = 5</code>）, 故要返回 <code>false</code></p><p><img src="https://i.imgur.com/3laL2XQ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要用 long 而非 int, 因為若用 int, 當 root = [INT_MAX] 時, 會返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">long</span> lower, <span class="type">long</span> upper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 若 tree 為空樹, 也是合法的 BST</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &lt;= lower || node-&gt;val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當前 node 是合法的, 故遞迴判斷左、右子樹是否合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(node-&gt;left, lower, node-&gt;val) &amp;&amp; </span><br><span class="line">                <span class="built_in">dfs</span>(node-&gt;right, node-&gt;val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>230. Kth Smallest Element in a BST</title>
      <link href="/post/kth-smallest-element-in-a-bst/"/>
      <url>/post/kth-smallest-element-in-a-bst/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">https://leetcode.cn/problems/kth-smallest-element-in-a-bst/</a></strong></p><p><strong>題意：</strong>給一 BST 的 <code>root</code> 和一整數 <code>k</code>, 返回 BST 中第 <code>k</code> 小的元素（從 <code>1</code> 開始計數）。</p></blockquote><p><img src="https://i.imgur.com/FNXlEpo.png"></p><p><img src="https://i.imgur.com/qQJ4RXw.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS（inorder）, 不斷取當前 node 的 <code>left</code> 直到 <code>node-&gt;left</code> 為 <code>null</code>, 由於 <code>left child</code> 是「後進先出」, 故要使用 stack。將這些 <code>left</code> 一個一個 pop 掉, 並將 <code>k</code> 減去 <code>1</code></strong></p><ul><li>若 <code>k == 0</code>, 代表當前 <code>node</code> 為第 <code>k</code> 小的數</li><li>若 <code>k &gt; 0</code>, 代表當前的數還太小, 故要嘗試其右子樹中的 node</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 不斷加入 left child, 直到 left child 為 null</span></span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出最左邊的 node</span></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            --k; <span class="comment">// 扣除 root 本身</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// k == 0, 代表當前 root 為第 k 小的</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 嘗試最左邊的 node 之 right subtree</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ worse case：skew tree, 其中 <code>n</code> 為 node 數</li><li><strong>space：</strong>$O(n)$ ➔ 取決於 stack 長度, 最大長度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/post/construct-binary-tree-from-preorder-and-inorder-traversal/"/>
      <url>/post/construct-binary-tree-from-preorder-and-inorder-traversal/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></strong></p><p><strong>題意：</strong>給一 BT 的 <code>preorder</code> 和 <code>inorder</code>, 構建並返回該 BT。</p><p>tree 中沒有重複的元素。</p></blockquote><p><img src="https://i.imgur.com/H1ONem7.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 跟 <a href="https://zako945.github.io/maximum-binary-tree">654. Maximum Binary Tree</a> 類似, 只是可以先遍歷 inorder, 紀錄 inorder 元素的 idx, 讓後續遍歷 preorder 元素時可快速定位, 將時間複雜度降到 $O(n)$</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 紀錄 inorder 元素的 idx, 方便 preorder 快速定位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cur; <span class="comment">// preorder 當前要拜訪的 idx</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index; <span class="comment">// &#123;inorder[i], i&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速取得 preorder 元素在 inorder 中的 idx</span></span><br><span class="line">        <span class="type">int</span> idx = index[preorder[cur]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立 root 後, cur 往下一個</span></span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[cur++]);</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(preorder, left, idx - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(preorder, idx + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>preorder</code> 和 <code>inorder</code></li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>208. Implement Trie (Prefix Tree)</title>
      <link href="/post/implement-trie-prefix-tree/"/>
      <url>/post/implement-trie-prefix-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">https://leetcode.cn/problems/implement-trie-prefix-tree/</a></strong></p><p><strong>題意：</strong>Trie 也稱作 prefix tree, 是一種可以高效儲存、取得 string 中的 key 的資料結構。這一資料結構有相當多的應用情境, 例如 : 自動補全和拼寫檢查。</p><p><strong>請實現 <code>Trie</code> class：</strong></p><ul><li><code>Trie()</code>：初始化 trie object</li><li><code>void insert(String word)</code>：插入 <code>word</code></li><li><code>bool search(String word)</code>：返回 <code>word</code> 是否已經存在於 trie 中</li><li><code>boolean startsWith(String prefix)</code> ：若已經插入的 <code>word</code> 的前綴之一為 <code>prefix</code>, 則 return <code>true</code></li></ul><p><strong>注意：</strong><code>word</code> 和 <code>prefix</code> 僅由<strong>小寫</strong>字母所組成。</p></blockquote><p><img src="https://i.imgur.com/JPDWBFO.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：先用一個 <code>root</code> 作為所有開頭 TrieNode 之 dummy node</strong></p><ul><li><code>Trie()</code> : 初始化 <code>root</code></li><li><code>void insert(String word)</code> : 遍歷 word 中的每個 char, 若 <code>p-&gt;children[ch - &#39;a&#39;]</code> 為 <code>null</code>, 則新增一 TrieNode 並指向它, 當走到 word 之 end, 記得將 trie 中的 end node 之 <code>isEnd</code> 設為 <code>true</code></li><li><code>bool search(String word)</code> 和 <code>boolean startsWith(String prefix)</code> : 兩者皆得遍歷傳入參數的每個 char, 因此我額外寫了一個 <code>TrieNode* find(string&amp; word)</code> 來遍歷<ul><li><code>TrieNode* find(string&amp; word)</code> : 若 word 不在 trie 中, 則返回 nullptr。否則, 返回 end node 之 ptr</li><li><code>bool search(String word)</code> : 若 end node 之 ptr <code>p</code> 存在, 且 <code>p-&gt;isEnd</code> 為 <code>true</code><br>  ➔ 代表 <code>word</code> 存在 trie 中, 因此返回 <code>true</code></li><li><code>boolean startsWith(String prefix)</code> : 若 end node 之 ptr <code>p</code> 存在<br>  ➔ 代表 <code>prefix</code> 存在 trie 中, 因此返回 <code>true</code></li></ul></li></ul><p>e.g. 下圖為插入 <code>[&quot;app&quot;, &quot;ape&quot;, &quot;at&quot;, &quot;atp&quot;, &quot;to&quot;]</code> 後的 trie, 每個 TrieNode 中的是 char 和 is_end</p><p><img src="https://i.imgur.com/G23n4gQ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>; <span class="comment">// 預設每個 char 不為 end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;children[i]) &#123;</span><br><span class="line">                cur-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;isEnd = <span class="literal">true</span>; <span class="comment">// 將最後一個 char 設為 end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不僅 word 要在 trie 中, 且 word 的最後一個 char 還必須是 end</span></span><br><span class="line">        TrieNode *p = <span class="built_in">find</span>(word);</span><br><span class="line">        <span class="keyword">return</span> (p != <span class="literal">nullptr</span>) &amp;&amp; p-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代表 prefix 為 trie 的前綴之一</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 word 不在 trie 中, 則返回 nullptr; 否則, 返回 end node 之 ptr</span></span><br><span class="line">    <span class="function">TrieNode* <span class="title">find</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li>$O(1)$ ➔ 初始化 Trie</li><li>$O(n)$ ➔ insert、search 和 startWith, <code>n</code> 為要查詢或插入的 string 長度</li></ul></li><li><strong>space：</strong>$O(26 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ worse case：每個 <code>word</code> 的 <code>prefix</code> 皆不重覆<ul><li>$\displaystyle\sum_{i&#x3D;1}^{n}w_i$：所有要插入的 string 長度之和（最大 node 數）</li><li>$O(26)$ : 每個 node 有 26 個 children</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>211. Design Add and Search Words Data Structure</title>
      <link href="/post/design-add-and-search-words-data-structure/"/>
      <url>/post/design-add-and-search-words-data-structure/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">https://leetcode.cn/problems/design-add-and-search-words-data-structure/</a></strong></p><p><strong>題意：</strong>請設計一資料結構, 支持新增單字、搜尋 string 是否和先前新增的單字匹配。</p><p><strong>實作 <code>WordDictionary</code> class：</strong></p><ul><li><code>WordDictionary()</code>：初始化 instance</li><li><code>void addWord(word)</code>：將 <code>word</code> 新增到資料結構中, 之後可以對它進行匹配</li><li><code>bool search(word)</code>：如果資料結構中存在 string 和 <code>word</code> 匹配, 則返回 <code>true</code> ; 否則, 返回 <code>false</code>。<code>word</code> 中可能包含一些 <code>.</code>, 每個 <code>.</code> 都可表示成任何一個 char</li></ul><p><strong>注意：</strong></p><ul><li><code>addWord</code> 中的 <code>word</code> 只由<strong>小寫</strong>字母所組成</li><li><code>search</code> 中的 <code>word</code> 由 <code>.</code> or <strong>小寫</strong>字母所組成</li></ul></blockquote><p><img src="https://i.imgur.com/K0RzE7t.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Trie + DFS, 一旦遇到 <code>.</code>, 就對當前 node 中所有的 child 進行 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idx = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;children[idx]) &#123;</span><br><span class="line">                cur-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        trie.<span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(trie.root, word, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TrieNode* node, string&amp; word, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        TrieNode *cur = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; child : cur-&gt;children)&#123;</span><br><span class="line">                    <span class="comment">// 要先判斷 child 是否為 nullptr, i + 1 是因為跳過當前 char</span></span><br><span class="line">                    <span class="keyword">if</span> (child &amp;&amp; <span class="built_in">dfs</span>(child, word, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> idx = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;children[idx]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;children[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>WordDictionary()</code>：$O(1)$</li><li><code>addWord(word)</code>：$O(n)$ ➔ 其中 <code>n</code> 為 <code>word.size()</code></li><li><code>search(word)</code>：$O(26^n)$ ➔ worse case : <code>word</code> 中每個 char 皆為 <code>.</code>, 這樣每個 char 都有 26 種可能</li></ul></li><li><strong>space：</strong>$O(T)$ ➔ $O(26 \cdot T)$, 其中 <code>T</code> 為 <code>trie</code> 中所有的 node 數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>973. K Closest Points to Origin</title>
      <link href="/post/k-closest-points-to-origin/"/>
      <url>/post/k-closest-points-to-origin/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/k-closest-points-to-origin/">https://leetcode.cn/problems/k-closest-points-to-origin/</a></strong></p><p><strong>題意：</strong>給一 array <code>points</code> 和一整數 <code>k</code>, 其中 <code>points[i] = [x_i, y_i]</code> 表示平面上的一個點, 返回距離 <code>(0, 0)</code> 最近的 <code>k</code> 個點。</p><p>平面上兩點的距離是採用<strong>歐式距離</strong> $\sqrt{(x1 - x2)^2 + (y1 - y2)^2}$</p><p>可以按<strong>任何順序</strong>返回答案。</p></blockquote><p><img src="https://i.imgur.com/TeyvJue.png"></p><p><img src="https://i.imgur.com/YC2fgLx.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap, 用 max heap 維護前 <code>k</code> 小的元素, 類似 <a href="https://zako945.github.io/post/top-k-frequent-elements/">347. Top K Frequent Elements</a></strong></p><ul><li>先將前 <code>k</code> 個元素加入到 max heap 中</li><li>後面 <code>n - k</code> 個點, 都是先 insert 到 heap 中再 pop 掉, 來維持 heap 中 <code>k</code> 個元素</li><li>此時, heap 中為前 <code>k</code> 小的元素, 將其取出即可</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; t3i; <span class="comment">// &#123;dist, x, y&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> k) &#123;</span><br><span class="line">        priority_queue&lt;t3i&gt; pq; <span class="comment">// max heap 維護前 k 小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; point : points) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> dist = x * x + y * y;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(t3i&#123;dist, x, y&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若加入後 heap 中有 k + 1 個, 則 pop 掉 dist 最大的來維持 k 個</span></span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此時, heap 中為前 k 小元素, 將其取出即可</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [dist, x, y] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;x, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(k))$ ➔ 前面兩個 for loop 最多 insert&#x2F;delete <code>n</code> 個點, 每次操作需 $O(log(k))$, 因為 <code>pq</code> 中最多 <code>k</code> 個點</li><li><strong>space：</strong>$O(k)$ ➔ <code>pq</code> 最多有 <code>k</code> 個元素</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. Kth Largest Element in an Array</title>
      <link href="/post/kth-largest-element-in-an-array/"/>
      <url>/post/kth-largest-element-in-an-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和一整數 <code>k</code>, 返回第 <code>k</code> 大的元素。</p><p><strong>注意：</strong>你需要找的是 <code>nums</code> 排序後的第 <code>k</code> 大的元素, 而非第 <code>k</code> 個不同的元素。</p><p>設計滿足 $O(n)$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/vHep5hb.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Heap, 維護前 <code>k</code> 大的元素, 類似 <a href="https://zako945.github.io/post/top-k-frequent-elements/">347. Top K Frequent Elements</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(num);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若加入後 heap 中有 k + 1 個, 則 pop 掉最小的來維持 k 個</span></span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(k))$ ➔ for loop 最多 insert&#x2F;delete <code>n</code> 個點, 每次操作需 $O(log(k))$, 因為 <code>pq</code> 中最多 <code>k</code> 個點</li><li><strong>space：</strong>$O(k)$ ➔ <code>pq</code> 的最大長度為 <code>k</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Quick Select, 原題目就會變成求將 <code>nums</code> 由小到大排序後 <code>idx = n - k</code> 的元素, 因為排序完後 <code>idx = n - 1</code> 為第一大的元素, 故 <code>idx = n - k</code> 為第 <code>k</code> 大的元素</strong></p><ul><li>先選一元素當作 pivot<ul><li>把 <code>val ≤ pivot</code> 的元素放在 pivot 的左邊</li><li>而 <code>val &gt; pivot</code> 的元素放在 pivot 的右邊</li></ul></li><li>比較 <code>pivot_idx</code> 是否為 <code>k</code><ul><li>若 <code>k &gt; pivot_idx</code>：遞迴搜索右邊的部分 <code>quickSelect(pivot_idx + 1, right)</code></li><li>若 <code>k &lt; pivot_idx</code>：遞迴搜索左邊的部分 <code>quickSelect(left, pivot_idx - 1)</code></li><li>若 <code>k == pivot_idx</code>：返回 <code>nums[k]</code></li></ul></li></ul><p>e.g. <code>nums = [3,2,1,5,6,4]</code>, <code>k = 2</code> ➔ <code>k = n - k = 6 - 2 = 4</code></p><ul><li>首先, <code>left = 0</code>, <code>right = 5</code>, 取出 <code>pivotVal = 4</code>, <code>pivotIdx = 0</code>,</li><li>第一輪 Quick Select 做完, 得到 <code>nums = [3,2,1,4,6,5]</code>, <code>pivotIdx = 3</code></li><li>由於 <code>k = 4 &gt; pivotIdx = 3</code>, 故往右邊尋找 <code>quickSelect(nums, pivotIdx + 1, right, k)</code></li><li>第二輪 Quick Select 做完, 得到 <code>nums = [3,2,1,4,5,6]</code>, <code>pivotIdx = 4</code></li><li><code>k == pivotIdx</code>, 故返回 <code>nums[4] = 5</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k = n - k; <span class="comment">// 若由小排到大, 則 nums 中 idx = n - k 的元素為第 k 大的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = nums[right], pivotIdx = left; <span class="comment">// 取最右的元素為 pivot</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將比 pivot 小的元素從 idx = left 的位置開始放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[pivotIdx++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 pivot 放在 pivotIdx 上, 使得左邊皆 &lt;= pivot, 右邊皆 &gt; pivot</span></span><br><span class="line">        <span class="comment">// 必須寫 nums[right], 不能寫 pivot, 否則 nums[pivotIdx] 仍會是 pivot</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[pivotIdx], nums[right]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt; pivotIdx) &#123; <span class="comment">// 搜索左邊的部分</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, left, pivotIdx - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; pivotIdx) &#123; <span class="comment">// 搜索右邊的部分</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, pivotIdx + <span class="number">1</span>, right, k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[pivotIdx]; <span class="comment">// k == pivotIdx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ Quick Select 的 Avg case<ul><li>worse case 為 $O(n^2)$, 也就是每次取完 <code>pivot</code> 都只篩掉一個元素</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>621. Task Scheduler</title>
      <link href="/post/task-scheduler/"/>
      <url>/post/task-scheduler/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/task-scheduler/">https://leetcode.cn/problems/task-scheduler/</a></strong></p><p><strong>題意：</strong>給一 char array <code>tasks</code> 代表 CPU 須執行的任務 list, 其中每個字母代表一種不同種類的任務, 任務能以任意順序執行, 且每個任務皆可在 1 個單位時間內完成。在任意一個時間單位, CPU 可以選擇完成一個任務 or 處於待命狀態。</p><p>然而, 在兩個<strong>相同種類</strong>的任務之間必須有長度為 <code>n</code> 的冷卻時間。</p><p>計算並返回完成所有任務的<strong>最短時間</strong>。</p><p><strong>注意：</strong><code>tasks[i]</code> 必為<strong>大寫</strong>字母。</p></blockquote><p><img src="https://i.imgur.com/6aS60TV.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Greedy + Heap, 應該處理的出現次數最多的 task, 盡量讓每一輪都能塞滿 <code>n + 1</code> 個 task（因為題目要求最短時間）。盡量先取高頻的 task, 然後再來取低頻的 task, 理由如下：</strong></p><p>若改成優先取那些低頻的 task, 可能會讓低頻的 task 一下就被取完, 導致<strong>剩下的 task 整體的多樣性減少</strong>。當 max heap 中的 task 種類 <code>&lt; n + 1</code>, 但每一輪又要取 <code>n + 1</code>  個時, 就會需要使用 <code>idle</code> 來填補每一輪中剩餘的 task ➔ 這無法滿足題目要求的<strong>最短時間</strong></p><ul><li>每次從 max heap 中取出 <code>n + 1</code> 個不同種類的 task</li><li>若無法從 max heap 取出 <code>n + 1</code> 個 task, 分成兩種情況：<ul><li>非最後一輪, 用 <code>idle</code> 填滿剩餘的 task</li><li>為最後一輪, 則不需用 <code>idle</code> 填滿剩餘的 task（因為沒有下一輪）</li></ul></li><li>將取出的 task 之 <code>cnt -= 1</code>, 若 <code>cnt &gt; 0</code>, 則 push 回 max heap 中</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; tasks, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freqs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : tasks) &#123;</span><br><span class="line">            freqs[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// max heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ch, num] : freqs) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; bucket; <span class="comment">// 用來暫存這一輪取出的 task 之 cnt - 1</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> num = <span class="built_in">min</span>(n + <span class="number">1</span>, <span class="built_in">int</span>(pq.<span class="built_in">size</span>())); <span class="comment">// 紀錄這一輪取出的 task 個數</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一次從 max heap 中取 num 個 task 放入桶子中, 取出記得 cnt 要減 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">                bucket.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>() - <span class="number">1</span>); <span class="comment">// 紀錄 cnt - 1</span></span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若取出的 task 之 cnt &gt; 0, 則 push 回 max heap 中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; cnt : bucket) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cnt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 max heap 不為空, 則代表還有下一輪, 那這一輪的桶會是全填滿的狀態</span></span><br><span class="line">            <span class="comment">// 否則, 代表這一輪為最後一輪, 且桶中個數為 num 個(可能不滿 n + 1 個)</span></span><br><span class="line">            res += (pq.<span class="built_in">empty</span>() ? num : n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(len)$ ➔ $O(len) + O(len \cdot log(26))$<ul><li>$O(len)$：遍歷 <code>tasks</code> 每個 char</li><li>$O(len \cdot log(26))$：每一次從 <code>pq</code> 中取 <code>n + 1</code> 個數放入桶子中, 總共取 <code>len</code> 個, 故 <code>pq</code> 要調整 <code>len</code> 次 , 而 <code>pq</code> 中最多 26 個數</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間, 因為 <code>freqs</code> 只需 $O(26)$, 且 <code>bucket</code> 和 <code>pq</code> 最多 $O(26)$</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 假設今天只有一種任務 <code>A</code>, <code>tasks = [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]</code> 且 <code>n = 2</code>, 則最小排列方式為 <code>A _ _ A _ _ A</code>, 其中 <code>A _ _</code> 可看作是一個桶子（長度為 <code>n + 1</code>）, 總共需花費 <code>(3 - 1) x (2 + 1) + 1 = 7</code> 個時間單位, 也就是 <code>(頻率最高任務的次數 - 1) x (n + 1) + 1</code>, 但會有以下情況不適用：</strong></p><ul><li><p><strong>當頻率最高任務次數的任務數不只一個時</strong><br>e.g. <code>tasks = [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]</code>, <code>n = 2</code><br>最小排列方式為 <code>A B _ A B _ A B</code>, 總共需花費 <code>(3 - 1) x (2 + 1) + 2 = 8</code><br>➔ <strong>公式需修改為 <code>(頻率最高任務的次數 - 1) x (n + 1) + (頻率最高任務次數的任務數)</code></strong></p></li><li><p><strong>當中間的間隔不夠其他任務插入時</strong><br>e.g. <code>tasks = [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C&#39;, &#39;D&#39;, &#39;D&#39;]</code>, <code>n = 2</code><br>按照上述公式會得出需花費 <code>(3 - 1) x (2 + 1) + 1 = 7</code><br>但總共有 9 個任務, 根本不可能在 7 個時間單位內完成<br>我們可以在間隔 <code>_ _</code> 後加上其他任務, 因此最小排列方式為 <code>A B C D A B C D A</code><br>➔ <strong>如果 <code>任務個數 &gt; 公式算出的最少時間</code>, 則答案為<code>任務個數</code></strong></p><p>  <img src="https://i.imgur.com/cZ2GHF7.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; tasks, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">freqs</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : tasks) &#123;</span><br><span class="line">            freqs[ch - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出現次數最多的 char (最高任務的次數)</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> maxFreq = *<span class="built_in">max_element</span>(freqs.<span class="built_in">begin</span>(), freqs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出現次數為 maxVal 的個數</span></span><br><span class="line">        <span class="type">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : freqs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == maxFreq) &#123;</span><br><span class="line">                maxCnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>((maxFreq - <span class="number">1</span>) * (n + <span class="number">1</span>) + maxCnt, tasks.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(len)$ ➔ 遍歷 <code>tasks</code></li><li><strong>space：</strong>$O(1)$ ➔ <code>freqs</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>355. Design Twitter</title>
      <link href="/post/design-twitter/"/>
      <url>/post/design-twitter/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/design-twitter/">https://leetcode.cn/problems/design-twitter/</a></strong></p><p><strong>題意：</strong>設計一個簡化版的 Twitter, 可以讓用戶實現發送推文、關注 &#x2F; 取消關注 其他用戶, 以及能夠看見關注人（包括自己）的最近 <code>10</code> 條推文。</p><ul><li><code>Twitter()</code>：初始化 twitter instance。</li><li><code>void postTweet(int userId, int tweetId)</code>：根據給定的 <code>tweetId</code> 和 <code>userId</code> 創建一條新推文。每次調用此函數都會使用一個不同的 <code>tweetId</code>。</li><li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code>：檢索當前用戶新聞推送中最近 <code>10</code> 條推文的 ID。<ul><li>新聞推送中的每一項都必須是由用戶關注的人 or 用戶自己發布的推文。</li><li>推文必須按照時間順序由<strong>最近到最遠排序</strong>。</li></ul></li><li><code>void follow(int followerId, int followeeId)</code>：ID 為 <code>followerId</code> 的用戶開始關注 ID 為 <code>followeeId</code> 的用戶。</li><li><code>void unfollow(int followerId, int followeeId)</code>：ID 為 <code>followerId</code> 的用戶取消關注 ID 為 <code>followeeId</code> 的用戶。</li></ul></blockquote><p><img src="https://i.imgur.com/sSGB6Yx.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1</strong>：</h2><blockquote><p><strong>想法：利用 hash table, 利用兩個 hash table <code>friends</code>、<code>tweets</code> 來分別記錄每一位用戶的好友、每一位用戶發的推文。<code>getNewsFeed()</code> 獲取自己和好友的最近 10 條推文, 首先要將自己添增到自己的好友列表中, 然後依序遍歷每個好友的所有推文, 並維護一個大小為 10 的 min heap</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Twitter</span>() &#123;</span><br><span class="line">        ts = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        tweets[userId].<span class="built_in">emplace_back</span>(pii&#123;++ts, tweetId&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">follow</span>(userId, userId); <span class="comment">// 先 follow 自己</span></span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> i : friends[userId]) &#123;</span><br><span class="line">            <span class="comment">// 遍歷該好友「最新 -&gt; 最舊」的推文</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tweets[i].<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(tweets[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">10</span>) &#123; <span class="comment">// 若大於 10 則, 則 pop 掉 ts 最小的, 以維持 10 則</span></span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出 的 tweetId 是根據 ts 由小到大排序, 故取出後要 reverse</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        friends[followerId].<span class="built_in">emplace</span>(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (friends[followerId].<span class="built_in">find</span>(followeeId) != friends[followerId].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            friends[followerId].<span class="built_in">erase</span>(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ts; <span class="comment">// timestamp, ts 越大代表該推文越新</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;pii&gt;&gt; tweets; <span class="comment">// userId -&gt; &#123;ts, tweetId&#125;</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; friends; <span class="comment">// &#123;follower, set of followee&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>Twitter()</code>：$O(1)$</li><li><code>postTweet()</code>：$O(1)$</li><li><code>getNewsFeed()</code>：$O(f \cdot t)$ ➔ $O(f \cdot t \cdot log(10))$, 遍歷該用戶每個好友的所有推文<ul><li><code>f</code> 為該用戶的好友數</li><li><code>t</code> 為每位好友的平均推文數</li><li>$O(log(10))$ 為 heap 中 insert &#x2F; erase 一個元素所需的時間</li></ul></li><li><code>follow()</code>：$O(1)$</li><li><code>unfollow()</code>：$O(1)$</li></ul></li><li><strong>space：</strong>$O(u \cdot t)$ ➔ <code>tweets</code>, 其中 <code>u</code> 為所有用戶數, <code>t</code> 為所有用戶的平均推文數</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 只是 <code>getNewsFeed()</code> 改成維護一個大小為 10 的 set, 並做 pruning 來優化。每個好友的推文是根據 <code>ts</code> 「大(新) -&gt; 小(舊)」來遍歷, 一旦當前好友 <code>f1</code> 的推文比 <code>news</code> 中最舊推文的 <code>ts</code> 還要小, 則 <code>f1</code> 剩餘的推文都不必遍歷（因為 <code>ts</code> 只會更小）, 可直接跳到下一個好友</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Twitter</span>() &#123;</span><br><span class="line">        ts = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        tweets[userId].<span class="built_in">emplace_back</span>(pii&#123;++ts, tweetId&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">follow</span>(userId, userId); <span class="comment">// 先 follow 自己</span></span><br><span class="line"></span><br><span class="line">        set&lt;pii&gt; news;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> i : friends[userId]) &#123;</span><br><span class="line">            <span class="comment">// 遍歷該好友「最新 -&gt; 最舊」的推文</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tweets[i].<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="comment">// 不足 10 則, 直接加入到 news 中</span></span><br><span class="line">                <span class="keyword">if</span> (news.<span class="built_in">size</span>() &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                    news.<span class="built_in">emplace</span>(tweets[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tweets[i][j].first &gt; news.<span class="built_in">begin</span>()-&gt;first) &#123; <span class="comment">// 若該推文比 news 中最舊的推文還新, 則加入該推文, 並移除最舊的推文</span></span><br><span class="line">                    news.<span class="built_in">erase</span>(news.<span class="built_in">begin</span>());</span><br><span class="line">                    news.<span class="built_in">emplace</span>(tweets[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 該推文比 news 中最舊的推文還舊, 則該好友不必再繼續往下遍歷</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出 news 中的 tweetId, 由於 news 是根據 ts 由小到大排序, 故取出後要 reverse</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ts, tweetId] : news) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(tweetId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        friends[followerId].<span class="built_in">emplace</span>(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (friends[followerId].<span class="built_in">find</span>(followeeId) != friends[followeeId].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            friends[followerId].<span class="built_in">erase</span>(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ts; <span class="comment">// timestamp, ts 越大代表該推文越新</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;pii&gt;&gt; tweets; <span class="comment">// userId -&gt; &#123;ts, tweetId&#125;</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; friends; <span class="comment">// &#123;follower, set of followee&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>Twitter()</code>：$O(1)$</li><li><code>postTweet()</code>：$O(1)$</li><li><code>getNewsFeed()</code>：$O(f \cdot t)$ ➔ $O(f \cdot t \cdot log(10))$, 遍歷該用戶每個好友的所有推文<ul><li><code>f</code> 為該用戶的好友數</li><li><code>t</code> 為每位好友的平均推文數</li><li>$O(log(10))$ 為 set 中 insert &#x2F; erase 一個元素所需的時間</li></ul></li><li><code>follow()</code> : $O(1)$</li><li><code>unfollow()</code> : $O(1)$</li></ul></li><li><strong>space：</strong>$O(u \cdot t)$ ➔ <code>tweets</code>, 其中 <code>u</code> 為所有用戶數, <code>t</code> 為所有用戶的平均推文數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78. Subsets</title>
      <link href="/post/subsets/"/>
      <url>/post/subsets/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 當中的元素互不相同, 返回所有可能的 subset。</p></blockquote><p><img src="https://i.imgur.com/sASUAcK.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking, 每個元素都有取 or 不取兩種選擇</strong></p><p><img src="https://i.imgur.com/1JtQlEc.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n); <span class="comment">// 不取</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取</span></span><br><span class="line">        cur.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$<ul><li>有 $2^n$ 種 subset</li><li>建每一種 subset 需 $O(n)$ time, 因為 <code>i</code> 從 <code>[0, n]</code></li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array, 則只需 $O(n)$<ul><li>$O(n)$：<code>dfs()</code> 遞迴最大深度、<code>cur</code> 中的元素個數</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39. Combination Sum</title>
      <link href="/post/combination-sum/"/>
      <url>/post/combination-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></strong></p><p><strong>題意：</strong>給一無重複數的 array <code>candidates</code> 和一整數 <code>target</code>, 找出 <code>candidates</code> 中可以使數字和等於 <code>target</code> 的所有不同組合, 以<strong>任意順序</strong>返回。</p><p>其中, <code>candidates[i]</code> 皆 <code>&gt; 0</code></p><p><strong>注意：</strong><code>candidates</code> 同一個數字可以<strong>無限次重複選取</strong>, 如果至少一個數字的被選數量不同, 則兩種組合是不同的</p></blockquote><p><img src="https://i.imgur.com/R8ihvki.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking, 其中每個元素 <code>candidates[i]</code> 有兩種選擇：</strong></p><ul><li><p>選, 並從此位置 <code>i</code> 繼續選要不要重複選取</p></li><li><p>不選, 從下一個位置 <code>i + 1</code> 的元素繼續開始</p><p>  <img src="https://i.imgur.com/1te9bt9.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, candidates.<span class="built_in">size</span>(), target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> i, <span class="type">int</span> n, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span> || i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, i + <span class="number">1</span>, n, target); <span class="comment">// 不取</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取, 由於可重複取同一數, 故 idx 仍是從 i 開始取</span></span><br><span class="line">        cur.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, i, n, target - candidates[i]);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ 每個元素都有兩種選擇, 故最多有 $2^n$ 種選擇, 而每一種選擇皆需花 $O(n)$</li><li><strong>space：</strong>$O(target)$ ➔ worse case 下, <code>dfs()</code> 最大遞迴深度為 $O(target)$</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 只是透過 pruning 來做優化, 一旦當前元素超過 <code>target</code>, 則直接跳過。for loop 中之所以沒有不取元素的部分, 是因為：</strong></p><ul><li>若取, 則會遞迴執行 <code>dfs(j, target - candidates[j])</code></li><li>若不取, 則在下一輪 for loop 中 <code>dfs(j + 1, target)</code> 是不會有 <code>nums[j]</code> 的, 因為上一輪的 <code>cur</code> 有做 backtracking, 會將狀態還原回加入 <code>nums[j]</code> 前的狀態後, 才進到下一輪的 <code>j + 1</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, candidates.<span class="built_in">size</span>(), target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> i, <span class="type">int</span> n, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若要取, 則會遞迴執行；若不取, 則 for loop 迭代到 j + 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[j] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 剪枝, 一旦超過 target 則跳過</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(candidates[j]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, j, n, target - candidates[j]);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ worse case 仍為 $O(n \cdot 2^n)$, 透過使用 pruning, 實際運行情況應該是<strong>遠小於</strong> $O(n \cdot 2^n)$ 的</li><li><strong>space：</strong>$O(target)$ ➔ worse case 下, <code>dfs()</code> 最大遞迴深度為 $O(target)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46. Permutations</title>
      <link href="/post/permutations/"/>
      <url>/post/permutations/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></strong></p><p><strong>題意：</strong>給一不含重複數字的 array <code>nums</code>, 求所有可能的排列, 以<strong>任意順序</strong>返回。</p></blockquote><p><img src="https://i.imgur.com/adGJ3ij.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：DFS, <code>nums[i]</code> 輪流當頭</strong></p><p>e.g. <code>nums = [1, 2, 3]</code></p><ul><li><p><code>1</code> 當頭 : <code>[1, 2, 3], [1, 3, 2]</code></p></li><li><p><code>2</code> 當頭 : <code>[2, 1, 3], [2, 3, 1]</code></p></li><li><p><code>3</code> 當頭 : <code>[3, 2, 1], [3, 1, 2]</code></p><p>  <img src="https://i.imgur.com/rC0P6Cu.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n); <span class="comment">// 跟開頭 nums[i] 做 swap, 排序 i + 1 (開頭以後)</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot n!)$ ➔ 總共 $n!$ 種排列, 建構每一種排列皆需花 $O(n)$ time</li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array, 則取決於遞迴的最大深度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>90. Subsets II</title>
      <link href="/post/subsets-ii/"/>
      <url>/post/subsets-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 當中的元素可能會重複, 返回所有可能的 subset <code>res</code>。</p><p><strong>注意：</strong><code>res</code> 不能包含重複的 subset, 可以按<strong>順序任意</strong>排列</p></blockquote><p><img src="https://i.imgur.com/Fp3brwo.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 先將 <code>nums</code> 排序（讓相同值的數相鄰）, 然後跟 <a href="https://zako945.github.io/post/subsets/">78. Subsets</a> 一樣</strong></p><ul><li>不一樣的是, <code>res</code> 中不能有重複的 subset</li><li>只是若不取, 則後面跟當前值一樣的數, 都要跳過, 從值不一樣的繼續</li></ul><p>e.g. <code>nums = [1, 2, 2, 3]</code><br>下圖中紅色圈起來的部分, 即是選 1 之後不選 2, 所以後面值為 2 的都要跳過, 下一個從 3 開始取</p><p><img src="https://i.imgur.com/eeaaTX2.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取</span></span><br><span class="line">        cur.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不取</span></span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; n &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ $O(n \cdot log(n)) + O(n \cdot 2^n)$<ul><li>$O(n \cdot log(n))$：sorting</li><li>$O(n \cdot 2^n)$：最多 $2^n$ 種 subset, 建每一種 subset 需 $O(n)$ time</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array, 則取決於遞迴的最大深度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40. Combination Sum II</title>
      <link href="/post/combination-sum-ii/"/>
      <url>/post/combination-sum-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a></strong></p><p><strong>題意：</strong>給一 array <code>candidates</code> 和一整數 <code>target</code>, 求 <code>candidates</code> 中所有可以使數字和為 <code>target</code> 的組合, 且 <code>candidates</code> 中的每個數字在每個組合中只能使用<strong>一次</strong>。</p><p><strong>注意：</strong>Output 不能有重複的組合</p></blockquote><p><img src="https://i.imgur.com/nDVC8BI.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先做 sorting, 再用 DFS, 類似 <a href="https://zako945.github.io/post/combination-sum/">39. Combination Sum</a>, 一旦不取 <code>nums[j]</code>, 則後面區間 <code>[j + 1, n)</code> 中若有跟 <code>candidates[j]</code> 相同的都直接跳過</strong></p><p>e.g. <code>candidates = [10,1,2,7,6,1,5]</code>, <code>target = 8</code></p><ul><li>先做 sorting</li><li>若不取 <code>idx = 0</code> 的 <code>1</code>, 則可以直接跳過 <code>idx = 1</code> 的 <code>1</code>, 讓 <code>idx = 2</code> 的元素開始取</li></ul><p><img src="https://i.imgur.com/ZL06Ywq.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, candidates.<span class="built_in">size</span>(), target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> i, <span class="type">int</span> n, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span> || i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取</span></span><br><span class="line">        cur.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, i + <span class="number">1</span>, n, target - candidates[i]);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不取, 若後面有跟 candidates[i] 值一樣的, 則都跳過</span></span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; n &amp;&amp; candidates[i] == candidates[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, i + <span class="number">1</span>, n, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ $O(n \cdot log(n)) + O(n \cdot 2^n)$<ul><li>$O(n \cdot log(n))$：sorting</li><li>$O(n \cdot 2^n)$：最多有 $2^n$ 種組合, 建構每一種組合需 $O(n)$ time</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array, 則取決於遞迴的最大深度</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 只是透過剪枝（pruning）來做優化, 一旦當前元素超過 <code>target</code>, 則直接退出（因為有排序）。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, candidates.<span class="built_in">size</span>(), target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> i, <span class="type">int</span> n, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若要取, 則會遞迴執行；若不取, 則 for loop 迭代到 j + 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="comment">// 剪枝, 因為有排序, 故 candidates[j] &gt; target, 則後面皆 &gt; target</span></span><br><span class="line">            <span class="keyword">if</span> (candidates[j] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取</span></span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(candidates[j]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, j + <span class="number">1</span>, n, target - candidates[j]);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不取, 若後面有跟 candidates[i] 值一樣的, 則都跳過</span></span><br><span class="line">            <span class="keyword">while</span> (j + <span class="number">1</span> &lt; n &amp;&amp; candidates[j] == candidates[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ worse case 仍為 $O(n \cdot 2^n)$, 透過使用 pruning, 實際運行情況應該是<strong>遠小於</strong> $O(n \cdot 2^n)$ 的</li><li><strong>space：</strong>$O(target)$ ➔ worse case 下, <code>dfs()</code> 最大遞迴深度為 $O(target)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79. Word Search</title>
      <link href="/post/word-search/"/>
      <url>/post/word-search/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/word-search/">https://leetcode.cn/problems/word-search/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的網格 <code>board</code> 和一 string <code>word</code>, 求 <code>word</code> 是否出現在 <code>board</code> 中。</p><p>其中, <code>board</code> 和 <code>word</code> 僅由大小寫英文字母所組成</p><p><strong>注意：</strong>必須按照 <code>word</code> 中字母的順序, 並通過相鄰的 cell 所構成, 其中相鄰是指水平相鄰 or 垂直相鄰, 且同一位置的 cell 不允許被重複使用。</p></blockquote><p><img src="https://i.imgur.com/BMKYeN9.png"></p><p><img src="https://i.imgur.com/nYhEf4S.png"></p><p><img src="https://i.imgur.com/apterok.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 要記得將已拜訪過的 node 設為已拜訪, 避免重複拜訪</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依序把 board[i][j] 作為起始點來探索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, i, j, word, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, <span class="type">const</span> string&amp; word, <span class="type">const</span> <span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">outOfBound</span>(i, j) || board[i][j] != word[idx]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// word 的最後一個 char 有被找到(前面的也都有被找到, idx 才會執行到最後一個)</span></span><br><span class="line">        <span class="keyword">if</span> (idx == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> ch = board[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 (i, j) 標記為已拜訪, 避免重複拜訪</span></span><br><span class="line">        <span class="comment">// 本題 word 中的 char 皆為英文字母, 故這邊設為數字</span></span><br><span class="line">        <span class="comment">// 這樣下方的 dfs 若走到拜訪過的位置必和 word[idx] 不相等, 並返回 false</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r = i + dirY, c = j + dirX;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, r, c, word, idx + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = ch; <span class="comment">// 還原</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot 4^L)$ ➔ for loop 中每個 <code>board[i][j]</code> 都要執行 dfs, 其中 $L$ 為 <code>word</code> 的長度<ul><li>$O(m \cdot n)$：<code>exist()</code> 中的 for loop</li><li>$O(4^L)$：<code>dfs()</code> 的 worse case, <code>word[idx]</code> 每次都有四個方向要探索, 故為 $4^L$</li></ul></li><li><strong>space：</strong>$O(L)$ ➔ 最大遞迴深度, 受限於 $L$, 因為 <code>if (idx == word.size() - 1)</code> 為中止條件</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131. Palindrome Partitioning</title>
      <link href="/post/palindrome-partitioning/"/>
      <url>/post/palindrome-partitioning/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindrome-partitioning/">https://leetcode.cn/problems/palindrome-partitioning/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 將 <code>s</code> 切割成一些 substring, 使每個 substring 皆回文, 返回 <code>s</code> 所有可能的切割方法。</p><p>其中, <code>s</code> 僅由小寫英文字母所組成。</p></blockquote><p><img src="https://i.imgur.com/IzaJUX6.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 如果切下去是回文, 則遞迴剩下的 substring</strong></p><p><img src="https://i.imgur.com/ZnBhKRI.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, i, j)) &#123;</span><br><span class="line">                cur.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>));</span><br><span class="line">                <span class="built_in">dfs</span>(s, j + <span class="number">1</span>, n);</span><br><span class="line">                cur.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left++] != s[right--]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ 最壞情況下, <code>s</code> 為 <code>n</code> 個相同的 char<ul><li>總共 $2^{n-1}$ 種切法（每個 char 之間的間隙都有切 or 不切兩種選擇）</li><li>每種耗時 $O(n)$, 判斷每個 substring 是否為回文</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, 最大遞迴深度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. Letter Combinations of a Phone Number</title>
      <link href="/post/letter-combinations-of-a-phone-number/"/>
      <url>/post/letter-combinations-of-a-phone-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></strong></p><p><strong>題意：</strong>給一 string 包含數字 <code>2-9</code>, 以<strong>任意順序</strong>返回所有它所能表示的英文組合。<br>數字到英文的 mapping 如下, 其中數字 1 不對應任何字母</p></blockquote><p><img src="https://i.imgur.com/ObUlOvR.png"></p><p><img src="https://i.imgur.com/gdaxaKL.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, <span class="number">0</span>, digits.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string cur;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;string&gt; mapping = &#123;</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string&amp; digits, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : mapping[digits[i] - <span class="string">&#x27;2&#x27;</span>]) &#123;</span><br><span class="line">            cur += ch;</span><br><span class="line">            <span class="built_in">dfs</span>(digits, i + <span class="number">1</span>, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 4^n)$<ul><li>一個數字最多 4 種選擇（數字 <code>7</code> 和 <code>9</code>）</li><li>總共 $4^n$ 種排列, 建構每一種需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array <code>res</code>, 則取決於遞迴深度, 最大遞迴深度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>200. Number of Islands</title>
      <link href="/post/number-of-islands/"/>
      <url>/post/number-of-islands/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的二維矩陣 <code>grid</code>, 其中 <code>&#39;1&#39;</code> 代表陸地, 而 <code>&#39;0&#39;</code> 代表水, 返回島嶼的個數。</p><p>每座島嶼只能由水平 or 垂直方向的相鄰陸地連接而成。</p></blockquote><p><img src="https://i.imgur.com/pY28FxG.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS, 若 <code>grid[row][col] == 1</code>, 則以其為起始 node 開始進行 DFS。在 DFS 的過程中. 每個搜索到的 <code>1</code> 都會被重新標記為 <code>0</code>, 最後整個地圖都會變成水</strong></p><p><img src="https://i.imgur.com/nZbHrWq.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">outOfBound</span>(i, j) || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 表示已拜訪過</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, i + dirY, j + dirX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ 取決於遞迴深度, 最大遞迴深度為 $mn$（worse case：全部都是陸地）</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 概念類似 Solution 1, 拜訪後一樣要設為 <code>0</code>。若在 <code>q.pop()</code> 下面放 <code>grid[row][col] = &#39;0&#39;</code>, 而不是在將 <code>&#123;r, c&#125;</code> push 到 <code>q</code> 時將 <code>grid[r][c]</code> 設為 <code>0</code>, 這樣會使 node 被重複拜訪, 導致 TLE</strong></p><p><img src="https://i.imgur.com/6Ge76fI.png"></p><p>e.g. <code>grid = [[1, 1], [1, 1]]</code></p><ul><li><p>若是在 <code>q.pop()</code> 下面放 <code>grid[row][col] = &#39;0&#39;</code>, 則 <code>grid[1][1]</code> 會被 <code>grid[0][1]</code> 和 <code>grid[1][0]</code> 重複拜訪（因為 <code>grid[1][1]</code> 在下一輪的 <code>q.pop()</code> 後才被設為 0）</p><p>  <img src="https://i.imgur.com/nR05xdp.png"></p></li><li><p>若是在將 <code>&#123;r, c&#125;</code> push 到 <code>q</code> 時將 <code>grid[r][c]</code> 設為 <code>0</code>, 則 <code>grid[1][1]</code> 只會被 <code>grid[1][0]</code> 拜訪。因為在 <code>grid[0][1]</code> 的 for loop 中 <code>if (grid[1][1] == &#39;1&#39;)</code> 不會成立, 因為 <code>grid[1][1]</code> 已經在 <code>grid[1][0]</code> 的 for loop 中被設成 <code>0</code></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, i, j);</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    vector&lt;pii&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(pii&#123;i, j&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [row, col] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> r = row + dirY, c = col + dirX;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">outOfBound</span>(r, c) &amp;&amp; grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(pii&#123;r, c&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(min(m, n))$ ➔ worse case：全部都是陸地, 則 <code>q</code> 的長度最多為 <code>min(m, n)</code>, 也就是圖中線的最大長度</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Union Find + Path Compression, 將所有的連在一起的 <code>1</code> 的位置歸到一個 <code>root</code>, 最後有多少個 <code>root</code> 就有多少個島嶼。值得注意的是, 與 DFS 或者 BFS 的方法不同的是, 不需要搜索四個方向, 只需要看兩個方向（右、下）即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        parents.<span class="built_in">resize</span>(m * n, <span class="number">0</span>);</span><br><span class="line">        ranks.<span class="built_in">resize</span>(m * n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 parents, 每個 node 指向自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; ++i) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> r = i + dirY, c = j + dirX;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// (i, j) 和 (r, c) 做 union</span></span><br><span class="line">                        <span class="keyword">if</span> (!<span class="built_in">outOfBound</span>(r, c) &amp;&amp; grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            <span class="built_in">union_</span>(i * n + j, r * n + c, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parents, ranks;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n1, <span class="type">const</span> <span class="type">int</span> n2, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(n1); <span class="comment">// root of n1</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(n2); <span class="comment">// root of n2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 n1, n2 是同個 set, 則不做任何事</span></span><br><span class="line">        <span class="keyword">if</span> (r1 == r2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// n1, n2 是不同 set, 則兩個 set 合併成一個 set</span></span><br><span class="line">        <span class="comment">// 深度低的 tree root 把深度高的 tree root 作為 parent</span></span><br><span class="line">        <span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[r1] &lt; ranks[r2]) &#123;</span><br><span class="line">            parents[r1] = r2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若深度一樣, 可以任意選擇一個 root 作為 parent</span></span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">            ++ranks[r1]; <span class="comment">// 作為 parent 的 node 之 rank 值會加一, 因為深度變了</span></span><br><span class="line">        &#125;</span><br><span class="line">        --res; <span class="comment">// 合併後, set 數 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]]; <span class="comment">// path compression</span></span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>parent</code>, <code>ranks</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>133. Clone Graph</title>
      <link href="/post/clone-graph/"/>
      <url>/post/clone-graph/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/clone-graph/">https://leetcode.cn/problems/clone-graph/</a></strong></p><p><strong>題意：</strong>給一無向連通圖的 node, 請返回該圖的 copy。</p><p>圖中每個 node 都包含它的 <code>val</code> (int) 和其 <code>neighbors</code> (list[node])</p><p><img src="https://i.imgur.com/SX9Lom7.png"></p></blockquote><p><img src="https://i.imgur.com/e2OGv2r.png"></p><p><img src="https://i.imgur.com/64YLSCn.png"></p><p><img src="https://i.imgur.com/FP1rkWQ.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited; <span class="comment">// &#123;old : new&#125;, 用來記錄已生成的 node</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若 node 已經生成過, 則返回其 copy</span></span><br><span class="line">        <span class="keyword">if</span> (visited.<span class="built_in">find</span>(node) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> visited[node];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成當前 node</span></span><br><span class="line">        Node* copy = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        visited[node] = copy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加當前 node 的 neighbors</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; neighbor : node-&gt;neighbors) &#123;</span><br><span class="line">            copy-&gt;neighbors.<span class="built_in">emplace_back</span>(<span class="built_in">dfs</span>(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V+E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V)$ ➔ <code>oldToNew</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; visited; <span class="comment">// &#123;old : new&#125;, 用來記錄已生成的 node</span></span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(node);</span><br><span class="line">        visited[node] = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node* n = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; neighbor : n-&gt;neighbors) &#123;</span><br><span class="line">                <span class="comment">// 如果 neighbor 還沒被拜訪過</span></span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">find</span>(neighbor) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="keyword">new</span> <span class="built_in">Node</span>(neighbor-&gt;val); <span class="comment">// 生成該 node</span></span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor); <span class="comment">// 加到 queue 中</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 更新當前 node 的 neighbors</span></span><br><span class="line">                visited[n]-&gt;neighbors.<span class="built_in">emplace_back</span>(visited[neighbor]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V+E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V)$ ➔ <code>visited</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>695. Max Area of Island</title>
      <link href="/post/max-area-of-island/"/>
      <url>/post/max-area-of-island/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/max-area-of-island/">https://leetcode.cn/problems/max-area-of-island/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的矩陣 <code>grid</code>。</p><p><strong>島嶼</strong>是由一些相鄰的 <code>1</code> （代表土地）所構成的組合, 這里的「相鄰」要求兩個 <code>1</code> 必須在<strong>水平 or 垂直</strong>的四個方向上相鄰。</p><p>假設 <code>grid</code> 的邊界都被 <code>0</code>（代表水）包圍著。</p><p>返回 <code>grid</code> 中最大的島嶼面積。如果沒有島嶼, 則返回 <code>0</code>。</p></blockquote><p><img src="https://i.imgur.com/7InE5Cq.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 以每一個 <code>grid[i][j]</code> 作為起點做 DFS 計算 area, 一旦拜訪過, 就將 <code>grid[i][j]</code> 設為 <code>0</code>, 避免遞迴遍歷時 area 重複計算</strong></p><ul><li>若 <code>grid[i][j] == 1</code> : <code>area++</code>, 並遞迴遍歷四個方向</li><li>若 <code>grid[i][j] == 0</code> : 直接返回</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(grid, i, j, area);</span><br><span class="line">                res = <span class="built_in">max</span>(res, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, <span class="type">int</span>&amp; area)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">outOfBound</span>(i, j) || grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 設為已拜訪, 避免重覆計算到 area</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        ++area;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r = i + dirY, c = j + dirX;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, r, c, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>grid</code>, 且每個 cell 最多被拜訪一次</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ 取決於遞迴深度, worse case：整個 <code>grid</code> 都是 <code>1</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>417. Pacific Atlantic Water Flow</title>
      <link href="/post/pacific-atlantic-water-flow/"/>
      <url>/post/pacific-atlantic-water-flow/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">https://leetcode.cn/problems/pacific-atlantic-water-flow/</a></strong></p><p><strong>題意：</strong>今有一 <code>m x n</code> 矩形島嶼, 與<strong>太平洋</strong>和<strong>大西洋</strong>相鄰。</p><ul><li>太平洋位於島嶼的左邊界和上邊界</li><li>大西洋位於島嶼的右邊界和下邊界</li></ul><p>給一 <code>m x n</code> 整數 array <code>heights</code>, 其中 <code>heights[r][c]</code> 代表座標 <code>(r, c)</code> <strong>高於海平面的高度</strong></p><p>相鄰 cell 的高度 <strong>小於或等於</strong> 目前 cell 的高度, 則雨水可以直接流向相鄰 cell</p><p>求哪些位置的雨水能同時流進太平洋和大西洋？</p></blockquote><p><img src="https://i.imgur.com/MeL335x.png"></p><p><img src="https://i.imgur.com/XcJyHJQ.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS, 從邊界開始往內陸行進, 若高度越來越高則代表水可往邊界流, 藉此可找到抵達太平洋和大西洋的兩個集合, 然後取交集</strong></p><ul><li><strong>最左和最上的邊界一定能抵達太平洋（由這兩邊界向內延伸）</strong></li><li><strong>最右和最下的邊界一定能抵達大西洋（由這兩邊界向內延伸）</strong></li></ul><p><img src="https://i.imgur.com/pemKCwI.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        m = heights.<span class="built_in">size</span>(), n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">pac</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">atl</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(heights, i, <span class="number">0</span>, pac); <span class="comment">// left</span></span><br><span class="line">            <span class="built_in">bfs</span>(heights, i, n - <span class="number">1</span>, atl); <span class="comment">// right</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(heights, <span class="number">0</span>, j, pac); <span class="comment">// top</span></span><br><span class="line">            <span class="built_in">bfs</span>(heights, m - <span class="number">1</span>, j, atl); <span class="comment">// bottom</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pac[i][j] &amp;&amp; atl[i][j]) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    vector&lt;pii&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; h, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(pii&#123;i, j&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [y, x] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visited[y][x]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[y][x] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> r = y + dirY, c = x + dirX;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">outOfBound</span>(r, c) &amp;&amp; h[y][x] &lt;= h[r][c] &amp;&amp; !visited[r][c]) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(pii&#123;r, c&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r == m || c &lt; <span class="number">0</span> || c == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 每個 node 最多被訪問四次（來自上下左右的鄰居）</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>pac</code>, <code>atl</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 想法同 Solution 1</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        m = heights.<span class="built_in">size</span>(), n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">pac</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">atl</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(heights, i, <span class="number">0</span>, pac); <span class="comment">// left</span></span><br><span class="line">            <span class="built_in">bfs</span>(heights, i, n - <span class="number">1</span>, atl); <span class="comment">// right</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(heights, <span class="number">0</span>, j, pac); <span class="comment">// top</span></span><br><span class="line">            <span class="built_in">bfs</span>(heights, m - <span class="number">1</span>, j, atl); <span class="comment">// bottom</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pac[i][j] &amp;&amp; atl[i][j]) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    vector&lt;pii&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; h, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(pii&#123;i, j&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [y, x] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">outOfBound</span>(y, x) || visited[y][x]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[y][x] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> r = y + dirY, c = x + dirX;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">outOfBound</span>(r, c) &amp;&amp; h[y][x] &lt;= h[r][c]) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(pii&#123;r, c&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r == m || c &lt; <span class="number">0</span> || c == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 每個 node 最多被訪問四次（來自上下左右的鄰居）</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>pac</code>, <code>atl</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>130. Surrounded Regions</title>
      <link href="/post/surrounded-regions/"/>
      <url>/post/surrounded-regions/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/surrounded-regions/">https://leetcode.cn/problems/surrounded-regions/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的矩陣 <code>board</code>, 由若干個 char <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>, 找到所有被 <code>&#39;X&#39;</code> 圍繞的區域, 並用 <code>&#39;X&#39;</code> 來替代這些區域裡的 <code>&#39;O&#39;</code>。</p></blockquote><p><img src="https://i.imgur.com/h78wviU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 題目希望我們找出被 <code>X</code> 包圍的區域, 但我們可以反向思考, 從邊界出發（因為邊界上的 <code>O</code> 一定不會被 <code>X</code> 包圍）, 往內陸延伸找出那些沒有被 <code>X</code> 包圍的區域, 概念同</strong> <a href="https://zako945.github.io/post/pacific-atlantic-water-flow/">417. Pacific Atlantic Water Flow</a><strong>。因此步驟如下：</strong></p><ul><li>找出沒有被 <code>X</code> 包圍的 <code>O</code> 區域, 並把這些區域設為 <code>#</code>（區分是否被 <code>X</code> 包圍）</li><li>遍歷 <code>board</code>, 將 <code>O</code> 設為 <code>X</code>（因為沒被設為 <code>#</code> 的區域就是被 <code>X</code> 包圍的 <code>O</code> 區域）</li><li>遍歷 <code>board</code>, 將 <code>#</code> 設為 <code>O</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(board, i, <span class="number">0</span>); <span class="comment">// left</span></span><br><span class="line">            <span class="built_in">dfs</span>(board, i, n - <span class="number">1</span>); <span class="comment">// right</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(board, <span class="number">0</span>, j); <span class="comment">// top</span></span><br><span class="line">            <span class="built_in">dfs</span>(board, m - <span class="number">1</span>, j); <span class="comment">// bottom</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">replace</span>(board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">outOfBound</span>(i, j) || board[i][j] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// 將沒有被 X 包圍的 O 設成 #</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(board, i + dirY, j + dirX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先將被包圍的 O 設成 X</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再將沒被包圍的 # 設成 O</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：$O(m \cdot n)$</strong> ➔ 遍歷 <code>board</code></li><li><strong>space：$O(m \cdot n)$</strong> ➔ 取決於遞迴深度, worse case：整個 <code>board</code> 皆為 <code>&#39;O&#39;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>994. Rotting Oranges</title>
      <link href="/post/rotting-oranges/"/>
      <url>/post/rotting-oranges/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/rotting-oranges/">https://leetcode.cn/problems/rotting-oranges/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的網格 <code>grid</code>, 其中每個 cell 有三種可能：</p><ul><li><code>0</code> 代表沒橘子</li><li><code>1</code> 代表新鮮橘子</li><li><code>2</code> 代表腐爛的橘子</li></ul><p>每分鐘, 腐爛的橘子<strong>周圍 <code>4</code> 個方向</strong>上相鄰的新鮮橘子都會腐爛。</p><p>返回 <code>grid</code> 中沒有新鮮橘子所必須經過的最短時間。如果不可能, 則返回 <code>-1</code> 。</p></blockquote><p><img src="https://i.imgur.com/8cPRq6f.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS, 因為 <code>grid</code> 一開始可能有多顆腐爛的橘子</strong></p><p><img src="https://i.imgur.com/1PhPxVa.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, fresh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ++fresh;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(pii&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bfs</span>(grid, res, fresh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    vector&lt;pii&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span>&amp; res, <span class="type">int</span>&amp; fresh)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一旦沒有新鮮的橘子即可退出</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; fresh &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [y, x] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> r = y + dirY, c = x + dirX;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">outOfBound</span>(r, c) &amp;&amp; grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                        --fresh;</span><br><span class="line">                        grid[r][c] = <span class="number">2</span>;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(pii&#123;r, c&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>grid</code></li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>q</code> 中的元素個數不超過 <code>m * n</code>, worse case：<code>grid</code> 元素皆為 2</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>286. Walls and Gates</title>
      <link href="/post/walls-and-gates/"/>
      <url>/post/walls-and-gates/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/walls-and-gates/">https://leetcode.cn/problems/walls-and-gates/</a></strong></p><p><strong>題意：</strong>給一 <code>m × n</code> 的網格 <code>rooms</code>, 其中每個 cell 有三種可能：</p><ul><li><code>1</code> 表示牆 or 障礙物</li><li><code>0</code> 表示門</li><li><code>INF</code> 表示空房間。用 <code>2^31 - 1 = 2147483647</code> 代表 <code>INF</code>。<br>且通往門的距離總是小於 <code>2147483647</code></li></ul><p>返回每個空房間位到<strong>最近門的距離</strong>。如果無法到達門, 則距離設為 <code>INF</code>。</p></blockquote><p><img src="https://i.imgur.com/IhxF72p.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS（因為可能不只一個門）, 以門為起點向外做 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wallsAndGates</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        m = rooms.<span class="built_in">size</span>(), n = rooms[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dist = <span class="number">1</span>; <span class="comment">// 房間離門的最小距離為 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(pii&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bfs</span>(rooms, dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    vector&lt;pii&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms, <span class="type">int</span>&amp; dist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [y, x] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> r = y + dirY, c = x + dirX;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">outOfBound</span>(r, c) &amp;&amp; rooms[r][c] == INT_MAX) &#123;</span><br><span class="line">                        rooms[r][c] = dist;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(pii&#123;r, c&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outOfBound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>space：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>rooms</code></li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>q</code> 中元素個數不超過 <code>m * n</code>, worse case：<code>rooms</code> 元素皆為 0</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>207. Course Schedule</title>
      <link href="/post/course-schedule/"/>
      <url>/post/course-schedule/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/</a></strong></p><p><strong>題意：</strong>你這學期必須選修 <code>numCourses</code> 門課程, 標記為 <code>0</code> 到 <code>numCourses - 1</code>。</p><p>在修習某些課程前需要一些先修課程 <code>prerequisites</code>, 其中 <code>prerequisites[i] = [a_i, b_i]</code>, 表示要修 <code>a_i</code> 前必須先修 <code>b_i</code>。</p><ul><li>e.g. <code>[0, 1]</code> 表示想要修課程 <code>0</code>, 需要先完成課程 <code>1</code>。</li></ul><p>返回是否能完成所有課程。</p></blockquote><p><img src="https://i.imgur.com/876CO4y.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + BFS, 依序取出 <code>inDegree = 0</code> 之 node</strong></p><p>在 BFS 中, <code>[0, 1]</code> 表示想要修課程 <code>0</code>, 需要先完成課程 <code>1</code>。<br>用圖表示為 <strong><code>1</code> 指向 <code>0</code><strong>（</strong>方向跟 DFS 相反</strong>）, 這樣 <code>1</code> 的 <code>inDegree = 0</code>, 才會優先被執行</p><p><img src="https://i.imgur.com/joTEmA8.png"></p><ul><li>首先將 <code>inDegree = 0</code> 的 node（不需要任何先修課程的課）加入到 queue 中</li><li>BFS<ul><li>取出 <code>queue.front()</code> 後, 將其相鄰 node 的 <code>inDegree - 1</code></li><li>若相鄰 node 之 <code>inDegree - 1</code> 後為 <code>0</code>, 則將該 node push 到 queue 中</li></ul></li><li><strong>特殊情況：若 Graph 有 cycle</strong><ul><li><p>不會有任何 node 加入到 queue 中（所有 node 之 inDegree 皆不為 0）, 故要用一變數 <code>visited</code> 紀錄 <code>inDegree = 0</code> 的個數</p></li><li><p>當 queue 取出 front 時 <code>visited + 1</code>, 因為 queue 中的 node 一定是 <code>inDegree = 0</code> 的 node</p></li><li><p>最後判斷 <code>visited</code> 是否等於 <code>numCourses</code></p><p>  <img src="https://i.imgur.com/iN4nJqM.png"></p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個 node 的 in degree</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(numCourses); <span class="comment">// adjacent list</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : prerequisites) &#123;</span><br><span class="line">            adj[p[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(p[<span class="number">0</span>]);</span><br><span class="line">            inDegree[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先將 in degree = 0 的 node 加入到 queue 中</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            ++visited;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將其 adjacent node 的 in degree - 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n + m)$ ➔ <code>n</code> 為課程數(vertex), <code>m</code> 為先修課程數(edge)。其實就是對圖進行 BFS 所需之時間複雜度 $O(V+E)$</li><li><strong>space：</strong>$O(n + m)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + DFS, 其實本題就是在問有向圖中是否有 cycle。此外也要考慮存在 isolated node 的情況（也就是 Graph 非 connected, 如下圖中的 3）</strong></p><p>e.g. 下圖中 <code>(0, 1, 5)</code> 為 cycle, 故返回 false</p><p><img src="https://i.imgur.com/Oa6kJ2h.png"></p><p>在 DFS 中, <code>[0, 1]</code> 表示想要修課程 <code>0</code>, 需要先完成課程 <code>1</code>。用圖表示為 <strong><code>0</code> 指向 <code>1</code></strong></p><p><img src="https://i.imgur.com/vFPkwm7.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(numCourses); <span class="comment">// adjacency list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pre : prerequisites) &#123;</span><br><span class="line">            adj[pre[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(pre[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0: 未搜索, 1: 搜索中, 2: 已搜索</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">states</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123; <span class="comment">// 讓 isolated node 也能被搜索</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(i, states, adj)) &#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 返回 true 代表有 cycle</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; states, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 當前 node 狀態為搜索中, 代表有 cycle</span></span><br><span class="line">        <span class="keyword">if</span> (states[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當前 node 狀態為已搜索, 代表沒 cycle</span></span><br><span class="line">        <span class="keyword">if</span> (states[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        states[i] = <span class="number">1</span>; <span class="comment">// 若為未搜索, 將其設為搜索中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// dfs 遍歷其 adjacent node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(v, states, adj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        states[i] = <span class="number">2</span>; <span class="comment">// 設為已完成</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n + m)$ ➔ <code>n</code> 為課程數(vertex), <code>m</code> 為先修課程數(edge)。其實就是對圖進行 DFS 所需之時間複雜度 $O(V+E)$</li><li><strong>space：</strong>$O(n + m)$ ➔ 因為 <code>adj</code> 為 $O(V+E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>210. Course Schedule II</title>
      <link href="/post/course-schedule-ii/"/>
      <url>/post/course-schedule-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/course-schedule-ii/">https://leetcode.cn/problems/course-schedule-ii/</a></strong></p><p><strong>題意：</strong>你這學期必須選修 <code>numCourses</code> 門課程, 標記為 <code>0</code> 到 <code>numCourses - 1</code>。</p><p>在修習某些課程前需要一些先修課程 <code>prerequisites</code>, 其中 <code>prerequisites[i] = [a_i, b_i]</code>, 表示要修 <code>a_i</code> 前必須先修 <code>b_i</code>。</p><ul><li>e.g. <code>[0, 1]</code> 表示想要修課程 <code>0</code>, 需要先完成課程 <code>1</code>。</li></ul><p>返回能夠學習完所有可成的學習順序。可能會有很多種正確的順序, 只要返回其中一種就行。若不可能完成所有課程, 則返回空 list。</p></blockquote><p><img src="https://i.imgur.com/5yuYO2q.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + BFS, 同 <a href="https://zako945.github.io/post/course-schedule/">207. Course Schedule</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個 node 的 in degree</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(numCourses); <span class="comment">// adjacent list</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pre : prerequisites) &#123;</span><br><span class="line">            adj[pre[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(pre[<span class="number">0</span>]);</span><br><span class="line">            ++inDegree[pre[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先將 in degree = 0 的 node 加入到 queue 中</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123; </span><br><span class="line">                q.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將其 adjacent node 的 in degree - 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res.<span class="built_in">size</span>() == numCourses) ? res : <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n + m)$ ➔ <code>n</code> 為課程數(vertex), <code>m</code> 為先修課程數(edge)。其實就是對圖進行 BFS 所需之時間複雜度 $O(V+E)$</li><li><strong>space：</strong>$O(n + m)$ ➔ 因為 <code>adj</code> 為 $O(V+E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用  Topological Sort + DFS, 同</strong> <a href="https://zako945.github.io/post/course-schedule/">207. Course Schedule</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(numCourses); <span class="comment">// adjacency list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pre : prerequisites) &#123;</span><br><span class="line">            adj[pre[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(pre[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0: 未搜索, 1: 搜索中, 2: 已搜索</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">states</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(i, states, adj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 true 代表有 cycle</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; states, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 當前 node 狀態為搜索中, 代表有 cycle</span></span><br><span class="line">        <span class="keyword">if</span> (states[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當前 node 狀態為已搜索, 代表沒 cycle</span></span><br><span class="line">        <span class="keyword">if</span> (states[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        states[i] = <span class="number">1</span>; <span class="comment">// 若為未搜索, 將其設為搜索中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// dfs 遍歷其 adjacent node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(v, states, adj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        states[i] = <span class="number">2</span>; <span class="comment">// 設為已完成</span></span><br><span class="line">        res.<span class="built_in">emplace_back</span>(i); <span class="comment">// push 到 order list 中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n + m)$ ➔ <code>n</code> 為課程數(vertex), <code>m</code> 為先修課程數(edge)。其實就是對圖進行 DFS 所需之時間複雜度 $O(V+E)$</li><li><strong>space：</strong>$O(n + m)$ ➔ 因為 <code>adj</code> 為 $O(V+E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>684. Redundant Connection</title>
      <link href="/post/redundant-connection/"/>
      <url>/post/redundant-connection/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/redundant-connection/">https://leetcode.cn/problems/redundant-connection/</a></strong></p><p><strong>題意：</strong>給一 <code>n</code> 個 node 的 tree（編號從 <code>1</code> 到 <code>n</code>）, 並在其中添加一條邊。添加的邊其兩個頂點包含在 <code>1</code> 到 <code>n</code> 中間, 且這條邊不屬於 tree 中已存在的邊。<code>edges[i] = [a, b]</code> 表示圖中 <code>a</code> 和 <code>b</code> 之間存在一條邊。</p><p>找出一條可以刪去的邊, 刪除後可使得剩餘部分為 tree。如果有多個答案, 則返回這些答案在 <code>edges</code> 中順序最後的那條邊。</p></blockquote><p><img src="https://i.imgur.com/SBu9b3T.png"></p><p><img src="https://i.imgur.com/6He3AY4.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：同 <a href="https://zako945.github.io/post/graph-valid-tree/">261. Graph Valid Tree</a>, 利用 DFS, 每次加入一條 edge <code>e</code>, 就檢查是否有 cycle, 一旦發現了 cycle, 就返回 <code>e</code>（最後加入形成 cycle 的 edge）</strong></p><ul><li>令 <code>e</code> 的兩端點分別為 <code>u</code>、<code>v</code>, 檢查是否已經有 path 能連接 <code>u</code>、<code>v</code>。若有, 則代表加入 <code>e</code> 後會形成 cycle</li><li>由於為<strong>無向圖</strong>, 所以遞迴遍歷時需要用 <code>visited</code> 紀錄哪些 node 已經拜訪過, 一旦拜訪過就不再遞迴遍歷。假設 edge <code>e = [u,v]</code>, 則 <code>u</code>、<code>v</code> 之間並無 cycle, 若不用 <code>visited</code> 紀錄, 則會發生 <code>u -&gt; v</code>、<code>v -&gt; u</code>, 因而得出 <code>u</code>、<code>v</code> 之間存在 cycle 的錯誤判斷。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">hasPath</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], visited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加入 e</span></span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; adj; <span class="comment">// adjacent list</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 cur 能走到 goal, 則返回 true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(<span class="type">const</span> <span class="type">int</span> cur, <span class="type">const</span> <span class="type">int</span> goal, unordered_set&lt;<span class="type">int</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == goal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited.<span class="built_in">emplace</span>(cur);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其中一個點不在 adj 中, 則一定找不到 path 連接兩點</span></span><br><span class="line">        <span class="keyword">if</span> (adj.<span class="built_in">find</span>(cur) == adj.<span class="built_in">end</span>() || adj.<span class="built_in">find</span>(goal) == adj.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; next : adj[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(next) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 已經拜訪過則跳過</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">hasPath</span>(next, goal, visited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 其中 <code>n</code> 代表 edge、node 數<ul><li>$O(n^2)$：worse case 對於每次新增的 edge <code>e</code>, 必須搜索圖中之前出現的每條 edge<br>  ➔ $1 + 2 + … + n$ &#x3D; $\dfrac{(n + 1) \cdot n}{2}$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>adj</code> 的 avg case 為 $O(V + E)$, 本題的 <code>V</code>、<code>E</code> 皆為 <code>n</code>（因為是 tree + 1 edge）</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 <a href="https://zako945.github.io/post/graph-valid-tree/">261. Graph Valid Tree</a>, 利用 Union Find + Path Compression, 用 Union Find 合併每條邊的兩個 node 時, 如果這兩個 node 已經在同一 set 中, 則存在 cycle</strong></p><p>e.g. <code>edges = [[1,2], [1,3], [2,3]]</code></p><p><img src="https://i.imgur.com/j0HG1wZ.png"></p><ul><li>當完成 <code>[1,2]</code> 和 <code>[1,3]</code> 時, <code>parents[2] = 1 = parent[3]</code></li><li>然後執行 <code>[2,3]</code> 時, 因為 <code>parents[2] == parents[3]</code> 代表有 cycle</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parents</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個點的 parent</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ranks</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 紀錄每個點的 rank</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每個點的 parent 都初始成自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(parents, e[<span class="number">0</span>]); <span class="comment">// root of a</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(parents, e[<span class="number">1</span>]); <span class="comment">// root of b</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// a, b 已經是同個 set, 則代表加入 e 後會形成 cycle</span></span><br><span class="line">            <span class="keyword">if</span> (r1 == r2) &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a, b 是不同 set, 則兩個 set 合併成一個 set</span></span><br><span class="line">            <span class="built_in">union_</span>(parents, ranks, r1, r2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]];</span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">int</span>&amp; r1, <span class="type">int</span>&amp; r2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 深度低的 tree root 把深度高的 tree root 作為 parent</span></span><br><span class="line">        <span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[r1] &lt; ranks[r2]) &#123;</span><br><span class="line">            parents[r1] = r2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若深度一樣, 可以任意選擇一個 root 作為 parent</span></span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">            ++ranks[r1]; <span class="comment">// 作為 parent 的 node 之 rank 值會加一, 因為深度變了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷每個 node 初始化 <code>parents</code>, 以及遍歷每條 edge 做 union find, 而 edge 的兩端點做 <code>find()</code> 皆只需 $O(1)$, 其中 node、edge 數皆為 <code>n</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>parent</code>, <code>ranks</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>323. Number of Connected Components in an Undirected Graph</title>
      <link href="/post/number-of-connected-components-in-an-undirected-graph/"/>
      <url>/post/number-of-connected-components-in-an-undirected-graph/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/">https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/</a></strong></p><p><strong>題意：</strong>有一含 <code>n</code> 個 node 的 graph, 給你一整數 <code>n</code> 和 <code>edges</code>, 其中 <code>edges[i] = [a, b]</code> 代表 graph 中 <code>a</code> 和 <code>b</code> 之間有一邊, 返回 connected component 個數。</p></blockquote><p><img src="https://i.imgur.com/6FgGu4s.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS, 依序對所有 node 做 dfs, 每次判斷該 node 是否被拜訪過, 若還沒代表有新的 component</strong></p><p>e.g. <code>n = 5</code>, <code>edges = [[0, 1], [1, 2], [3, 4]]</code></p><ul><li><p>先對 <code>0</code> 做 dfs 得到第一個 <code>component(0,1,2)</code>, 同時 <code>visited[0,1,2]</code> 都被設為 <code>true</code></p></li><li><p>因為 <code>visited[3] = false</code>, 所以對 <code>3</code> 做 dfs 得到第二個 <code>component(3,4)</code></p><p>  <img src="https://i.imgur.com/lQHOPPC.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countComponents</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                <span class="built_in">dfs</span>(adj, visited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, vector&lt;<span class="type">bool</span>&gt;&amp; visited, <span class="type">int</span>&amp; cur)</span></span>&#123;</span><br><span class="line">        visited[cur] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(adj, visited, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V + E)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 道理同 DFS, 依序對所有 node 做 bfs, 每次判斷該 node 是否被拜訪過, 若還沒代表有新的 component</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countComponents</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                <span class="built_in">bfs</span>(adj, visited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, vector&lt;<span class="type">int</span>&gt;&amp; visited, <span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">        <span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(&#123;i&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                visited[cur] = <span class="literal">true</span>; <span class="comment">// 將 cur 設為已拜訪</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(v); <span class="comment">// 將未拜訪的相鄰點加到 queue 中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V + E)$ ➔ <code>adj</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Union Find + Path Compression</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countComponents</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parents</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個點的 parent</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ranks</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// 紀錄每個點的 rank</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每個點的 parent 都初始成自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = n; <span class="comment">// 一開始令每個 node 都自己一個 set, 然後才開始合併</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(parents, e[<span class="number">0</span>]); <span class="comment">// root of a</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(parents, e[<span class="number">1</span>]); <span class="comment">// root of b</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 a, b 是同個 set, 則不做任何事</span></span><br><span class="line">            <span class="keyword">if</span> (r1 == r2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a, b 是不同 set, 則兩個 set 合併成一個 set</span></span><br><span class="line">            <span class="built_in">union_</span>(parents, ranks, r1, r2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">const</span> <span class="type">int</span> r1, <span class="type">const</span> <span class="type">int</span> r2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 深度低的 tree root 把深度高的 tree root 作為 parent</span></span><br><span class="line">        <span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[r1] &lt; ranks[r2]) &#123;</span><br><span class="line">            parents[r1] = r2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若深度一樣, 可以任意選擇一個 root 作為 parent</span></span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">            ++ranks[r1]; <span class="comment">// 作為 parent 的 node 之 rank 值會加一, 因為深度變了</span></span><br><span class="line">        &#125;</span><br><span class="line">        --res; <span class="comment">// 合併後, set 數 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]]; <span class="comment">// path compression</span></span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 遍歷每個 node 初始化 <code>parents</code>, 以及遍歷每條 edge 做 union find, 其中 edge 的兩端點做 <code>find()</code> 皆只需 $O(1)$</li><li><strong>space：</strong>$O(n)$ ➔ <code>parents</code> , <code>ranks</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>261. Graph Valid Tree</title>
      <link href="/post/graph-valid-tree/"/>
      <url>/post/graph-valid-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/graph-valid-tree/">https://leetcode.cn/problems/graph-valid-tree/</a></strong></p><p><strong>題意：</strong>給定編號 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 個 node, 和一個<strong>無向邊</strong>的 list <code>edges</code>, 其中 <code>edges[i] = [a, b]</code> 代表 graph 中 <code>a</code> 和 <code>b</code> 之間有一邊, 返回此 graph 是否為 tree。</p><p><strong>注意：</strong><code>edges</code> 中沒有重複的邊（e.g. <code>[1, 0]</code> 和 <code>[0, 1]</code> 不會同時出現在 <code>edges</code> 中）</p></blockquote><p><img src="https://i.imgur.com/JRd3uYU.png"></p><p><img src="https://i.imgur.com/lkjc6oP.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS, 若 graph 要為 tree, 則必須滿足以下兩點：</strong></p><ul><li><strong>graph 中不可有 cycle</strong></li><li><strong>graph 必須為 connected, 也就是圖中任兩點必定有邊相連, 不能有 isolated vertex</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n); <span class="comment">// adjacent list</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs 起始點為 0, 令 0 的前一個 node 設為 -1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(adj, visited, <span class="number">0</span>, <span class="number">-1</span>) &amp;&amp; <span class="built_in">connected</span>(visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若無 cycle, 則 dfs 會 return true; 否則 return false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, vector&lt;<span class="type">bool</span>&gt;&amp; visited, <span class="type">int</span> cur, <span class="type">int</span> prev)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若有 node 被重複拜訪, 代表有 cycle</span></span><br><span class="line">        <span class="keyword">if</span> (visited[cur]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[cur] = <span class="literal">true</span>; <span class="comment">// 將 cur 設為已拜訪</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123; <span class="comment">// dfs 拜訪 adjacent node</span></span><br><span class="line">            <span class="comment">// 若 v 為前一個 node, 則不進行 dfs</span></span><br><span class="line">            <span class="keyword">if</span> (v != prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">dfs</span>(adj, visited, v, cur)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有 cycle</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判斷圖中所有點是否都有被拜訪到</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : visited) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有點沒被拜訪到</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V + E)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(&#123;<span class="number">0</span>&#125;)</span></span>; <span class="comment">// 初始點設為 0</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(&#123;<span class="number">0</span>&#125;)</span></span>; <span class="comment">// 初始點設為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                    <span class="comment">// 若 v 已被拜訪代表有 cycle, 返回 false</span></span><br><span class="line">                    <span class="keyword">if</span> (visited.<span class="built_in">find</span>(v) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    visited.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    adj[v].<span class="built_in">erase</span>(cur); <span class="comment">// 避免等下拜訪 v 時重複拜訪 cur</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.<span class="built_in">size</span>() == n; <span class="comment">// 判斷是否所有點都被拜訪到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V + E)$ ➔ <code>adj</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Union Find + Path Compression, 用 Union Find 合併每條邊的兩個 node 時, 如果這兩個 node 已經在同一 set 中, 則存在 cycle</strong></p><p>e.g. <code>edges = [[1,2], [1, 3], [2, 3]]</code></p><p><img src="https://i.imgur.com/j0HG1wZ.png"></p><ul><li>當完成 <code>[1, 2]</code> 和 <code>[1, 3]</code> 時, <code>parents[2] = 1 = parents[3]</code></li><li>然後執行 <code>[2, 3]</code> 時, 因為 <code>parents[2] == parents[3]</code> 代表有 cycle</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parents</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個點的 parent</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ranks</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// 紀錄每個點的 rank</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每個點的 parent 都初始成自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = n; <span class="comment">// 一開始令每個 node 都自己一個 set, 然後才開始合併</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(parents, e[<span class="number">0</span>]); <span class="comment">// root of a</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(parents, e[<span class="number">1</span>]); <span class="comment">// root of b</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// a, b 已經是同個 set, 則代表加入 e 後會形成 cycle</span></span><br><span class="line">            <span class="keyword">if</span> (r1 == r2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a, b 是不同 set, 則兩個 set 合併成一個 set</span></span><br><span class="line">            <span class="built_in">union_</span>(parents, ranks, r1, r2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">1</span>; <span class="comment">// 合併到最後只剩下一個 set, 代表所有 node 皆 connected</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">const</span> <span class="type">int</span> r1, <span class="type">const</span> <span class="type">int</span> r2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[r2] &gt; ranks[r1]) &#123;</span><br><span class="line">            parents[r1] = r2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">            ranks[r1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        --res; <span class="comment">// 合併後, set 數 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]]; <span class="comment">// path compression</span></span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 遍歷每個 node 初始化 <code>parents</code>, 以及遍歷每條 edge 做 union find, 其中 edge 的兩端點做 <code>find()</code> 皆只需 $O(1)$</li><li><strong>space：</strong>$O(n)$ ➔ <code>parents</code>, <code>ranks</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33. Search in Rotated Sorted Array</title>
      <link href="/post/search-in-rotated-sorted-array/"/>
      <url>/post/search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">https://leetcode.cn/problems/search-in-rotated-sorted-array/</a></strong></p><p><strong>題意</strong>: 有一整數 array <code>nums</code> 按升序排列, 其中的值<strong>互不相同</strong>。</p><p>給一<strong>旋轉後</strong>的 array <code>nums</code> 和一整數 <code>target</code>, 如果 <code>nums</code> 中存在 <code>target</code>, 則返回其 index; 否則, 返回 <code>-1</code>。</p><p>請設計 $O(log(n))$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/oxWfuYg.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 將 <code>nums</code> 從中間分開成左右兩部分的時候, 一定有一部分是有序的。</strong></p><p><strong>e.g. <code>nums = [4,5,6,7,0,1,2]</code>, 從 <code>6</code> 切割, 可分成 <code>[4,5,6]</code> 和 <code>[7,0,1,2]</code> 兩個部分, 其中左邊 <code>[4,5,6]</code> 是有序的</strong></p><p>因此我們可以在 Binary Search 時查看當前 <code>mid</code> 分割的兩個部分 <code>[left, mid]</code> 和 <code>[mid + 1, right]</code> 中哪個是有序的, 藉此來縮小左邊界 or 右邊界。</p><ul><li>若 <code>target == nums[mid]</code>, 則直接返回 <code>mid</code></li><li>若 <code>[left, mid]</code> 是有序的, 且 <code>target</code> 界於 <strong><code>[nums[left], nums[mid])</code></strong> 間, 則縮小搜索範圍為 <code>[left, mid - 1]</code>; 否則, 縮小搜索範圍為 <code>[mid + 1, right]</code></li><li>若 <code>[mid + 1, right]</code> 是有序的, 且 <code>target</code> 界於 <strong><code>(nums[mid], nums[right]]</code></strong> 間, 則縮小搜索範圍為 <code>[mid + 1, right]</code>; 否則, 縮小搜索範圍為 <code>[left, mid - 1]</code></li></ul><p>當 <code>[left, mid]</code> 區間恰好只有一個元素時, 也滿足左半邊已排序的定義</p><p>e.g. <code>nums = [3, 1]</code>, <code>target = 1</code></p><ul><li><code>left = 0</code>, <code>right = 1</code>, <code>mid = 0</code> ➔ <code>[left, mid]</code> 區間恰好只有一個元素, 使得 <code>nums[left] == nums[mid]</code>, 這時 <code>target</code> 應跟左半邊中的元素比較, 然後才縮小邊界</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 這種特殊的 Binary Search 建議搜到就返回</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左半邊是被排序過的, e.g. [4,5,6,7,0,1,2], mid = 7</span></span><br><span class="line">            <span class="comment">// nums[left] == nums[mid] 也滿足左半邊是排序的定義（有可能 left == mid）</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 因為 target != nums[mid], 故用 &lt; 即可</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右半邊是被排序過的, e.g. [7,0,1,2,4,5,6], mid = 2</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>981. Time Based Key-Value Store</title>
      <link href="/post/time-based-key-value-store/"/>
      <url>/post/time-based-key-value-store/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/time-based-key-value-store/">https://leetcode.cn/problems/time-based-key-value-store/</a></strong></p><p><strong>題意：</strong>設計一個基於時間的 key-value 的資料結構, 它可以在不同 timestamp 儲存對應同一個 key 的多個值, 並針對特定 timestamp 得到相對應的 key 的 value。</p><p>實作 <code>TimeMap</code> class：</p><ul><li><code>TimeMap()</code> : 初始化 instance</li><li><code>void set(String key, String value, int timestamp)</code> : 儲存 <code>key</code>、 <code>value</code>, 以及 <code>timestamp</code>。</li><li><code>String get(String key, int timestamp)</code> :<ul><li>返回 <code>timestamp_prev</code> 對應的 value, 其中 <code>timestamp_prev &lt;= timestamp</code></li><li>如果存在多個值, 則返回對應<strong>最大</strong>的 <code>timestamp_prev</code> 的 value。</li><li>如果不存在, 則返回 <code>&quot;&quot;</code>。</li></ul></li></ul><p><strong>注意:</strong> <code>set(key, value, timestamp)</code> 中的 <code>timestamp</code> 都是嚴格遞增的。</p></blockquote><p><img src="https://i.imgur.com/9V7VWMN.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：題目的意思如下圖, <code>key</code> 裡面會儲存 <code>values</code>, 而 <code>values</code> 裡面可以有多個 <code>&#123;value, timestmap&#125;</code> pair。由於 <code>values</code> 裡面的 <code>timestamp</code> 都是嚴格遞增的(已排序), 所以我們可直接使用 Binary Search</strong></p></blockquote><p><img src="https://i.imgur.com/PdkaQmt.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeMap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeMap</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(string key, string value, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        m[key].<span class="built_in">emplace_back</span>(pair&lt;string, <span class="type">int</span>&gt;&#123;value, timestamp&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(string key, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">find</span>(key) == m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = m[key].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m[key][mid].second &gt; timestamp) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left 為 &gt; timestamp 的位置, 故 left - 1 為 &lt;= timestamp 的位置</span></span><br><span class="line">        <span class="keyword">return</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span>) ? m[key][left - <span class="number">1</span>].first : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt;&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search, 其中 <code>n</code> 為 <code>m[key]</code> 的長度</li><li><strong>space：</strong>$O(n)$ ➔ 其中 <code>n</code> 為 <code>set()</code> 的次數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>143. Reorder List</title>
      <link href="/post/reorder-list/"/>
      <url>/post/reorder-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reorder-list/">https://leetcode.cn/problems/reorder-list/</a></strong></p><p><strong>題意：</strong>給一單向 linked list 的起始節點 <code>head</code>, 該 linked list 可表示為</p><p><code>L0 → L1 → … → Ln - 1 → Ln</code></p><p>將其重新排序為</p><p><code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code></p><p>不能只是單純改變節點內部的值, 必須進行實際的節點交換。</p></blockquote><p><img src="https://i.imgur.com/HgeYnkh.png"></p><p><img src="https://i.imgur.com/IblLtsI.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：分成以下步驟</strong></p><ul><li><strong>找到 linked list 的中點, 按照 <a href="https://zako945.github.io/post/linked-list-cycle/">141. Linked List Cycle</a> 的方法</strong><ul><li>奇數時, <code>mid</code> 指向中點</li><li>偶數時, <code>mid</code> 指向右中點</li><li>因此, 最一開始要先讓 <code>fast</code> 先走一步, 這樣不管是奇偶數, <code>mid</code> 都會指向左中點</li></ul></li><li><strong>重要：截斷兩個 list ➔ <code>mid-&gt;next = nullptr</code>（容易忘記這步）</strong></li><li><strong>reverse 右半部分 <code>Ln → Ln - 1 → Ln - 2 → ...</code></strong></li><li><strong>merge 左半和右半</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *mid = <span class="built_in">get_mid</span>(head); <span class="comment">// 得到第一個中點</span></span><br><span class="line">        ListNode *right = mid-&gt;next; <span class="comment">// 得到右半部分</span></span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// **重要** 截斷兩個 list</span></span><br><span class="line">        right = <span class="built_in">reverse</span>(right); <span class="comment">// reverse 右半部分</span></span><br><span class="line">        <span class="built_in">merge</span>(head, right); <span class="comment">// merge 左半和右半</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// // 找到中點; 若為偶數, 則返回第一個中點</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">get_mid</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先讓 fast 先走一步, 這樣偶數時, slow 才會是第一個中點</span></span><br><span class="line">        ListNode *slow = head, *fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *tail = head;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (tail) &#123;</span><br><span class="line">            nxt = tail-&gt;next;</span><br><span class="line">            tail-&gt;next = prev;</span><br><span class="line">            prev = tail;</span><br><span class="line">            tail = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="comment">// 先儲存各自的 next</span></span><br><span class="line">            ListNode *n1 = l1-&gt;next;</span><br><span class="line">            ListNode *n2 = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// l1 下一個指向當前的 l2, 然後 l2 下一個指向 n1</span></span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 各自前進到下一個</span></span><br><span class="line">            l1 = n1;</span><br><span class="line">            l2 = n2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/post/remove-nth-node-from-end-of-list/"/>
      <url>/post/remove-nth-node-from-end-of-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></strong></p><p><strong>題意：</strong>給一 linked list, 請刪除倒數第 <code>n</code> 個 node, 並返回 linked list 的 head。</p><p><strong>進階：</strong>試著用一次掃描就完成。</p></blockquote><p><img src="https://i.imgur.com/o9Lnn8T.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 slow &amp; fast pointers, 用 <code>dummy</code> 是因為有可能第一個 node 被刪, 所以需要有 ptr 指著第一個 node 的前一個 node。首先 <code>fast</code> 先從 head 走 <code>n</code> 步（讓 <code>fast</code> 領先）, 然後 <code>slow</code> 才從 <code>dummy</code> 開始往前走, 直到 <code>fast</code> 變成 <code>NULL</code></strong></p><ul><li><strong>為什麼 <code>fast</code> 是初始化為 <code>head</code>, 而 <code>slow</code> 初始化為 <code>dummy</code> ?</strong><br>因為若 <code>fast</code> 和 <code>slow</code> 都初始化為 <code>head</code>, 則當 <code>fast</code> 為 <code>NULL</code> 時, <code>slow</code> 恰好在倒數第 <code>n</code> 個 node(因為 <code>fast</code> 領先 <code>n</code> 步), 但是我們是要<strong>刪除</strong>倒數第 <code>n</code> 個 node, <strong>要取得的是倒數第 <code>n</code> 個 node 的前一個節點</strong>(倒數第 <code>n + 1</code> 的 node), 故讓 slow 在初始化時就慢 <code>fast</code> 一步, 讓 <code>fast</code> 領先 <code>n + 1</code> 步, 這樣 <code>slow</code> 最後才會是倒數第 <code>n + 1</code> 的 node</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *slow = dummy, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(L)$ ➔ 遍歷 linked list, 其中 <code>L</code> 為 linked list 的長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138. Copy List with Random Pointer</title>
      <link href="/post/copy-list-with-random-pointer/"/>
      <url>/post/copy-list-with-random-pointer/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></strong></p><p><strong>題意：</strong>給一長度為 <code>n</code> 的 linked list, 每個節點包含一個額外增加的隨機 pointer <code>random</code>, 該 pointer 可以指向 linked list 中的任何節點 or 空節點。</p><p>建構該 linked list 的 deep copy, 它由 <code>n</code> 個新節點組成, 其中每個新節點的值都設為其對應的 <code>node.val</code>。</p><p>新節點的 <code>next</code> 和 <code>random</code> 也都應指向新 linked list 中的其他節點, 使原 linked list 和新 linked list 能夠表示成相同的 linked list。</p><p>e.g. 如果原 linked list 中有 <code>X</code> 和 <code>Y</code> 兩個節點, 其中 <code>X.random --&gt; Y</code>。則新 linked list 中對應的兩個節點 <code>x</code> 和 <code>y</code>, 同樣有 <code>x.random --&gt; y</code>。</p><p>返回新 linked list 的 <code>head</code>。</p></blockquote><p><img src="https://i.imgur.com/pfPzZ9u.png"></p><p><img src="https://i.imgur.com/a0gJl5X.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table, 先遍歷原 linked list, 並在遍歷的同時不斷創建新節點, 將 <code>原節點</code> 作為 <code>key</code>、<code>新節點</code> 作為 <code>value</code> 放入 hash table 中。最後, 再遍歷一次原 linked list, 並設置新 linked list 的 <code>next</code> 和 <code>random</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        Node *cur = head;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; oldToNew; <span class="comment">// &#123;old, new&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            oldToNew[cur] = newNode;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            oldToNew[cur]-&gt;next = oldToNew[cur-&gt;next];</span><br><span class="line">            oldToNew[cur]-&gt;random = oldToNew[cur-&gt;random];</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldToNew[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list</li><li><strong>space：</strong>$O(n)$ ➔ <code>oldToNew</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：分成三個步驟</strong></p><ul><li>根據遍歷到的原節點來創建對應的新節點, 並把每個新節點放在原節點後面<br>e.g. <code>1 -&gt; 1&#39; -&gt; 2 -&gt; 2&#39; -&gt; 3 -&gt; 3&#39;</code></li><li>設置新節點的 <code>random</code><br>➔ 新節點的 <code>random</code> 為原節點的 <code>random-&gt;next</code> (原 <code>random</code> 對應的新節點)</li><li>將兩個 linked list 分開</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根據遍歷到的原節點來創建對應的新節點, 並把每個新節點放在原節點後面</span></span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            newNode-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            cur = newNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 設置新節點的 random</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="comment">// 不用判斷 cur-&gt;next 是否為 null, 是因為 cur 為原 linked list 的節點</span></span><br><span class="line">            <span class="comment">// cur-&gt;next 為對應的新節點, 在 cur != null 的前提下, cur-&gt;next 必不為 null</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;random) &#123;</span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將兩個 linked list 分開</span></span><br><span class="line">        cur = head;</span><br><span class="line">        Node *dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>), *tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            tail-&gt;next = cur-&gt;next; <span class="comment">// 將新節點加到新 linked list</span></span><br><span class="line">            tail = tail-&gt;next; <span class="comment">// 更新 tail</span></span><br><span class="line">            cur-&gt;next = tail-&gt;next; <span class="comment">// 將 cur 指向下一個原 linked list 的 node</span></span><br><span class="line">            cur = cur-&gt;next; <span class="comment">// 將 cur 更新成下一個原 linked list 的 node</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要 copy 的 node, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/post/add-two-numbers/"/>
      <url>/post/add-two-numbers/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></strong></p><p><strong>題意</strong>：給兩個<strong>非空</strong> linked list 表示兩個非負整數, 每位數字都是按照<strong>逆序</strong>（e.g. 個位數在前, 十位數在後）儲存的, 且每一個 node 只能存一位數字。請將兩數相加, 並以相同型式返回和的 linked list。</p><p>除了數字 0 以外, 其他數字都不會以 0 作為開頭。</p></blockquote><p><img src="https://i.imgur.com/ICc2d6B.png"></p><p><img src="https://i.imgur.com/9nnmNaL.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution</strong>：</h2><blockquote><p><strong>想法：用 dummy 記住新的 linked list 開頭, tail 用來更新新的 linked list 之尾端。除此之外, 還要考慮進位(carry bit)和以下特殊情況</strong>：</p><ul><li><p><strong>兩個整數長度不一（e.g. <code>123</code> + <code>4567</code>）</strong><br>➔ 當 <code>node</code> 為 <code>NULL</code> 時, 把 <code>node-&gt;val</code> 設為 <code>0</code></p></li><li><p><strong>進位導致輸出比原本最長整數還長（e.g. <code>1</code> + <code>99</code> &#x3D; <code>100</code>）</strong><br>➔ loop 終止條件須判斷 carry bit 是否為 0</p><p>  <img src="https://i.imgur.com/atRCQf4.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *tail = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 ptr, 若 ptr 為 null, 則不能用 ptr-&gt;next, 而是直接設成 null</span></span><br><span class="line">            l1 = l1 ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(max(m,n))$ ➔ while loop 終止是取決最長的 linked list 長度</li><li><strong>space：</strong>$O(max(m,n))$ ➔ 新的 linked list 長度取決於最長的 linked list 長度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>287. Find the Duplicate Number</title>
      <link href="/post/find-the-duplicate-number/"/>
      <url>/post/find-the-duplicate-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-the-duplicate-number/">https://leetcode.cn/problems/find-the-duplicate-number/</a></strong></p><p><strong>題意</strong>：給一有 <code>n + 1</code> 個數的 array <code>nums</code>, 每個元素值皆在 <code>[1, n]</code>, 剛好<strong>只有一數字重複</strong>, 求重複的數字。</p><p><strong>注意</strong>：只能使用 $O(1)$ space, 且<strong>不能改變</strong> <code>nums</code></p><p><strong>進階</strong>：設計 $O(n)$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/GNc82JD.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1</strong>：</h2><blockquote><p><strong>想法：利用 Binary Search, 先在 <code>[1, n]</code> 中找中點 <code>mid</code>, 然後判斷整個 <code>nums</code> 中 <code>≤ mid</code> 的元素個數 <code>cnt</code>。若 <code>cnt &gt; mid</code> 代表有重複, 則往左繼續找</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不要考慮 nums, 只需要考慮數字都在 1 到 n 之間</span><br><span class="line">nums = [1,3,4,2,2] 此時數字在 1 到 4 之間</span><br><span class="line"></span><br><span class="line">mid = (1 + 4) / 2 = 2, nums 中 ≤ 2 的有3個(1,2,2), 1到2中肯定有重複, 往左搜尋 ➔ right = 2</span><br><span class="line">mid = (1 + 2) / 2 = 1, nums 中 ≤ 1 的有1個(1), 2到2中肯定有重複, 往右搜尋</span><br><span class="line">➔ left = 2, left &lt; right 不成立</span><br><span class="line">➔ 所以重複的數是 2</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; mid) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$<ul><li>$O(log(n))$：Binary Search, while loop 得做 $O(log(n))$ 次</li><li>$O(n)$：while loop 每迭代一次, for loop 都得遍歷 <code>nums</code></li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：將此問題轉換成 linked list cyle, 利用 slow &amp; fast pointers 找出 cycle 的起點, 可參考 142. Linked List Cycle II</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [1,3,4,2,2]</span><br><span class="line"></span><br><span class="line">第一個 0 代表從 idx = 0 開始</span><br><span class="line">下一個移動到 nums[0] = 1</span><br><span class="line">下一個移動到 nums[1] = 3, 依此類推</span><br><span class="line">因為有重複數, 代表會有兩個數指向同一個數 e.g. nums[3] 和 nums[4] 都指向 nums[2] = 4</span><br><span class="line">0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2, cycle: 2-&gt;4-&gt;2</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/65xJ87D.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 slow 和 fast 相遇的點</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 cycle 的起點</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146. LRU Cache</title>
      <link href="/post/lru-cache/"/>
      <url>/post/lru-cache/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a></strong></p><p><strong>題意：</strong>設計並實現一個滿足 <strong>LRU（Least Recently Used）</strong>的資料結構。</p><p><strong>實現 <code>LRUCache</code> class：</strong></p><ul><li><code>LRUCache(int capacity)</code>：以 <code>capacity</code> 初始化 LRU cache 的大小。</li><li><code>int get(int key)</code>：若 <code>key</code> 存在於 cache 中, 則返回其對應的 <code>val</code>, 否則返回 <code>1</code>。</li><li><code>void put(int key, int value)</code>：<ul><li>若 <code>key</code> 已經存在, 則變更其 <code>value</code></li><li>若不存在, 則將該組 <code>key-value</code> insert 到 cache 中</li><li>若 insert 操作導致 pair 數量超過 <code>capacity</code>, 則移除最久未使用的 <code>key-value</code> pair</li></ul></li></ul><p><strong>注意：</strong><code>get()</code> 和 <code>put()</code> 必須是 $O(1)$ time</p></blockquote><p><img src="https://i.imgur.com/xxJOpVQ.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution</strong>：</h2><blockquote><p><strong>想法：利用 hash table + list, 其中 <code>cache</code> 用來存放所有的 <code>key</code>, 用來記錄哪個 <code>key</code> 最近被使用、最久沒被使用。用 list 而非 forward_list 的原因是：「當 <code>get()</code> 訪問的是處於中間位置的節點時, 可以直接獲取其前一個節點和後一個節點, 從而省去了遍歷整個 linked list的時間」。若用 forward_list, 要獲取前一個節點和後一個節點必須從 linked list 的 head 開始遍歷</strong></p><ul><li><code>cache.begin()</code> : 最久未用的 key</li><li><code>--cache.end()</code> : 最近使用的 key</li></ul><p><strong>而 <code>key2val</code> 和 <code>key2iter</code> 分別存放 <code>key</code> 所對應到的 <code>val</code> 和 <code>iterator</code></strong></p><ul><li><strong><code>get(key)</code> :</strong><ul><li>若 <code>key</code> 已在 <code>cache</code> 中, 則將其放到 <code>cache</code> 尾部</li><li>若 <code>key</code> 不在 <code>cache</code> 中, 則返回 <code>1</code></li></ul></li><li><strong><code>put(key, value)</code> :</strong><ul><li>若 <code>key</code> 已在 <code>cache</code> 中, 則更新其對應的 val</li><li>若 <code>key</code> 不在 <code>cache</code> 中, 則要新增該 key。若 <code>capacity</code> 已滿, 則要移除 <code>cache.begin()</code></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        capacity_ = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若 cache 已存在該 key, 則將其放到 cache 尾部</span></span><br><span class="line">        <span class="keyword">if</span> (key2val.<span class="built_in">find</span>(key) != key2val.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = key2val[key];</span><br><span class="line">            <span class="keyword">auto</span> it = key2iter[key];</span><br><span class="line">            cache.<span class="built_in">erase</span>(it);</span><br><span class="line">            cache.<span class="built_in">push_back</span>(key);</span><br><span class="line">            key2iter[key] = --cache.<span class="built_in">end</span>();</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// key not found</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cache 已存在該 key, 則更新其對應的 val</span></span><br><span class="line">        <span class="comment">// 直接調用 get(key), 若存在 key, 則 get 會將其放到 cache 尾端, 然後更新 val 即可</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(key) != <span class="number">-1</span>) &#123;</span><br><span class="line">            key2val[key] = value;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// key 已存在, 因此 put 後 size 不變, 不會超過 cap, 所以直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache 不存在該 key, 則要新增該 key</span></span><br><span class="line">        <span class="comment">// 若 cache 已滿, 則要先移除 cache.begin()</span></span><br><span class="line">        <span class="keyword">if</span> (key2val.<span class="built_in">size</span>() == capacity_) &#123;</span><br><span class="line">            <span class="type">int</span> keyDel = *cache.<span class="built_in">begin</span>();</span><br><span class="line">            cache.<span class="built_in">erase</span>(cache.<span class="built_in">begin</span>());</span><br><span class="line">            key2val.<span class="built_in">erase</span>(keyDel);</span><br><span class="line">            key2iter.<span class="built_in">erase</span>(keyDel);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cache.<span class="built_in">push_back</span>(key);</span><br><span class="line">        key2val[key] = value;</span><br><span class="line">        key2iter[key] = --cache.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity_;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; cache; <span class="comment">// 存放 &quot;key&quot; 的 list</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; key2val; <span class="comment">// &#123;key, val&#125;</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;::iterator&gt; key2iter; <span class="comment">// &#123;key, iterator&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$</li><li><strong>space：</strong>$O(capacity)$ ➔ <code>cache</code>, <code>key2val</code>, <code>key2iter</code> 的元素個數不超過 <code>capacity</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>235. Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="/post/lowest-common-ancestor-of-a-binary-search-tree/"/>
      <url>/post/lowest-common-ancestor-of-a-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></strong></p><p><strong>題意：</strong>給一 BT 和兩個節點 <code>p</code>, <code>q</code>, 求兩節點之<strong>最低共同祖先(LCA)</strong></p></blockquote><p><img src="https://i.imgur.com/aMLdW4p.png"></p><p><img src="https://i.imgur.com/wS3XAZv.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS 和 BST 的性質, 找到一 node 滿足 <code>node.val</code> 介於 <code>p</code>、<code>q</code> 之間</strong></p><ul><li><code>p-&gt;val ≤ node.val ≤ q-&gt;val</code> 或</li><li><code>q-&gt;val ≤ node.val ≤ p-&gt;val</code></li></ul><p><strong>BST 性質:</strong></p><ul><li><code>root</code> 左子樹中所有 <code>node.val</code> 皆小於 <code>root.val</code></li><li><code>root</code> 右子樹中所有 <code>node.val</code> 皆大於 <code>root.val</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123; <span class="comment">// 當前 root 太小</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123; <span class="comment">// 當前 root 太大</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 當前 root-&gt;val 介於 p、q 之間, 故返回 root</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, 遞迴深度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/post/trapping-rain-water/"/>
      <url>/post/trapping-rain-water/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></strong></p><p><strong>題意：</strong>給 <code>n</code> 個非負整數, 代表每個寬度為 <code>1</code> 的柱子之高度圖, 計算按此排列的柱子, 在下雨後能接多少雨水。</p></blockquote><p><img src="https://i.imgur.com/YA2gsx4.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用暴力法, 我們計算每個 col 所能接住的水量, 因此對於每個 <code>i</code> 我們要在 <code>height[0 ~ i]</code> 和 <code>height[i ~ (n - 1)]</code> 中分別找出最大值 <code>leftMax</code> 和 <code>rightMax</code>, 則該 col 所能接住的水量 &#x3D; <code>min(leftMax, rightMax) - height[i]</code></strong></p><p><img src="https://i.imgur.com/uRPc5KE.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = height.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> leftMax = *<span class="built_in">max_element</span>(it, it + i + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> rightMax = *<span class="built_in">max_element</span>(it + i, it + n);</span><br><span class="line">            res += <span class="built_in">min</span>(leftMax, rightMax) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 每計算一次需找出 <code>leftMax</code> 和 <code>rightMax</code>, 此過程需 $O(n)$, 總共要計算 <code>n</code> 次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 概念同 Solution 1, 只是我們用兩個 array <code>leftMax</code> 和 <code>rightMax</code> 來記錄, 其中 <code>leftMax[i]</code> 和 <code>rightMax[i]</code> 分別代表 <code>height[0 ~ i]</code> 和 <code>height[(n - 1) ~ i]</code> 之最大值</strong></p><ul><li>由左往右遍歷 <code>height</code> 得到每一個 <code>leftMax[i]</code></li><li>由右往左遍歷 <code>height</code> 得到每一個 <code>rightMax[i]</code></li><li>最後計算每個 col 所能接住的雨水</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(n, height.front())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(n, height.back())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            leftMax[i] = <span class="built_in">max</span>(height[i], leftMax[i - <span class="number">1</span>]);</span><br><span class="line">            rightMax[n - <span class="number">1</span> - i] = <span class="built_in">max</span>(height[n - <span class="number">1</span> - i], rightMax[n - i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res += <span class="built_in">min</span>(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>leftMax</code>, <code>rightMax</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers, 改進 Solution 2, 因為 <code>leftMax[i]</code> 和 <code>rightMax[i]</code> 只會用到一次, 然後就再也不會用到了, 因此我們用一個變數記住即可。我們定義以下變數：</strong></p><ul><li><code>leftMax</code>：左邊的最大值, 它是由左往右遍歷得到的</li><li><code>rightMax</code>：右邊的最大值, 它是由右往左遍歷得到的</li><li><code>left</code>：由左往右處理的當前 idx</li><li><code>right</code>：由右往左處理的當前 idx</li></ul><p><strong>我們有以下定理可使用：</strong></p><ul><li><p><strong>定理一</strong>：在 <code>idx = i</code> 時能接住的水量是取決於左右兩邊的最大值中<strong>較小</strong>的那一個</p></li><li><p><strong>定理二</strong>：</p><ul><li>當我們由左往右處理到 <code>left</code> 時, 左邊的最大值 <code>leftMax</code> 對它而言是可信的, 但 <code>rightMax</code> 對它而言是不可信的</li><li>當我們由右往左處理到 <code>right</code> 時, 右邊的最大值 <code>rightMax</code> 對它而言是可信的, 但 <code>leftMax</code> 對它而言是不可信的</li></ul><p>  <img src="https://i.imgur.com/qwYcmK4.png"></p></li></ul><p><strong>由上述定理, 我們可以得到：</strong></p><ul><li>對於 <code>left</code> 而言, 它左邊最大值一定是 <code>leftMax</code>, 就算 <code>右邊實際最大值 ≥ rightMax</code>, 只要 <code>leftMax &lt; rightMax</code> 成立, 就能知道 <code>left</code> 能接住多少水(<strong>定理一</strong>), 無論右邊將來是否會出現更大的 <code>rightMax</code>, 都不會影響到這個結果。反之, <code>right</code> 也是同樣道理。</li></ul><p><strong>while loop 的條件為何是 <code>left &lt;= right</code>, 而非 <code>left &lt; right</code> ?</strong></p><p>因為是先計算當前 ptr, 再移動 ptr 的</p><p>e.g. <code>height = [1, 0, 3]</code></p><ul><li>一開始 <code>leftMax(0) &lt; rightMax(0)</code> 不成立, 故處理 <code>right</code> ➔ 得 <code>rightMax = 3</code>, <code>res = 0</code>, <code>right = 1</code></li><li><code>leftMax(0) &lt; rightMax(3)</code> 成立, 故處理 <code>left</code> ➔ 得 <code>leftMax = 1</code>, <code>res = 0</code>, <code>left = 1</code></li><li>此時, <code>left = 1 = right</code>, 若 while loop 條件為 <code>left &lt; right</code>, 則無法計算到 <code>idx = 1</code> 位置的水量</li><li><code>leftMax(1) &lt; rightMax(3)</code>成立, 故處理 <code>left</code> ➔ 得 <code>leftMax = 1</code>, <code>res = 1</code>, <code>left = 2</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                leftMax = <span class="built_in">max</span>(leftMax, height[left]); <span class="comment">// 得到左邊最大值(含自身)</span></span><br><span class="line">                res += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightMax = <span class="built_in">max</span>(rightMax, height[right]); <span class="comment">// 得到右邊最大值(含自身)</span></span><br><span class="line">                res += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>height</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>739. Daily Temperatures</title>
      <link href="/post/daily-temperatures/"/>
      <url>/post/daily-temperatures/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></strong></p><p><strong>題意:</strong> 給一整數 array <code>temperatures</code> 代表每天的溫度。請返回 array <code>res</code>, 其中 <code>res[i]</code> 是指對於第 <code>i</code> 天, 下一個更高溫度是出現在幾天後。如果氣溫在這之後都不會升高, 則該位置用 <code>0</code> 來代替。</p></blockquote><p><img src="https://i.imgur.com/NEFqBSZ.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack, 使用 Monotonic（遞減） Stack <code>stk</code> 紀錄 <code>&#123;temperature, idx&#125;</code>, 一旦當前溫度 <code>temperatures[i]</code> 比 <code>stk.top().first</code> 還高, 則不斷將 <code>stk.top()</code> 取出, 並計算 <code>res[idx]</code>, 直到 <code>stk.top().first &gt; temperatures[i]</code> 才把 <code>temperatures[i]</code> push 到 <code>stk</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 若最後 stk 不為空, 則剩餘元素的 res[idx] 皆為 0</span></span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; stk; <span class="comment">// &#123;temperature, idx&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 一旦當前溫度 &gt; top, 則不斷將 top 給 pop 掉, 並計算 res[idx]</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; stk.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [temperature, idx] = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                res[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">emplace</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&#123;temperatures[i], i&#125;); <span class="comment">// push 當前元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>853. Car Fleet</title>
      <link href="/post/car-fleet/"/>
      <url>/post/car-fleet/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/car-fleet/">https://leetcode.cn/problems/car-fleet/</a></strong></p><p><strong>題意:</strong> 在一條單行道上, 有 <code>n</code> 輛車開往同一目的地, 目的地是幾英里外的 <code>target</code>。</p><p>給兩個整數 array <code>position</code>、<code>speed</code>, 其中 <code>position[i]</code> 是第 <code>i</code> 輛車的位置, <code>speed[i]</code> 是第 <code>i</code> 輛車的時速(英里&#x2F;小時)。</p><p>一輛車永遠不會超過前面的另一輛車, 但它可以追上去, 並與前車<strong>以相同的速度</strong>緊接著行駛。此時, 我們可忽略這兩輛車之間的距離, 也就是說, 它們被假定處於相同的位置。</p><p><strong>車隊</strong>是一些由行駛在相同位置、具有相同速度的車組成的非空集合。注意, 一輛車也可以是一個車隊。</p><p>即便一輛車在目的地才趕上了一個車隊, 它們仍然會被視作是同一個車隊。</p><p>返回到達目的地的<strong>車隊數量</strong>。</p></blockquote><p><img src="https://i.imgur.com/A0EImP6.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Monotonic（遞減） Stack, 先使用 map 根據 <code>position[i]</code> 「由小到大」排序, 然後依序取出, 並計算 <code>position[i]</code> 到 <code>target</code> 所需的時間。如果當前所需的時間 <code>time ≥ stk.top()</code>, 則代表兩車會合併為一個車隊, 因為離 <code>target</code> 較遠的那輛車所需的時間 <code>stk.top()</code> 較短, 但是道路為單向且不能超車。所以最後抵達 <code>target</code> 的時間會受制於 <code>time</code>。所以一旦 <code>time ≥ stk.top()</code> 就要 <code>stk.pop()</code>, 將兩輛車合併為一個車隊（受限於當前 <code>time</code> 的車隊）, 直到 <code>stk.top() &gt; time</code>, 才能將 <code>time</code> push 到 <code>stk</code> 中。最後, <code>stk</code> 中的元素個數即為車隊數量。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">carFleet</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; position, vector&lt;<span class="type">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ps;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; position.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ps[position[i]] = speed[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">float</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [pos, spd] : ps) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">float</span> time = <span class="built_in">float</span>(target - pos) / spd;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; time &gt;= stk.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">emplace</span>(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>74. Search a 2D Matrix</title>
      <link href="/post/search-a-2d-matrix/"/>
      <url>/post/search-a-2d-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></strong></p><p><strong>題意</strong>: 設計一高效演算法來搜索 <code>m x n</code> matrix 中是否存在整數 <code>target</code>, matrix 滿足以下特性:</p><ul><li>每列的元素由左到右按升序排列</li><li>每列的第一個元素 &gt; 前一列的最後一個元素</li></ul></blockquote><p><img src="https://i.imgur.com/1iXww8t.png"></p><p><img src="https://i.imgur.com/PJveiV8.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, <code>matrix</code> 其實就是 1D 已排序的 array, 只是改成用 2D array 表達而已, 故將 <code>matrix</code> 看成 1D array, 然後還原回 2D array 座標來做 Binary Search</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matrix[mid / n][mid % n] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left &lt; m * n &amp;&amp; matrix[left / n][left % n] == target) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(mn))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>875. Koko Eating Bananas</title>
      <link href="/post/koko-eating-bananas/"/>
      <url>/post/koko-eating-bananas/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/koko-eating-bananas/">https://leetcode.cn/problems/koko-eating-bananas/</a></strong></p><p><strong>題意:</strong> Koko 喜歡吃香蕉。這里有 <code>n</code> 堆香蕉, 第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警衛已經離開了, 並且將在 <code>h</code> 小時後回來。</p><p>Koko 可以決定她吃香蕉的速度 <code>k</code> （單位：根 &#x2F; 小時）。每個小時, 她將會選擇其中一堆的香蕉, 並從中吃掉 <code>k</code> 根。如果這堆香蕉少於 <code>k</code> 根, 她將吃掉這堆所有的香蕉, 然後這一小時內都不會再吃更多的香蕉。  </p><p>Koko 喜歡慢慢吃, 但仍然想在警衛回來前吃掉所有的香蕉。</p><p>返回她可以在 <code>h</code> 小時內吃掉所有香蕉的最小速度 <code>k</code>, 其中 <code>k</code> 為整數。</p></blockquote><p><img src="https://i.imgur.com/8vBcc5O.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 其中 <code>k</code> 的區間為 <code>[1,  max(piles)]</code>, 因為 Koko 吃掉該堆所有的香蕉後, 這一小時內都不會再吃更多的香蕉, 所以 <code>k</code> 取到 <code>max(piles)</code> 即可。此外, <code>left</code> 不能為 <code>0</code>, 否則 <code>mid</code> 有可能為 <code>0</code>, 這會導致計算 <code>time += ceil(1.0 * pile / mid)</code> 時發生錯誤</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = *<span class="built_in">max_element</span>(piles.<span class="built_in">begin</span>(), piles.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// speed</span></span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> cost = <span class="number">0</span>; <span class="comment">// 加總有可能會 overflow, 故取 long</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; pile : piles) &#123;</span><br><span class="line">                cost += <span class="built_in">ceil</span>(<span class="number">1.0</span> * pile / mid); <span class="comment">// 先轉成 float 再運算, 最後取 ceiling</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cost &lt;= h) &#123; <span class="comment">// 速度過快, 往左區間繼續搜尋</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(m))$ ➔ 其中 <code>n</code> 為 <code>piles</code> 的長度, <code>m</code> 為 <code>piles</code> 中的最大值<ul><li>$O(log(m))$ : Binary Search 的次數</li><li>$O(n \cdot log(m))$ : 每一次 Binary Search 皆須 $O(n)$, 因為計算出 mid 後, 皆須遍歷 <code>piles</code></li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>153. Find Minimum in Rotated Sorted Array</title>
      <link href="/post/find-minimum-in-rotated-sorted-array/"/>
      <url>/post/find-minimum-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/</a></strong></p><p><strong>題意</strong>: 給一長度為 <code>n</code> 的 array, 已照升序排列, 經過 1 到 <code>n</code> 次旋轉後得到 input array。</p><p>e.g. <code>nums = [0,1,2,4,5,6,7]</code> 經過變化後可得到:</p><ul><li>若旋轉 <code>4</code> 次, 可得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋轉 <code>7</code> 次, 可得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>給一元素互不相同的 array <code>nums</code>, 已照升序排列, 並進行多次旋轉, 返回 <code>nums</code> 中最小的元素。</p><p><strong>注意</strong>: 請設計 $O(log(n))$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/gSIGk6B.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 根據比較左、中、右三個位置的值來縮小左邊界 or 右邊界, 有以下幾種情況：</strong></p><ul><li><strong>(左 &lt; 中) 且 (中 &lt; 右)</strong>, e.g. <code>[1,2,3,4,5]</code>。代表<strong>沒有旋轉</strong> ➔ min 在左半邊, 故縮小<strong>右</strong>邊界。</li><li><strong>(左 &gt; 中) 且 (中 &lt; 右)</strong>, e.g. <code>[5,1,2,3,4]</code>。代表<strong>有旋轉</strong> ➔ min 在左半邊, 故縮小<strong>右</strong>邊界</li><li><strong>(左 &lt; 中) 且 (中 &gt; 右)</strong>, e.g. <code>[2,3,4,5,1]</code>。代表<strong>有旋轉</strong> ➔ min 在右半邊, 故縮小<strong>左</strong>邊界</li><li><strong>(左 &gt; 中) 且 (中 &gt; 右)</strong>, e.g. <code>[5,4,3,2,1]</code>。單調遞減, 本題不可能出現此種情形, 因為遞增的 array 再怎麼轉也不可能變遞減的</li></ul><p>分析前面三種可能的情況, 我們選擇比較<strong>中、右</strong></p><p>➔ 因為這樣可將情況 1、2 是視作一類（中 &lt; 右, 縮小右邊界）, 而情況 3 視作另一類（中 &gt; 右, 縮小左邊界）</p><p><img src="https://i.imgur.com/uuP4Hbh.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>]; <span class="comment">// 初始值設 array 的第一個元素</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            res = <span class="built_in">min</span>(res, nums[mid]); <span class="comment">// 更新最小值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>637. Average of Levels in Binary Tree</title>
      <link href="/post/average-of-levels-in-binary-tree/"/>
      <url>/post/average-of-levels-in-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 Binary Tree(BT), 計算每一層的平均值。</p></blockquote><p><img src="https://i.imgur.com/I7IRJWJ.png"></p><p><img src="https://i.imgur.com/cZP2nAa.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於樹的高度, worse case 為 skew tree, tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>844. Backspace String Compare</title>
      <link href="/post/backspace-string-compare/"/>
      <url>/post/backspace-string-compare/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/backspace-string-compare/">https://leetcode.cn/problems/backspace-string-compare/</a></strong></p><p><strong>題意：</strong>給兩個 string <code>s</code>, <code>t</code>, 其中的 <code>#</code> 代表 <code>退格(backspace)字元</code>, 求兩字串是否相等。</p></blockquote><p><img src="https://i.imgur.com/DvHelFY.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 two pointers, 其中 <code>slowindex</code> 負責 in-place 記錄新的 string, 而 <code>fastindex</code> 負責遍歷整個 string</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(s) == <span class="built_in">build</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">string <span class="title">build</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> slowindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fastindex = <span class="number">0</span>; fastindex &lt; s.<span class="built_in">size</span>(); ++fastindex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[fastindex] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                slowindex = <span class="built_in">max</span>(<span class="number">0</span>, --slowindex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[slowindex++] = s[fastindex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(<span class="number">0</span>, slowindex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code>, <code>m</code> 為 <code>s</code> 之長度, <code>n</code> 為 <code>t</code> 之長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110. Balanced Binary Tree</title>
      <link href="/post/balanced-binary-tree/"/>
      <url>/post/balanced-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 判斷它是否 <strong>height-balanced</strong>。</p><p><strong>height-balanced 的定義：</strong>BT 中每個 node 的左、右子樹的高度差不超過 1。</p></blockquote><p><img src="https://i.imgur.com/iNX9uVN.png"></p><p><img src="https://i.imgur.com/jCJucay.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 如果當前 node 的左、右子樹的高度差不超過 <code>1</code>, 且左、右子樹皆為 height-balanced, 則返回 <code>true</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp;</span><br><span class="line">               <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp;</span><br><span class="line">               <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(<span class="type">const</span> TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 BT 中所有 node</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case：BT 為 skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link href="/post/best-time-to-buy-and-sell-stock/"/>
      <url>/post/best-time-to-buy-and-sell-stock/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></strong></p><p><strong>題意：</strong>給一 array <code>prices</code>, 從左到右分別是每天的股票價格, 求如何買賣可以獲得最大的利潤。</p><p><strong>注意：</strong>買入的天數必須在賣出的天數之前。</p></blockquote><p><img src="https://i.imgur.com/oGeonr9.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 紀錄前 <code>i - 1</code> 天的最大利潤、最小價格, 然後計算第 <code>i</code> 天的利潤並比較</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 紀錄前 (i - 1) 天的最大利潤</span></span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>];<span class="comment">// 紀錄前 (i - 1) 天的最小價格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - minPrice);</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>prices</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>704. Binary Search</title>
      <link href="/post/binary-search/"/>
      <url>/post/binary-search/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></strong></p><p><strong>題意：</strong>給一已排序的整數 array <code>nums</code>, 用 binary search 找出 <code>nums</code> 中是否存在 <code>target</code>。若存在, 則返回該元素的 idx；否則, 返回 <code>-1</code>。</p></blockquote><p><img src="https://i.imgur.com/ZzNPVSo.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 找到 left 為第一個 <code>≥ target</code> 的數。若 <code>left</code> 越界 or <code>nums[left] != target</code>, 則代表 <code>target</code> 不存在於 <code>nums</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當 nums 中所有的元素都比 target 小 (target 不存在), left 會越界 (left = n)</span></span><br><span class="line">        <span class="comment">// 所以在存取 nums[left] 前, 要先判斷 left 是否越界, 否則存取會出錯</span></span><br><span class="line">        <span class="keyword">return</span> (left &lt; n &amp;&amp; nums[left] == target) ? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70. Climbing Stairs</title>
      <link href="/post/climbing-stairs/"/>
      <url>/post/climbing-stairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></strong></p><p><strong>題意：</strong>今天有 <code>n</code> 階樓梯要爬, 每一次你可以選擇要爬 1階 or 2階, 求總共有幾種不同的爬法。</p></blockquote><p><img src="https://i.imgur.com/345Jp3i.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用遞迴求解</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>time complexity 證明：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">T(n) = T(n - 1) + T(n - 2) + c</span><br><span class="line">     &lt;= 2T(n - 1) + c, 取 upper bound T(n - 2) &lt;= T(n - 1)</span><br><span class="line">      = 2*(2T(n - 2) + 1) + (1 * c)</span><br><span class="line">      = 4T(n - 2) + (2 * c)</span><br><span class="line">      = 8T(n - 3) + (3 * c)</span><br><span class="line">      = 2^k * T(n - k) + (2^k * c)</span><br><span class="line"></span><br><span class="line">令 k = n , T(0) = 1</span><br><span class="line">T(n) &lt;= 2^n * T(0) + (2^n * c)</span><br><span class="line">      = 2^n * (1 + c)</span><br></pre></td></tr></table></figure><ul><li><p><strong>time：</strong>$O(2^n)$</p></li><li><p><strong>space：</strong>$O(n)$ ➔ 受限於 tree 的深度, 下圖中可以看到 F(6) 的深度 &#x3D; 6 - 1 &#x3D; n - 1</p><p>  <img src="https://i.imgur.com/vaRiYvD.png"></p><p>  <strong>遞迴缺點：重複計算</strong>, e.g. 上圖中可看到 F(3) 被重複呼叫好幾次</p></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 紀錄 0, 1, 2, …, n 階的方法數, 用空間換取時間, 避免重複計算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, <code>dp[i] = dp[i - 1] + dp[i - 2]</code> 中 <code>dp[i]</code> 只會用到前兩步的方法數, 也就是說只需紀錄 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> 就好, 根本不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">1</span>; <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="type">int</span> two = <span class="number">1</span>; <span class="comment">// dp[i - 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur = one + two; <span class="comment">// dp[i]</span></span><br><span class="line">            two = one;</span><br><span class="line">            one = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>543. Diameter of Binary Tree</title>
      <link href="/post/diameter-of-binary-tree/"/>
      <url>/post/diameter-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求任兩點的 path 之最大長度。</p><ul><li>最大長度：最長 path 上的 <code>edge</code> 數</li></ul></blockquote><p><img src="https://i.imgur.com/NkrA6am.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, LP(node) 返回以 <code>node</code> 為 root 的 subtree 之最長路徑, 只有當前 node 可以同時使用左子樹和右子樹（由左至右分別是 1, 2, 1）, 也就是計算 <code>res</code> 時可用, 但返回時只能 return 單邊路徑。由於 path 不一定要經過 root, 因此可用 global 變數 <code>res</code> 來記錄最長 path 之長度</strong></p><p><img src="https://i.imgur.com/48fZdOl.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">LP</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LP</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> left = <span class="built_in">LP</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> right = <span class="built_in">LP</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        res = <span class="built_in">max</span>(res, left + right); <span class="comment">// 只有當前 root 可以同時使用左子樹和右子樹</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right); <span class="comment">// 每個 node 都看成是轉折點, 只能返回單邊路徑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case：skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link href="/post/evaluate-reverse-polish-notation/"/>
      <url>/post/evaluate-reverse-polish-notation/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></strong></p><p><strong>題意：</strong>給一 postorder, 返回 inorder 的運算結果。</p><p>保證 postorder 運算式皆為有效的, 不會有除數為 <code>0</code> 的情況。</p></blockquote><p><img src="https://i.imgur.com/Fib7hlW.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack, 一旦當前 <code>token</code> 為數字, 則 push 到 stack 中; 否則, 取出 stack 中最上面的兩個 top 元素出來做運算, 並把運算結果 push 到 stack 中。重複以上步驟, 最後 stack 會剩下一個元素, 也就是最終的運算結果</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(token)) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意順序</span></span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> n2 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> n1 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (token[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 + n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 - n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(<span class="built_in">long</span>(n1) * <span class="built_in">long</span>(n2));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 / n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isdigit</span><span class="params">(string&amp; token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop, 其中 <code>n</code> 為 <code>token</code> 的個數</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>448. Find All Numbers Disappeared in an Array</title>
      <link href="/post/find-all-numbers-disappeared-in-an-array/"/>
      <url>/post/find-all-numbers-disappeared-in-an-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/</a></strong></p><p><strong>題意：</strong>原本有一包含 <code>[1, n]</code> 總共 <code>n</code> 個數的 array, 今給一個 <code>n</code> 個數的 array (含重複數) <code>nums</code>, 找出所有缺失的數。</p></blockquote><p><img src="https://i.imgur.com/uWoILtq.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將數字設為 負數 來標記我們看到的數字的 index, 然後遍歷 <code>nums</code> 元素, 若 <code>nums[i] &gt; 0</code>, 代表數字 <code>i + 1</code> 沒出現過</strong></p><p>e.g. <code>[1, 2, 2]</code> ➔ <code>[-1, -2, 2]</code>, 其中 <code>nums[0]</code> 紀錄數字 1 是否出現</p><p>因為數字 1 有出現, 所以 <code>nums[0]</code> 被設為負數, 依此類推</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 將數字設為負數來標記我們看到的數字的index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除返回的 array, 且缺失 idx 都儲存在 <code>nums</code> 中, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>744. Find Smallest Letter Greater Than Target</title>
      <link href="/post/find-smallest-letter-greater-than-target/"/>
      <url>/post/find-smallest-letter-greater-than-target/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/">https://leetcode.cn/problems/find-smallest-letter-greater-than-target/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> char array <code>letters</code>, 在其中找到比 <code>target</code> 大的最小 char。</p><p><strong>注意：</strong><code>letters</code> 是循環的</p><ul><li>e.g. <code>target == &#39;z&#39;</code> 且 <code>letters == [&#39;a&#39;, &#39;b&#39;]</code>, 則返回 <code>&#39;a&#39;</code></li></ul></blockquote><p><img src="https://i.imgur.com/8BY6pKe.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 binary search</strong></p><ul><li><code>letters[mid] &gt; target</code> 時, 往左查找, 看是否有比 <code>mid</code> 更小的</li><li><code>letters[mid] &lt;= target</code> 時, 往右查找</li></ul><p>最後記得檢查是否 <code>&gt; target</code>, 如果不滿足(代表 <code>letters</code> 中沒有 <code>&gt; target</code> 的 char), 則返回 <code>letters[0]</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; letters, <span class="type">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = letters.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 避免 overflow</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (letters[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> letters[left] &gt; target ? letters[left] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. Generate Parentheses</title>
      <link href="/post/generate-parentheses/"/>
      <url>/post/generate-parentheses/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/generate-parentheses/">https://leetcode.cn/problems/generate-parentheses/</a></strong></p><p><strong>題意：</strong>數字 <code>n</code> 代表生成括號的對數, 生成所有可能的且<strong>有效的</strong>括號組合。</p></blockquote><p><img src="https://i.imgur.com/3fkGh4I.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p><ul><li><p>當 <code>左括號個數 &lt; n</code> 時, 可以加入左括號</p></li><li><p>當 <code>右括號個數 &lt; 左括號個數</code> 時, 可以加入右括號</p><p>  <img src="https://i.imgur.com/TmAGVht.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string cur;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == n &amp;&amp; right == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">            cur += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(left + <span class="number">1</span>, right, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">            cur += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(left, right + <span class="number">1</span>, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(\dfrac{4^n}{n \sqrt n})$ ➔ 取決於第 <code>n</code> 個 Catalan number $\dfrac{1}{n+1} \left(\begin{array}{ccc} 2n \\ n \ \end{array} \right)$, 近似於 $O(\dfrac{4^n}{n \sqrt n})$<br><a href="https://math.stackexchange.com/questions/1986247/asymptotic-approximation-of-catalan-numbers">證明網址(不重要)</a></li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 array <code>res</code>, 取決於遞迴深度, 遞迴最大深度為 <code>2n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/post/3sum/"/>
      <url>/post/3sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 返回 <code>nums</code> 是否存在 <code>[nums[i], nums[j], nums[k]]</code>, 使得 <code>nums[i] + nums[j] + nums[k] == 0</code>, 其中 <code>i != j</code>, <code>i != k</code> 且 <code>j != k</code>。</p><p><strong>注意：</strong>答案中不可包含重複的 tuple。</p></blockquote><p><img src="https://i.imgur.com/yeEmHb3.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers</strong></p><ul><li><p>首先, 將 <code>nums</code> 由小到大做<strong>排序</strong></p><ul><li>用來避免取重複的 tuple, 並可使用 two pointer 來移動 ptr</li></ul></li><li><p>用 <code>i</code> 遍歷 <code>index = [0, n - 3]</code>, 得到 <code>nums[i]</code></p><ul><li>為了避免第一次取到與上一輪相同的元素，我們需要在這裡進行一次判斷並跳過</li><li>使用 Two pointer <code>left = i + 1</code>, <code>right = n - 1</code> 尋找滿足條件的 pair</li><li>若 <code>sum &lt; 0</code> : 則 <code>left + 1</code></li><li>若 <code>sum &gt; 0</code> : 則 <code>right - 1</code></li><li>若 <code>sum == 0</code> : 則將 tuple 加入到 <code>res</code> 中，由於還要檢查剩餘的元素中是否有滿足條件的。因此在加入 tuple 後，<code>left</code> 和 <code>right</code> 都需要跳過與當前元素相同的值</li></ul></li><li><p>注意：答案中不可包含重複的 tuple</p><ul><li>對於第一個元素，我們在判斷時已經確保不會與上一輪相同</li><li>對於第二和第三個元素，在加入 <code>res</code> 後，我們繼續遍歷剩餘元素時，需要判斷是否與上一個元素相同，如果相同則跳過</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// skip duplicates for the second element</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// skip duplicates for the third element</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// move pointers to the next elements with different values</span></span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ $O(n \cdot log(n))$ + $O(n^2)$<ul><li>$O(n \cdot log(n))$ : 排序 <code>nums</code></li><li>$O(n^2)$ : for loop 需 $O(n)$, 其中每一個元素用 two ptr 遍歷剩餘元素需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮 output array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/post/container-with-most-water/"/>
      <url>/post/container-with-most-water/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/container-with-most-water/">https://leetcode.cn/problems/container-with-most-water/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>height</code> 和一整數 <code>n</code>。有 <code>n</code> 條線其高度為 <code>height[i]</code>, 找出其中的兩條線，使得它們與 x 軸組成的容器可以容納最多的水。</p></blockquote><p><img src="https://i.imgur.com/9XQIlRp.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers</strong></p><ul><li>當前 area &#x3D; 兩條線中<strong>較短</strong>的高度 * 彼此間的距離</li><li><strong>移動較短</strong>那端的 ptr, 盡量保留較長的線</li></ul><p><strong>為何是移動較短那端的 ptr？</strong> 因為 area 是用<strong>下限</strong>計算的, 我們希望下限越高越好, 但是下限會受限於上限 ➔ 因此我們採取的策略為<strong>「維持上限、提升下限」</strong></p><p>e.g. <code>height = [1, 3, 5, 7]</code></p><ul><li><p>最一開始 <code>left = 0</code>, <code>right = 3</code> ➔ <code>nums[left] = 1</code>, <code>nums[right] = 7</code><br>此時 <code>area = min(1, 7) * (3 - 0) = 1 * 3 = 3</code></p><ul><li><p><strong>若移動 right</strong> : <code>left = 0</code>, <code>right = 2</code> ➔ <code>nums[left] = 1</code>, <code>nums[right] = 5</code><br>  此時 <code>area = min(1, 5) * (2 - 0) = 1 * 2 = 2</code> 反而更小了</p></li><li><p><strong>若移動 left</strong> : <code>left = 1</code>, <code>right = 3</code> ➔ <code>nums[left] = 3</code>, <code>nums[right] = 7</code><br>  此時 <code>area = min(3, 7) * (3 - 1) = 3 * 2 = 6</code></p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)  &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> area = <span class="built_in">min</span>(height[left], height[right]) * (right - left);</span><br><span class="line">            res = <span class="built_in">max</span>(res, area);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>height</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>217. Contains Duplicate</title>
      <link href="/post/contains-duplicate/"/>
      <url>/post/contains-duplicate/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/contains-duplicate/">https://leetcode.cn/problems/contains-duplicate/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 判斷當中是否有重複數字。</p></blockquote><p><img src="https://i.imgur.com/Er5lLKp.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先排序, 再用 loop 兩兩比較 <code>nums[i - 1]</code> 和 <code>nums[i]</code> 是否相等</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ sorting 後 data 仍儲存在 <code>nums</code> 中, 不需要額外空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 hash table 紀錄出現過的元素</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(num) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>s</code> 長度不超過 <code>n</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：比較 <code>nums</code> 和 <code>set(nums)</code> 長度是否相等, 若不相等代表有重複</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() != <span class="built_in">set</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()).<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 將 <code>nums</code> 轉成 <code>set(nums)</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>set(nums)</code> 長度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022. Convert 1D Array Into 2D Array</title>
      <link href="/post/convert-1d-array-into-2d-array/"/>
      <url>/post/convert-1d-array-into-2d-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/convert-1d-array-into-2d-array/">https://leetcode.cn/problems/convert-1d-array-into-2d-array/</a></strong></p><p><strong>題意：</strong>將 1d array <code>original</code> 轉成 <code>m</code> 列 <code>n</code> 行的 2d array。</p></blockquote><p><img src="https://i.imgur.com/Ys9chvQ.png"></p><p><img src="https://i.imgur.com/DMHTmAS.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：每次塞 <code>1 x n</code> 的 vector</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">construct2DArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; original, <span class="type">int</span> m, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m * n != original.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i += n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(original.<span class="built_in">begin</span>() + i, original.<span class="built_in">begin</span>() + i + n));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>original</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>338. Counting Bits</title>
      <link href="/post/counting-bits/"/>
      <url>/post/counting-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/counting-bits/">https://leetcode.cn/problems/counting-bits/</a></strong></p><p><strong>題意：</strong>給一整數 <code>n</code>, 對於 <code>0 ≤ i ≤ n</code> 中的每個 <code>i</code>, 計算其在二進制中 <code>1</code> 的個數, 返回一個長度為 <code>n + 1</code> 的 array 作為答案。</p></blockquote><p><img src="https://i.imgur.com/xLkiXO6.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：判斷 <code>i</code> 最靠右的 bit 是否為 <code>1</code>。若是的話, 則 <code>cnt++</code>, 每次判斷完後就將 <code>i</code> 右移一位, 直到 <code>i = 0</code>（沒有 1-bit）為止</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val = i; val &gt; <span class="number">0</span>; val &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> rightmost = val &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (rightmost == <span class="number">1</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ $n * O(log(n))$<ul><li>$O(log(n))$ : <code>n</code> 右移 <code>1</code> 位等價 <code>n</code> 除以 <code>2</code>, 令 <code>k</code> 為右移次數, $\dfrac{n}{2^k} &#x3D; 1$ ➔ $k &#x3D; log(n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要返回的 array, 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 因為透過觀察發現：</strong></p><p><strong>1. 前一數（偶數）的 1 之個數 + 1, 因為偶數最右邊的 bit 必為 0, 奇數多的就是最右邊的 bit</strong></p><ul><li>e.g. 3 &#x3D; 011, 2 &#x3D; 010 ➔ 故 3 的 1 之個數 &#x3D; 2 的 1 之個數 + 1</li></ul><p><strong>2. 偶數的 1 之個數 &#x3D; （該數 &#x2F; 2） 的 1 之個數, 因為偶數最右邊的 bit 必為 0, 所以偶數往右移一位, 該數的 1 之個數並不會減少</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = (i &amp; <span class="number">1</span>) ? dp[i - <span class="number">1</span>] + <span class="number">1</span> : dp[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $n * O(1)$<ul><li><code>dp[i]</code> 都是去存取先前已計算過的 <code>dp[i-1]</code> 或 <code>dp[i &gt;&gt; 1]</code>, 故每一次計算 <code>dp[i]</code> 故只需花 $O(1)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>271. Encode and Decode Strings</title>
      <link href="/post/encode-and-decode-strings/"/>
      <url>/post/encode-and-decode-strings/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/encode-and-decode-strings/">https://leetcode.cn/problems/encode-and-decode-strings/</a></strong></p><p><strong>題意：</strong>給一 string list <code>strs</code>, 請設計一演算法, 讓 encode 後的 string 可以透過網路高效傳輸, 並透過 decode 還原回原本的 string list。</p><p><strong>注意：</strong></p><ul><li>string 可能會包含所有的 ASCII char, 所以你設計的演算法要能處理任何可能出現的 char</li><li>請勿使用 <code>class member</code>、<code>global variable</code>、<code>static variable</code> 來儲存額外的狀態</li></ul></blockquote><p><img src="https://i.imgur.com/ftVLgXk.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：不能只在兩個 string 間只用一個分隔符 (delimiter) 隔開, 因為也有可能 input 中恰好有該分隔符組成的 string</strong></p><p>e.g. <code>delimiter = &#39;#&#39;</code>, <code>strs = [&#39;1&#39;, &#39;2#3&#39;]</code></p><p>這樣會得到錯誤的答案 <code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</code>, 而非 <code>[&#39;1&#39;, &#39;2#3&#39;]</code></p><p><strong>因此, 要額外紀錄每個 string 的長度：</strong></p><ul><li>Encode 時, 在每個 string <code>s</code> 前面加上長度 <code>s.size()</code> 和分割符 <code>#</code></li><li>Decode 時, 首先找出 idx <code>i</code> 往後的第一個 <code>#</code>, 假設其 idx 為 <code>j</code>, 則 <code>s[i, j)</code> 轉成 int 後即為 <code>s</code> 的長度。從 <code>j + 1</code> 往後(含)取 <code>s[i, j)</code> 個 char 即可得到當前的 <code>s</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a list of strings to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : strs) &#123;</span><br><span class="line">            ss &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;#&#x27;</span> &lt;&lt; s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a single string to a list of strings.</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">decode</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (s[j] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(i, j - i));</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(j + <span class="number">1</span>, len)); <span class="comment">// push 當前的 string</span></span><br><span class="line">            i = j + <span class="number">1</span> + len; <span class="comment">// 更新下一次開始的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><strong>encode：</strong>$O(n)$ ➔ <code>n</code> 為 <code>strs</code> 中所有 string 的總長度</li><li><strong>decode：</strong>$O(n)$ ➔ <code>n</code> 為 <code>s</code> 的長度</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 皆需要 $O(n)$ 來儲存原先所有的 string</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/post/group-anagrams/"/>
      <url>/post/group-anagrams/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a></strong></p><p><strong>題意：</strong>給一 string list <code>strs</code>, 其中 <code>strs[i]</code> 僅由小寫字母所組成, 將 <code>strs</code> 中的<strong>字母異位詞 (Anagram)</strong> 進行分組, 可按任意順序返回。</p><p><strong>字母異位詞 (Anagram) 定義 ：</strong>若 <code>s</code> 和 <code>t</code> 中每個字母的出現次數都相同, 則 <code>s</code> 和 <code>t</code> 互為字母異位詞。</p></blockquote><p><img src="https://i.imgur.com/EGOaFHh.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Sorting + hash table, 遍歷每個 string <code>s</code>, 並對其進行排序得到 string key, 將 <code>key</code> 和對應的 <code>s</code> 加入到 hash table 中。最後再根據 <code>key</code> 取出整個 group 即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : strs) &#123;</span><br><span class="line">            string key = s;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            groups[key].<span class="built_in">emplace_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, group] : groups) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(group);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot log(n))$ ➔ 其中 <code>m</code> 為 string 的個數, <code>n</code> 為 string 的平均長度。<ul><li>$O(n \cdot log(n))$：<code>s</code> 進行 sorting 的時間</li></ul></li><li><strong>space：</strong>$O(m \cdot n)$ ➔ hash table 中儲存所有的 string</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 hash table, 紀錄每個 string <code>s</code> 中每種 char 出現的頻率, 並把每種 char 的頻率當作是 key, 連同 <code>s</code> 一起加入到 hash table 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line">            <span class="function">string <span class="title">freqs</span><span class="params">(<span class="number">26</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>; <span class="comment">// 用 string 代替 vector 紀錄出現頻率</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : str) &#123;</span><br><span class="line">                freqs[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            groups[freqs].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [freq, group] : groups) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(group);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 所有 string 中每種 char 的出現頻率, 其中 <code>m</code> 為 <code>strs</code> 的元素個數, <code>n</code> 為 <code>strs[i]</code> 的平均長度</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>groups</code> 儲存所有的 string</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202. Happy Number</title>
      <link href="/post/happy-number/"/>
      <url>/post/happy-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></strong></p><p><strong>題意：</strong>判斷整數 <code>n</code> 是否為<strong>快樂數</strong>。</p><p><strong>快樂數</strong>的定義為：</p><ul><li>對於一正整數, 每次將該數轉換為它每一位數的平方和</li><li>重複此步驟直到該數為 <code>1</code>, 也有可能進入無窮迴圈（始終無法變成 <code>1</code> ）</li><li>如果該數能變成 <code>1</code>, 則它就是快樂數</li></ul><p>若 <code>n</code> 為快樂數, 則返回 <code>true</code>; 否則, 返回 <code>false</code>。</p></blockquote><p><img src="https://i.imgur.com/1nDigjm.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table 來記錄出現過的數, 一旦重複出現, 代表會無限循環</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s&#123;n&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">            n = <span class="built_in">squareSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(n) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">emplace</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ 令 <code>k</code> 為 <code>n</code> 除以 <code>10</code> 的次數, $\dfrac{n}{10^k} &#x3D; 1 ➔ k &#x3D; log(n)$</li><li><strong>space：</strong>$O(log(n))$ ➔ <code>s</code> 中儲存 $log(n)$ 次轉換後的元素</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：概念同 Solution 1, 只是改成利用 Two Pointers 來判斷是否出現重複的數, 可參考 <a href="https://zako945.github.io/post/linked-list-cycle/">141. Linked List Cycle</a>, <code>slow</code> 每次只轉換一次, 而 <code>fast</code> 每次轉換兩次</strong></p><ul><li>若存在循環（重複數）, 則 <code>slow</code> 和 <code>fast</code> 必相遇（<code>fast</code> 倒追 <code>slow</code>） ➔ <code>n</code> 不為快樂數</li><li>若不存在循環, 經過 <code>x</code> 步後 <code>fast</code> 必先變成 1, 然後再經過 <code>x</code> 步後 <code>slow</code> 才會接著變成 1</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="built_in">squareSum</span>(n);</span><br><span class="line">        <span class="type">int</span> fast = <span class="built_in">squareSum</span>(<span class="built_in">squareSum</span>(n));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = <span class="built_in">squareSum</span>(slow);</span><br><span class="line">            fast = <span class="built_in">squareSum</span>(<span class="built_in">squareSum</span>(fast));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ 令 <code>k</code> 為 <code>n</code> 除以 <code>10</code> 的次數, $\dfrac{n}{10^k} &#x3D; 1 ➔ k &#x3D; log(n)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>703. Kth Largest Element in a Stream</title>
      <link href="/post/kth-largest-element-in-a-stream/"/>
      <url>/post/kth-largest-element-in-a-stream/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">https://leetcode.cn/problems/kth-largest-element-in-a-stream/</a></strong></p><p><strong>題意：</strong>設計一個找到 stream 中第 <code>k</code> 大的元素。注意是排序後的第 <code>k</code> 大元素, 而非第 <code>k</code> 個不同的元素。</p><p><strong>實現 <code>KthLargest</code> class：</strong></p><ul><li><code>KthLargest(int k, int[] nums)</code>：使用 <code>k</code> 和 <code>nums</code> 來初始化 instance</li><li><code>int add(int val)</code>：將 <code>val</code> 加入倒 <code>nums</code> 中, 並返回第 <code>k</code> 大的元素</li></ul></blockquote><p><img src="https://i.imgur.com/wRrfh84.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution</strong>：</h2><blockquote><p><strong>想法：利用 Heap, 使用 min heap <code>pq</code> 來記錄前 <code>k</code> 大的元素, 其中 <code>pq.top()</code> 代表當前第 <code>k</code> 大的元素</strong></p><ul><li><code>KthLargest(k, nums)</code>：先 push <code>nums[i]</code>, 然後確認 <code>pq.size()</code> 是否 &gt; k。若是的話, 則把 <code>pq.top()</code> 給 pop 掉, 讓 <code>pq</code> 的元素個數維持在 <code>k</code> 個</li><li><code>add(val)</code>：先 push <code>val</code>, 然後確認 <code>pq.size()</code> 是否 <code>&gt; k</code>。若是的話, 則把 <code>pq.top()</code> 給 pop 掉, 讓 <code>pq</code> 的元素個數維持在 <code>k</code> 個</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        k_ = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="built_in">add</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k_) &#123;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> k_;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>KthLargest(k, nums)</code>：$O(n \cdot log(k))$, 其中 <code>n</code> 為 <code>nums</code> 中的元素個數, 因為 heap 要 add &#x2F; delete 元素皆需花 $O(log(k))$ 來調整 heap</li><li><code>add(val)</code>：$O(log(k))$ ➔ heap 要 add &#x2F; delete 元素皆需花 $O(log(k))$ 來調整 heap</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ <code>pq</code> 中的元素不超過 <code>k + 1</code> 個</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1065. Index Pairs of a String</title>
      <link href="/post/index-pairs-of-a-string/"/>
      <url>/post/index-pairs-of-a-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/index-pairs-of-a-string/">https://leetcode.cn/problems/index-pairs-of-a-string/</a></strong></p><p><strong>題意：</strong>給一 string <code>text</code> 和 string list <code>words</code>, 求所有 <code>index pair</code> 使得 <code>text[i~j]</code> 出現在 <code>words</code> 中。</p></blockquote><p><img src="https://i.imgur.com/ITZF5on.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：暴力搜尋法</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">indexPairs</span>(string text, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = text.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(words.begin(), words.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; m; ++start) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> end = start; end &lt; m; ++end) &#123;</span><br><span class="line">                <span class="type">const</span> string cur = text.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(cur) != wordSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;start, end&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令總共有 <code>n</code> 個 word, 其中 $w_i$ 代表 <code>words[i]</code> 的長度, 且 text 之長度為 <code>m</code></p><ul><li><strong>time：</strong>$O(m^2 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ 因為 c++ 的 <strong><code>find()</code></strong> 不是用 <strong>KMP</strong> 實作的<ul><li>$O(m^2)$：每次以 <code>start</code> 為起點往後遍歷, 取 <code>text[start:end]</code> 然後去判斷是否在 <code>wordset</code> 中<ul><li>$m + (m-1) + (m-2) + … + 1$ &#x3D; $\dfrac{(m+1)\cdot m}{2}$</li></ul></li><li>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$：每次判斷 <code>text[start:end]</code> 是否在 <code>wordset</code> 中</li></ul></li><li><strong>space：</strong>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ <code>wordset</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Trie(prefix tree), 可參考 <a href="https://zako945.github.io/post/implement-trie-prefix-tree/">208. Implement Trie (Prefix Tree)</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>; <span class="comment">// 預設每個 char 不為 end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[i]) &#123;</span><br><span class="line">                p-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>; <span class="comment">// 將最後一個 char 設為 end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">search</span>(<span class="type">const</span> string&amp; text)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = text.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; m; ++start) &#123;</span><br><span class="line">            TrieNode *p = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> end = start; end &lt; m &amp;&amp; p != <span class="literal">nullptr</span>; ++end) &#123;</span><br><span class="line">                p = p-&gt;children[text[end] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span> (p &amp;&amp; p-&gt;isEnd) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;start, end&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">indexPairs</span>(string text, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        Trie trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trie.<span class="built_in">search</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令總共有 <code>n</code> 個 word, 其中 $w_i$ 代表 <code>words[i]</code> 的長度, 且 text 之長度為 <code>m</code></p><ul><li><strong>time：</strong>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i + m^2)$<ul><li>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$ : insert 所有 word 到 Trie 中</li><li>$O(m^2)$ : 每次以 <code>start</code> 為起點往後遍歷, 判斷 <code>text[start:end]</code> 是否在 Trie 中<ul><li>$m + (m-1) + (m-2) + … + 1 &#x3D;$ $\dfrac{(m+1)\cdot m}{2}$</li></ul></li></ul></li><li><strong>space：</strong>$O(26 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ worse case : 每個 word 的 <code>prefix</code> 皆不重覆<ul><li>總共 <code>n</code> 個 word, 每一個 word 有 $w_i$ 個 node, 而每個 node 又有 26 個 children</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>226. Invert Binary Tree</title>
      <link href="/post/invert-binary-tree/"/>
      <url>/post/invert-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 反轉其左右子樹。</p></blockquote><p><img src="https://i.imgur.com/0KPB1wQ.png"></p><p><img src="https://i.imgur.com/UQcx1Lg.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ worse case：skew tree, 遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(cur-&gt;left, cur-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1046. Last Stone Weight</title>
      <link href="/post/last-stone-weight/"/>
      <url>/post/last-stone-weight/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/last-stone-weight/">https://leetcode.cn/problems/last-stone-weight/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>stones</code>, 其中 <code>stones[i]</code> 代表第 <code>i</code> 塊石頭的重量。</p><p>每一回合取出最重的兩塊石頭, 並將其互相撞擊。假設石頭的重量分別為 <code>x</code>、<code>y</code>, 且 <code>x ≤ y</code>。則撞擊後的可能結果如下：</p><ul><li>若 <code>x == y</code>, 則兩塊石頭都將完全粉碎</li><li>若 <code>x != y</code>, 則重量為 <code>x</code> 的石頭將完全粉碎, 而重量為 <code>y</code> 的石頭之新重量為 <code>y - x</code></li></ul><p>最後, 頂多剩下一塊石頭。若沒有石頭剩下, 則返回 <code>0</code>; 否則, 返回該石頭的重量。</p></blockquote><p><img src="https://i.imgur.com/tUYixRb.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap, 先將所有的元素 push 到 max heap <code>pq</code> 中, 再從 <code>pq</code> 中兩兩取出元素做運算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// max heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; stone : stones) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(stone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> y = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> x = <span class="built_in">getTop</span>(pq);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">emplace</span>(y - x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ 將所有的 stone push 到 <code>pq</code> 中、將所有 stone 取出來做運算, 其中 <code>n</code> 為 stone 的個數</li><li><strong>space：</strong>$O(n)$ ➔ <code>pq</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle</title>
      <link href="/post/linked-list-cycle/"/>
      <url>/post/linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></strong></p><p><strong>題意：</strong>判斷 linked list 中是否有 cycle。</p></blockquote><p><img src="https://i.imgur.com/Ylw08jF.png"></p><p><img src="https://i.imgur.com/m3WoSHi.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用兩個不同步長的 ptr, <code>slow</code> 每次只走一步, 而 <code>fast</code> 每次走兩步</strong></p><ul><li>若存在循環, 則 <code>slow</code> 和 <code>fast</code> 必相遇（<code>fast</code> 倒追 <code>slow</code>）</li><li>若不存在循環, <code>fast</code> 必先抵達 <code>nullptr</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷 fast, 因為若沒有 cycle, fast 會比較快抵達 nullptr</span></span><br><span class="line">        <span class="keyword">while</span> ( fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 一次走一步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 一次走兩步</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中的元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128. Longest Consecutive Sequence</title>
      <link href="/post/longest-consecutive-sequence/"/>
      <url>/post/longest-consecutive-sequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></strong></p><p><strong>題意：</strong>給一<strong>未排序的</strong> array <code>nums</code>, 找出數字連續的最長 sequence（sequence 元素不需在 <code>nums</code> 中位置連續）。</p><p><strong>注意：</strong>請設計 $O(n)$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/JkHCMuK.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將 <code>nums</code> 視覺化發現, 每個 sequence 形成的首要條件就是開頭的數左邊沒有數, 結尾的數右邊沒有數</strong></p><p><img src="https://i.imgur.com/RZNbX7F.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="comment">// 判斷左邊的數有無在 hash table 中</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(num - <span class="number">1</span>) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> end = num + <span class="number">1</span>; <span class="comment">// 則 num 可當作 sequence 的開頭</span></span><br><span class="line">                <span class="keyword">while</span> (s.<span class="built_in">find</span>(end) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, end - num); <span class="comment">// 檢查是否為最長 sequence</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 雖然有 for loop 和 while loop, 但是每一個數<strong>最多</strong>被訪問 &#96;2&#96;&#96; 次<ul><li>一次是 <code>for (const auto&amp; num : nums)</code></li><li>一次是 <code>if (s.find(num - 1) == s.end())</code>, 也就是剛好是某數的左邊</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>s</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>424. Longest Repeating Character Replacement</title>
      <link href="/post/longest-repeating-character-replacement/"/>
      <url>/post/longest-repeating-character-replacement/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">https://leetcode.cn/problems/longest-repeating-character-replacement/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code> 和一整數 <code>k</code>, 你可以選擇將 <code>s</code> 中的任意字元變成其他大寫英文字母, 該操作最多執行 <code>k</code> 次。</p><p>經上述操作後, 返回<strong>僅包含相同字元</strong>的最大 substring 長度。</p><p>s 由大寫英文字母所組成。</p></blockquote><p><img src="https://i.imgur.com/xPxWZv5.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 將 <code>window</code> 中的元素分成兩部分</strong></p><ul><li>出現頻率最多的元素</li><li>扣掉出現頻率最多的元素後，所剩餘的元素</li></ul><p><strong>若剩餘的元素個數 <code>≤ k</code>, 代表剩餘的元素可全部替換為頻率最多的元素。反之, 則不行。做完後, 更新 <code>res</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">window</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> c = s[right];</span><br><span class="line">            ++window[c - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若剩餘元素個數 &gt; k，則縮小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (right - left - *<span class="built_in">max_element</span>(window.<span class="built_in">begin</span>(), window.<span class="built_in">end</span>()) &gt; k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> d = s[left];</span><br><span class="line">                --window[d - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(26 \cdot n)$, <code>s</code> 中的每個元素最多被遍歷 2 次（<code>left</code>、<code>right</code>）<ul><li>$O(26 \cdot n)$：while loop 中每次取 <code>max_element()</code> 需 $O(26)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code></li></ul><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a><strong>Solution 2:</strong></h2><blockquote><p><strong>想法: 改善 Solution 1, 將 <code>max_element()</code> 提出, 變成在 while loop 外部維護, 而非在 while loop 中維護</strong></p><ul><li>能這樣做是因為在內層 while loop 中移除 <code>window[s[left]]</code> 後, <code>maxf</code> 只會<strong>越來越小</strong></li><li>也就是說 <code>right - left - maxf(移除前) ≥ right - left - maxf(移除後)</code> 始終是成立的, 因為 <code>maxf(移除後) ≤ maxf(移除前)</code></li><li>若 <code>right - left - maxf(移除前) &gt; k</code> 成立, 則 <code>right - left - maxf(移除後) &gt; k</code> 也必定成立, 因此根本不必在 while loop 中更新 <code>maxf</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> c = s[right];</span><br><span class="line">            ++window[c];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 widnow 中出現頻率最高的 char 的個數</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> maxf = <span class="built_in">max_element</span>(window.<span class="built_in">begin</span>(), window.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; p1, <span class="keyword">auto</span>&amp; p2)&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">            &#125;)-&gt;second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (right - left - maxf &gt; k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> d = s[left];</span><br><span class="line">                --window[d];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>s</code> 中的每個元素最多被遍歷 2 次（<code>left</code>、<code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code> 長度為 $O(26)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169. Majority Element</title>
      <link href="/post/majority-element/"/>
      <url>/post/majority-element/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/majority-element/">https://leetcode.cn/problems/majority-element/</a></strong></p><p><strong>題意：</strong>給一大小為 <code>n</code> 的 array <code>nums</code>, 找出當中個數<strong>大於</strong> $⌊ \dfrac{n}{2} ⌋$ 的數字(保證存在一個數滿足此條件)。</p><p><strong>進階：</strong>試著用 $O(n)$ time, $O(1)$ space 的演算法解決此問題</p></blockquote><p><img src="https://i.imgur.com/jvwdXOf.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table 紀錄 <code>&#123;num: count&#125;</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, maxCount = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; n : nums) &#123;</span><br><span class="line">            ++umap[n];</span><br><span class="line">            <span class="keyword">if</span> (umap[n] &gt; maxCount) &#123;</span><br><span class="line">                res = n;</span><br><span class="line">                maxCount = umap[n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>umap</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p>想法：利用 Boyer – Moore 投票法</p><ul><li>當 <code>res = 0</code> 時, 將 <code>res</code> 設為 <code>nums[i]</code></li><li>否則, 檢查 <code>nums[i]</code> 是否為 <code>res</code>。若是的話 <code>res + 1</code>, 否則 <code>res - 1</code></li></ul><p><img src="https://i.imgur.com/ySun2rW.png"></p><p><strong>考慮特殊 case</strong>:</p><ol><li><p><code>nums = [2,2,1,1,3]</code>, 得出 <code>res</code> &#x3D; 3</p><table><thead><tr><th>nums[i]</th><th>2</th><th>2</th><th>1</th><th>1</th><th>3</th></tr></thead><tbody><tr><td>cnt</td><td>1</td><td>2</td><td>1</td><td>0</td><td>1</td></tr><tr><td>res</td><td>2</td><td>2</td><td>2</td><td>2</td><td>3</td></tr></tbody></table></li><li><p><code>nums = [2,2,3,4,5]</code>, 得出 <code>res</code> &#x3D; 5</p><table><thead><tr><th>nums[i]</th><th>2</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>cnt</td><td>1</td><td>2</td><td>1</td><td>0</td><td>1</td></tr><tr><td>res</td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td></tr></tbody></table></li></ol><p>➔ 以上情況皆不會在本題出現, 因為 2 的個數並沒有 &gt; $⌊ \dfrac{5}{2} ⌋$<br>➔ <strong>而本題的先決條件就是必有一數的個數 &gt; $⌊ \dfrac{n}{2} ⌋$, 因此 Boyer – Moore 投票法在本題必成立</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                res = n;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt += (n == res) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/post/longest-substring-without-repeating-characters/"/>
      <url>/post/longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 返回一沒有重複 char 的<strong>最長 substring</strong> 的長度。</p></blockquote><p><img src="https://i.imgur.com/jg9qqTK.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 類似 <a href="https://zako945.github.io/post/longest-repeating-character-replacement/">424. Longest Repeating Character Replacement</a>, 每次檢查 <code>s[right]</code> 是否已經在 <code>visited</code> 中</strong></p><ul><li>若是, 則移除 <code>s[left]</code>, 且 <code>left + 1</code>, 直到 <code>visited</code> 中不存在 <code>s[right]</code></li><li>將 <code>s[right]</code> 加入到 <code>visited</code> 中</li><li>更新 <code>res</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); ++right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (visited.<span class="built_in">find</span>(s[right]) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                visited.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">emplace</span>(s[right]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>s</code> 中的每個元素最多被拜訪 <code>2</code> 次（<code>left</code>, <code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>cnt</code> 長度最多為 <code>26</code>, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104. Maximum Depth of Binary Tree</title>
      <link href="/post/maximum-depth-of-binary-tree/"/>
      <url>/post/maximum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求 <strong>root-to-leaf</strong> 的 path 之最大長度(tree 的最大深度)。</p><ul><li>最大長度：path 上的 <code>node</code> 數</li></ul></blockquote><p><img src="https://i.imgur.com/HasniTr.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ worse case : skew tree, 遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>252. Meeting Rooms</title>
      <link href="/post/meeting-rooms/"/>
      <url>/post/meeting-rooms/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/meeting-rooms/">https://leetcode.cn/problems/meeting-rooms/</a></strong></p><p><strong>題意：</strong>給定一包含開始時間和結束時間的 <code>intervals</code>, 其中<code>intervals[i] = [starti, endi]</code>, 返回一個人是否可以參加所有會議。</p><p><strong>注意：</strong><code>(0,8)</code>、<code>(8,10)</code> 並不衝突</p></blockquote><p><img src="https://i.imgur.com/3p0FW4o.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：先將 <code>intervals</code> 根據 <code>interval.start</code> 進行排序, 然後判斷當前 <code>interval[i - 1].end</code> 是否大於 <code>interval[i].start</code>。若是的話, 代表會衝突到</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canAttendMeetings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 不需要額外空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>617. Merge Two Binary Trees</title>
      <link href="/post/merge-two-binary-trees/"/>
      <url>/post/merge-two-binary-trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></strong></p><p><strong>題意：</strong>給兩棵 BT, 請合併它們。</p><ul><li>如果兩個節點重疊, 則將節點值相加作為合併節點的新值。</li><li>否則, 不為 NULL 的節點將作為新樹的節點。</li></ul></blockquote><p><img src="https://i.imgur.com/ggMDIUx.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root1) &#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root2) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// root1, root2 皆存在</span></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ stack 最大長度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>876. Middle of the Linked List</title>
      <link href="/post/middle-of-the-linked-list/"/>
      <url>/post/middle-of-the-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/middle-of-the-linked-list/">https://leetcode.cn/problems/middle-of-the-linked-list/</a></strong></p><p><strong>題意：</strong>返回 linked list 的中點, 若 linked list 的 node 數為偶數, 則返回<strong>第二個中點</strong>。</p></blockquote><p><img src="https://i.imgur.com/8nZD1k4.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers<br><code>slow</code> 一次走一步, <code>fast</code> 一次走兩步, 當 <code>fast</code> 走到 <code>NULL</code> 時, <code>slow</code> 剛好走到中點</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當 n 為偶數時, 跳出迴圈是因為 fast == NULL</span></span><br><span class="line">        <span class="comment">// 當 n 為奇數時, 跳出迴圈是因為 fast-&gt;nxt = NULL</span></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. Merge Two Sorted Lists</title>
      <link href="/post/merge-two-sorted-lists/"/>
      <url>/post/merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></strong></p><p><strong>題意：</strong>給兩個 <code>sorted</code> linked list: <code>list1</code> 和 <code>list2</code>, 將兩個合併成一個 <code>sorted</code> linked list。</p></blockquote><p><img src="https://i.imgur.com/CuDl9AB.png"></p><p><img src="https://i.imgur.com/uAf35hh.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 dummy node, 其中 <code>tail</code> 指向當前 <code>val</code> 較小的 list node</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail = tail-&gt;next; <span class="comment">// 指向下一個</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 某中一個 list 結束跳出迴圈, 要處理另一個 list 剩下的元素</span></span><br><span class="line">        <span class="keyword">if</span> (list1) &#123;</span><br><span class="line">            tail-&gt;next = list1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2) &#123;</span><br><span class="line">            tail-&gt;next = list2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 其中 <code>m</code> 為 <code>list1</code> 的長度, <code>n</code> 為 <code>list2</code> 的長度, worse case：每個點都恰拜訪一次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155. Min Stack</title>
      <link href="/post/min-stack/"/>
      <url>/post/min-stack/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/min-stack/">https://leetcode.cn/problems/min-stack/</a></strong></p><p><strong>題意：</strong>設計一個支持 <code>push</code>、<code>pop</code>、<code>top</code> 操作, 並且能在 $O(1)$ time 得到最小元素的 stack。</p><p><strong>實作 <code>MinStack</code> class：</strong></p><ul><li><code>MinStack()</code>：初始化 instance</li><li><code>void push(int val)</code>：將 <code>val</code> push 到 stack 中</li><li><code>void pop()</code>：移除 stack 頂端元素</li><li><code>void top()</code>：得到 stack 頂端元素</li><li><code>int getMin()</code>：得到 stack 中的最小元素</li></ul></blockquote><p><img src="https://i.imgur.com/8x7sde8.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用兩個 Stack, 其中 stack <code>stk</code> 紀錄元素 push &#x2F; pop 的過程, 另一個 stack <code>minStk.top()</code> 紀錄每一次 push 元素到 <code>stk</code> 後, 當前 <code>stk</code> 中的的最小值</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        <span class="comment">// 讓 minStk 初始有一個最大值, 這樣後續 push 時 minStk 一定有 top 元素可比較</span></span><br><span class="line">        minStk.<span class="built_in">emplace</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">emplace</span>(val);</span><br><span class="line">        minStk.<span class="built_in">emplace</span>(<span class="built_in">min</span>(minStk.<span class="built_in">top</span>(), val)); <span class="comment">// 新增元素後, 紀錄當前的最小元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        minStk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minStk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>皆為 $O(1)$</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 的元素個數最多為 <code>n</code>, <code>minStk</code> 的元素個數最多為 <code>n + 1</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>746. Min Cost Climbing Stairs</title>
      <link href="/post/min-cost-climbing-stairs/"/>
      <url>/post/min-cost-climbing-stairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>cost</code>, 其中 <code>cost[i]</code> 代表從第 <code>i</code> 皆樓梯往上爬所需支付的費用。一旦支付該費用, 可以選擇往上爬一個 or 二個台階。</p><p>可以選擇從 index 為 <code>0</code> or <code>1</code> 的位置開始往上爬。</p><p>請計算到達樓梯頂部 <code>index = cost.size()</code> 所需的最小費用。</p></blockquote><p><img src="https://i.imgur.com/SQZ2B6d.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 定義 <code>dp[i]</code> 為抵達 <code>index = i</code> 所需的最小費用, 因此 <code>dp[i]</code> 為 <code>抵達前一階的最小費用 + 該階的費用</code>、<code>抵達前兩階的最小費用 + 該階的費用</code> 中取較小者</strong></p><ul><li><code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123; <span class="comment">// index = 0 和 1 的費用都為 0</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為發現計算 <code>dp[i]</code> 只需用到 <code>dp[i - 1]</code>、<code>dp[i - 2]</code> 即可, 也就是說只需紀錄 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> 就好, 根本不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>; <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="type">int</span> two = <span class="number">0</span>; <span class="comment">// dp[i - 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">min</span>(one + cost[i - <span class="number">1</span>], two + cost[i - <span class="number">2</span>]);</span><br><span class="line">            two = one;</span><br><span class="line">            one = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111. Minimum Depth of Binary Tree</title>
      <link href="/post/minimum-depth-of-binary-tree/"/>
      <url>/post/minimum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求 <strong>root-to-leaf</strong> 的 path 之最小長度(tree 的最小深度)。</p><ul><li>最小長度: path 上的 <code>node</code> 數</li></ul><p><strong>注意：</strong>若今給一 skew tree, 則 <code>min_depth = n</code></p></blockquote><p><img src="https://i.imgur.com/tbUhkxE.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 需遍歷所有 node</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, stack 長度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 需遍歷所有 node</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, stack 長度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191. Number of 1 Bits</title>
      <link href="/post/number-of-1-bits/"/>
      <url>/post/number-of-1-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></strong></p><p><strong>題意：</strong>給一無號整數 <code>n</code>, 返回其二進制表示中 <code>1</code> 的個數。</p><p><strong>進階：</strong>如果多次呼叫此 function, 要如何優化？</p></blockquote><p><img src="https://i.imgur.com/hvYGLCW.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：每次判斷 <code>n</code> 的最右 bit 是否為 <code>1</code>, 若是的話, 則 <code>cnt++</code>, 判斷完最右 bit 後將 <code>n</code> 右移一位, 重複以上步驟直到 <code>n == 0</code> （沒有 1-bit）為止</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> rightmost = n &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (rightmost == <span class="number">1</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 因為 <code>n</code> 只有 <code>32</code> bit, 所以最多右移 <code>32</code> 次, 故為 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：<code>n &amp; (n-1)</code> 會讓 <code>n</code> 最右邊的 <code>1</code> 變為 <code>0</code>（重要）, 每做一次 <code>cnt++</code>, 直到 <code>n == 0</code> 為止</strong></p><p>e.g. <code>n = 100</code></p><p><img src="https://i.imgur.com/zB7GfKf.png"></p><p>e.g. <code>n = 101</code></p><p><img src="https://i.imgur.com/RyZlDKQ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 因為 <code>n</code> 只有 <code>32</code> bit, 所以最多右移 <code>32</code> 次, 故為 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268. Missing Number</title>
      <link href="/post/missing-number/"/>
      <url>/post/missing-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/missing-number/">https://leetcode.cn/problems/missing-number/</a></strong></p><p><strong>題意：</strong>原本有一包含 <code>[0, n]</code> 總共 <code>n + 1</code> 個數的 array, 今給一只有 <code>n</code> 個數的 array <code>nums</code>, 找出缺失的數。</p></blockquote><p><img src="https://i.imgur.com/qAxMn9S.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先將 <code>nums</code> 排序, 然後用 loop 檢查第 <code>i</code> 個數是否在 <code>nums</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>(); <span class="comment">// Example 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ sorting 後 data 仍儲存在 <code>nums</code> 中, 不需要額外空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：先計算 <code>[0, n]</code> 這 <code>n + 1</code> 個數之和, 然後扣掉 <code>nums</code> 中 data 之和, 即可得到缺失的數</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// 取得 nums 總和</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> total = nums.<span class="built_in">size</span>() * (nums.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 計算 0 ~ n 之和</span></span><br><span class="line">        <span class="keyword">return</span> total - sum; <span class="comment">// 相減即為缺值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍例 <code>nums</code> 計算所有 data 之和</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 XOR 中 <code>a ^ a = 0</code> 且 <code>0 ^ a = a</code> 的特性（還有交換性）</strong></p><p>e.g. <code>[0, 1, 2, 3] ^ [0, 1, 3] = 2</code></p><p><strong>XOR：</strong></p><ul><li><code>0 ^ 0 = 0</code></li><li><code>b ^ b = b</code></li><li><code>0 ^ a = a</code></li><li><code>a ^ b ^ b = a ^ (b ^ b) = a ^ 0 = a</code></li><li><strong>交換性：</strong><code>b ^ a ^ b = a ^ (b ^ b) = a ^ 0 = a</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res = res ^ i ^ nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/post/palindrome-linked-list/"/>
      <url>/post/palindrome-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></strong></p><p><strong>題意：</strong>判斷 linked list 是否迴文。</p></blockquote><p><img src="https://i.imgur.com/dCswt4N.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 <a href="https://zako945.github.io/post/middle-of-the-linked-list/">876. Middle of the Linked List</a> 的方法取得 linked list 的中點<br>然後 reverse 以 <code>slow</code> 為 head 的 linked list, 最後比較兩個 linked list 是否相等<br>(reverse linked list 可參考 <a href="https://zako945.github.io/post/reverse-linked-list/">206. Reverse Linked List</a>)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast != NULL 代表 linked list 之 node 個數為奇數</span></span><br><span class="line">        <span class="keyword">if</span> (fast) &#123;</span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 若為奇數, 則中點往後一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = <span class="built_in">reverse</span>(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slow-&gt;val != head-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112. Path Sum</title>
      <link href="/post/path-sum/"/>
      <url>/post/path-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></strong></p><p><strong>題意：</strong>給一 BT 和一整數 <code>targetSum</code>, 返回是否存在 <strong>root-to-leaf</strong> 之路徑總和為 <code>targetSum</code> 的 path。</p></blockquote><p><img src="https://i.imgur.com/i0rjjOX.png"></p><p><img src="https://i.imgur.com/8XRgIUG.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) ||</span><br><span class="line">               <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度最大長度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;); <span class="comment">// sum 初始設 0, 而非 root-&gt;val, 因為等等會加上 root-&gt;val</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> TreeNode* curNode = front.first;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> curSum = front.second + curNode-&gt;val;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若為 leaf</span></span><br><span class="line">            <span class="keyword">if</span> (!curNode-&gt;left &amp;&amp; !curNode-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curSum == targetSum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;curNode-&gt;left, curSum&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;curNode-&gt;right, curSum&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>567. Permutation in String</title>
      <link href="/post/permutation-in-string/"/>
      <url>/post/permutation-in-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/permutation-in-string/">https://leetcode.cn/problems/permutation-in-string/</a></strong></p><p><strong>題意：</strong>給兩 string <code>s1</code> 和 <code>s2</code>, 若 <code>s2</code> 包含 <code>s1</code> 的<strong>排列</strong>, 則返回 <code>true</code>。否則, 返回 <code>false</code>。</p><p><code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>substring</strong>。</p><p><strong>注意：</strong>substring 為連續的, subsequence 為非連續的</p></blockquote><p><img src="https://i.imgur.com/XbTG8Fb.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 類似 <a href="https://zako945.github.io/post/minimum-window-substring/">76. Minimum Window Substring</a></strong></p><ul><li>先不斷地增加 <code>right</code> 來擴大窗口</li><li>縮小窗口的時機是窗口大小 <code>≥ s1.size()</code> 時</li><li>當 <code>valid == need.size()</code> 時, 代表窗口中的 substring 為合法的排列</li></ul><p><strong>注意：這題是「固定長度」的窗口, 因為窗口每次向前滑動時只會移出一個字元, 故可以把內層的 while 改成 if, 其效果是一樣的</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right= <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window, need;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s1) &#123;</span><br><span class="line">            ++need[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> c = s2[right];</span><br><span class="line">            window[c]++;</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">find</span>(c) != need.<span class="built_in">end</span>() &amp;&amp; window[c] == need[c]) &#123;</span><br><span class="line">                ++valid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (right - left &gt;= s1.<span class="built_in">size</span>()) &#123; <span class="comment">// 固定窗口，可以改成 if 判斷</span></span><br><span class="line">                <span class="comment">// 存在排列 substring</span></span><br><span class="line">                <span class="keyword">if</span> (valid == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> d = s2[left];</span><br><span class="line">                <span class="keyword">if</span> (need.<span class="built_in">find</span>(d) != need.<span class="built_in">end</span>() &amp;&amp; window[d] == need[d]) &#123; <span class="comment">// 移出前相等</span></span><br><span class="line">                    --valid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                --window[d];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n1 + n2)$ ➔ 其中 <code>n1</code>、<code>n2</code> 分別為 <code>s1</code>、<code>s2</code> 的長度<ul><li>$O(n1)$：遍歷 <code>s1</code> 計算 <code>need</code></li><li>$O(n2)$：<code>s2</code> 中的每個元素最多被遍歷 <code>2</code> 次（<code>left</code>、<code>right</code>）</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code>、<code>need</code> 長度皆為 $O(26)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66. Plus One</title>
      <link href="/post/plus-one/"/>
      <url>/post/plus-one/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/plus-one/">https://leetcode.cn/problems/plus-one/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>digits</code> 用來表示一非負整數。返回該非負整數 + 1 後所表示的 <code>digits</code>。</p><p>非負整數的最高為儲存在 <code>digits</code> 的首位, 其中 <code>digits[i]</code> 只儲存單個數字。</p><p>除了 <code>0</code> 之外, 其他整數都不會以 <code>0</code> 作為開頭。</p></blockquote><p><img src="https://i.imgur.com/AGxIfBP.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：遍歷 <code>digits</code>, 並紀錄進位 <code>carry</code>。若最後 <code>carry</code> 為 <code>1</code>, 則在 <code>digits</code> 最前面補上 <code>1</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">1</span>; <span class="comment">// 因為最後一位要加 1, 所以把 carry 設成 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            digits[i] = carry + digits[i];</span><br><span class="line">            carry = digits[i] / <span class="number">10</span>;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            digits.<span class="built_in">emplace</span>(digits.<span class="built_in">begin</span>(), carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 改成一旦不用進位, 則終止循環（循環裡會不斷將 <code>digits[i] + 1</code>）, 並返回 digits</strong></p><ul><li><code>digits[i] &lt; 9</code>：代表不用進位, 將 <code>digits[i] + 1</code> 後, 終止循環並返回 <code>digits</code></li><li><code>digits[i] == 9</code>：代表要進位, 將 <code>digits[i]</code> 設為 <code>0</code>, 並繼續循環</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                ++digits[i];</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 執行到這裡, 代表原先 digits 裡的元素全為 9, 現在全變為 0 了</span></span><br><span class="line">        <span class="comment">// 因此在最前面加入 1 即可, e.g. 999 ➔ 000 ➔ 1000</span></span><br><span class="line">        digits.<span class="built_in">emplace</span>(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>238. Product of Array Except Self</title>
      <link href="/post/product-of-array-except-self/"/>
      <url>/post/product-of-array-except-self/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/product-of-array-except-self/">https://leetcode.cn/problems/product-of-array-except-self/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 返回一 array <code>answer</code>, 其中 <code>answer[i]</code> 為 <code>nums</code> 中除了 <code>nums[i]</code> 以外其餘元素的乘積, 乘積保證在 32-bit 整數的範圍內（不用考慮 overflow）。</p><p><strong>注意：請不要使用除法</strong>, 並在 $O(n)$ time 內解決此問題</p><p><strong>進階：</strong>請設計 $O(1)$ space 的演算法, 其中 output array 不算額外空間</p></blockquote><p><img src="https://i.imgur.com/CDIeTxS.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 prefix 和 postfix, 以 <code>index = i</code> 為分界, <code>prefix[i]</code> 記錄區間 <code>[0, i - 1]</code> 之乘積, <code>postfix[i]</code> 記錄區間 <code>[i + 1, n - 1]</code> 之乘積, 最後 <code>nums[i] = prefix[i] * postfix[i]</code> 即為題目所求</strong></p><ul><li><strong>prefix：</strong><code>prefix[i]</code> 紀錄 <code>num[0] ~ nums[i - 1]</code> 的乘積（由前往後填）</li><li><strong>postfix：</strong><code>postfix[n - i - 1]</code> 紀錄 <code>nums[n - 1] ~ nums[n - i]</code> 的乘積（由後往前填）</li><li><strong>nums：</strong><code>nums[i]</code> 紀錄 <code>prefix[i] * postfix[i]</code>, 也就是除了位置 <code>i</code> 剩餘其他數的乘積</li></ul><p>e.g. <code>nums = [1,2,3,4]</code></p><table><thead><tr><th>nums</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>prefix</td><td>1</td><td>1</td><td>2</td><td>6</td></tr><tr><td>postfix</td><td>24</td><td>12</td><td>4</td><td>1</td></tr><tr><td>nums</td><td>24</td><td>12</td><td>8</td><td>6</td></tr></tbody></table></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">postfix</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            prefix[i] = prefix[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">            postfix[n - i - <span class="number">1</span>] = nums[n - i] * postfix[n - i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = prefix[i] * postfix[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>prefix</code>, <code>postfix</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 將 <code>prefix</code> 直接儲存在 <code>res</code> 中, 然後計算出 <code>postfix</code> 後乘上對應的 <code>prefix</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nums:   [ <span class="number">1</span>,  <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">➔ res: [<span class="number">24</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>] <span class="comment">// postfix 做完</span></span><br><span class="line">➔ res: [<span class="number">24</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">6</span>] <span class="comment">// prefix 做完</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 計算 postfix</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[n - i - <span class="number">1</span>] = res[n - i] * nums[n - i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> prefix = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] *= prefix;</span><br><span class="line">            prefix *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 撇除要返回的 output array <code>res</code>, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>303. Range Sum Query - Immutable</title>
      <link href="/post/range-sum-query-immutable/"/>
      <url>/post/range-sum-query-immutable/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a></strong></p><p><strong>題意：</strong>給一 array, 多次輸入不同的 <code>left</code> 和 <code>right</code>, 求 array 中從 <code>idx = left</code> 到 <code>idx = right</code> 之和。</p></blockquote><p><img src="https://i.imgur.com/JfAhPC1.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法: 每一次 query 都去計算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        nums_ = <span class="built_in">move</span>(nums); <span class="comment">// 複製 nums</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            sum += nums_[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令 <code>query</code> 次數：<code>m</code> 次, <code>nums</code> 中元素個數：<code>n</code></p><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ <code>m</code> 次 query，每次 query 需 $O(n)$ 時間</li><li><strong>space：</strong>$O(n)$ ➔ <code>nums_</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Prefix Sum, 事先計算前 <code>i</code> 個數之和</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sums 紀錄前 i 個數之和</span><br><span class="line">nums: [-2,  0, 3, -5,  2, -1]</span><br><span class="line">sums: [-2, -2, 1, -4, -2, -3]</span><br><span class="line"></span><br><span class="line">range(left, right):</span><br><span class="line">    <span class="keyword">if</span> (left == 0) &#123; // e.g. range(0, 2)</span><br><span class="line">        <span class="built_in">sum</span> = sums[right]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; // e.g. range(2, 5) -&gt; -3 - (-2) = 1</span><br><span class="line">        <span class="built_in">sum</span> = sums[right] - sums[left-1]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sums = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sums[i] = sums[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sums[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sums[right] - sums[left - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令 <code>query</code> 次數：<code>m</code> 次, <code>nums</code> 中元素個數：<code>n</code></p><ul><li><strong>time：</strong>$O(m+n)$ ➔ $O(n)$ + $m * O(1)$<ul><li>$O(n)$ : 計算 prefix sum 的時間</li><li>$m * O(1)$ : <code>m</code> 次 query, 每次 query 只需 $O(1)$ 時間</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>sums</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>83. Remove Duplicates from Sorted List</title>
      <link href="/post/remove-duplicates-from-sorted-list/"/>
      <url>/post/remove-duplicates-from-sorted-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> linked list, 刪除 linked list 所有重複的元素, 讓每種元素恰好出現一次。</p></blockquote><p><img src="https://i.imgur.com/06GrNA5.png"></p><p><img src="https://i.imgur.com/51OBB5i.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：比較當前 node 和 下一個 node 的 val, 若相同則刪除下一個, 直到下一個的值不同, <code>cur</code> 才前進</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;val == curr-&gt;next-&gt;val) &#123;</span><br><span class="line">                curr-&gt;next = curr-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203. Remove Linked List Elements</title>
      <link href="/post/remove-linked-list-elements/"/>
      <url>/post/remove-linked-list-elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-linked-list-elements">https://leetcode.cn/problems/remove-linked-list-elements</a></strong></p><p><strong>題意：</strong>給一整數 <code>val</code>, 刪除 linked list 中所有 <code>node.val == val</code> 的 node。</p></blockquote><p><img src="https://i.imgur.com/zEGcTRx.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：用 <code>dummy</code> 來指向 head, <code>pre</code> 則記住當前 node 的前一個 node<br>初始化 <code>pre</code> 為 <code>dummy</code>(head 的前一個 node)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dummy 指向 link-list 之 head</span></span><br><span class="line">        <span class="type">const</span> ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *curr = head, *prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;val == val) &#123; <span class="comment">// 當前 node 要刪除</span></span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不刪除, 往下一個 node 前進, current node 變成前一個 node</span></span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>190. Reverse Bits</title>
      <link href="/post/reverse-bits/"/>
      <url>/post/reverse-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-bits/">https://leetcode.cn/problems/reverse-bits/</a></strong></p><p><strong>題意：</strong>給一無號整數 <code>n</code>, 請將其二進制進行反轉。</p></blockquote><p><img src="https://i.imgur.com/00zH6zZ.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：每次先把 <code>res</code> 的最右 bit 設為 <code>0</code>（左移一位, 最右 bit 補 0）, 然後取得 <code>n</code> 的最右 bit（對 <code>n</code> 的最右 bit 取 OR）, 做完後將 <code>n</code> 右移一位（捨棄最右 bit）</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>; <span class="comment">// 最右 bit 設 0</span></span><br><span class="line">            res |= (n &amp; <span class="number">1</span>); <span class="comment">// 得到 n 的最右 bit</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>; <span class="comment">// 捨棄最右 bit</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ for loop 只需 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="/post/reverse-linked-list/"/>
      <url>/post/reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></strong></p><p><strong>題意：</strong>反轉 linked-list。</p></blockquote><p><img src="https://i.imgur.com/JN4Kd2M.png"></p><p><img src="https://i.imgur.com/l7LB6ZU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：必須要有 <code>prev</code>, <code>nxt</code> 來記住前一個 node 和 下一個 node</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            nxt = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136. Single Number</title>
      <link href="/post/single-number/"/>
      <url>/post/single-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></strong></p><p><strong>題意：</strong>給一非空的 array <code>nums</code>, 當中只有一個數 <code>n1</code> 只出現一次, 找出 <code>n1</code>。</p></blockquote><p><img src="https://i.imgur.com/jhihJCU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 XOR 的特性, <code>a ^ a = 0</code> 且 <code>0 ^ b = b</code>, 還有交換性<br>e.g. <code>b ^ a ^ b = a ^ (b ^ b) = a ^ 0 = a</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            res ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>977. Squares of a Sorted Array</title>
      <link href="/post/squares-of-a-sorted-array/"/>
      <url>/post/squares-of-a-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> array <code>nums</code>, 求每個數字平方所組成的 <code>sorted</code> array。</p></blockquote><p><img src="https://i.imgur.com/pOCljbp.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 two pointers</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// res 從後面往前填(先填大的)</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(nums[left]) &gt; <span class="built_in">abs</span>(nums[right])) &#123;</span><br><span class="line">                res[i] = nums[left] * nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = nums[right] * nums[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ 扣除返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100. Same Tree</title>
      <link href="/post/same-tree/"/>
      <url>/post/same-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/same-tree/">https://leetcode.cn/problems/same-tree/</a></strong></p><p><strong>題意：</strong>給兩 BT, 求兩者是否相等。</p></blockquote><p><img src="https://i.imgur.com/0OPiUyV.png"></p><p><img src="https://i.imgur.com/tWUqJkw.png"></p><p><img src="https://i.imgur.com/7UBxdM2.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少其中一個為 null, 兩個都為 null 時, return true; 其他情況皆為 false</span></span><br><span class="line">        <span class="keyword">if</span> (!(p &amp;&amp; q)) &#123;</span><br><span class="line">            <span class="keyword">return</span> p == q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兩個皆不為 null</span></span><br><span class="line">        <span class="keyword">return</span> (p-&gt;val == q-&gt;val) &amp;&amp;</span><br><span class="line">               <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp;</span><br><span class="line">               <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(min(m, n))$ ➔ 其中 <code>m</code>、<code>n</code> 分別是兩個 BT 的 node 個數, 被訪問到的 node 個數不超過較小的 BT 之節點個數</li><li><strong>space：</strong>$O(min(m, n))$ ➔ 遞迴深度不超過較小的 BT 之節點個數</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 要注意 <code>nullptr</code> 也要 insert 到 queue 中, 否則下方範例會出錯</strong></p><p>e.g. <code>左邊 = [1, null, 2]</code>, <code>右邊 = [1, 2]</code></p><p><img src="https://i.imgur.com/ALYOTs3.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少其中一個為 null, 兩個都為 null 時, return true; 其他情況皆為 false</span></span><br><span class="line">        <span class="keyword">if</span> (!(p &amp;&amp; q)) &#123;</span><br><span class="line">            <span class="keyword">return</span> p == q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兩個皆不為 null</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        queue&lt;TreeNode*&gt; q2;</span><br><span class="line">        q1.<span class="built_in">emplace</span>(p);</span><br><span class="line">        q2.<span class="built_in">emplace</span>(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> n1 = q1.<span class="built_in">size</span>(), n2 = q2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n1 != n2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur1 = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur2 = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 這邊做判斷是為了避免下面出錯</span></span><br><span class="line">                <span class="keyword">if</span> (!(cur1 &amp;&amp; cur2)) &#123; <span class="comment">// 其中一個為 null</span></span><br><span class="line">                    <span class="keyword">if</span> (cur1 != cur2) &#123; <span class="comment">// 一個是 null, 一個不是</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兩個皆為 null</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur1-&gt;val != cur2-&gt;val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">addChild</span>(q1, cur1);</span><br><span class="line">                <span class="built_in">addChild</span>(q2, cur2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>() &amp;&amp; q2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// nullptr 也要 insert 到 queue 中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addChild</span><span class="params">(queue&lt;TreeNode*&gt;&amp; q, TreeNode* node)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">        q.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(min(m, n))$ ➔ 其中 <code>m</code>、<code>n</code> 分別是兩個 BT 的 node 個數, 被訪問到的 node 個數不超過較小的 BT 之節點個數</li><li><strong>space：</strong>$O(min(m, n))$ ➔ <code>q</code> 的元素個數不超過較小的 BT 之節點個數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>572. Subtree of Another Tree</title>
      <link href="/post/subtree-of-another-tree/"/>
      <url>/post/subtree-of-another-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/subtree-of-another-tree/">https://leetcode.cn/problems/subtree-of-another-tree/</a></strong></p><p><strong>題意：</strong>給兩棵 BT <code>root</code> 和 <code>subRoot</code>, 求 <code>subRoot</code> 是否為 <code>root</code> 之 subtree。</p></blockquote><p><img src="https://i.imgur.com/dnJkv2i.png"></p><p><img src="https://i.imgur.com/8JvUpJg.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 先判斷是否為 Same Tree（可參考 <a href="https://zako945.github.io/post/same-tree/">100. Same Tree</a>）<br>若不是的話, 則遞迴判斷 <code>subRoot</code> 是否為 <code>root</code> 之左子樹 or <code>root</code> 之右子樹</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!subRoot) &#123; <span class="comment">// subRoot == null, 則一定為 root 之 subtree</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root) &#123; <span class="comment">// root == null &amp;&amp; subRoot != null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSameTree</span>(root, subRoot)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubtree</span>(root-&gt;left, subRoot) ||</span><br><span class="line">               <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(p &amp;&amp; q)) &#123;</span><br><span class="line">            <span class="keyword">return</span> p == q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (p-&gt;val == q-&gt;val) &amp;&amp;</span><br><span class="line">               <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp;</span><br><span class="line">               <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>令 <code>root</code> 的 node 個數為 <code>m</code>, <code>subRoot</code> 的 node 個數為 <code>n</code><br>令 <code>root</code> 的深度為 <code>s</code>, <code>subRoot</code> 的深度為 <code>t</code></strong></p><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 對於 root 中的每個 node <code>s</code>, 都以 <code>s</code> 為 root 檢查 <code>n</code> 個 node</li><li><strong>space：</strong>$O(max(s, t))$ ➔ 遞迴最大深度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. Top K Frequent Elements</title>
      <link href="/post/top-k-frequent-elements/"/>
      <url>/post/top-k-frequent-elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和一整數 <code>k</code>, 返回出現頻率前 <code>k</code> 高的元素。可以按任何順序返回答案。</p><p><strong>進階：</strong>請設計 $O(n \cdot log(n))$ time 的演算法, 其中 <code>n</code> 為 <code>nums.size()</code>。</p></blockquote><p><img src="https://i.imgur.com/Niq9pgv.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap</strong></p><ul><li>計算每種元素的出現次數</li><li>直接將元素 push 到 min heap <code>pq</code> 中</li><li>若 <code>pq.size() &gt; k</code>, 代表現在 <code>pq</code> 中有 <code>k + 1</code> 個元素, 故把最小的元素給 pop 掉, 讓 <code>pq</code> 元素個數始終保持在 <code>k</code> 個</li><li>此時, <code>pq</code> 中的元素為前 <code>k</code> 大的元素, 將其取出即可</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freqs; <span class="comment">// &#123;num, freq&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            ++freqs[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [num, freq] : freqs) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(pii&#123;freq, num&#125;);</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) &#123; <span class="comment">// 讓 pq 始終儲存前 k 大的元素</span></span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>time: $O(n \cdot log(k))$ ➔ <code>pq</code> 最多 insert &#x2F; delete <code>n</code> 個點, 每次操作需 $O(log(k))$, 因為 <code>pq</code> 中最多 <code>k + 1</code> 個點, 其中 <code>n</code> 為 <code>nums</code> 的元素個數</li><li>space: $O(n)$ ➔ <code>freqs</code> 最大長度為 <code>n</code>, 而 <code>pq</code> 的最大長度為 <code>k + 1</code>, 其中 <code>n ≥ k</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/post/two-sum/"/>
      <url>/post/two-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和一整數 <code>target</code>, 求 <code>nums</code> 中兩數和剛好為 <code>target</code> 之 index, 假設每一種 <code>target</code> 只會對應到一組解。</p><p><strong>注意：</strong>同一個元素不可重複使用, 可按照任意順序返回。</p></blockquote><p><img src="https://i.imgur.com/zKI5XRV.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 hash table, 由於題目保證一定有解, 因此對 <code>nums[i]</code> 而言, 先去 hash table 中找 <code>target - nums[i]</code> 是否存在</strong></p><ul><li>若存在, 則直接返回</li><li>否則, 將 <code>nums[i]</code> 還有其 <code>index</code> 加入到 hash table 中</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;  <span class="comment">// &#123;value, index&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> search = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (umap.<span class="built_in">find</span>(search) != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, umap[search]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            umap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：$O(n)$</strong> ➔ <code>umap</code> 的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242. Valid Anagram</title>
      <link href="/post/valid-anagram/"/>
      <url>/post/valid-anagram/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a></strong></p><p><strong>題意：</strong>給兩 string <code>s</code> 和 <code>t</code>, 返回 <code>t</code> 是否為 <code>s</code> 的字母異位詞(Anagram) 則返回 <code>true</code>, 其中 <code>s</code> 和 <code>t</code> 僅由<strong>小寫</strong>字母所組成。</p><p><strong>字母異位詞 (Anagram) 定義：</strong>若 <code>s</code> 和 <code>t</code> 中每個字母的出現次數都相同, 則 <code>s</code> 和 <code>t</code> 互為字母異位詞。</p><p><strong>進階：</strong>若 input string 包含 Unicode char, 你要如何調整你的解法？</p></blockquote><p><img src="https://i.imgur.com/x5ZFFwG.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：將 <code>s</code>、<code>t</code> 進行排序, 若排序後 <code>s</code>、<code>t</code> 相等, 就代表為 anagram</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Array 來記錄每個字母的出現次數, 若 <code>s</code> 和 <code>t</code> 為 anagram, 則 <code>s 中每個字母的出現頻率 - t 中每個字母的出現頻率</code> 後, 每個字母的出現頻率應皆為 0</strong></p><p>e.g. <code>s = &quot;abc&quot;</code>, <code>t = &quot;cba&quot;</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">freqs</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freqs[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 s 和 t 長度相等的情況下, 若不為 anagram, 則必存在一 char 相減後的 freq &lt; 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--freqs[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code></li><li><strong>space：</strong>$O(1)$ ➔ $O(26)$, 只需常數空間</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 hash table, 概念同 Solution 1, 但是 Solution 1 只能解決 <code>s</code> 和 <code>t</code> 為小寫字母的問題, Solution 2 可解決 input string 包含 Unicode char 的問題</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freqs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freqs[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--freqs[ch] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code></li><li><strong>space：</strong>$O(S)$ ➔ $S$ 為 <code>s</code> 和 <code>t</code> union 後的 char set 之元素個數, 本題的 <code>S = 26</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167. Two Sum II - Input Array Is Sorted</title>
      <link href="/post/two-sum-ii-input-array-is-sorted/"/>
      <url>/post/two-sum-ii-input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/</a></strong></p><p><strong>題意：</strong>給一 index 從 <code>1</code> 開始的整數 array <code>numbers</code>, 該 array 已按照非遞減順序排列, 請從 <code>numbers</code> 中找出相加等於 <code>target</code> 的兩數之 index <code>index1</code>、<code>index2</code>, 其中 <code>1 ≤ index1 ≤ index2 ≤ numbers.length</code>。</p><p>假設每一種 <code>target</code> 只會對應到一組解, 且同一個元素不可重複使用。</p><p>請設計 $O(1)$ space 的演算法。</p></blockquote><p><img src="https://i.imgur.com/DVvXBxC.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：概念同 <a href="https://zako945.github.io/post/3sum/">15. 3Sum</a>, 由於 array 已排序, 故直接使用 Two Pointers 即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>numbers</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="/post/valid-palindrome/"/>
      <url>/post/valid-palindrome/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-palindrome/">https://leetcode.cn/problems/valid-palindrome/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 將其大寫轉換成小寫、並移除非字母和數字的 char, 返回轉換後是否為迴文。</p></blockquote><p><img src="https://i.imgur.com/9LPedjt.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two pointers, 若當前的 char 不為數字 or 字母則跳過, 直到 <code>left</code>、<code>right</code> 相會。判斷式為 <code>left &lt; right</code> 即可, 因為 <code>left == right</code> 時 <code>s[left]</code>、<code>s[right]</code> 必相等, 因此不用判斷</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 注意：這裡更新時還是要保持 left &lt; right</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update ptr</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>s</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. Valid Parentheses</title>
      <link href="/post/valid-parentheses/"/>
      <url>/post/valid-parentheses/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></strong></p><p><strong>題意：</strong>給一只包含 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、<code>&#39;&#123;&#39;</code>、<code>&#39;&#125;&#39;</code>、<code>&#39;[&#39;</code>、<code>&#39;]&#39;</code> 的 string <code>s</code>, 判斷 <code>s</code> 是否有效。</p><p>有效的定義如下：</p><ul><li>左括號必須有相同類型的右括號閉合</li><li>左括號必須以正確的順序閉合</li><li>每個右括號都有一個對應的相同類型之左括號</li></ul></blockquote><p><img src="https://i.imgur.com/1vJ8lkJ.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs.<span class="built_in">find</span>(ch) != pairs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>(); <span class="comment">// 若 stack 為空, 則代表有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; pairs = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code>, 其中 <code>n</code> 為 <code>s</code> 的長度</li><li><strong>space：</strong>$O(n)$ ➔ stack 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku</title>
      <link href="/post/valid-sudoku/"/>
      <url>/post/valid-sudoku/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-sudoku/">https://leetcode.cn/problems/valid-sudoku/</a></strong></p><p><strong>題意：</strong>判斷 <code>9 x 9</code> 數獨是否有效, 根據以下規則, 判斷已填入的數字是否有效即可。</p><ul><li>數字 <code>1 - 9</code> 在每一行只能出現一次</li><li>數字 <code>1 - 9</code> 在每一列只能出現一次</li><li>數字 <code>1 - 9</code> 在每一個 <code>3 x 3</code> 九宮格中只能出現一次</li></ul><p>空白格以 <code>&#39;.&#39;</code> 表示。</p></blockquote><p><img src="https://i.imgur.com/CZidDFe.png"></p><p><img src="https://i.imgur.com/TiCSPjx.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：一旦 <code>board[r][c]</code> 不為 <code>&#39;.&#39;</code>, 就去判斷該 row、col、block 是否有重複的 char</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> target = board[r][c];</span><br><span class="line">                <span class="keyword">if</span> (target == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isValidRow</span>(board, r, target)</span><br><span class="line">                    || !<span class="built_in">isValidCol</span>(board, c, target)</span><br><span class="line">                    || !<span class="built_in">isValidBlock</span>(board, r, c, target)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidRow</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span>&amp; row, <span class="type">const</span> <span class="type">char</span>&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> seen[<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidCol</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span>&amp; col, <span class="type">const</span> <span class="type">char</span>&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> seen[<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBlock</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span>&amp; row, <span class="type">const</span> <span class="type">int</span>&amp; col, <span class="type">const</span> <span class="type">char</span>&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> blockR = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> blockC = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">bool</span> seen[<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = blockR; r &lt; blockR + <span class="number">3</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = blockC; c &lt; blockC + <span class="number">3</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (seen[board[r][c] - <span class="string">&#x27;1&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                seen[board[r][c] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 每個 <code>board[r][c]</code> 判斷該 row、col、block 是否重複皆需 $O(9)$, 故總共需 $O((9 * 9) \cdot (3 * 9))$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
