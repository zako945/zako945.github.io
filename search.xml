<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>216. Combination Sum III</title>
      <link href="/post/combination-sum-iii/"/>
      <url>/post/combination-sum-iii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a></strong></p><p><strong>題意：</strong>找出所有相加之和為 <code>n</code> 的 <code>k</code> 個數的組合，且滿足下列條件：</p><ul><li>只使用數字 <code>1</code> 到 <code>9</code></li><li>每个數字<strong>最多使用一次</strong></li></ul><p>以<strong>任意順序</strong>返回所有可能的組合, 組合不能重複。</p></blockquote><p><img src="https://i.imgur.com/mF7XnYg.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> k, <span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; n) &#123; <span class="comment">// 剪枝</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取 j</span></span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">            <span class="built_in">dfs</span>(k - <span class="number">1</span>, n - j, j + <span class="number">1</span>);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot \binom{M}{k})$ ➔ 其中 <code>M</code> 為集合的大小，本題中 <code>M</code> 固定為 <code>9</code><ul><li>共 $\binom{M}{k}$ 種組合, 每建一種需判斷 <code>k</code> 次</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ $O(k) + O(k)$<ul><li>$O(k)$：<code>cur</code> 最大長度為 <code>k</code></li><li>$O(k)$：遞迴最大深度為 <code>k</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>377. Combination Sum IV</title>
      <link href="/post/combination-sum-iv/"/>
      <url>/post/combination-sum-iv/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/combination-sum-iv/">https://leetcode.cn/problems/combination-sum-iv/</a></strong></p><p><strong>題意：</strong>給一<strong>元素皆不同</strong>的array <code>nums</code> 和一整數 <code>target</code>, 返回總合為 <code>target</code> 的元素<strong>排列</strong>個數。</p><p>答案保證符合 32-bit 整數範圍（而非 32-bit 有號整數）</p><p><strong>進階：</strong>如果 <code>nums</code> 中允許有負數, 需要向題目中添加哪些限制條件?</p></blockquote><p><img src="https://i.imgur.com/qYgtgMl.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 DFS, 類似 <a href="https://zako945.github.io/post/combination-sum/">39. Combination Sum</a></strong></p><p><img src="https://i.imgur.com/LSY5gOu.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, target, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span>&amp; target, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            target -= num;</span><br><span class="line">            <span class="built_in">dfs</span>(nums, target, res);</span><br><span class="line">            target += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ 最差情況應為 $O(n \cdot 2^n)$, 但是遞迴時會用 <strong><code>num &gt; target</code></strong> 來進行<strong>剪枝(pruning)</strong>, 所以實際運行情況是<strong>遠小於</strong> $O(n \cdot 2^n)$ 的</li><li><strong>space：</strong>$O(target)$ ➔ 取決於遞迴深度, 最大遞迴深度為 <code>target</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 來避免重複計算, 其中 <code>dp[i]</code> 表示 <code>nums</code> 中加總為 <code>i</code> 之排列數, e.g. 下圖中紅框部分 <code>dp[2]</code> 重複計算, 故用 <code>dp</code> 保存計算過的結果</strong></p><p><img src="https://i.imgur.com/eKgssGQ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 總和為 0, 也就是任何元素都不取, 方法數為 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= target; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= num) &#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(target \cdot n)$ ➔ for loop, 其中 <code>n</code> 為 <code>nums</code> 的長度</li><li><strong>space：</strong>$O(target)$ ➔ <code>dp</code></li></ul><hr><h2 id="進階問題"><a href="#進階問題" class="headerlink" title="進階問題"></a><strong>進階問題</strong></h2><p>Q：如果 <code>nums</code> 中允許有負數, 需要向題目中添加哪些限制條件?</p><p>A：假設 <code>nums</code> 為 [a, -b] (其中 a &gt; 0, b &gt; 0), 且 <code>target</code> 為 0 ➔ a * (-b) + (-b) * a &#x3D; 0<br>在該排列的後面添加 b 個 a 和 a 個 -b 後, 得到的新排列的元素之和仍然等於 <code>target</code><br>➔ 如果允許負數出現, 則必須<strong>限制排列的最大長度</strong>, 避免出現無限長度的排列, 這樣才能計算排列數</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>77. Combinations</title>
      <link href="/post/combinations/"/>
      <url>/post/combinations/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></strong></p><p><strong>題意：</strong>給兩個整數 <code>n</code> 和 <code>k</code>, 以<strong>任意順序</strong>返回 <code>[1, n]</code> 中所有可能的 <code>k</code> 個數<strong>組合</strong>。</p></blockquote><p><img src="https://i.imgur.com/YrPe1tx.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：取每個 <code>i</code> 輪流當開頭, 其中 <code>i</code> 的範圍是 <code>[1, n]</code>, 並從 <code>[i + 1, n]</code> 取 <code>k - 1</code> 個（從 <code>i + 1</code> 取必不會重複到前面）。<code>dfs()</code> 中的 for loop 是取 <code>j + 1</code>, 因為若取 <code>i + 1</code>, 則當 <code>j &gt; i + 1</code> 後, 便會取到重複的組合。</strong><br>e.g. <code>n = 3, k = 2</code>,  其中 <code>[1, 2]</code>, <code>[2, 1]</code> 不能同時出現</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++j) &#123;</span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">            <span class="built_in">dfs</span>(j + <span class="number">1</span>, n, k - <span class="number">1</span>);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot \binom{n}{k})$ ➔ $\binom{n}{k}$ 種組合, 每種組合需 $O(k)$ time</li><li><strong>space：</strong>$O(k \cdot \binom{n}{k})$ ➔ $O(k) + O(k \cdot \binom{n}{k}) + O(k)$<ul><li>$O(k)$：<code>dfs()</code> 最大遞迴深度</li><li>$O(k \cdot \binom{n}{k})$：$\binom{n}{k}$ 種組合, 每種組合長度為 <code>k</code></li><li>$O(k)$：<code>cur</code> 最大長度</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>373. Find K Pairs with Smallest Sums</title>
      <link href="/post/find-k-pairs-with-smallest-sums/"/>
      <url>/post/find-k-pairs-with-smallest-sums/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/</a></strong></p><p><strong>題意</strong>：給兩個<strong>升序排列</strong>的 array <code>nums1</code> 和 <code>nums2</code>。</p><p>定義 pair <code>(u, v)</code>, 其中 <code>u</code> 來自 <code>nums1</code>, <code>v</code> 來自 <code>nums2</code></p><p>求和最小的 <code>k</code> 個 pair</p></blockquote><p><img src="https://i.imgur.com/UPRj530.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Heap, 解法同 <a href="https://zako945.github.io/post/kth-smallest-element-in-a-sorted-matrix/">378. Kth Smallest Element in a Sorted Matrix</a>, <code>pair</code> 分別存 <code>nums1</code> 第 <code>i</code> 個元素、<code>nums2</code> 第 <code>j</code> 個元素 (只存 index, 不存 val), 然後用 <code>minHeap</code> 取最小的 <code>sum(nums1[i], nums2[j])</code></strong></p><p><img src="https://i.imgur.com/txLwhgc.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 重要: 將 nums1, nums2 傳入 cmp 中</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重要: 自定義 priority_queue 的 cmp 函數, 請牢記 heap 預設為 !cmp</span></span><br><span class="line">        <span class="comment">// 故 minHeap 要用 greater&lt;T&gt;, 且 cmp 裡面是判斷第一個 &gt; 第二個</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將第一行元素加到 minHeap 中, k 的個數有可能小於 m</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(k, m); i++) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [i, j] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot log(k))$<ul><li>$O(k)$：while loop, 其中 worse case 為 <code>k = mn</code></li><li>$O(log(k))$：insertion of heap(因為 heap 是 balanced tree, <code>swap()</code> 最多為樹高 $log(k)$ 次)</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ <code>minHeap</code> 最多 <code>k</code> 個元素</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 解法同 <a href="https://zako945.github.io/post/kth-smallest-element-in-a-sorted-matrix/">378. Kth Smallest Element in a Sorted Matrix</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">count</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span>&amp; mid)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 只需 O(m+n) time, 因為 nums1 遞增, 若 i 變大, 則 j 變小</span></span><br><span class="line">        <span class="comment">// 假設 i = 0 做完, j = 10</span></span><br><span class="line">        <span class="comment">// 則 i = 1 時, j 從 10 繼續(pos 不用重設成 nums2.size() - 1)</span></span><br><span class="line">        <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = nums2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums1[i] + nums2[j] &gt; mid) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt += (j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">long</span> left = nums1[<span class="number">0</span>] + nums2[<span class="number">0</span>];</span><br><span class="line">        <span class="type">long</span> right = nums1.<span class="built_in">back</span>() + nums2.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">count</span>(nums1, nums2, mid) &lt; k) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> pairSum = left;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res1, res2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>() &amp;&amp; nums1[i] + nums2[j] &lt;= pairSum; ++j) &#123;</span><br><span class="line">                <span class="comment">// sum &lt; pairSum 的 pair 一定會取</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[i] + nums2[j] &lt; pairSum) &#123;</span><br><span class="line">                    res1.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// sum == pairSum 的 pair 不一定會取(有可能很多個, 導致最後超過 k 個)</span></span><br><span class="line">                    <span class="comment">// 故用另一個 vector 存</span></span><br><span class="line">                    res2.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 從 res2 中取 k - res1.size() 個</span></span><br><span class="line">        <span class="comment">// 也有可能 res2 沒那麼多個給你取(k取太大, 沒那麼多pair), 故要取 min</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> remain = <span class="built_in">min</span>(k - res1.<span class="built_in">size</span>(), res2.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; remain; ++i) &#123;</span><br><span class="line">            res1.<span class="built_in">emplace_back</span>(res2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O((m+n) \cdot log(r-l) + m \cdot n)$ ➔ <code>m</code> 為 <code>nums1.size()</code>, <code>n</code> 為 <code>nums2.size()</code><ul><li>$O(log(r-l))$：Binary Search 次數</li><li>$O(m+n)$：<code>count()</code> 所需時間</li><li>$O(m \cdot n)$：for loop, 有用 <code>nums1[i] + nums2[j] ≤ pairSum</code> 做 pruning, 實際遠小於 <code>mn</code> 次</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 扣除要返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>162. Find Peak Element</title>
      <link href="/post/find-peak-element/"/>
      <url>/post/find-peak-element/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>nums</code>, 找到峰值並返回其 index。<code>nums</code> 中可能有多個峰值, 返回<strong>任何一個</strong>峰值的 index 即可。</p><p>假設 <code>nums[-1] = nums[n] = -∞</code></p><p>設計 $O(log(n))$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/vyhitL2.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 從一個位置開始, 不斷地向高處走, 那麼最終一定可以到達一個峰值位置, 根據比較 <code>nums[i − 1]</code>, <code>nums[i]</code>, <code>nums[i + 1]</code> 三個位置的值來縮小左邊界 or 右邊界, 有以下幾種情況：</strong></p><ol><li><code>nums[i − 1] &lt; nums[i] &gt; nums[i + 1]</code> : <code>i</code> 即為峰值</li><li><code>nums[i − 1] &lt; nums[i] &lt; nums[i + 1]</code> : <code>i</code> 處於上坡, 峰值在右半邊, 故縮小<strong>左</strong>邊界</li><li><code>nums[i − 1] &gt; nums[i] &gt; nums[i + 1]</code> : <code>i</code> 處於下坡, 峰值在左半邊, 故縮小<strong>右</strong>邊界</li><li><code>nums[i − 1] &gt; nums[i] &lt; nums[i + 1]</code> : <code>i</code> 處於山谷, 兩側都是上坡, 可以朝任意方向走(這邊我們選擇往右走, 故縮小<strong>左</strong>邊界)</li></ol><p>分析前面四種可能的情況, 我們選擇比較 <strong><code>nums[i]</code>、 <code>nums[i + 1]</code></strong><br>➔ <strong>因為這樣可將情況 1、3 是視作一類, 而情況 2、4 視作另一類</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>320. Generalized Abbreviation</title>
      <link href="/post/generalized-abbreviation/"/>
      <url>/post/generalized-abbreviation/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/generalized-abbreviation/">https://leetcode.cn/problems/generalized-abbreviation/</a></strong></p><p><strong>題意：</strong>寫一函式來生成一個單字的通用縮寫, 以<strong>任意順序</strong>返回。</p></blockquote><p><img src="https://i.imgur.com/jvA4EsG.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：每個 char 都有「取縮寫 or 不取縮寫」兩種選擇, 其中用 <code>num</code> 代表在 <code>word[i]</code> 前面取縮寫的連續 char 數</strong></p><ul><li><strong>取縮寫</strong>：<code>i + 1</code>, 且 <code>num + 1</code>, 並進入下一輪遞迴</li><li><strong>不取縮寫</strong>：<ul><li>若 <code>num != 0</code>：<ul><li>將 <code>num</code> 加入到 <code>cur</code> 中, 並將 <code>num</code> 歸零</li><li>將 <code>word[i]</code> 加入到 <code>cur</code> 中, 並進入下一輪遞迴</li></ul></li><li>若 <code>num == 0</code>：<ul><li>將 <code>num</code> 歸零</li><li>將 <code>word[i]</code> 加入到 <code>cur</code> 中, 並進入下一輪遞迴</li></ul></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateAbbreviations</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        string cur;</span><br><span class="line">        <span class="built_in">dfs</span>(word, <span class="number">0</span>, word.<span class="built_in">size</span>(), cur, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; word, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n, string cur, <span class="type">const</span> <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                cur += <span class="built_in">to_string</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// word[i] 取縮寫</span></span><br><span class="line">        <span class="built_in">dfs</span>(word, i + <span class="number">1</span>, n, cur, num + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// word[i] 不取縮寫（共通點：word[i] 加入到 cur 中, 故將 word[i] 提出）</span></span><br><span class="line">        cur += (num == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : <span class="built_in">to_string</span>(num)) + word[i];</span><br><span class="line">        <span class="built_in">dfs</span>(word, i + <span class="number">1</span>, n, cur, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$<ul><li>每個 char 都有兩種選擇 ➔ 總共 $2^n$ 種</li><li>建構每一種需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array <code>res</code>, 則取決於遞迴深度, 最大遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 由於本題不需剪枝, 且每個 char 都有「取縮寫 or 不取縮寫」兩種選擇, 故用 Bit Manipulation 比較方便（狀態壓縮）。</strong></p><ul><li>首先, 遍歷 <code>00...0</code> 到 <code>11...1</code> 所有 <code>n</code> 位的二進位狀態（所有 char 的選擇總共有 $2^n$ 種）, 並定義：<ul><li>若某 bit 為 <code>0</code>, 就代表對應位置的 char 不取縮寫</li><li>若某 bit 為 <code>1</code>, 就代表對應位置的 char 取縮寫</li></ul></li><li><strong>若第 <code>i</code> 個 bit 要取縮寫</strong>：<ul><li>往後遍歷也要縮寫的連續 char, 直到遇到不縮寫的 char（假設其 <code>index = j</code>）</li><li>將縮寫的長度加入到 <code>cur</code> 中</li><li>將 <code>i</code> 設為 <code>j - 1</code> ➔ 下一輪循環, <code>i</code> 將從 <code>j</code> 開始往後遍歷</li></ul></li><li><strong>若第 <code>i</code> 個 bit 不取縮寫</strong>：<ul><li>將 <code>word[i]</code> 加入到 <code>cur</code> 中, 並進入下一輪遞迴</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateAbbreviations</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = word.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> state = <span class="number">0</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); ++state) &#123; <span class="comment">// 遍歷所有二進位狀態</span></span><br><span class="line">            string cur;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 遍歷該狀態所有 char 是否要縮寫</span></span><br><span class="line">                <span class="function">i <span class="title">f</span><span class="params">((state &gt;&gt; i) &amp; <span class="number">1</span>)</span> </span>&#123; <span class="comment">// 若第 i 個 char 要縮寫</span></span><br><span class="line">                    <span class="comment">// 往後遍歷也要縮寫的連續 char, 直到遇到不縮寫的 char</span></span><br><span class="line">                    <span class="type">int</span> j = i;</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; (state &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        ++j;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> len = j - i; <span class="comment">// 縮寫的長度</span></span><br><span class="line">                    cur += <span class="built_in">to_string</span>(len);</span><br><span class="line">                    i = j - <span class="number">1</span>; <span class="comment">// 下一輪 i 從 j 開始繼續往後遍歷 char</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur += word[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$<ul><li>每個 char 都有兩種選擇 ➔ 總共 $2^n$ 種</li><li>建構每一種需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array <code>res</code>, 則取決於 <code>cur</code> 的長度（<code>cur</code> 長度不超過 <code>n</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>986. Interval List Intersections</title>
      <link href="/post/interval-list-intersections/"/>
      <url>/post/interval-list-intersections/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/</a></strong></p><p><strong>題意</strong>：給一 <code>n x n</code> matrix, 其中每行、每列各自按照<strong>升序</strong>排序, 返回 matrix 中第 <code>k</code> 小的元素。</p><p><strong>注意</strong>：它是<strong>排序</strong>後第 <code>k</code> 小的元素, 而不是第 <code>k</code> 個不同的元素</p><p>e.g. matrix &#x3D; <code>[[1,2], [2,3]]</code>, <code>k = 3</code>, 答案是 2</p><p>➔ 因為排序後 <code>[1, 2, 2, 3]</code> 中第 3 小的是 2, 重複數不能只算一次（不能看做 <code>[1, 2, 3]</code>）</p><p>設計 $O(n^2)$ time 的演算法</p><p><strong>進階</strong>：設計 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/iY11wGp.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Heap, 由於 matrix 是已排序好的, 所以 (i, j) 的值一定比 (i + 1, j) 和 (i, j + 1) 的值小, 演算法可參考此影片, 簡單來說分成以下步驟：</strong></p><ol><li>取出 min heap 的 top, 也就是當前最小</li><li>insert top 的右方和下方到 heap 中 (同位置不能重複 insert)</li><li>從 heap 中取出 <code>k - 1</code> 個 top 後, 剩餘 heap 中的 top 即為第 <code>k</code> 小的數</li></ol><p><img src="https://i.imgur.com/TB2A0PC.png"></p><p><strong>min Heap 定義</strong>：任意 parent 的值一定比 children 的都小</p><p><img src="https://i.imgur.com/knIJ15m.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coord</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> r, c, val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Coord</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val) : <span class="built_in">r</span>(i), <span class="built_in">c</span>(j), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Coord&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &gt; a.val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>)); <span class="comment">// 避免重複 insert</span></span><br><span class="line">        priority_queue&lt;Coord, vector&lt;Coord&gt;, greater&lt;Coord&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(<span class="number">0</span>, <span class="number">0</span>, matrix[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pop 掉前 k - 1 小的數, 則 pq.top() 即為第 k 小的數</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [r, c, val] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 top 下方 insert 到 pq 中</span></span><br><span class="line">            <span class="keyword">if</span> (r + <span class="number">1</span> &lt; n &amp;&amp; !visited[r + <span class="number">1</span>][c]) &#123;</span><br><span class="line">                visited[r + <span class="number">1</span>][c] = <span class="literal">true</span>;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(r + <span class="number">1</span>, c, matrix[r + <span class="number">1</span>][c]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 top 右方 insert 到 pq 中</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; n &amp;&amp; !visited[r][c + <span class="number">1</span>]) &#123;</span><br><span class="line">                visited[r][c + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(r, c + <span class="number">1</span>, matrix[r][c + <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot log(n))$<ul><li>$O(k)$：for loop, 其中 worse case 為 $k &#x3D; n^2$</li><li>$O(log(n))$：insertion of heap(因為 heap 是 balanced tree, <code>swap()</code> 最多為樹高 $log(n)$ 次)</li></ul></li><li><strong>space：</strong>$O(n^2)$ ➔ <code>visited</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：Solution 1 的改進, 藍色數字代表 minHeap 中元素(初始為第一行的元素), 彈出 minHeap 最小的後, 將該元素右邊一格加入到 heap 中成為下一個候選人</strong></p><p><img src="https://i.imgur.com/WX4nfyA.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coord</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> r, c, val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Coord</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val) : <span class="built_in">r</span>(i), <span class="built_in">c</span>(j), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Coord&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &gt; a.val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;Coord, vector&lt;Coord&gt;, greater&lt;Coord&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將第一行元素加到 minHeap 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            minHeap.<span class="built_in">emplace</span>(r, <span class="number">0</span>, matrix[r][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [r, c, val] = minHeap.<span class="built_in">top</span>();</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 top 右邊一格還沒越界, 則將其加入到 heap 中</span></span><br><span class="line">            <span class="keyword">if</span> (c != n - <span class="number">1</span>) &#123;</span><br><span class="line">                minHeap.<span class="built_in">emplace</span>(r, c + <span class="number">1</span>, matrix[r][c + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minHeap.<span class="built_in">top</span>().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot log(n))$<ul><li>$O(k)$：for loop, 其中 worse case 為 $k &#x3D; n^2$</li><li>$O(log(n))$：insertion of heap(因為 heap 是 balanced tree, <code>swap()</code> 最多為樹高 $log(n)$ 次)</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>minHeap</code> 中最多 <code>n</code> 個元素</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 其中 <code>left = matrix[0][0]</code>, <code>right = matrix[n - 1][n - 1] + 1</code>, 得出 <code>mid</code> 後, 計算 <code>matrix</code> 中 <code>≤ mid</code> 的個數 <code>cnt</code> (可參考 240. Search a 2D Matrix II 的 Z 字形搜索), 希望找到一個 <code>mid</code> 使得 <code>matrix</code> 中剛好有 <code>k</code> 個數 <code>≤ mid</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>], right = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">count_less_equal</span>(n, matrix, mid) &gt;= k) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// left 為第一個有 k 個數 &gt;= 自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 計算 matrix 中 ≤ mid 的元素個數, 此處也可以改成用 binary search 實作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_less_equal</span><span class="params">(<span class="type">int</span>&amp; n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span>&amp; mid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; n &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] &lt;= mid) &#123;</span><br><span class="line">                cnt += (col + <span class="number">1</span>);</span><br><span class="line">                ++row;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --col;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(r-l))$ ➔ <code>r</code> 代表 <code>right</code>, <code>l</code> 代表 <code>left</code><ul><li>$O(log(r-l))$：Binary Search 的次數</li><li>$O(n)$：計算 <code>cnt</code> 的時間 $O(n+n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>378. Kth Smallest Element in a Sorted Matrix</title>
      <link href="/post/kth-smallest-element-in-a-sorted-matrix/"/>
      <url>/post/kth-smallest-element-in-a-sorted-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/</a></strong></p><p><strong>題意</strong>：給一 <code>n x n</code> matrix, 其中每行、每列各自按照<strong>升序</strong>排序, 返回 matrix 中第 <code>k</code> 小的元素。</p><p><strong>注意</strong>：它是<strong>排序</strong>後第 <code>k</code> 小的元素, 而不是第 <code>k</code> 個不同的元素</p><p>e.g. matrix &#x3D; <code>[[1,2], [2,3]]</code>, k &#x3D; <code>3</code>, 答案是 2</p><p>➔ 因為排序後 <code>[1, 2, 2, 3]</code> 中第 3 小的是 2, 重複數不能只算一次（不能看做 <code>[1, 2, 3]</code>）</p><p>設計 $O(n^2)$ time 的演算法</p><p><strong>進階</strong>：設計 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/iY11wGp.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Heap, 由於 matrix 是已排序好的, 所以 <code>(i, j)</code> 的值一定比 <code>(i + 1, j)</code> 和 <code>(i, j + 1)</code> 的值小, 演算法可參考此影片, 簡單來說分成以下步驟：</strong></p><ol><li>取出 min heap 的 top, 也就是當前最小</li><li>insert top 的右方和下方到 heap 中 (同位置不能重複 insert)</li><li>從 heap 中取出 <code>k - 1</code> 個 top 後, 剩餘 heap 中的 top 即為第 <code>k</code> 小的數</li></ol><p><img src="https://i.imgur.com/TB2A0PC.png"></p><p><strong>min Heap 定義</strong>：任意 parent 的值一定比 children 的都小</p><p><img src="https://i.imgur.com/knIJ15m.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coord</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> r, c, val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Coord</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val) : <span class="built_in">r</span>(i), <span class="built_in">c</span>(j), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Coord&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &gt; a.val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>)); <span class="comment">// 避免重複 insert</span></span><br><span class="line">        priority_queue&lt;Coord, vector&lt;Coord&gt;, greater&lt;Coord&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(<span class="number">0</span>, <span class="number">0</span>, matrix[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pop 掉前 k - 1 小的數, 則 pq.top() 即為第 k 小的數</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [r, c, val] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 top 下方 insert 到 pq 中</span></span><br><span class="line">            <span class="keyword">if</span> (r + <span class="number">1</span> &lt; n &amp;&amp; !visited[r + <span class="number">1</span>][c]) &#123;</span><br><span class="line">                visited[r + <span class="number">1</span>][c] = <span class="literal">true</span>;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(r + <span class="number">1</span>, c, matrix[r + <span class="number">1</span>][c]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 top 右方 insert 到 pq 中</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; n &amp;&amp; !visited[r][c + <span class="number">1</span>]) &#123;</span><br><span class="line">                visited[r][c + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(<span class="built_in">Coord</span>(r, c + <span class="number">1</span>, matrix[r][c + <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot log(n))$<ul><li>$O(k)$：for loop, 其中 worse case 為 $k &#x3D; n^2$</li><li>$O(log(n))$：insertion of heap（因為 heap 是 balanced tree, <code>swap()</code> 最多為樹高 $log(n)$ 次）</li></ul></li><li><strong>space：</strong>$O(n^2)$ ➔ <code>visited</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：Solution 1 的改進, 藍色數字代表 minHeap 中元素(初始為第一行的元素), 彈出 minHeap 最小的後, 將該元素右邊一格加入到 heap 中成為下一個候選人</strong></p><p><img src="https://i.imgur.com/WX4nfyA.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coord</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> r, c, val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Coord</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val) : <span class="built_in">r</span>(i), <span class="built_in">c</span>(j), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Coord&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &gt; a.val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;Coord, vector&lt;Coord&gt;, greater&lt;Coord&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將第一行元素加到 minHeap 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            minHeap.<span class="built_in">emplace</span>(r, <span class="number">0</span>, matrix[r][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [r, c, val] = minHeap.<span class="built_in">top</span>();</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 top 右邊一格還沒越界, 則將其加入到 heap 中</span></span><br><span class="line">            <span class="keyword">if</span> (c != n - <span class="number">1</span>) &#123;</span><br><span class="line">                minHeap.<span class="built_in">emplace</span>(r, c + <span class="number">1</span>, matrix[r][c + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minHeap.<span class="built_in">top</span>().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot log(n))$<ul><li>$O(k)$：for loop, 其中 worse case 為 $k &#x3D; n^2$</li><li>$O(log(n))$：insertion of heap（因為 heap 是 balanced tree, <code>swap()</code> 最多為樹高 $log(n)$ 次）</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>minHeap</code> 中最多 <code>n</code> 個元素</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 其中 <code>left = matrix[0][0]</code>, <code>right = matrix[n - 1][n - 1] + 1</code>, 得出 <code>mid</code> 後, 計算 <code>matrix</code> 中 <code>≤ mid</code> 的個數 <code>cnt</code> (可參考 240. Search a 2D Matrix II 的 Z 字形搜索), 希望找到一個 <code>mid</code> 使得 <code>matrix</code> 中剛好有 <code>k</code> 個數 <code>≤ mid</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>], right = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">count_less_equal</span>(n, matrix, mid) &gt;= k) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// left 為第一個有 k 個數 &gt;= 自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 計算 matrix 中 ≤ mid 的元素個數, 此處也可以改成用 binary search 實作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_less_equal</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">const</span> <span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; n &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] &lt;= mid) &#123;</span><br><span class="line">                cnt += (col + <span class="number">1</span>);</span><br><span class="line">                ++row;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --col;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(r-l))$ ➔ <code>r</code> 代表 <code>right</code>, <code>l</code> 代表 <code>left</code><ul><li>$O(log(r-l))$：Binary Search 的次數</li><li>$O(n)$：計算 <code>cnt</code> 的時間 $O(n+n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>142. Linked List Cycle II</title>
      <link href="/post/linked-list-cycle-ii/"/>
      <url>/post/linked-list-cycle-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></strong></p><p><strong>題意</strong>：給一 linked list 的 <code>head</code>, 返回 cycle 的起點。若無 cycle, 則返回 <code>null</code>。</p><p><strong>進階</strong>：設計 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/zAmBxdg.png"></p><p><img src="https://i.imgur.com/viHTrL4.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：定義以下變數</strong></p><ul><li><code>L</code> 是起始點和 cycle head 的距離</li><li><code>x</code> 是 cycle head 到第一次相遇的距離</li><li><code>C</code> 是整個 cycle 的長度</li></ul><p><strong>第一次相遇可以寫成一個等式：<code>2(L + x) = L + nC + x</code><br>其中, <code>L + x</code> 為烏龜走的步數, <code>L + nC + x</code> 為兔子走的步數<br><code>nC</code> 代表兔子率先進入 cycle, 在和烏龜第一次相遇之前可能已經繞 cycle 好幾圈了</strong></p><p><strong><code>2(L + x) = L + nC + x</code> 可化簡成 <code>L + x = nC</code></strong></p><ul><li><p>讓烏龜<strong>回到原點, 然後走 <code>L</code> 步抵達 cycle head</strong></p></li><li><p>兔子則在<strong>第一次相遇的地方 <code>(L+x)</code> 走 <code>L</code> 步</strong><br>此時兔子的新位置在 <code>(L + x) + L = nC + L</code> 也就是在 cycle head<br>(<code>nC + L</code> 可看成從起點走 <code>L</code> 步到達 cycle head, 然後繞了 cycle <code>n</code> 圈, 位置仍在 cycle head)</p><p>  <img src="https://i.imgur.com/ytJsHG3.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ cycle 長度不超過 <code>n</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>452. Minimum Number of Arrows to Burst Balloons</title>
      <link href="/post/minimum-number-of-arrows-to-burst-balloons/"/>
      <url>/post/minimum-number-of-arrows-to-burst-balloons/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/</a></strong></p><p><strong>題意</strong>：有一些氣球貼在 XY 平面上, 給一 array <code>points</code>, 其中 <code>points[i] = [x_start, x_end]</code> 代表氣球水平直徑在 <code>x_start</code> 和 <code>x_end</code> 的氣球。</p><p>一支弓箭可沿著 <code>x</code> 軸<strong>完全垂直</strong>地射出。在座標 <code>x</code> 射出弓箭, 若有一個氣球的直徑滿足 <code>x_start **≤** x **≤** x_end</code>, 則該氣球會被<strong>引爆</strong>。弓箭被射出後, 可以無限地前進。</p><p>返回引爆所有氣球的<strong>最小</strong>弓箭數。</p></blockquote><p><img src="https://i.imgur.com/CcoEOgh.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p>想法：利用 Greedy, 每增加一支箭, 想辦法讓那支箭盡可能地引爆多一點的氣球。每一支箭的射出位置為「所有氣球中右邊界位置最靠左的」可以引爆最多氣球。如果某個氣球的起始點大於 end, 說明前面的箭無法覆蓋到當前的氣球, 那麼就得再來一支箭</p><p>e.g. <code>points = [[1, 10], [2, 7], [8, 11]]</code>+</p><ul><li>當只有 <code>[[1, 10]</code>, <code>[2, 7]]</code> 時, 此時弓箭射在 <code>x = 7</code> 的位置可同時引爆這兩個氣球, 而下一個氣球的 start 必須 <code>≤ 7</code> 才能用同一支箭引爆</li><li>但下一個為 <code>[8, 11]</code>, 所以必須要新增一支箭</li></ul><p><img src="https://i.imgur.com/f4j4N7B.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort by start</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= end) &#123; <span class="comment">// 若有重疊, 則縮小右邊界, 必須考慮到先前的氣球</span></span><br><span class="line">                end = <span class="built_in">min</span>(end, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若無重疊, 則更新右邊界, 換下一支箭</span></span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p>想法：同 Solution 1, 只是 sort by end</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort by end</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 若無重疊, 則更新右邊界, 換下一支箭</span></span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; end) &#123;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>673. Number of Longest Increasing Subsequence</title>
      <link href="/post/number-of-longest-increasing-subsequence/"/>
      <url>/post/number-of-longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">https://leetcode.cn/problems/number-of-longest-increasing-subsequence/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 返回最長<strong>嚴格遞增</strong> subsequence 的個數。</p></blockquote><p><img src="https://i.imgur.com/BcNceHo.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：可看到下圖 5 的部分重複計算, 故利用 DP, <code>dp[i]</code> 代表 <code>nums[i]</code> 開頭的最大 LIS 長度</strong></p></blockquote><p><img src="https://i.imgur.com/MaJFevy.png"></p><p><img src="https://i.imgur.com/8CZhrRR.png"></p><ul><li><strong>特殊情況: 最長的 LIS 不只一個, 則 cnt 要相加</strong></li></ul><p><img src="https://i.imgur.com/1s86oUw.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span> , <span class="title">cnt</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> maxLis = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i] &lt; dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        cnt[i] = cnt[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                        cnt[i] += cnt[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; maxLis) &#123;</span><br><span class="line">                maxLis = dp[i];</span><br><span class="line">                res = cnt[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == maxLis) &#123;</span><br><span class="line">                res += cnt[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code> 和 <code>cnt</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>328. Odd Even Linked List</title>
      <link href="/post/odd-even-linked-list/"/>
      <url>/post/odd-even-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/odd-even-linked-list/">https://leetcode.cn/problems/odd-even-linked-list/</a></strong></p><p><strong>題意</strong>：給一 single linked list 的 <code>head</code>, 將奇數位置的 node 分組在一起, 然後是偶數位置的 node 分組在一起, 然後將偶數組 linked list 串接在奇數組 linked list 後面。</p><p><strong>注意</strong>：奇數組和偶數組內的相對順序應和輸入中的順序相同。</p><p>設計 $O(n)$ time 且 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/fk4XkgO.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：用兩個奇偶 pointers 分別指向奇偶 linked list 的起始位置, 另外需要一個單獨的 pointer evenHead 來保存偶數組 linked list 的起點位置</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *evenHead = head-&gt;next;</span><br><span class="line">        ListNode *odd = head, *even = evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷是否有偶奇節點</span></span><br><span class="line">        <span class="keyword">while</span> (odd-&gt;next &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">            odd-&gt;next = odd-&gt;next-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = even-&gt;next-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        odd-&gt;next = evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>698. Partition to K Equal Sum Subsets</title>
      <link href="/post/partition-to-k-equal-sum-subsets/"/>
      <url>/post/partition-to-k-equal-sum-subsets/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code> 和一正整數 <code>k</code>, 返回是否能把 <code>nums</code> 拆分成 <code>k</code> 的非空 subset, 且每個 subset 元素總和皆相等。</p><p><strong>注意</strong>：<code>nums.length ≤ 16</code></p></blockquote><p><img src="https://i.imgur.com/8BFDcbQ.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：總共有 <code>n</code> 顆球、<code>k</code> 個桶子, 以「球」為視角, 每顆球都有 <code>k</code> 個桶子可以選擇, 每個桶子的容量為 <code>target = sum / k</code>。</strong></p><p>e.g. <code>nums = [1, 2, 2, 4, 3, 3], k = 3</code></p><p><img src="https://i.imgur.com/pUMHQhG.png"></p><p><img src="https://i.imgur.com/TXUKjNx.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123; <span class="comment">// 無法分成 k 個相同的 subset</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(k, target)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nums 由大到小排序, 大的先做有利於剪枝</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>(), buckets, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; buckets, <span class="type">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 代表 n 顆球都能放入桶內, 不需用 for loop 檢查每個桶是否為 0</span></span><br><span class="line">        <span class="comment">// 因為前面已經判斷過 (sum % k) 是否為 0</span></span><br><span class="line">        <span class="comment">// 所以只要 n 顆球都能放入桶內, 每個桶之元素和必為 target</span></span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每顆球都有 k 個選擇</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; buckets[j]) &#123; <span class="comment">// buckets[i] 剩餘容量不足, 則跳過</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果當前桶和上一個桶內的元素和相等, 則跳過</span></span><br><span class="line">            <span class="comment">// 因為當前這顆球放在當前桶和上一個桶都是一樣的, 對後面的球如何擺放沒有影響</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; buckets[j - <span class="number">1</span>] == buckets[j]) &#123; <span class="comment">// 剪枝</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buckets[j] -= nums[i]; <span class="comment">// 將球放入桶中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遞迴窮舉下一顆球的所有情況, 返回是否能將所有球放入桶中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n, buckets, k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buckets[j] += nums[i]; <span class="comment">// 若不行, 則撤銷, 往下一個桶嘗試</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// nums[i] 無法放入任何桶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k^n)$ ➔ 每個顆都有 <code>k</code> 個桶子可以選擇桶子, 所以組合出的結果為 $k^n$ 種</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, stack 中每一層代表第 <code>i</code> 顆球選擇哪個桶子, 總共 <code>n</code> 層</li></ul><h2 id="Solution-2：（TLE-無法通過）"><a href="#Solution-2：（TLE-無法通過）" class="headerlink" title="Solution 2：（TLE 無法通過）"></a><strong>Solution 2：</strong>（<strong>TLE 無法通過）</strong></h2><blockquote><p><strong>想法：</strong>總共有 <code>n</code> 顆球、<code>k</code> 個桶子, 以「桶子」為視角（每個桶子都會遍歷所有球）, 每顆球有 <code>2</code> 種選擇（選 or 不選）, 每個桶子都有 $O(2^n)$ 種選擇。</p><p>e.g. <code>nums = [1, 2, 2, 4, 3, 3], k = 3</code></p><p><img src="https://i.imgur.com/d19Byj6.png"></p><p><img src="https://i.imgur.com/tMshhhb.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123; <span class="comment">// 無法分成 k 個相同的 subset</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(k, target)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>; <span class="comment">// 紀錄第 i 顆球是否已被使用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, used, <span class="number">0</span>, buckets, k - <span class="number">1</span>); <span class="comment">// 從最後一個桶開始放球</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; buckets, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 因為前面已經判斷過 (sum % k) 是否為 0</span></span><br><span class="line">        <span class="comment">// 若 k - 1 個桶子已放滿, 則剩下的球之和必為 target, 必能放入最後一個桶</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// buckets[k] 已被填滿, 故從下一個桶子開始放（i 設 0 是因為下一桶要遍歷所有球）</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, used, <span class="number">0</span>, buckets, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="comment">// 球已放入別的桶子 or 當前桶的容量不足, 則跳過</span></span><br><span class="line">            <span class="keyword">if</span> (used[j] || nums[j] &gt; buckets[k]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將球放入當前桶</span></span><br><span class="line">            buckets[k] -= nums[j];</span><br><span class="line">            used[j] = <span class="literal">true</span>; <span class="comment">// 將球標記為已用過</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// 遞迴窮舉下一顆球的所有情況, 下一顆球仍是從第 k 個桶開始放</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(nums, used, j + <span class="number">1</span>, buckets, k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將球從當前桶取出</span></span><br><span class="line">            buckets[k] += nums[j];</span><br><span class="line">            used[j] = <span class="literal">false</span>; <span class="comment">// 將球標記為未使用過</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// buckets[k] 無法放入任何球</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot 2^n)$<ul><li>每個桶要遍歷 <code>n</code> 顆球, 每顆球都有 2 種選擇(選 or 不選), 所以組合的結果有 $2^n$ 種</li><li>總共有 <code>k</code> 個桶, 故為 $O(k \cdot 2^n)$</li></ul></li><li><strong>space：</strong>$O(k \cdot n)$ ➔ 取決於遞迴深度, 每個桶子最多有 <code>n</code> 次選擇（<code>n</code> 層）, 總共 <code>k</code> 個桶, 故為 $O(k \cdot n)$</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, 之所以會 TLE 是因為會重複計算, 必須儲存已使用球的狀態來進行剪枝</strong></p><p><img src="https://i.imgur.com/GkJCeuG.png"></p><p><img src="https://i.imgur.com/ORVu1Yz.png"></p><ul><li>剪枝<ul><li><code>used array</code> 可以認為一 backtracking 過程中的狀態。可以用一個 <code>memo</code> 來記錄每種情況的 <code>used</code> 返回 <code>true</code> 或 <code>false</code>。如果當前的 <code>used</code> 狀態是曾經出現過的, 那就不用再繼續窮舉了</li><li>根據題目給的 <code>nums.length ≤ 16</code>, 所以我們可以用「<strong>狀態壓縮</strong>」的技巧, 用 <strong><code>int</code></strong> 類型的 used 來<strong>替代 used array</strong>, 其中 <code>used</code> 中最右邊的編號為 <code>0</code>（e.g. <code>used = 3 = 00...0011</code>, 代表 <code>nums[0]</code> 和 <code>nums[1]</code> 已被使用）</li><li>為了方便查找, 我們利用 hash map 來記錄每一種 <code>used</code> 狀態返回的是 <code>true</code> 還是 <code>false</code></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123; <span class="comment">// 無法分成 k 個相同的 subset</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(k, target)</span></span>;</span><br><span class="line">        <span class="type">int</span> used = <span class="number">0</span>;  <span class="comment">// 紀錄每個數字是否被拜訪過</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, used, <span class="number">0</span>, buckets, k - <span class="number">1</span>); <span class="comment">// 從最後一個桶開始放球</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; memo; <span class="comment">// memo 儲存每一種 used 狀態</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span>&amp; used, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; buckets, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 因為前面已經判斷過 (sum % k) 是否為 0</span></span><br><span class="line">        <span class="comment">// 若 k - 1 個桶子已放滿, 則剩下的球之和必為 target, 必能放入最後一個桶</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// buckets[k] 已被填滿, 故從下一個桶子開始放, 且必須儲存球的狀態</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">bool</span> res = <span class="built_in">dfs</span>(nums, used, <span class="number">0</span>, buckets, k - <span class="number">1</span>);</span><br><span class="line">            memo[used] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果出現過 used 這種情況, 則直接返回結果</span></span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">find</span>(used) != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[used];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((used &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 球已放入別的桶子, 則跳過</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; buckets[k]) &#123; <span class="comment">// 當前桶的容量不足, 則跳過</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將球放入當前桶</span></span><br><span class="line">            buckets[k] -= nums[j];</span><br><span class="line">            used |= (<span class="number">1</span> &lt;&lt; j); <span class="comment">// 用 OR 將球標記為已用過</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// 遞迴窮舉下一顆球的所有情況, 下一顆球仍是從第 k 個桶開始放</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(nums, used, j + <span class="number">1</span>, buckets, k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將球從當前桶取出</span></span><br><span class="line">            buckets[k] += nums[j];</span><br><span class="line">            used ^= (<span class="number">1</span> &lt;&lt; j); <span class="comment">// 用 XOR 將球標記為未使用過</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// buckets[k] 無法放入任何球</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot 2^n)$<ul><li>每個桶要遍歷 <code>n</code> 顆球, 每顆球都有 2 種選擇(選 or 不選), 所以組合的結果有 $2^n$ 種</li><li>總共有 <code>k</code> 個桶, 故為 $O(k \cdot 2^n)$</li></ul></li><li><strong>space：</strong>$O(2^n)$ ➔ <code>memo</code> 最大長度為 $2^n$, 因為最多 $2^n$ 種狀態</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>852. Peak Index in a Mountain Array</title>
      <link href="/post/peak-index-in-a-mountain-array/"/>
      <url>/post/peak-index-in-a-mountain-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/">https://leetcode.cn/problems/peak-index-in-a-mountain-array/</a></strong></p><p><strong>題意</strong>：如果以下屬性成立，我們就稱 <code>arr</code> 為山。</p><ul><li><code>arr.length &gt;= 3</code></li><li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i]</code></li><li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul><p>找到 <code>arr</code> 的山峰 <code>idx = i</code>, 滿足<code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></p></blockquote><p><img src="https://i.imgur.com/8Yv9RHU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 不斷找中點, 並和後面一數比較, 判斷要往左邊還右邊來縮小範圍</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt;= arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>47. Permutations II</title>
      <link href="/post/permutations-ii/"/>
      <url>/post/permutations-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></strong></p><p><strong>題意：</strong>給一含重複數的 array <code>nums</code>, 按<strong>任意順序</strong>返回所有不重複的排列。</p></blockquote><p><img src="https://i.imgur.com/mrbT2DO.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：類似 <a href="https://zako945.github.io/post/permutations/">46. Permutations</a>, 只是要排除掉相同數當頭<br>e.g. [1, 1, 2]</strong></p><ul><li>1 當頭 : [1, <strong>1</strong>, 2], [1, 2, <strong>1</strong>]</li><li><strong>1</strong> 當頭 : [<strong>1</strong>, 1, 2], [1, <strong>1</strong>, 2]<br>➔ 重複排列, 故要記住哪些數當過開頭, 若後面遇到做過開頭的數則不做 swap, 直接跳過</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(nums[j]) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 避免重複排列</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s.<span class="built_in">emplace</span>(nums[j]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n);</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot n!)$ ➔ 總共 $n!$ 種排列, 每一種要 $O(n)$</li><li><strong>space：</strong>$O(n \cdot n!)$ ➔ $O(n) + O(n \cdot n!)$<ul><li>$O(n)$：<code>dfs()</code> 遞迴最大深度</li><li>$O(n \cdot n!)$：最多 $n!$ 種排列, 每種排列的長度都為 <code>n</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>92. Reverse Linked List II</title>
      <link href="/post/reverse-linked-list-ii/"/>
      <url>/post/reverse-linked-list-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></strong></p><p><strong>題意</strong>：給一 single linked list 的 <code>head</code> 和兩整數 <code>left</code> 和 <code>right</code>, 其中 <code>left ≤ right</code>, 反轉位置 <code>left</code> 到位置 <code>right</code> 的 node, 並返回反轉後的 linked list。</p></blockquote><p><img src="https://i.imgur.com/cSX6dz4.png"></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a><strong>Solution:</strong></h2><blockquote><p><strong>想法：分成三步驟</strong></p><ul><li><p>將待反轉的區域反轉</p></li><li><p>將 <code>left</code> (leftPrev-&gt;next) 的 <code>next</code> 指向 <code>cur</code></p></li><li><p>將 <code>leftPre</code> 的 <code>next</code> 指向 <code>reverseHead</code></p><p>  <img src="https://i.imgur.com/4i8EkA0.png"></p><p>  <img src="https://i.imgur.com/ao66TLu.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *leftPrev = dummy, *cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop 做完後, leftPrev 指向 left 前一個 node, cur 則指向 left</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            leftPrev = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做完 reverse 後, cur 會指向 right 後一個 node</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> reverseHead = <span class="built_in">reverse</span>(cur, left, right);</span><br><span class="line">        leftPrev-&gt;next-&gt;next = cur; <span class="comment">// 將 reverse 前的 head 指向 right 後一個 node</span></span><br><span class="line">        leftPrev-&gt;next = reverseHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode*&amp; head, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            nxt = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = nxt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>61. Rotate List</title>
      <link href="/post/rotate-list/"/>
      <url>/post/rotate-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/</a></strong></p><p><strong>題意</strong>：給一 linked list 的 <code>head</code> 和一整數 <code>k</code>, 將 linked list 每個 node 向右移 <code>k</code> 個位置。</p></blockquote><p><img src="https://i.imgur.com/XJmxH4H.png"></p><p><img src="https://i.imgur.com/8gLkYNv.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將 linked list 分成兩個部分, 倒數 <code>k</code> 個 node(藍色部分)、剩餘部分(綠色部分)</strong></p><ul><li><strong>先將 <code>tail-&gt;next</code> 設為藍色部分的 head, 並把綠色部分的 <code>tail-&gt;next</code> 指向 <code>null</code></strong></li><li><strong>再將藍色部分的 <code>tail</code> 指向綠色部分的 head, 並把藍色部分的 head 設為 <code>newHead</code></strong></li></ul><p><img src="https://i.imgur.com/YeOM2tF.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || !head) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ListNode *tail = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到 len &amp; 藍色部分的 tail</span></span><br><span class="line">        <span class="keyword">while</span> (tail-&gt;next) &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因為 k 有可能會大於 len(如 example 2), 所以要 k % len(循環)</span></span><br><span class="line">        k %= len; <span class="comment">// 藍色部分的長度</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="comment">// cur 為綠色部分的 tail</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *newHead = cur-&gt;next; <span class="comment">// 藍色部分的 head</span></span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 綠色部分的 tail 指向 null</span></span><br><span class="line">        tail-&gt;next = head; <span class="comment">// 藍色部分的 tail 指向綠色部分的 head</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>81. Search in Rotated Sorted Array II</title>
      <link href="/post/search-in-rotated-sorted-array-ii/"/>
      <url>/post/search-in-rotated-sorted-array-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/</a></strong></p><p><strong>題意</strong>：存在一整數 array <code>nums</code>, 按非降序排列, <code>nums</code> 中的數值有可能會重複。</p><p>給一<strong>旋轉後</strong>的 <code>nums</code> 和一整數 <code>target</code>, 如果 <code>nums</code> 中存在 <code>target</code>, 則返回其 <code>true</code>; 否則, 返回 <code>false</code>。</p><p>盡可能地減少操作步驟。</p></blockquote><p><img src="https://i.imgur.com/yL9ycmg.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：類似 <a href="https://zako945.github.io/post/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a>, 差別在本題的 <code>nums</code> 可能會有重複數, 導致 <code>nums[left] == nums[mid]</code> 時, 無法判斷 <code>[left, mid]</code> 和 <code>[mid + 1, right]</code> 哪個才是有序的</strong></p><p>e.g. <code>nums = [1,1,1,0,1]</code>, <code>target = 0</code><br>無法判斷 <code>[0,2]</code> 和 <code>[3,4]</code> 哪個才是有序的。</p><p>對於這種情況, 將 <code>left + 1</code>, 然後在新區間繼續做 Binary Search</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ worse case：元素均相等, 且不為 <code>target</code>, 則需拜訪所有位置才能得出結果</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148. Sort List</title>
      <link href="/post/sort-list/"/>
      <url>/post/sort-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></strong></p><p><strong>題意</strong>：給一 linked list 的起始節點 <code>head</code>, 返回以<strong>升序</strong>排列過的 linked list。</p><p><strong>進階</strong>：設計 $O(n \cdot log(n))$ time 且 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/VoWQGBl.png"></p><p><img src="https://i.imgur.com/Tl9nO6Y.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Merge Sort (top-down)</strong></p><p><img src="https://i.imgur.com/3c0dx5l.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0 或 1 個 node</span></span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 讓 slow 指向中點; 若 n 為偶數, 則指向第一個中點</span></span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *mid = slow-&gt;next; <span class="comment">// 右半部分</span></span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 左半部分的結尾設為 NULL</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head), <span class="built_in">sortList</span>(mid));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *tail = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="comment">// 讓 l1 始終指向較小的 node</span></span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(l1, l2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 這邊可寫成 tail-&gt;next = l2; 因為 l1, l2 一開始一定皆不為 NULL</span></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ Merge Sort 的時間複雜度, $T(n) &#x3D; 2 \cdot T(\dfrac{n}{2}) + O(n)$<ul><li>每回合的合併需要花：$O(n)$</li><li>回合數：$O(log(n))$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ $O(n + log(n))$<ul><li>$O(n)$：merge 後的 linked list 長度最多為 <code>n</code></li><li>$O(log(n))$：取決於遞迴深度, 最大遞迴深度為 log(n)</li></ul></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Merge Sort (bottom-up)</strong></p><p><img src="https://i.imgur.com/nJ0XunR.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0 或 1 個 node</span></span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = <span class="built_in">getLen</span>(head);</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// log(n) 回合 : 2^0 ~ 2^(log(n)-1) =&gt; (log(n) - 1) - 0 + 1 = log(n)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt; len; n &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 不能寫 cur = head, 因為 dummy-&gt;next 會因 tail 而改變</span></span><br><span class="line">            ListNode *cur = dummy-&gt;next;</span><br><span class="line">            ListNode *tail = dummy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">                ListNode *left = cur;</span><br><span class="line">                ListNode *right = <span class="built_in">split</span>(left, n);</span><br><span class="line">                cur = <span class="built_in">split</span>(right, n);</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> merged = <span class="built_in">merge</span>(left, right);</span><br><span class="line">                tail-&gt;next = merged.first;</span><br><span class="line">                tail = merged.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLen</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (--n &amp;&amp; head) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *rest = head ? head-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head) &#123; <span class="comment">// 將左半部分的結尾設為 NULL</span></span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ListNode*, ListNode*&gt; <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="comment">// 讓 l1 始終指向較小的 node</span></span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(l1, l2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 當 list 只有一個元素時, l1 不為 NULL, 但 l2 為 NULL, 並不會進入 while loop</span></span><br><span class="line"><span class="comment">         * e.g. [1, 2, 3] =&gt; left = [1, 2], right = [3] = cur</span></span><br><span class="line"><span class="comment">         * cur 不為 null, 進入第二個 while loop</span></span><br><span class="line"><span class="comment">         * 此時 left = [3], right = null, 並不會進入 merge 的 while loop</span></span><br><span class="line"><span class="comment">         * 這邊不可寫成 tail-&gt;next = l2; 因為不保證一定進 while loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tail 到達 merged list 的最後一個非 null 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (tail-&gt;next) &#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;dummy-&gt;next, tail&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ Merge Sort 的時間複雜度</li><li><strong>space：</strong>$O(1)$ ➔ 用 loop 模擬 recursive, 因此只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24. Swap Nodes in Pairs</title>
      <link href="/post/swap-nodes-in-pairs/"/>
      <url>/post/swap-nodes-in-pairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></strong></p><p><strong>題意</strong>：給一 linked list, 兩兩交換相鄰的 node, 並返回交換後 linked list。</p><p><strong>注意</strong>：必須在不修改 node 值的情況下完成（只能進行 node swap）</p></blockquote><p><img src="https://i.imgur.com/FgC5y0Z.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 dummy node, 讓 <code>prev</code> 永遠指向當前 pair 的前一個 node, 分為三步驟</strong></p><ul><li><strong>1. 取得下一個 pair 的 head, 和當前 pair 的 tail</strong></li><li><strong>2. reverse 當前 pair, 並將 <code>prev</code> 指向當前 pair 的 head(更新前的 tail)</strong></li><li><strong>3. 更新 pointers</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *prev = dummy, *cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// save ptrs</span></span><br><span class="line">            ListNode *nxtPair = cur-&gt;next-&gt;next; <span class="comment">// 下一個 pair 的 head</span></span><br><span class="line">            ListNode *second = cur-&gt;next; <span class="comment">// 當前 pair 的 tail</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// reverse current pairs</span></span><br><span class="line">            second-&gt;next = cur; <span class="comment">// second 成為當前 pair 的 head, cur 則成為 tail</span></span><br><span class="line">            cur-&gt;next = nxtPair; <span class="comment">// 當前 pair 的 tail 指向下一個 pair</span></span><br><span class="line">            prev-&gt;next = second; <span class="comment">// prev 指向當前 pair 的 head</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// update ptrs</span></span><br><span class="line">            prev = cur; <span class="comment">// prev 指向下一個 pair 的前一個 node(當前 pair 的 tail)</span></span><br><span class="line">            cur = nxtPair; <span class="comment">// 移動到下一個 pair</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>240. Search a 2D Matrix II</title>
      <link href="/post/search-a-2d-matrix-ii/"/>
      <url>/post/search-a-2d-matrix-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">https://leetcode.cn/problems/search-a-2d-matrix-ii/</a></strong></p><p><strong>題意</strong>：設計一高效演算法來搜索 <code>m x n</code> matrix 中是否存在整數 <code>target</code>, matrix 滿足以下特性:</p><ul><li>每行的元素由上到下按升序排列</li><li>每列的元素由左到右按升序排列</li></ul></blockquote><p><img src="https://i.imgur.com/rhxdVz1.png"></p><p><img src="https://i.imgur.com/wply250.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：對每一列做 Binary Search, 判斷 <code>target</code> 是否在該列中，從而判斷 <code>target</code> 是否出現</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; m; ++row) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (matrix[row][mid] &gt;= target) &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 當 matrix 中所有的元素都比 target 小 (target 不存在), left 會越界</span></span><br><span class="line">            <span class="comment">// 所以在存取 matrix[row][left] 前, 要先判斷 left 是否越界, 否則存取會出錯</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; n &amp;&amp; matrix[row][left] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// not found</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot log(n))$ ➔ 對每一列做 Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Z 字形搜索, 從 <code>matrix</code> 右上角(左下角也行)開始</strong></p><ul><li><p><strong>若 <code>matrix[row][col] == target</code> : 則 return <code>true</code></strong></p></li><li><p><strong>若 <code>matrix[row][col] &gt; target</code> : 則代表 <code>matrix[row ~ m][col]</code> 都比 <code>target</code> 大, 故 <code>col - 1</code></strong></p><p>  <img src="https://i.imgur.com/oouaKHO.png"></p></li><li><p><strong>若 <code>matrix[row][col] &lt; target</code> : 則代表 <code>matrix[row][col ~ n]</code> 都比 <code>target</code> 小, 故 <code>row + 1</code></strong></p><p>  <img src="https://i.imgur.com/fjttTzY.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target) &#123;</span><br><span class="line">                ++row;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --col;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// not found</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 在搜索的過程中，如果我們沒有找到<code>target</code>, 那麼我們要馬將 <code>y - 1</code>, 要馬將 <code>x + 1</code>。由於 <code>(x, y)</code> 的初始值為 <code>(0, n - 1)</code>, 因此是 <code>y</code> 最多能被減少 <code>n</code> 次, <code>x</code> 最多能被增加 <code>m</code> 次, 總搜索次數為 <code>m + n</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>658. Find K Closest Elements</title>
      <link href="/post/find-k-closest-elements/"/>
      <url>/post/find-k-closest-elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-k-closest-elements/">https://leetcode.cn/problems/find-k-closest-elements/</a></strong></p><p><strong>題意</strong>：給一已排序的 array <code>arr</code> 以及兩整數 <code>k</code> 和 <code>x</code>, 從 <code>arr</code> 中找到最接近 <code>x</code> 的 <code>k</code> 個數。返回的 array 必須是已排序好的。</p><p>整數 <code>a</code> 比整數 <code>b</code> 更接近 <code>x</code> 須滿足：</p><ul><li><code>|a - x| &lt; |b - x|</code>（<code>a</code> 比 <code>b</code> 更靠近 <code>x</code>） 或</li><li><code>|a - x| == |b - x|</code> 且 <code>a &lt; b</code>（兩者到 <code>x</code> 的距離相等, 但 <code>a</code> 比 <code>b</code> 小）</li></ul></blockquote><p><img src="https://i.imgur.com/FbefD1n.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：由於 <code>arr</code> 是有序的, 所以最後返回的 <code>k</code> 個元素也一定是有序的, 其實就是返回了原 array 中的一個長度為 <code>k</code> 的 subarray。實際上相當於在長度為 <code>n</code> 的 array 中去掉 <code>n - k</code> 個數字, 而且去掉的順序肯定是從兩頭開始, 因為距離 <code>x</code> 最遠的數字肯定在首尾出現。</strong></p><p>➔ <strong>每次比較首尾兩個數字跟 <code>x</code> 的距離, 並刪除距離較大的數字, 直到剩餘的 array 長度為 k 為止</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (arr.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x - arr.<span class="built_in">front</span>() &lt;= arr.<span class="built_in">back</span>() - x) &#123;</span><br><span class="line">                arr.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr.<span class="built_in">erase</span>(arr.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n-k)$ ➔ while loop, 其中 <code>n</code> 為 <code>arr.size()</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除要返回的 array, 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用移動 window, 從位置 <code>i</code> 開始延伸出去的長度為 <code>k</code> 的 window(其中 <code>0 ≤ i ≤ n-k</code>)</strong></p><p><strong>以下圖為例, <code>nums = [1,2,3,4,5]</code>, 其中每個不同顏色的框代表不同的 window</strong></p><p><img src="https://i.imgur.com/kqNglvc.png"></p><p>➔ <strong>利用 Binary Search, 算出 mid 後, 先看最左邊元素為 mid 的 window, 然後其右邊一個的 window 進行比較</strong></p><p>e.g. 圖中, <code>mid = 2</code>, 故當前 window 為藍框的 <code>[3,4]</code>, 右邊一個的 window 為紫框的 <code>[4,5]</code></p><p>透過比較 <code>arr[mid]</code> 及右邊一個的 window 中最右的元素 <code>arr[mid + k]</code> 來決定要往哪繼續做 Binary Search</p><p>e.g. 透過上例, 比較 <code>3</code> 和 <code>5</code> 來決定要縮小左邊界 or 右邊界</p><p>由於 5 比較接近 <code>x = 5</code>, 故往右走(右半邊剩下的 window 繼續做 Binray Search)</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>() - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比較 arr[mid] 和右邊一個 window 中最右的元素哪個比較接近 x</span></span><br><span class="line">            <span class="keyword">if</span> (x - arr[mid] &gt; arr[mid + k] - x) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(arr.<span class="built_in">begin</span>() + left, arr.<span class="built_in">begin</span>() + left + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n) + k)$<ul><li>$O(log(n))$：binary search</li><li>$O(k)$：建立返回的 array</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 扣除要返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>209. Minimum Size Subarray Sum</title>
      <link href="/post/minimum-size-subarray-sum/"/>
      <url>/post/minimum-size-subarray-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></strong></p><p><strong>題意</strong>：給一正整數 array <code>nums</code> 和一正整數 <code>target</code>, 返回滿足元素和  <code>≥ target</code> 的長度最小的<strong>連續 subarray</strong>, 如果不存在這樣的 subarray 則返回 <code>0</code>。</p><p><strong>進階</strong>：設計 $O(n \cdot log(n))$ time 和 $O(n)$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/llcfQcb.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window</strong></p><ul><li>先擴大窗口, 直到窗口裡的元素總和 <code>sum ≥ target</code></li><li>此時, 開始縮小窗口, 並同時更新 <code>res</code>, 直到 <code>sum &lt; target</code></li><li>重複上述步驟, 直到 <code>right</code> 到 <code>nums</code> 的結尾</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n + <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, right - left); <span class="comment">// 此時, sum 是符合要求的, 故在此更新 res</span></span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res == n + <span class="number">1</span>) ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>nums</code> 中的元素每個最多被遍歷 2 次(<code>left</code>, <code>right</code>)</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>904. Fruit Into Baskets</title>
      <link href="/post/fruit-into-baskets/"/>
      <url>/post/fruit-into-baskets/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/fruit-into-baskets/">https://leetcode.cn/problems/fruit-into-baskets/</a></strong></p><p><strong>題意</strong>：有一農場種植了一排果樹, 用 <code>fruits</code> 表示, 其中 <code>fruits[i]</code> 代表第 <code>i</code> 棵樹的水果<strong>種類</strong>。</p><p>農場主人設立了一些規矩, 你必須按照規矩採收:</p><ul><li>你只有<strong>兩個</strong>籃子, 每個籃子只能裝<strong>單一種類</strong>的水果。每個籃子能裝的水果總量沒有限制。</li><li>可以選擇任一棵樹開始採收, 你必須從<strong>每棵</strong>樹上<strong>恰摘一個水果</strong>。採收的水果須符合籃子中的水果種類。每採一次, 就要往右移動到下一棵樹繼續採收。</li><li>一旦某棵樹的水果不符合籃子中的種類, 就必須停止採收。</li></ul><p>返回可以採收的水果的<strong>最大</strong>數目。</p></blockquote><p><img src="https://i.imgur.com/6BqvwxT.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法: 利用 Sliding Window</strong></p><ul><li>先擴大窗口, 直到 <code>window</code> 中的種類超過 2 種（<code>window.size() &gt; 2</code>）</li><li>此時, 開始縮小窗口, 直到 <code>window.size() == 2</code>。注意：<strong>當某個種類的個數為 <code>0</code> 時, 要將其從 <code>window</code> 中移除</strong>, 不然 <code>window.size()</code> 無法減少</li><li>跳出內層 while loop 時, 代表 <code>window.size() == 2</code>, 故在此處更新 <code>res</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; fruits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ++window[fruits[right]];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (window.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--window[fruits[left]] == <span class="number">0</span>) &#123; <span class="comment">// 數量為 0 時, 要將其從 window 中移除</span></span><br><span class="line">                    window.<span class="built_in">erase</span>(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>fruits</code> 中的元素每個最多被遍歷 2 次（<code>left</code>, <code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code> 的長度不會超過 2, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>451. Sort Characters By Frequency</title>
      <link href="/post/sort-characters-by-frequency/"/>
      <url>/post/sort-characters-by-frequency/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sort-characters-by-frequency/">https://leetcode.cn/problems/sort-characters-by-frequency/</a></strong></p><p><strong>題意</strong>：給一 string <code>s</code>, 根據每個 char 出現的<strong>頻率</strong>對其進行降序排列。</p><p>返回已排序過的 string, 若有多個答案, 則返回其中任意一個。</p></blockquote><p><img src="https://i.imgur.com/kOcMCTl.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap</strong></p><ul><li>計算 <code>s</code> 中每個元素的出現頻率</li><li>將 <code>&#123;char, cnt&#125;</code> push 到 max heap 中</li><li>不斷取出 top 直到 heap 為空, s<code>.append(cnt, char)</code> 代表 <code>s</code> 一次新增 <code>cnt</code> 個 char</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt; q; <span class="comment">// max heap</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freq[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ch, cnt] : freq) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(cnt, ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [cnt, ch] = q.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">append</span>(cnt, ch);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(n) + O(26 \cdot log(n))$<ul><li>$O(n)$：第一個 for loop 和 while loop 的 <code>s.append()</code></li><li>$O(26 \cdot log(n))$：第二個 for loop 和 while loop, 因為 char 最多 <code>26</code> 種, 因此 <code>q</code> 的元素不超過 <code>26</code> 個</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 因為 <code>freq</code> 和 <code>q</code> 最多 <code>26</code> 個元素, 且 <code>s</code> 為 input string, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>767. Reorganize String</title>
      <link href="/post/reorganize-string/"/>
      <url>/post/reorganize-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reorganize-string/">https://leetcode.cn/problems/reorganize-string/</a></strong></p><p><strong>題意</strong>：給一 string <code>s</code>, 重新建構 <code>s</code> 使得相鄰的 char 不同。</p><p>返回 <code>s</code> 任何可能的排列。若不可行, 則返回 <code>&quot;&quot;</code>。</p></blockquote><p><img src="https://i.imgur.com/TBHoTku.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap, 若有 char 的出現次數超過 $\dfrac{n+1}{2}$, 則不可能存在相鄰 char 不同的 string</strong></p><ul><li>建立 max heap</li><li>每次從 heap 中取兩個 top, 保證這兩個 char 必不相同</li><li>取出 top 後, 其 <code>count - 1</code> 若 <code>&gt; 0</code>, 將其 push 回 heap 中</li><li>跳出 while loop 是因為 <code>pq.size() &lt; 2</code><ul><li>若 <code>pq.size() == 1</code>：<code>s</code> 要加上 <code>pq.top()</code></li><li>若 <code>pq.size() == 0</code>：直接返回 <code>s</code></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reorganizeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freq[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt; pq; <span class="comment">// max heap</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> half = (s.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ch, num] : freq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; half) &#123; <span class="comment">// 若超過 (n+1) / 2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(num, ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> top1 = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> top2 = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            s += top1.second;</span><br><span class="line">            s += top2.second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--top1.first &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(top1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--top2.first &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(top2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s += pq.<span class="built_in">top</span>().second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(n) + O(26 \cdot log(n))$<ul><li>$O(n)$<strong>：</strong>第一個 for loop, 和 while loop 中重構 <code>s</code></li><li>$O(26 \cdot log(n))$<strong>：</strong>第二個 for loop 最多 insert 26 次</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>freq</code> 和 <code>pq</code> 最多 26 個元素, 且 <code>s</code> 為 input string, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>310. Minimum Height Trees</title>
      <link href="/post/minimum-height-trees/"/>
      <url>/post/minimum-height-trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-height-trees/">https://leetcode.cn/problems/minimum-height-trees/</a></strong></p><p><strong>題意</strong>：給一數字 <code>n</code> 和 <code>n - 1</code> 條無向邊的 <code>edges</code> list, 代表一包含 <code>n</code> 個 node 編號從 <code>0</code> 到 <code>n - 1</code> 的 tree。</p><p>可選擇 tree 中任意 node 作為 root。在所有可能的 tree 中, 具有<strong>最小高度</strong>的 tree 被稱為<strong>最小高度樹</strong>。</p><p>找到所有最小高度樹的 root 並按<strong>任意順序</strong>返回。</p></blockquote><p><img src="https://i.imgur.com/BuWJ3tx.png"></p><p><img src="https://i.imgur.com/dFTerX5.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + BFS, 我們發現若希望高度越小, 則 root 應選 degree 越大的。</strong></p><p><strong>下圖中, 紅圈以外的是 leaf, 若將這些點作為 root, 其樹高不可能為最小的, 原因如下:</strong></p><ul><li><p>若將 leaf 作為 root, 其樹高的路徑必「走進」紅圈, 再「走出」紅圈</p></li><li><p>若將 non-leaf 為 root, 其樹高的路徑只需「走出」紅圈</p><p>  <img src="https://i.imgur.com/Ri0pdIh.png"></p></li></ul><p>➔ <strong>故可透過「剝洋蔥」的方式, 一層一層剝掉 degree &#x3D; 1 的 node, 直到剩下 ≤ 兩個 node。</strong></p><p><strong>思考: 為何不是三個 node 就停呢? 因為三個 node 可以繼續剝下去</strong></p><p><img src="https://i.imgur.com/fzbebcY.png"></p><p><strong>特殊情況：當 tree 只有一個 node 時, 則答案即為該 node 本身</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="comment">// 特殊情況</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n); <span class="comment">// adjacency list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj[i].<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> k = q.<span class="built_in">size</span>();</span><br><span class="line">            n -= k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 讓 adjacent node 的 degree - 1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                    adj[v].<span class="built_in">erase</span>(cur);</span><br><span class="line">                    <span class="keyword">if</span> (adj[v].<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>time：</strong>$O(n)$ ➔ $O(n+(n-1))$, 其實就是對圖進行 BFS 所需之時間複雜度 $O(V+E)$</p><ul><li>$O(V)$<strong>：</strong><code>n</code> 個 node</li><li>$O(E)$：<code>n - 1</code> 條 edge, 因為 tree 是 acyclic</li></ul></li><li><p><strong>space：</strong>$O(n)$ ➔ $O(n+(n-1))$, 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</p><p>  <img src="https://i.imgur.com/qdZwrCz.png"></p></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS, tree 中最長 path 的兩端點皆必為 leaf, 否則 path 可繼續拓展, 我們的目標就是找出最長 path 之中點</strong></p><ul><li>先隨機選取一個 node（可能不為 leaf）, 並對其進行 dfs 取得離它最遠的點 <code>n1</code>（第一個 leaf）</li><li>對 <code>n1</code> 進行 dfs 取得離它最遠的點 <code>n2</code>（第二個 leaf）</li><li>此時, <code>n1 -&gt; n2</code> 為 tree 中<strong>最長的 path</strong>, 其 path 之中點即為答案<ul><li>若 path 長度為奇數, 則取 <code>&#123;path[len / 2]&#125;</code></li><li>若 path 長度為偶數, 則取 <code>&#123;path[(len / 2) - 1], path[len / 2]&#125;</code></li></ul></li></ul><p>e.g. 下圖中</p><ul><li><p>首先選取 <code>1</code> 並做 dfs 取得 <code>n1 = 6</code></p></li><li><p>再對 <code>n1</code> 做 dfs 得 <code>n2 = 7</code>。 <code>n1 -&gt; n2</code> 之 path 長度為 5（<code>6 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 7</code>）</p></li><li><p>取 path 中點 1 會得到最小高度樹</p><p>  <img src="https://i.imgur.com/zTAGRzt.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n); <span class="comment">// adjacency list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n1 = <span class="built_in">findFarestNode</span>(<span class="number">0</span>, parent, adj, n);</span><br><span class="line">        <span class="type">int</span> n2 = <span class="built_in">findFarestNode</span>(n1, parent, adj, n);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        parent[n1] = <span class="number">-1</span>; <span class="comment">// 將 n1 的 parent 設為 -1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="number">-1</span>) &#123; <span class="comment">// 從 n2 往 n1 走, 並把 node 加到 path 中</span></span><br><span class="line">            path.<span class="built_in">emplace_back</span>(n2);</span><br><span class="line">            n2 = parent[n2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> k = path.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;path[k / <span class="number">2</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;path[(k / <span class="number">2</span>) - <span class="number">1</span>], path[k / <span class="number">2</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFarestNode</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">const</span> vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt;&amp; adj, <span class="type">int</span>&amp; n)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        dis[cur] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(cur, dis, adj, parent);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> node = <span class="number">0</span>; <span class="comment">// farest node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            node = (dis[i] &gt; dis[node]) ? i : node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; dis, <span class="type">const</span> vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt;&amp; adj, vector&lt;<span class="type">int</span>&gt;&amp; parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dis[v] = dis[cur] + <span class="number">1</span>;</span><br><span class="line">                parent[v] = cur;</span><br><span class="line">                <span class="built_in">dfs</span>(v, dis, adj, parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(n+(n-1))$, 其實就是對圖進行 DFS 所需之時間複雜度 $O(V+E)$<ul><li>$O(V)$：<code>n</code> 個 node</li><li>$O(E)$：<code>n - 1</code> 條 edge, 因為 tree 是 acyclic</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ $O(n+(n-1))$, 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>444. Sequence Reconstruction</title>
      <link href="/post/sequence-reconstruction/"/>
      <url>/post/sequence-reconstruction/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sequence-reconstruction/">https://leetcode.cn/problems/sequence-reconstruction/</a></strong></p><p><strong>題意</strong>：給一 <code>[1, n]</code> 長度為 <code>n</code> 的整數 array <code>nums</code>, 以及一些 2d 整數 array <code>sequences</code>, 其中 <code>sequences[i]</code> 是 <code>nums</code> 的 subsequence。</p><p>返回 <code>sequences</code> 是否能唯一重建出 <code>nums</code>。</p><p>e.g. <code>nums = [1,2,3]</code>, <code>sequences = [[1,2], [1,3]]</code></p><ul><li><code>sequences</code> 可重建出 <code>[1,2,3]</code> 和 <code>[1,3,2]</code> 並不唯一, 故返回 <code>false</code>。因為 1 必須在 2、3 的前面, 但 2 和 3 間並沒有唯一的順序</li><li>但若更改 <code>sequences = [[1,2], [1,3], [2,3]]</code>, 則可唯一重建出 <code>[1,2,3]</code>, 故返回 <code>true</code>。因為 1 必須在 2、3 的前面, 且 2 必須在 3 的前面, 故只能重建出 <code>[1,2,3]</code></li></ul></blockquote><p><img src="https://i.imgur.com/MiIRJjn.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + BFS, 將 <code>sequences</code> 轉成有向圖, 給定的順序 <code>nums</code> 等價於有向圖的 Topological Sort</strong></p><ul><li>首先, 計算每個點的 <code>inDegree</code></li><li>將所有 <code>inDegree = 0</code> 的 node 加到 <code>queue</code> 中, 並進行 Topological Sort</li><li><code>queue</code> 中的元素個數表示可以作為下一個數字的元素個數<ul><li>若 <code>queue</code> 中的元素個數 <code>&gt; 1</code>, 則下一個數字並不唯一, 應返回 <code>false</code></li><li>若 <code>queue</code> 中的元素個數 <code>= 1</code>, 則下一個數字是唯一的數字。並將該數字從 <code>queue</code> 取出, 且該數字指向的每個數字的 <code>inDegree - 1</code>, 並將 <code>inDegree</code> 變成 <code>0</code> 的數字加到 <code>queue</code> 中</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; sequences)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// nums 由 [1, n] 組成, 而非 [0, n-1]</span></span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>); <span class="comment">// adjacency list</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; seq : sequences) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; seq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> pre = seq[i - <span class="number">1</span>], cur = seq[i];</span><br><span class="line">                adj[pre].<span class="built_in">emplace</span>(cur);</span><br><span class="line">                ++inDegree[cur];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 遍歷 node 1 ~ n</span></span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 下一個數字的選擇不唯一</span></span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把 cur 給 pop 掉後, 將 cur 的 adjacent vertex 之 in degree - 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n+m)$ ➔ <code>bfs()</code> 所需的時間複雜度 $O(V+E)$<ul><li><code>n</code> 為 <code>nums</code> 的個數(即為 vertex 數)</li><li><code>m</code> 為 <code>sequences</code> 的個數(即為 edge 數)</li></ul></li><li><strong>space：</strong>$O(n+m)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>107. Binary Tree Level Order Traversal II</title>
      <link href="/post/binary-tree-level-order-traversal-ii/"/>
      <url>/post/binary-tree-level-order-traversal-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></strong></p><p><strong>題意</strong>：給一 BT 的 <code>root</code>, 返回 <code>node.val</code> <strong>由下往上的 level order</strong>（由下層往上層, 每層由左至右）。</p></blockquote><p><img src="https://i.imgur.com/xU5BDit.png"></p><p><img src="https://i.imgur.com/eAyKwcZ.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS, 同 <a href="https://zako945.github.io/post/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a>, 只是多了 reverse</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i )&#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 <code>res</code>, 在 while loop 迭代的過程中, <code>q</code> 的元素個數不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS, 同 <a href="https://zako945.github.io/post/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a>, 只是多了 reverse</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, res);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">const</span> <span class="type">int</span> depth, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &lt;= depth) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[depth].<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, depth + <span class="number">1</span>, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, depth + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2013. Detect Squares</title>
      <link href="/post/detect-squares/"/>
      <url>/post/detect-squares/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/detect-squares/">https://leetcode.cn/problems/detect-squares/</a></strong></p><p><strong>題意：</strong>給一在 <code>X-Y</code> 平面上的點所構成的 data stream。設計一個滿足下述要求的算法：</p><ul><li><strong>新增</strong>一個在 data stream 中的新點到某個資料結構中。可以新增<strong>重覆</strong>的點, 並且會被視作不同的點</li><li>給一查詢點, 從資料結構中選出三個點, 使這三點、查詢點構成一個<strong>面積為正</strong>的 <strong>axis-aligned square</strong>, <strong>統計</strong>滿足該要求的方法數。</li></ul><p><strong>axis-aligned square</strong> 是一個正方形, 除了四條邊的長度相同外, 還滿足每條邊皆與 <code>X軸</code> or <code>Y軸</code> 平行或垂直。</p><p>實現 <code>DetectSquares</code> class：</p><ul><li><code>DetectSquares()</code>：初始化 <code>DetectSquares</code> instance</li><li><code>void add(int[] point)</code>：向資料結構新增一個新的點 <code>point = [x, y]</code></li><li><code>int count(int[] point)</code>：按上述方式統計與點 <code>point = [x, y]</code> 共同構成 <strong>axis-aligned square</strong> 的方法數</li></ul></blockquote><p><img src="https://i.imgur.com/0Mthla4.png"></p><p><img src="https://i.imgur.com/uPdqbcf.png"></p><p><img src="https://i.imgur.com/MoAYuMS.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：若要建構一正方形, 要先找出 query node 的對角線上的點 <code>(x3, y3)</code>, 便能形成正方形 <code>[(x1, y1), (x1, y3), (x3, y3), (x3, y1)]</code>。首先一一遍歷所有 node, 然後找出滿足符合條件的 query node 的對角線上的點 <code>(x3, y3)</code>, 並計算其方法數</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DetectSquares</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DetectSquares</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; point)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">        ++points[x][y]; <span class="comment">// 新增重覆的點, 會被視作不同的點</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(vector&lt;<span class="type">int</span>&gt; point)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> x1 = point[<span class="number">0</span>], y1 = point[<span class="number">1</span>], res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x = points.<span class="built_in">begin</span>(); x != points.<span class="built_in">end</span>(); ++x) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> yPoints = x-&gt;second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> y = yPoints.<span class="built_in">begin</span>(); y != yPoints.<span class="built_in">end</span>(); ++y) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> x3 = x-&gt;first;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> y3 = y-&gt;first;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 (x3, y3) 不與 (x1, y1) 在同一 X軸 or Y軸上, 且邊的長度相同</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(x3 - x1) != <span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(x3 - x1) == <span class="built_in">abs</span>(y3 - y1)) &#123;</span><br><span class="line">                    res += (points[x3][y3] * points[x3][y1] * points[x1][y3]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 一個 x 對應多個 y 點, e.g. (1, 3), (1, 4) 都會存在 x = 1  umap 中</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; points; <span class="comment">// &#123;x, &#123;y, count&#125;&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>DetectSquares()</code>：$O(1)$</li><li><code>add()</code>：$O(1)$</li><li><code>count()</code>：$O(n^2)$ ➔ for loop 遍歷所有點, 其中 <code>n</code> 為點的個數</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>points</code> 紀錄每個點, 其中 <code>n</code> 為點的個數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>442. Find All Duplicates in an Array</title>
      <link href="/post/find-all-duplicates-in-an-array/"/>
      <url>/post/find-all-duplicates-in-an-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/">https://leetcode.cn/problems/find-all-duplicates-in-an-array/</a></strong></p><p><strong>題意：</strong>給一有 <code>n</code> 個數的 array <code>nums</code>, 每個元素值皆在 <code>[1, n]</code>, 且每個元素可能出現 <strong>一次</strong> or <strong>兩次</strong>, 求所有出現<strong>兩次</strong>的數。</p><p><strong>注意：</strong>使用 $O(n)$ time 和 $O(1)$ space 的演算法</p></blockquote><p><img src="https://i.imgur.com/e8xqQOb.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將數字乘以負號來標記我們看到的數字的 index, 然後遍歷 <code>nums</code> 元素, 若 <code>nums[i] &gt; 0</code>, 代表數字 <code>i + 1</code> 出現過兩次(類似 <a href="https://zako945.github.io/post/find-all-numbers-disappeared-in-an-array/">448. Find All Numbers Disappeared in an Array</a>)</strong></p><p>e.g. <code>[1, 1, 2]</code> ➔ <code>[1, -1, 2]</code>, <strong><code>nums[i - 1]</code> 決定數字 <code>i</code> 出現的次數</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(<span class="built_in">abs</span>(num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>784. Letter Case Permutation</title>
      <link href="/post/letter-case-permutation/"/>
      <url>/post/letter-case-permutation/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/letter-case-permutation/">https://leetcode.cn/problems/letter-case-permutation/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 將 <code>s</code> 中的每個字母轉變大小寫, 可得到新的 string。求所有可能的 string, 可以按<strong>順序任意</strong>排列。</p></blockquote><p><img src="https://i.imgur.com/yCztlFW.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p><ul><li>若 <code>s[i]</code> 為數字, 則 <code>s[i]</code> 不變繼續往後走</li><li>若 <code>s[i]</code> 為字母, 則有兩種情況：<ul><li><p><code>s[i]</code> 不變繼續往後走</p></li><li><p><code>s[i]</code> 轉變大小寫後, 繼續往後走</p><p>  <img src="https://i.imgur.com/AOrMtJP.png"></p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCasePermutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string&amp; s, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不論是字母還是數字, 都先自己不變, 並往下一個走</span></span><br><span class="line">        <span class="built_in">dfs</span>(s, i + <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">            <span class="comment">// 因為 &#x27;a&#x27; - &#x27;A&#x27; = 32 = 2^5</span></span><br><span class="line">            <span class="comment">// 在 s[i] 為字母的條件下, 對右邊數來第5個 bit 跟 1 做 XOR</span></span><br><span class="line">            <span class="comment">// 因為 XOR: (0, 1) = 1, (1, 1) = 0</span></span><br><span class="line">            s[i] ^= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); <span class="comment">// 等同於 s[i] 根據大小寫 +/- 32</span></span><br><span class="line">            <span class="built_in">dfs</span>(s, i + <span class="number">1</span>, n);</span><br><span class="line">            s[i] ^= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); <span class="comment">// XOR 做兩次相同運算 = 還原</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$<ul><li>最多 $2^n$ 種狀態（<code>n</code> 個都字母）</li><li>建每一種狀態的需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(n \cdot 2^n)$ ➔ $O(n) + O(n \cdot 2^n)$<ul><li>$O(n)$ : <code>dfs()</code> 遞迴最大深度</li><li>$O(n \cdot 2^n)$ : 最多 $2^n$ 種狀態（<code>n</code> 個都字母）, 每種狀態的 string 長度都為 <code>n</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>253. Meeting Rooms II</title>
      <link href="/post/meeting-rooms-ii/"/>
      <url>/post/meeting-rooms-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/meeting-rooms-ii/">https://leetcode.cn/problems/meeting-rooms-ii/</a></strong></p><p><strong>題意：</strong>給一 array <code>intervals</code>, 其中 <code>intervals[i] = [start_i, end_i]</code>, 返回所需的最小會議室數量。</p><p><strong>注意：</strong><code>(0, 8)</code> 和 <code>(8, 10)</code> 並不衝突</p></blockquote><p><img src="https://i.imgur.com/Cl83cfU.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 heap 來紀錄所有會議室的 <code>end</code>, 並每次取 heap 中最小的, 來確認跟當前 interval 是否有衝突</strong></p><ul><li>若有, 則將當前 <code>interval.end</code> 加入到 heap 中</li><li>若沒有, 則把 <code>top</code> 取代為當前 <code>interval.end</code>（先 <code>pop()</code>, 再 <code>push(newEnd)</code>）</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;Interval&gt; &amp;intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="type">const</span> Interval&amp; i1, <span class="type">const</span> Interval&amp; i2) &#123;</span><br><span class="line">            <span class="keyword">return</span> i1.start &lt; i2.start;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        pq.<span class="built_in">emplace</span>(intervals[<span class="number">0</span>].end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> minEnd = pq.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有重疊, 要加開會議室</span></span><br><span class="line">            <span class="keyword">if</span> (minEnd &gt; intervals[i].start) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 沒重疊</span></span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">emplace</span>(intervals[i].end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$<ul><li>$O(n \cdot log(n))$ : sorting</li><li>$O(n \cdot log(n))$ : <code>n</code> 次從 minHeap 中取 <code>top</code>, 每次取完後會調整 heap, 需 $O(log(n))$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ heap size 最大為 <code>n</code> 個</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：占用資源問題可看做是上下車問題, 則問題可轉化成車上最多有幾人</strong></p><p>e.g. <code>intervals = [[0,30], [5,10], [15,20]]</code></p><p>可想成：</p><ul><li>第一個人從 <code>0</code> 上車, 從 <code>30</code> 下車</li><li>第二個人從 <code>5</code> 上車, 從 <code>10</code> 下車</li><li>第三個人從 <code>15</code> 上車, 從 <code>20</code> 下車</li></ul><p>問題可轉化成車上最多有幾人（最多有幾間會議室）</p><p><strong>顯然：上車, 車上人數+1；下車, 車上人數-1</strong></p><p>先把 <code>intervals</code> 拆解成：</p><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">上車 : <span class="comment">[0, 1]</span>, <span class="comment">[5, 1]</span>, <span class="comment">[15, 1]</span></span><br><span class="line">下車 : <span class="comment">[10, -1]</span>, <span class="comment">[20, -1]</span>, <span class="comment">[30, -1]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>時間</th><th>0</th><th>5</th><th>10</th><th>15</th><th>20</th><th>30</th></tr></thead><tbody><tr><td>變化</td><td>+1</td><td>+1</td><td>-1</td><td>+1</td><td>-1</td><td>-1</td></tr><tr><td>人數</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td><td>0</td></tr></tbody></table><p>➔ <strong>車上最多 <code>2</code> 人</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; meetings;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; iv : intervals) &#123;</span><br><span class="line">            meetings.<span class="built_in">emplace_back</span>(iv[<span class="number">0</span>], <span class="number">1</span>); <span class="comment">// 上車, cnt + 1</span></span><br><span class="line">            meetings.<span class="built_in">emplace_back</span>(iv[<span class="number">1</span>], <span class="number">-1</span>); <span class="comment">// 下車, cnt - 1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(meetings.<span class="built_in">begin</span>(), meetings.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m : meetings)&#123;</span><br><span class="line">            cnt += m.second;</span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal, cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(n)$ ➔ <code>meetings</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>43. Multiply Strings</title>
      <link href="/post/multiply-strings/"/>
      <url>/post/multiply-strings/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/multiply-strings/">https://leetcode.cn/problems/multiply-strings/</a></strong></p><p><strong>題意：</strong>給兩個以 string 表示的非負整數 <code>num1</code> 和 <code>num2</code>, 返回 <code>num1</code> 和 <code>num2</code> 的乘積 (以 string 表示)。</p><p><strong>注意：</strong>不得使用任何內建的 BigInteger library 或是 直接將 input string 轉換為整數。</p></blockquote><p><img src="https://i.imgur.com/jdW4xux.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用大數乘法, 用整數 array <code>digits</code> 來儲存乘積</strong></p><p>e.g. <code>num1 = &quot;123&quot;</code>, <code>num2 = &quot;45&quot;</code></p><ul><li>令每個數最左邊的數 <code>idx = 0</code>, 每往右一位 <code>idx + 1</code>, <code>digits</code> 最左邊的 idx 也為 0<ul><li><code>num1</code> 中 <code>2</code> 的 <code>idx = 1</code></li><li><code>num2</code> 中 <code>4</code> 的 <code>idx = 0</code></li></ul></li><li>若 <code>num1.size() = m</code>, <code>num2.size() = n</code>, 則 <code>digits.size() = m + n</code><ul><li>若 <code>num1</code> 和 <code>num2</code> 都取最小值, 則 <code>num1</code> 為 $10^{m-1}$, <code>num2</code> 為 $10^{n-1}$<br>  ➔ <code>num1 x num2</code> 為 $10^{m + n - 2}$, 因此乘積的長度 &#x3D; <code>m + n - 1</code></li><li>若 <code>num1</code> 和 <code>num2</code> 都取最大值, 則 <code>num1</code> 為 $10^m-1$, <code>num2</code> 為 $10^n-1$<br>  ➔ <code>num1 x num2</code> 為 $10^{m + n} - 10^m - 10^n + 1$<br>  ➔ $10^{m + n - 1}$ &lt; 乘積 &lt; $10^{m + n}$, 因此乘積的長度 &#x3D; <code>m + n</code></li></ul></li><li>由上述得知 <code>num1 x num2</code> 的長度最多為 <code>m + n</code></li><li><code>num1</code> 中 <code>2</code> 的 <code>idx = 1</code>, 和 <code>num2</code> 中 <code>4</code> 的 <code>idx = 0</code>, 計算出來的 <code>08</code> 會在 <code>digits</code> 的 index 為 <code>[i + j, i + j + 1]</code> 的區間</li><li>計算 <code>digits</code> 是先計算 <code>idx = i + j + 1</code>, 因為 <code>i + j + 1</code> 較靠右 (平時我們做乘法加總時的順序), 然後才讓靠左的 <code>i + j</code> 加總 <code>carry</code></li><li>下圖 <code>123 x 45</code> 會得出 <code>digits</code> 為 <code>05535</code><ul><li>要先<strong>去掉</strong>左邊<strong>開頭為 0 的部分</strong> (leading zero)</li><li>再把剩餘的部分轉成 string, 得到 <code>5535</code></li></ul></li></ul><p><img src="https://i.imgur.com/jEO8iMS.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = num1.<span class="built_in">size</span>(), n = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">digits</span><span class="params">(m + n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                digits[i + j + <span class="number">1</span>] += (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                digits[i + j] += (digits[i + j + <span class="number">1</span>] / <span class="number">10</span>);</span><br><span class="line">                digits[i + j + <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        string res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉開頭的 0(leading zero)</span></span><br><span class="line">        <span class="keyword">while</span> (digits[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res += <span class="built_in">to_string</span>(digits[i++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m + n)$ ➔ <code>digits</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>435. Non-overlapping Intervals</title>
      <link href="/post/non-overlapping-intervals/"/>
      <url>/post/non-overlapping-intervals/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/non-overlapping-intervals/">https://leetcode.cn/problems/non-overlapping-intervals/</a></strong></p><p><strong>題意：</strong>給一區間集合 <code>intervals</code>, 其中 <code>intervals[i] = [start_i, end_i]</code>, 返回需要移除的最小區間個數, 使得剩下的區間互不重疊。</p></blockquote><p><img src="https://i.imgur.com/479NCdI.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：首先, 先將 <code>intervals</code> 做排序, 然後紀錄前一天的 <code>end</code>, 當有兩天 <code>start</code> 相同時, <code>end</code> 會取較小的那一個, 這樣才能最大化避免重疊</strong></p><p><strong>以下圖為例, sorting 後的 <code>intervals = [[1,2], [1,3], [2,3], [3,4]</code>, 最一開始 <code>[1,2]</code> 和 <code>[1,3]</code> 我們會選擇捨棄 <code>[1,3]</code>, 因為 <code>[1,2]</code> 的 <code>end</code> 較小, 若保留 <code>[1,3]</code> 則會和後面的 <code>[2,3]</code> 重疊</strong></p><p><img src="https://i.imgur.com/Dmj8LLZ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, prevEnd = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// prevEnd &gt; current start, 代表有重疊, 捨棄其中一個, 且 prevEnd 要更新</span></span><br><span class="line">            <span class="keyword">if</span> (prevEnd &gt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                prevEnd = <span class="built_in">min</span>(prevEnd, intervals[i][<span class="number">1</span>]);</span><br><span class="line">                ++res;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 沒重疊, 則 prevEnd 更新為當前 interval 的 end</span></span><br><span class="line">                prevEnd = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50. Pow(x, n)</title>
      <link href="/post/powx-n/"/>
      <url>/post/powx-n/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/powx-n/">https://leetcode.cn/problems/powx-n/</a></strong></p><p><strong>題意：</strong>給一 double <code>x</code> 和一整數 <code>n</code>, 返回 <code>x</code> 的 <code>n</code> 次方。</p></blockquote><p><img src="https://i.imgur.com/idwSS22.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Divide and Conquer, 比如 $2^{10}$ 可拆成 $2^5 * 2^5$, 而 $2^5$ 又可拆成 $2(2^2 * 2^2)$, 依此類推。透過這樣的方法可以避免重複計算, 而不用一直乘 <code>x</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意 res 要宣告成 double (容易粗心)</span></span><br><span class="line">        <span class="type">double</span> res = <span class="built_in">quickPow</span>(x, <span class="built_in">abs</span>(n)); <span class="comment">// 計算 x^n, 其中 n 取正</span></span><br><span class="line">        <span class="keyword">return</span> (n &gt;= <span class="number">0</span>) ? res : (<span class="number">1</span> / res); <span class="comment">// 若 n &lt; 0, 則取倒數 1 / (x^n)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 0^n = 0</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x != 0, 則 x^0 = 1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> half = <span class="built_in">quickPow</span>(x, n / <span class="number">2</span>); <span class="comment">// 計算 x^(n / 2), 注意 half 的 data type</span></span><br><span class="line">        <span class="comment">// 若 n 為奇數, 則前面還要再多乘一次 x</span></span><br><span class="line">        <span class="keyword">return</span> (n % <span class="number">2</span>) ? (x * half * half) : (half * half);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ $T(n)$ &#x3D; $2 \cdot T(\dfrac{n}{2})$ + $O(1)$</li><li><strong>space：</strong>$O(log(n))$ ➔ 取決於遞迴深度, 遞迴深度不超過 $log(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. Reverse Integer</title>
      <link href="/post/reverse-integer/"/>
      <url>/post/reverse-integer/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-integer/">https://leetcode.cn/problems/reverse-integer/</a></strong></p><p><strong>題意：</strong>給一 32-bit 的有號整數 <code>x</code>, 返回將 <code>x</code> 中的數字部分反轉後的結果。</p><p>如果反轉後的整數超過 32-bit 的有號整數的範圍 <code>[−$2^&#123;31&#125;$,  $2^&#123;31&#125;$ − 1]</code>, 則返回 <code>0</code>。</p><p>假設不允許儲存 64-bit 整數（有號 or 無號）, 也就是說結果只能用 int 來儲存, 不允許用 long 之類的 data type。</p></blockquote><p><img src="https://i.imgur.com/0QQMzp9.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：int 的範圍是 <code>[-2147483648, 2147483647]</code>, 因此在執行 <code>res = (10 * res) + (x % 10)</code> 前, 要先判斷這樣做是否會 overflow</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="comment">// 避免下面 (10 * res) + (x % 10) 時, 正整數會 overflow</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX / <span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; x % <span class="number">10</span> &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 避免下面 (10 * res) + (x % 10) 時, 負整數會 overflow</span></span><br><span class="line">            <span class="keyword">if</span> (res &lt; INT_MIN / <span class="number">10</span> || (res == INT_MIN / <span class="number">10</span> &amp;&amp; x % <span class="number">10</span> &lt; <span class="number">-8</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = (<span class="number">10</span> * res) + (x % <span class="number">10</span>);</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(x))$ ➔ $\dfrac{x}{10^k} &#x3D; 1$, 得 $k &#x3D; log(x)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48. Rotate Image</title>
      <link href="/post/rotate-image/"/>
      <url>/post/rotate-image/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/rotate-image/">https://leetcode.cn/problems/rotate-image/</a></strong></p><p><strong>題意：</strong>給一 <code>n x n</code> 的 2D array 表示一個 image, 請將 image <strong>順時針旋轉 90 度</strong>。</p><p><strong>注意：</strong>請使用 <strong>in-place</strong> 演算法</p></blockquote><p><img src="https://i.imgur.com/9501ib1.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：將 <code>matrix</code> 由外而內分成好幾層, 每一層依序交換以完成旋轉</strong></p><p><img src="https://i.imgur.com/BBcgX0W.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想像從 (0, 0) 沿著對角線往中心點前進(n為奇數時中心不用旋轉, 故為 i &lt; n / 2)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 每層共 n-2*(i+1) 個元素, 每往內一層元素個數就會減2, 減掉最左、最右兩個數</span></span><br><span class="line">            <span class="comment">// i 為起始 idx, 則 i+n-2*(i+1) = n-i-2 為結束 idx</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - i - <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i];</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i];</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 遍歷 <code>matrix</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2：（進階）"><a href="#Solution-2：（進階）" class="headerlink" title="Solution 2：（進階）"></a><strong>Solution 2：（進階）</strong></h2><blockquote><p><strong>想法：先將 <code>matrix</code> 做轉置（將同 row 的元素變成同 col）, 然後再每列做水平翻轉（reverse）<br>（水平翻轉：原本左邊 $1^{st}$ col 變成右邊 $1^{st}$ col, 左邊 $2^{nd}$ col 變成右邊 $2^{nd}$ col, 依此類推）</strong></p></blockquote><p><img src="https://i.imgur.com/XOzokhE.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 轉置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一列做 reverse</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(matrix[i].<span class="built_in">begin</span>(), matrix[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 遍歷 <code>matrix</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73. Set Matrix Zeroes</title>
      <link href="/post/set-matrix-zeroes/"/>
      <url>/post/set-matrix-zeroes/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/set-matrix-zeroes/">https://leetcode.cn/problems/set-matrix-zeroes/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的 matrix, 若其中一元素為<code>0</code>, 將其所在列和行的所有元素都設為<code>0</code>。</p><p><strong>注意：</strong>請使用 <strong>in-place</strong> 演算法</p><p><strong>進階：</strong></p><ul><li>用 <code>O(mn)</code> space 的直覺作法似乎是個壞主意</li><li>設計 <code>O(m + n)</code> space 的演算法，但這仍然不是最好的解決方案</li><li>設計 <code>O(1)</code> space 的演算法</li></ul></blockquote><p><img src="https://i.imgur.com/oxqB8Bh.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：分別用 <code>rows</code>, <code>cols</code> 來記錄哪些 row, col 上的元素要設為 <code>0</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rows</span><span class="params">(m, <span class="number">0</span>)</span>, <span class="title">cols</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    rows[i] = cols[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rows[i] || cols[j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>matrix</code></li><li><strong>space：</strong>$O(m + n)$ ➔ <code>rows</code> 和 <code>cols</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：用 <code>col0</code>, <code>row0</code> 分別記錄第一行、第一列是否有元素為 <code>0</code>, 然後用 <code>matrix</code> 中的第一行、第一列分別紀錄該行、列是否有元素為 <code>0</code><br>（用 <code>matrix</code> 中的第一行、第一列取代 Solution 1 的 <code>rows</code>、<code>cols</code> ）</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> row0 = <span class="literal">false</span>, col0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 記錄第一行是否有元素為0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                col0 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 記錄第一列是否有元素為0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                row0 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 matrix 中的第一行、第一列分別紀錄該行、列是否有元素為0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根據 matrix[i][0]、matrix[0][j] 是否為0, 來決定是否把 matrix[i][j] 設為0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷 matrix 的第一行是否要設0</span></span><br><span class="line">        <span class="keyword">if</span> (col0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷 matrix 的第一列是否要設0</span></span><br><span class="line">        <span class="keyword">if</span> (row0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>matrix</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54. Spiral Matrix</title>
      <link href="/post/spiral-matrix/"/>
      <url>/post/spiral-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的 matrix, 按照 <strong>順時針螺旋</strong> 順序, 返回 matrix 中所有元素。</p></blockquote><p><img src="https://i.imgur.com/cbrZA9Z.png"></p><p><img src="https://i.imgur.com/K9q2pnS.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法： 將 <code>matrix</code> 由外而內分成好幾層, 每層都有四個方向要走, 依序是</strong></p><ul><li>由左至右</li><li>由上至下</li><li>由右至左</li><li>由下至上</li></ul><p><img src="https://i.imgur.com/4pVqcBW.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, bottom = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> direction = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">            <span class="keyword">if</span> (direction == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 top row 的元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; ++i) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(matrix[top][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++top;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 right col 的元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt; bottom; ++i) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(matrix[i][right - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                --right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 bottom row 的元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = right - <span class="number">1</span>; i &gt;= left; --i) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(matrix[bottom - <span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                --bottom;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 left col 的元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = bottom - <span class="number">1</span>; i &gt;= top; --i) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            direction = (direction + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>matrix</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>371. Sum of Two Integers</title>
      <link href="/post/sum-of-two-integers/"/>
      <url>/post/sum-of-two-integers/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/sum-of-two-integers/">https://leetcode.cn/problems/sum-of-two-integers/</a></strong></p><p><strong>題意：</strong>給兩整數 <code>a</code> 和 <code>b</code>, 在不使用 <code>+</code>、 <code>-</code> 運算的情況下, 返回兩整數之和。</p></blockquote><p><img src="https://i.imgur.com/630CQnM.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將加法拆分成無進位加法、進位這兩個部分</strong></p><ul><li><p><strong>XOR：</strong>為無進位的加法, 透過 <code>a ^ b</code> 得到無進位的加法結果, 還需要找到進位的數, 並把這兩者相加才能得到答案</p><p>  <img src="https://i.imgur.com/OlkwphC.png"></p></li><li><p><strong>&amp;、shift：</strong><code>a &amp; b</code> 把 <code>a</code>、<code>b</code> 中相同位置皆為 1 的 bit 設為 1, 最後再將 <code>a &amp; b</code> 左移一位即可得到進位的數<br>e.g. <code>a = 5</code>, <code>b = 4</code>, 則進位數 &#x3D; <code>a &amp; b</code> &#x3D; <code>0100</code>, 但 <code>0100</code> 並非進位的數, <code>1000</code> 才是真正進位的數</p><p>  <img src="https://i.imgur.com/SXlAFRd.png"></p></li></ul><p><strong>因此, 我們的步驟如下：</strong></p><ul><li>得到 <code>a</code> 和 <code>b</code> 的進位數</li><li>得到無進位加法</li><li>循環此過程, 直到 <code>carry = 0</code></li></ul><p>e.g. <code>a = 5</code>, <code>b = 4</code></p><ul><li>得到 carry <code>b = (a &amp; b) &lt;&lt; 1 = 1000</code>、無進位加法 <code>a = (a ^ b) = 0001</code></li><li>得到 carry <code>b = (a &amp; b) &lt;&lt; 1 = 0000</code>、無進位加法 <code>a = (a ^ b) = 1001</code></li><li><code>b = 0</code> 表示 <code>carry = 0</code> 要結束循環, 得到答案 <code>a = 1001 = 9</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a ^= b;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 最多計算 32 次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>309. Best Time to Buy and Sell Stock with Cooldown</title>
      <link href="/post/best-time-to-buy-and-sell-stock-with-cooldown/"/>
      <url>/post/best-time-to-buy-and-sell-stock-with-cooldown/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></strong></p><p><strong>題意：</strong>給一 array <code>prices</code>, 其中 <code>prices[i]</code> 代表第 i 天的股票價格, 在滿足下列條件的前提下, 盡可能地完成更多的交易, 計算出最大利潤。</p><ul><li>賣出股票後, 你沒辦法在下一天買入股票(冷凍期為一天)</li><li>不能同時參與多筆交易, 必須在再次購買前出售掉之前的股票</li></ul></blockquote><p><img src="https://i.imgur.com/Q4znRVs.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>prices</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>rest[i]</code> 代表第 <code>i</code> 天手上<strong>未持有</strong>股票, 且狀態為 <code>rest</code> 的最大收益</li><li><code>hold[i]</code> 代表第 <code>i</code> 天手上<strong>持有</strong>股票, 且狀態為 <code>hold</code> 的最大收益<br>（手上持有股票然後休息, 其狀態仍是 <code>hold</code>。<code>rest</code> 狀態必須在未持有股票時）</li><li><code>sold[i]</code> 代表第 <code>i</code> 天手上<strong>未持有</strong>股票, 且狀態為 <code>sold</code> 的最大收益</li></ul><p><strong>2. 根據下圖, 可得狀態轉移方程：</strong></p><ul><li><p><code>rest[i] = max(rest[i - 1], sold[i - 1])</code></p></li><li><p><code>hold[i] = max(hold[i - 1], rest[i - 1] - prices[i])</code></p></li><li><p><code>sold[i] = hold[i - 1] + prices[i]</code></p><p>  <img src="https://i.imgur.com/arUNmnP.png"></p></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>hold[0]</code>、<code>sold[0]</code>、<code>rest[0]</code>：沒有股票時, 最大利潤為 <code>0</code></li><li><code>hold[1]</code>：第一天買入 ➔ 此時最大利潤為 <code>prices[1]</code></li><li><code>sold[1]</code>：第一天買入, 並且賣出 ➔ 此時最大利潤為 <code>0</code></li><li><code>rest[1]</code>：第一天不操作 ➔ 此時最大利潤為 <code>0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hold</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">sold</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">rest</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        prices.<span class="built_in">emplace</span>(prices.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        hold[<span class="number">1</span>] = -prices[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            rest[i] = <span class="built_in">max</span>(sold[i - <span class="number">1</span>], rest[i - <span class="number">1</span>]);</span><br><span class="line">            hold[i] = <span class="built_in">max</span>(hold[i - <span class="number">1</span>], rest[i - <span class="number">1</span>] - prices[i]); <span class="comment">// 買入股票, 收益減少</span></span><br><span class="line">            sold[i] = hold[i - <span class="number">1</span>] + prices[i]; <span class="comment">// 賣出股票, 收益增加</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大利潤不可能出現在 buy 而未 sell 的時候, 所以不考慮最後一天為 hold 的狀態</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rest.<span class="built_in">back</span>(), sold.<span class="built_in">back</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>hold</code>, <code>sell</code> 和 <code>rest</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>hold[i]</code>、<code>sold[i]</code>、<code>rest[i]</code> 只會用到 <code>i - 1</code> 的狀態, 因此只要儲存 <code>i - 1</code> 的狀態即可, 根本不需要開到 $O(n)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        prices.<span class="built_in">emplace</span>(prices.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hold = -prices[<span class="number">1</span>], sold = <span class="number">0</span>, rest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> prevHold = hold, prevSold = sold, prevRest = rest;</span><br><span class="line">            rest = <span class="built_in">max</span>(prevRest, prevSold);</span><br><span class="line">            hold = <span class="built_in">max</span>(prevHold, prevRest - prices[i]);</span><br><span class="line">            sold = prevHold + prices[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rest, sold);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>312. Burst Balloons</title>
      <link href="/post/burst-balloons/"/>
      <url>/post/burst-balloons/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/burst-balloons/">https://leetcode.cn/problems/burst-balloons/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code> 表示所有氣球上的編號。</p><p>戳破第 <code>i</code> 個氣球, 可以獲得 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬幣。其中 <code>i - 1</code> 和 <code>i + 1</code> 代表與 <code>i</code> 相鄰的兩個氣球之編號。若 <code>i - 1</code> 或 <code>i + 1</code> 超出了 <code>nums</code> 的邊界, 則將其看作是編號為 <code>1</code> 的氣球。</p><p>返回戳破所有氣球所能獲得的最大硬幣數。</p><p><strong>注意：</strong><code>1 ≤ nums[i] ≤ 300</code></p></blockquote><p><img src="https://i.imgur.com/p3m3onY.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>本題重點：</strong></p><ul><li>與其考慮先射爆哪個氣球, 不如<strong>考慮最後射爆哪個氣球</strong>。因為如果是考慮先射爆哪個氣球, 這種方式無法確定當前左、右邊的氣球編號。</li><li>若是考慮最後射爆哪個氣球, 則可以確定該氣球的左、右邊編號</li></ul><p><strong>1. 定義狀態：</strong></p><ul><li><code>dp[i][j]</code>：在 <code>nums[i:j]</code> 中最後射爆 <code>index = k</code> 的氣球</li><li>在射爆 <code>idx = k</code> 的氣球前, 必須先射爆 <code>nums[i:(k-1)]</code>、<code>nums[(k+1):j]</code> 區間中的氣球</li></ul><p><strong>2. 得到狀態轉移方程：</strong></p><ul><li>由於 <code>dp[i][j]</code> 只保證 <code>nums[i:j]</code> 區間的氣球會被射爆, 且 <code>idx = k</code> 的氣球最後才會被射爆。也就是說, 當射爆 <code>nums[k]</code> 時, 它左邊氣球的 idx 必為 <code>i - 1</code>, 且右邊氣球的 idx 必為 <code>j + 1</code> （區間外的沒被射爆, 故 k 之左、右邊為區間外的 idx）。因為 <code>nums[i:(k-1)]</code>、<code>nums[(k+1):j]</code> 區間的氣球都已經先被射爆</li><li>狀態轉移方程：<ul><li><code>last = nums[i - 1] * nums[k] * nums[j + 1]</code></li><li><code>dp[i][j] = max(dp[i][j], dp[i][k - 1] + dp[k + 1][j] + last)</code></li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：沒有氣球時, 所能獲得的最大硬幣數為 <code>0</code></li><li><code>dp[i][0]</code>：沒有氣球時, 所能獲得的最大硬幣數為 <code>0</code>。其中, <code>1 ≤ i ≤ n + 1</code></li><li><code>dp[0][j]</code>：由於要求最大值, 且 <code>nums[i] &gt; 0</code>, 乘積一定 <code>&gt; 0</code>, 故都先初始化成 <code>0</code>。其中, <code>1 ≤ j ≤ n + 1</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前、後各 insert 一個元素避免超出邊界</span></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">        nums.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; ++len) &#123; <span class="comment">// len 為區間的長度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; ++i) &#123; <span class="comment">// i 為區間的起始點</span></span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> j = i + len - <span class="number">1</span>; <span class="comment">// j 為區間的終點</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; ++k) &#123; <span class="comment">// k 用來遍歷區間 [i, j] 中的元素</span></span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> last = nums[i - <span class="number">1</span>] * nums[k] * nums[j + <span class="number">1</span>];</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k - <span class="number">1</span>] + dp[k + <span class="number">1</span>][j] + last);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^3)$ ➔ for loop, 其中 <code>n</code> 為氣球的數量</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322. Coin Change</title>
      <link href="/post/coin-change/"/>
      <url>/post/coin-change/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></strong></p><p><strong>題意</strong>：給一整數 array <code>coins</code>, 表示不同面額的零錢, 和一整數 <code>amount</code> 代表總金額。</p><p>計算可以湊成 <code>amount</code> 的<strong>最少硬幣數</strong>。如果無法湊成, 則返回 <code>-1</code>。</p><p>每種硬幣的數量都是無限的。</p></blockquote><p><img src="https://i.imgur.com/gYnZ7qR.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p><p><img src="https://i.imgur.com/OkYazSi.png"></p></blockquote><ul><li><p><strong>普通版</strong>：DFS</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = amount + <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(coins, amount, count, res);</span><br><span class="line">        <span class="keyword">return</span> (res == amount + <span class="number">1</span>) ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">const</span> <span class="type">int</span> amount, <span class="type">const</span> <span class="type">int</span> count, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(count, res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt;= coin) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(coins, amount - coin, count + <span class="number">1</span>, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>進階版</strong>：DFS + greedy（每次取最大面額）+ pruning</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort coins in descending order</span></span><br><span class="line">        <span class="built_in">sort</span>(coins.<span class="built_in">rbegin</span>(), coins.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="type">int</span> res = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(coins, <span class="number">0</span>, amount, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> (res == amount + <span class="number">1</span>) ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">const</span> <span class="type">int</span> idx, <span class="type">const</span> <span class="type">int</span> amount, <span class="type">const</span> <span class="type">int</span> count, <span class="type">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, count);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx == coins.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> coin = coins[idx]; <span class="comment">// 每次取最大面額的硬幣</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = amount / coin; k &gt;= <span class="number">0</span> &amp;&amp; count + k &lt; res; --k) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(coins, idx + <span class="number">1</span>, amount - k * coin, count + k, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 利用 DP 來避免重複計算（圖中綠色圈起來的部分）, 其中 <code>dp[i]</code> 為湊齊金額 <code>i</code> 的最少硬幣數</strong></p><p><img src="https://i.imgur.com/OkYazSi.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 金額範圍 : 0 ~ amount (amount + 1 種), 每種金額的最少硬幣數初始為 amount + 1</span></span><br><span class="line"><span class="comment">         * 若 coins 中的硬幣面額能湊齊金額 i, 則 dp[i] 一定小於 amount (因為面額最小為 1)</span></span><br><span class="line"><span class="comment">         * 故初始值故意設成大於 amount 的數 (amount + 1), 用一個不可能的數代表無法湊齊</span></span><br><span class="line"><span class="comment">         * 這樣當 dp[i] == amount + 1 時, 代表無法用 coins 中的硬幣面額湊齊金額 i</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 湊齊金額 0 的最少硬幣數為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(amount \cdot n)$ ➔ for loop, 其中 <code>n</code> 為硬幣的種類</li><li><strong>space：</strong>$O(amount)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>518. Coin Change II</title>
      <link href="/post/coin-change-ii/"/>
      <url>/post/coin-change-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>coins</code> 表示不同面額的硬幣, 和一整數 <code>amount</code> 表示總金額。</p><p>返回可以湊成 <code>amount</code> 的硬幣組合數。如果任何硬幣組合都無法湊出總金額, 則返回 <code>0</code>。</p><p>假設每一種面額的硬幣有無限個。</p><p>題目保證結果符合 32-bit 有號整數。</p></blockquote><p><img src="https://i.imgur.com/VMktizM.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>coins</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code>：前 <code>i</code> 種硬幣湊齊金額 <code>j</code> 的組合數</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>coins[i]</code> 有「選 or 不選」兩種可能：<ul><li><code>rods[i]</code> 不選, 則 <code>dp[i][j] = dp[i - 1][j]</code></li><li><code>rods[i]</code> 要選, 則 <code>dp[i][j] = dp[i][j - coins[i]]</code>（每一種面額可無限取, 故為 <code>i</code> 而非 <code>i - 1</code>）</li></ul></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：當沒有任何硬幣時, 湊齊金額 <code>0</code> 的組合數為 <code>1</code>（什麼都不選也是一種方案）<br>➔ <code>dp[0][0] = 1</code></li><li><code>dp[i][0]</code>：當 <code>amount = 0</code> 時, 前 <code>i</code> 種硬幣湊齊金額 <code>j</code> 的組合數為 <code>1</code>（什麼都不選也是一種方案）, 其中 <code>1 ≤ i ≤ n</code><br>➔ <code>dp[i][0] = 1</code></li><li><code>dp[0][j]</code>：當沒有任何硬幣時, 湊齊金額 <code>j</code> 的組合數為 <code>0</code>, 其中 <code>1 ≤ j ≤ amount</code><br>➔ <code>dp[0][j] = 0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        coins.<span class="built_in">emplace</span>(coins.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每種硬幣湊齊金額 0 的組合數皆只有一種</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123; <span class="comment">// 若金額 ≥ 硬幣面額, 則該種硬幣有取 or 不取兩種選擇</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若金額 &lt; 硬幣面額, 則該種硬幣只有不取這一選擇</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot amount)$ ➔ for loop, 其中 <code>n</code> 是硬幣種類</li><li><strong>space：</strong>$O(n \cdot amount)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>dp[i][j]</code> 只會用到上一列的狀態, 故只需記住上一列的狀態即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        coins.<span class="built_in">emplace</span>(coins.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> prevRow = dp; <span class="comment">// 記住上一列的狀態</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123; <span class="comment">// 若金額 ≥ 硬幣面額, 則該種硬幣有取 or 不取兩種選擇</span></span><br><span class="line">                    dp[j] = prevRow[j] + dp[j - coins[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若金額 &lt; 硬幣面額, 則該種硬幣只有不取這一選擇</span></span><br><span class="line">                    dp[j] = prevRow[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot amount)$ ➔ for loop, 其中 <code>n</code> 是硬幣種類</li><li><strong>space：</strong>$O(amount)$ ➔ <code>dp</code>, <code>prevRow</code></li></ul><h2 id="延伸問題："><a href="#延伸問題：" class="headerlink" title="延伸問題："></a>延伸問題：</h2><ul><li><p><strong>for loop 內、外層能否對調？</strong></p><p>  <strong>不能, 因為這裡定義的 subproblem 是「選擇第 <code>i</code> 種硬幣時, 湊齊金額 <code>j</code> 的方案（組合數）」。如果對調了, 則 subproblem 就會變成「對於金額 <code>j</code>, 選擇硬幣的方案（排列數）」</strong></p><p>  e.g. <code>amount = 3</code>, <code>coins = [1, 2]</code></p><ul><li>內、外層對調後, 會有 1 + 2、2 + 1 這兩種方案</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. Decode Ways</title>
      <link href="/post/decode-ways/"/>
      <url>/post/decode-ways/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/decode-ways/">https://leetcode.cn/problems/decode-ways/</a></strong></p><p><strong>題意：</strong>給一只含數字的<strong>非空</strong> string <code>s</code>，計算並返回解碼的方法數</p><p>一則包含字母 <code>A-Z</code> 的訊息透過以下 mapping 進行編碼:</p><p><img src="https://i.imgur.com/8r5NyQR.png"></p><p>要<strong>解碼</strong>已編碼的訊息, 其所有數字必須基於上述 mapping 的方法，反向 mapping 回字母（可能有多種方法）。例如 : “11106” 可以 mapping 為：</p><ul><li><code>AAJF</code> 將訊息分組為 <code>(1 1 10 6)</code></li><li><code>KJF</code> 將訊息分組為 <code>(11 10 6)</code></li></ul><p><strong>注意：</strong>訊息並不能分組為 <code>(1 11 06)</code>, 因為 <code>06</code> 並不能 mapping 為 <code>F</code>, 這是因為 <code>6</code> 和 <code>06</code> 在 mapping 中並不等價</p><p>答案保證符合 32-bit 整數的範圍</p></blockquote><p><img src="https://i.imgur.com/4qpRXdo.png"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 DFS, 其中每個 char 都有兩種選擇：</strong></p><ul><li>自己一組, 前提是自己不能為 <code>&#39;0&#39;</code>。若為 <code>&#39;0&#39;</code>, 則一定要跟其他 char 一組</li><li>自己 + 後面一個 char 一組, 前提是 <code>&quot;10&quot; &lt;= substring &lt;=&quot;26&quot;</code></li></ul><p><img src="https://i.imgur.com/WpThPOV.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能自己一組</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不為 &#x27;0&#x27;, 則可自己一組</span></span><br><span class="line">        <span class="built_in">dfs</span>(s, i + <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 兩個 char 一組, 則必須介於 10 ~ 26 之間</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span> || (s[i] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(s, i + <span class="number">2</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$<ul><li>$O(2^n)$ : 每一個 char 有兩種選擇, 一種是自己一組, 另外是和後面一個 char 一組, 總共 $2^n$ 種</li><li>建構每一種狀況需花 $O(n)$ time</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, 最大遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i]</code> 代表 <code>s[0~(i-1)]</code> 的解碼方法數</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// empty string 不需解碼, 方法數為 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 若不為 0, 則可以自己一組</span></span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 前一個 char + 自己一組, 則 dp[i] += dp[i-2]</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span> || (s[i - <span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">                    dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, <code>dp[i]</code> 最多用到 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code>, 因此不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">1</span>, two = <span class="number">1</span>; <span class="comment">// [two, one, cur]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 若不為 0, 則可以自己一組</span></span><br><span class="line">            <span class="type">int</span> cur = (s[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) ? <span class="number">0</span> : one;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span> || (s[i - <span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">                    cur += two;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            two = one;</span><br><span class="line">            one = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134. Gas Station</title>
      <link href="/post/gas-station/"/>
      <url>/post/gas-station/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/gas-station/">https://leetcode.cn/problems/gas-station/</a></strong></p><p><strong>題意：</strong>在一條環路上有 <code>n</code> 個加油站, 其中第 <code>i</code> 個加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一輛油箱容量無限的的汽車, 從第 <code>i</code> 個加油站開往第 <code>i + 1</code> 個加油站需要消耗 <code>cost[i]</code> 升汽油。你從其中的一個加油站出發, 開始時油箱為空。</p><p>給定兩個整數 array <code>gas</code> 和 <code>cost</code>, 如果可以繞環路行駛一圈, 則返回出發時加油站的 index, 否則返回 <code>-1</code>。如果存在解, 則<strong>保證</strong>它是<strong>唯一的</strong>。</p></blockquote><p><img src="https://i.imgur.com/MB2PiS5.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 首先判斷總油量是否小於總消耗量。如果是, 那肯定不能走完一圈。否則, 肯定能走完一圈。接下來就是遍歷 <code>nums</code>, 從第一站開始, 計算每一站剩餘的油量, 如果當走到第 <code>i</code> 站時油量為負, 則以第 <code>i + 1</code> 站作為起點重新計算。若抵達某一站時油量為負, 說明從起點到該站中間的所有站都不能到達該點</strong></p><p>e.g. <code>gas = [1, 2, 3, 4, 5]</code>, <code>cost = [3, 4, 5, 1, 2]</code> (見下圖)</p><ul><li><p>假設從 <code>i = 4</code> 出發, 此時的 <code>gas[i] = 5</code>, <code>cost[i] = 2</code></p><ul><li><code>i = 4</code> 做完, 此時 <code>curGas = 5 - 2 = 3 ≥ 0</code></li><li><code>i = 0</code> 做完, 此時 <code>curGas = 3 + 1 - 3 = 1 ≥ 0</code></li><li><code>i = 1</code> 做完, 此時 <code>curGas = 1 + 2 - 4 = -1 &lt; 0</code></li></ul><p>  ➔ 下一輪會從 <code>i = 2</code> 重新計算, 因為以 <code>i = 4、0、1</code> 為起點都無法抵達 <code>i = 2</code></p><ul><li>這是因為以 <code>i = 4</code> 為起點出發, 抵達 <code>i = 0</code> 時的油量必須 <code>≥ 0</code> 才行</li><li>若直接以 <code>i = 0</code> 為起點出發, 則起始油量會為 <code>0</code><br>  ➔ 等同從上一站抵達 <code>i = 0</code> 時的剩餘油量 &#x3D; 0 ( <code>≥ 0</code> 中的 worse case)</li><li>若從 <code>i = 4</code> 都無法抵達 <code>i = 2</code>, 則從 <code>i = 0、1</code> 更不可能抵達。</li></ul><p>  <img src="https://i.imgur.com/hRhTuVl.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 總油量 &lt; 總消耗量, 肯定無法走完一圈</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sum</span>(gas) &lt; <span class="built_in">sum</span>(cost)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, curGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            curGas += (gas[i] - cost[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curGas &lt; <span class="number">0</span>) &#123; <span class="comment">// 若抵達第 i 站時油量 &lt; 0, 則以第 (i + 1) 站為起點重新計算</span></span><br><span class="line">                curGas = <span class="number">0</span>;</span><br><span class="line">                res = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>846. Hand of Straights</title>
      <link href="/post/hand-of-straights/"/>
      <url>/post/hand-of-straights/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/hand-of-straights/">https://leetcode.cn/problems/hand-of-straights/</a></strong></p><p><strong>題意：</strong>Alice 手中有一堆牌, 她想要重新排列這些牌, 將其分成若干組, 使每一組的牌數都是 <code>groupSize</code>, 並且由 <code>groupSize</code> 張<strong>連續</strong>的牌組成。</p><p>給一整數 array <code>hand</code> 和一整數 <code>groupSize</code>, 其中 <code>hand[i]</code> 代表第 <code>i</code> 張牌。如果她可以重新排列這些牌, 返回 <code>true</code>；否則, 返回 <code>false</code>。</p></blockquote><p><img src="https://i.imgur.com/v90S1cr.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 首先判斷 <code>hand.size()</code> 能否被 <code>groupSize</code> 所整除, 若不行則返回 <code>false</code>。否則, 用 map 統計每張牌出現的次數, 並且根據 card value 由小到大排序。每個 group 每次都先從 map 中取出最小的 card value <code>start</code>, 則該 group 的數字範圍為 <code>[start, start + groupSize - 1]</code>, 只要缺少一個便直接返回 <code>false</code></strong></p><p>取出數字後, 要將其出現次數減一, 然後判斷是否為 <code>0</code>。若是的話, 要將其移除, 否則 <code>start</code> 會一直取到同一個數</p><p>e.g. <code>freqs = &#123;&#123;1, 1&#125;, &#123;2, 1&#125;&#125;</code>, <code>groupSize = 1</code></p><ul><li>若不移除 <code>cnt = 0</code> 的元素, 則取完第一個 group 後, <code>freqs = &#123;&#123;1, 0&#125;, &#123;2, 1&#125;&#125;</code></li><li>第二個 group 的 <code>start</code> 仍會取到 <code>1</code>, 而非 <code>2</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNStraightHand</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; hand, <span class="type">int</span> groupSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hand.<span class="built_in">size</span>() % groupSize != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freqs; <span class="comment">// &#123;card value, cnt&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; card : hand) &#123;</span><br><span class="line">            ++freqs[card];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!freqs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> start = freqs.<span class="built_in">begin</span>()-&gt;first; <span class="comment">// group 開頭數字</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// group range : [start, start + groupSize - 1]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; groupSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (freqs[start + i] == <span class="number">0</span>) &#123; <span class="comment">// 該 group 內有數字不存在</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取出該數字, 並將其出現次數減一, 然後判斷是否為 0</span></span><br><span class="line">                <span class="comment">// 若是的話, 要將其移除, 否則 start 會一直取到同一個數</span></span><br><span class="line">                <span class="keyword">if</span> (--freqs[start + i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    freqs.<span class="built_in">erase</span>(start + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ map 移除元素需花 $O(log(n))$, worse case：每個 <code>hand[i]</code> 都是 unique</li><li><strong>space：</strong>$O(n)$ ➔ <code>freqs</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>57. Insert Interval</title>
      <link href="/post/insert-interval/"/>
      <url>/post/insert-interval/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/insert-interval/">https://leetcode.cn/problems/insert-interval/</a></strong></p><p><strong>題意：</strong>給一無重疊的 interval array <code>intervals</code>, 且 <code>intervals</code> 已根據 <code>intervals[i][0]</code> 做<strong>升序</strong>排列。</p><p>今插入一區間 <code>newInterval</code>, 必須確保插入後 <code>intervals</code> 仍升序排列且不重疊 (如果有必要的話, 可以合併區間)</p></blockquote><p><img src="https://i.imgur.com/g1p0WiU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：先將 <code>newInterval</code> 插入 <code>intervals</code> 中的正確位置, 然後再利用 <a href="https://zako945.github.io/post/merge-intervals/">56. Merge Intervals</a> 進行 merge</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = intervals.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根據 start 將 newInterval 插入到 intervals 中</span></span><br><span class="line">        <span class="keyword">while</span> (it != intervals.<span class="built_in">end</span>() &amp;&amp; newInterval[<span class="number">0</span>] &gt; (*it)[<span class="number">0</span>]) &#123;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        intervals.<span class="built_in">insert</span>(it, newInterval);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res&#123;intervals[<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 取出前一個 interval 的 end</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> lastEnd = res.<span class="built_in">back</span>()[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 interval[i].start &lt;= interval[i-1].end, 則重設新的 end(合併)</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= lastEnd) &#123;</span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(lastEnd, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>intervals</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>res</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/post/jump-game/"/>
      <url>/post/jump-game/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></strong></p><p><strong>題意：</strong>給一非負整數 array <code>nums</code>, 最初位置在 <code>nums[0]</code>, 其中 <code>nums</code> 中的每個元素代表該位置可以跳躍的最大長度, 返回是否能從起點抵達最後一個 index。</p></blockquote><p><img src="https://i.imgur.com/2AvbHul.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i]</code> 代表第 <code>i</code> 個點能否被抵達, 條件是 <code>i</code> 前面的任意點 <code>j</code> 能被抵達 （<code>dp[j] = true</code>）, 且能從 <code>j</code> 跳到 <code>i</code> （<code>j + nums[j] &gt;= i</code> ）, 故得到狀態轉移方程：</strong></p><ul><li><strong><code>dp[i] = (dp[j] == true) &amp;&amp; (j + nums[j] &gt;= i)</code>, 其中 <code>0 ≤ j &lt; i</code></strong></li></ul><p><strong>從下圖中可看到, 從 <code>idx = 2</code> 開始往後走的有重複, 故用 cache 把結果存起來, 避免重複計算</strong></p><p><img src="https://i.imgur.com/F6EXZXZ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 起點一定能抵達</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="comment">// 第 j 個點能被抵達 &amp;&amp; 能從 j 跳到 i</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; j + nums[j] &gt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 從終點往回推, 只要有某點能到達終點, 就把該點設為終點（因為其他點只要能到達該點, 就一定能抵達終點）。若最後終點等於 <code>0</code>, 則代表能從起點能走到終點</strong></p><p><img src="https://i.imgur.com/OnUEHiO.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> goal = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = goal - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= goal) &#123;</span><br><span class="line">                goal = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> goal == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45. Jump Game II</title>
      <link href="/post/jump-game-ii/"/>
      <url>/post/jump-game-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></strong></p><p><strong>題意：</strong>給一非負整數 array <code>nums</code>, 你最初位於 <code>nums</code> 的第一個位置。</p><p><code>nums</code> 中的每個元素代表你在該位置可以跳躍的最大長度。</p><p>假設你總是可以到達 <code>nums</code> 的最後一個位置。</p><p>返回到達 <code>nums</code> 的最後一個位置所需的<strong>最少的跳躍次數</strong>。</p></blockquote><p><img src="https://i.imgur.com/KsGAy5K.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 用 <code>[start, end]</code> 來記錄每次跳躍的區間, 而 <code>maxPos</code> 則是用來紀錄 <code>[start, end]</code> 中所能跳躍的最遠 index。若 <code>end ≥ nums.size() - 1</code> 代表上一次跳躍已能抵達 <code>nums</code> 的終點, 因此結束循環</strong></p><p><img src="https://i.imgur.com/FnqWVHE.png"></p><p><img src="https://i.imgur.com/UgNxMDV.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxPos = <span class="number">0</span>; <span class="comment">// 所能跳躍的最遠 index</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, res = <span class="number">0</span>; <span class="comment">// 起始區間 [start, end]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 只要 end ≥ nums 的最後一個 index 就終止</span></span><br><span class="line">            <span class="comment">// 計算下一次跳躍所能到的最遠 idx</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">                maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            start = end + <span class="number">1</span>; <span class="comment">// 下一次跳躍的起點</span></span><br><span class="line">            end = maxPos; <span class="comment">// 下一次跳躍的終點</span></span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>97. Interleaving String</title>
      <link href="/post/interleaving-string/"/>
      <url>/post/interleaving-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/interleaving-string/">https://leetcode.cn/problems/interleaving-string/</a></strong></p><p><strong>題意：</strong>給三個 string <code>s1</code>、<code>s2</code>、<code>s3</code>, 返回 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> 交錯組成的。</p><p>兩個 sting <code>s</code>、<code>t</code> 交錯的定義與過程如下, 其中每個 string 都會被分割成若干個 <strong>non-empty</strong> substring：</p><ul><li><code>s = s1 + s2 + ... + sn</code></li><li><code>t = t1 + t2 + ... + tm</code></li><li><code>|n - m| &lt;= 1</code></li><li>交錯是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li></ul><p><strong>注意：</strong><code>a + b</code> 代表 string <code>a</code> 和 <code>b</code> 串接。</p></blockquote><p><img src="https://i.imgur.com/UAhxyXi.png"></p><p><img src="https://i.imgur.com/OFat657.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i][j]</code> 表示 <code>s1</code> 前 <code>i</code> 個 char 和 <code>s2</code> 前 <code>j</code> 個 char 能否構成 <code>s3</code> 前 <code>i + j</code> 個 char</strong></p><p><strong><code>dp[i][j]</code> 為 <code>true</code> 有兩種情況：</strong></p><ul><li><strong><code>s1[i - 1] == s3[i + j - 1] &amp;&amp; dp[i - 1][j]</code></strong><ul><li>當 <code>s1</code> 的最後一個 char 等於 <code>s3</code> 最後一個 char</li><li>且 <code>s1</code> 前 <code>i - 1</code> 個 char、<code>s2</code> 前 <code>j</code> 個 char 能構成 <code>s3</code> 前 <code>i + j - 1</code> 個 char</li></ul></li><li><strong><code>s2[j - 1] == s3[i + j - 1] &amp;&amp; dp[i][j - 1]</code></strong><ul><li>當 <code>s2</code> 的最後一個 char 等於 <code>s3</code> 最後一個 char</li><li>且 <code>s1</code> 前 <code>i</code> 個 char、<code>s2</code> 前 <code>j - 1</code> 個 char 能構成 <code>s3</code> 前 <code>i + j - 1</code> 個 char</li></ul></li></ul><p><strong>滿足上面公式的 <code>i</code>、<code>j</code> 必須 <code>≥ 1</code>, 否則 <code>dp[i - 1][j]</code>、<code>dp[i][j - 1]</code> 會越界</strong></p><p><strong>也就是說 <code>dp[i][j]</code> 只考慮了 <code>i, j ≥ 1</code> 的情況, 並沒有考慮到：</strong></p><ul><li><strong><code>i = 0, j = 0</code></strong> : 也就是 <code>s1</code>、<code>s2</code> 皆為 <code>&quot;&quot;</code> 時, 能否組成 <code>s3 = &quot;&quot;</code></li><li><strong><code>i = 0 ~ m, j = 0</code></strong> : 也就是 <code>s2</code> 為 <code>&quot;&quot;</code> 時, 僅靠 <code>s1</code> 能否構成 <code>s3</code></li><li><strong><code>i = 0, j = 0 ~ n</code></strong> : 也就是 <code>s1</code> 為 <code>&quot;&quot;</code> 時, 僅靠 <code>s2</code> 能否構成 <code>s3</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m + n != s3.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// m + 1、n + 1 是因為要考慮 s1、s2 為空的情況</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 當 s1、s2 皆為 &quot;&quot; 時, 能構成 s3 = &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2 皆為 &quot;&quot; 時, 僅靠 s1 能否構成 s3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = (s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]) &amp;&amp; dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s1 皆為 &quot;&quot; 時, 僅靠 s2 能否構成 s3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = (s2[j - <span class="number">1</span>] == s3[j - <span class="number">1</span>]) &amp;&amp; dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i, j 皆 ≥ 1 的狀態轉移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                dp[i][j] = (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j]) ||</span><br><span class="line">                           (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1143. Longest Common Subsequence</title>
      <link href="/post/longest-common-subsequence/"/>
      <url>/post/longest-common-subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></strong></p><p><strong>題意：</strong>給兩 string <code>text1</code>、<code>text2</code>, 返回最長<strong>共同 subsequence</strong> 的長度。若不存在最長<strong>共同 subsequence</strong>, 則返回 <code>0</code>。</p><p><strong>注意：</strong></p><ul><li>substring 指的是 string 中<strong>連續的</strong> subset</li><li>subsequence 則是 string 的 subset</li><li><code>text1</code>、<code>text2</code> 只由<strong>小寫</strong>字母所組成</li></ul></blockquote><p><img src="https://i.imgur.com/rJbnkDq.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>text1</code>、<code>text2</code> 前先加上一個 <code>#</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i][j]</code>：<code>text1[1:i]</code>、<code>text2[1:j]</code> 的 LCS 之長度</li></ul><p><strong>2. 得到轉移方程：</strong></p><p>令 <code>text1[1:i] = XXXXi</code>, <code>text2[1:j] = YYYj</code></p><ul><li><p>若 <code>text1[i] == text2[j]</code>, 則 <code>[XXXX]</code>、<code>[YYY]</code> 之 LCS 再加上 <code>text1[i]</code> 即可<br>➔ <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p></li><li><p>否則, LCS 為以下兩種中取較大者</p><ul><li><code>[XXXXi]</code>、<code>[YYY]</code>：<code>dp[i][j - 1]</code></li><li><code>[XXXX]</code>、<code>[YYYj]</code>：<code>dp[i - 1][j]</code></li></ul><p>  ➔ <code>dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</code></p></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0][0]</code>：當 <code>text1</code>、<code>text2</code> 皆為 <code>&quot;&quot;</code> 時, LCS 必為 <code>&quot;&quot;</code><br>➔ <code>dp[0][0] = 0</code></li><li><code>dp[i][0]</code>：當 <code>text2</code> 為 <code>&quot;&quot;</code> 時, LCS 必為 <code>&quot;&quot;</code><br>➔ <code>dp[i][0] = 0</code></li><li><code>dp[0][j]</code>：當 <code>text1</code> 為 <code>&quot;&quot;</code> 時, LCS 必為 <code>&quot;&quot;</code><br>➔ <code>dp[0][j] = 0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = text1.<span class="built_in">size</span>(), n = text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        text1 = <span class="string">&#x27;#&#x27;</span> + text1;</span><br><span class="line">        text2 = <span class="string">&#x27;#&#x27;</span> + text2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 發現其實計算 <code>dp[i][j]</code> 只需用到當前列的 <code>dp[i][j - 1]</code> 和上一列的 <code>dp[i - 1][j]</code>, 因此只需紀錄當前列和上一列的計算結果即可, 而不用紀錄整個 <code>m x n</code> matrix, 這樣就能將 $O(m \cdot n)$ space 降至 $O(n)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = text1.<span class="built_in">size</span>(), n = text2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 讓 n 為較短的 string 長度</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">longestCommonSubsequence</span>(text2, text1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        text1 = <span class="string">&#x27;#&#x27;</span> + text1;</span><br><span class="line">        text2 = <span class="string">&#x27;#&#x27;</span> + text2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; nextRow = dp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]) &#123;</span><br><span class="line">                    nextRow[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextRow[j] = <span class="built_in">max</span>(nextRow[j - <span class="number">1</span>], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow); <span class="comment">// 更新 dp, 下一輪中這輪所計算的會變成上一輪</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(min(m, n))$ ➔ <code>dp</code>, <code>nextRow</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>300. Longest Increasing Subsequence</title>
      <link href="/post/longest-increasing-subsequence/"/>
      <url>/post/longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 找出其中最長的<strong>嚴格遞增</strong> subarray 之長度。</p><p><strong>進階：</strong>設計 $O(n \cdot log(n))$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/lpfOr7e.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li>首先, 會在 <code>nums</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[i]</code>：<code>nums[1:i]</code> 中 LIS 的長度</li></ul><p><strong>2. 得到轉移方程：</strong></p><ul><li><code>dp[i] = max(dp[i], dp[j] + 1)</code>, for <code>1 ≤ j &lt; i</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li><code>dp[0]</code>：當沒有元素時, LIS 的長度為 <code>0</code></li><li><code>dp[i]</code>：至少一個元素時, LIS 的長度最小為 <code>1</code>, 其中 <code>1 ≤ i ≤ n</code></li><li><code>res</code>：至少一個元素時, LIS 的長度最小為 <code>1</code></li></ul><p><img src="https://i.imgur.com/lUEZXzy.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>; <span class="comment">// 題目給定 nums 不為空</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：使用 DP + Greedy + Binary Search, 我們在乎只當前 subarray 的結尾</strong></p><p><img src="https://i.imgur.com/iJkD0sg.png"></p><p><img src="https://i.imgur.com/sbioTED.png"></p><p><strong>每當有一新數字 <code>num</code> 進來之後, 判斷 <code>num</code> 是否比現在 <code>dp.back()</code> 的數值大</strong></p><ul><li>若 <code>num &gt; dp.back()</code>, 那就直接放到 <code>dp.back()</code> 的後面, 成為新的結尾</li><li>否則, 用 Binary Search 找到 <code>dp</code> 中從左數來第一個大於 <code>num</code> 的數字, 並將其替換掉。<br>（<strong>因為 <code>dp</code> 結尾變小, 將來可能可以接得更長</strong>）<br>e.g. 下圖中紅框部分, 用 <code>5</code> 取代 <code>8</code>, 使 <code>dp</code> 結尾變小, 讓之後的 <code>6</code> 能加入</li></ul><p>e.g. <code>nums = [3, 4, 1, 2, 8, 5, 6]</code></p><p><img src="https://i.imgur.com/SHbfXNJ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">        dp.<span class="built_in">emplace_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp.<span class="built_in">back</span>() &lt; nums[i]) &#123;</span><br><span class="line">                dp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *<span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), nums[i]) = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ for loop, 其中 <code>lower_bound()</code> 是使用 Binary Search 實作的</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>152. Maximum Product Subarray</title>
      <link href="/post/maximum-product-subarray/"/>
      <url>/post/maximum-product-subarray/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-product-subarray/">https://leetcode.cn/problems/maximum-product-subarray/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 找出乘積最大的非空<strong>連續</strong> subarray, 並返回該乘積。</p></blockquote><p><img src="https://i.imgur.com/rN6QfDI.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：定義乘積為區間 <code>[0, i]</code> 中的最大 or 最小乘積。為何乘積必須同時記錄 <code>curMax</code> 和 <code>curMin</code>？因為 array 中可能會有負數, 且負負得正。當 <code>nums[i]</code> 為負數時, 之前紀錄的 <code>curMax</code> 乘它之後變最小值, 也有可能之前紀錄的 <code>curMin</code> 乘它之後變比之前的 <code>curMax</code> 還大。所以當 <code>nums[i]</code> 為負數時, 要將 <code>curMax</code> 和 <code>curMin</code> 做 swap, 這樣才不會出錯</strong></p><p><img src="https://i.imgur.com/gsvOAgs.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curMax = <span class="number">1</span>, curMin = <span class="number">1</span>, res = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(curMax, curMin);</span><br><span class="line">            &#125;</span><br><span class="line">            curMax = <span class="built_in">max</span>(num * curMax, num);</span><br><span class="line">            curMin = <span class="built_in">min</span>(num * curMin, num);</span><br><span class="line">            res = <span class="built_in">max</span>(res, curMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53. Maximum Subarray</title>
      <link href="/post/maximum-subarray/"/>
      <url>/post/maximum-subarray/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 找到一 subarray, 其元素和為所有 subarray 中最大的。</p><p><strong>注意：</strong>subarray 必須是連續的（index 不可中斷）</p></blockquote><p><img src="https://i.imgur.com/m7Xl6vL.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 每個元素都有加入 or 不加入 subarray 兩種選擇。若不加入, 則該元素成為新的 subarray 的開頭繼續往後尋找, 其中 <code>dp[i]</code> 代表 <code>[0, i]</code> 這個區間中擁有最大和的 subarray 之和</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, nums[<span class="number">0</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code> 中的元素</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 由於 <code>dp[i]</code> 只需紀錄 <code>dp[i - 1]</code> 就好, 因此不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>], cur = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cur = <span class="built_in">max</span>(nums[i], cur + nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. Merge Intervals</title>
      <link href="/post/merge-intervals/"/>
      <url>/post/merge-intervals/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></strong></p><p><strong>題意：</strong>給一 array <code>intervals</code>, 其中 <code>intervals[i] = [start_i, end_i]</code>, 合併所有重疊的區間, 並返回一個不重疊區間 array。</p></blockquote><p><img src="https://i.imgur.com/hPbh5w5.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：類似 <a href="https://zako945.github.io/post/meeting-rooms/">252. Meeting Rooms</a>, 先根據 <code>intervals[i].start</code> 做排序, 若 <code>interval[i].start ≤ res.back().end</code> 的話代表有重疊, 則將當前的 <code>interval.end</code> 設為兩者 <code>end</code> 中較大的（合併）; 若無重疊, 則將 <code>interval[i]</code> 加入到 <code>res</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res&#123;intervals[<span class="number">0</span>]&#125;; <span class="comment">// 將第一個區間放入到 res</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 取出當前 interval 的 end</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> lastEnd = res.<span class="built_in">back</span>()[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 interval[i].start &lt;= res.back().end, 則重設新的 end (合併)</span></span><br><span class="line">            <span class="comment">// e.g. [[1,4], [2,3]] -&gt; [1,4]</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= lastEnd) &#123;</span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(lastEnd, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要返回 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1899. Merge Triplets to Form Target Triplet</title>
      <link href="/post/merge-triplets-to-form-target-triplet/"/>
      <url>/post/merge-triplets-to-form-target-triplet/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/">https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/</a></strong></p><p><strong>題意：triplet</strong> 是由三個整數所組成的 array。給一 2D 整數 array <code>triplets</code>, 其中 <code>triplets[i] = [ai, bi, ci]</code> 表示第 <code>i</code> 個 triplet。並給一整數 array <code>target = [x, y, z]</code>, 表示你想要得到的 triplet。</p><p>為了得到 <code>target</code>, 你需要對 <code>triplets</code> 進行下面的操作<strong>任意次</strong>（也可能是 <code>0</code> 次）：</p><ul><li>選出兩個 index（index 從 <code>0</code> 開始）<code>i</code> 和 <code>j</code>（<code>i != j</code>）, 並更新 <code>triplets[j]</code> 為 <code>[max(ai, aj), max(bi, bj), max(ci, cj)]</code></li></ul><p>e.g. <code>triplets[i] = [2, 5, 3]</code> 且 <code>triplets[j] = [1, 7, 5]</code></p><p>➔ 則 <code>triplets[j]</code> 將會更新為 <code>[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]</code>。</p><p>若透過上述操作可使得 <code>target</code> 成為 <code>triplets</code> 中的元素, 則返回 <code>true</code>；否則, 返回 <code>false</code>。</p></blockquote><p><img src="https://i.imgur.com/EuddNK2.png"></p><p><img src="https://i.imgur.com/c5eJ7vA.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 令 <code>x = target[0]</code>, <code>y = target[1]</code>, <code>z = target[2]</code>, 且 <code>ai = triplet[0]</code>, <code>bi = triplet[1]</code>, <code>ci = triplet[2]</code>。若 <code>ai &gt; x</code> 或 <code>bi &gt; y</code> 或 <code>ci &gt; z</code>, 則跳過該 triplet, 因為若拿該 triplet 做運算 <code>(a, b, c)</code> 一定不等於 <code>(x, y, z)</code>。否則, 更新 <code>a, b, c</code>。最後判斷 <code>(a, b, c)</code> 是否等於 <code>(x, y, z)</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">mergeTriplets</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triplets, vector&lt;<span class="type">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> x = target[<span class="number">0</span>], y = target[<span class="number">1</span>], z = target[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; triplet : triplets) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> ai = triplet[<span class="number">0</span>], bi = triplet[<span class="number">1</span>], ci = triplet[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 ai &gt; x 或 bi &gt; y 或 ci &gt; z, 則跳過該 triplet</span></span><br><span class="line">            <span class="keyword">if</span> (ai &lt;= x &amp;&amp; bi &lt;= y &amp;&amp; ci &lt;= z) &#123;</span><br><span class="line">                a = <span class="built_in">max</span>(a, ai);</span><br><span class="line">                b = <span class="built_in">max</span>(b, bi);</span><br><span class="line">                c = <span class="built_in">max</span>(c, ci);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tie 可用於比較 struct</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tie</span>(a, b, c) == <span class="built_in">tie</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>triplets</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>647. Palindromic Substrings</title>
      <link href="/post/palindromic-substrings/"/>
      <url>/post/palindromic-substrings/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 返回迴文 substring 數量。</p></blockquote><p><img src="https://i.imgur.com/RPEOQB5.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用DP, 可參考 <a href="https://zako945.github.io/post/longest-palindromic-substring/">5. Longest Palindromic Substring</a></strong></p><p><img src="https://i.imgur.com/hNq2e4T.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n; <span class="comment">// 每個 char 自己本身(對角線)為回文</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; ++i) &#123;</span><br><span class="line">                dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用中心擴散法</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">expand</span>(s, i, i, n, res); <span class="comment">// odd string</span></span><br><span class="line">            <span class="built_in">expand</span>(s, i, i + <span class="number">1</span>, n, res); <span class="comment">// even string</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">const</span> <span class="type">int</span> n, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 遍歷每個 char, 每個 char 為中心最多往外擴散 $\dfrac{n}{2}$ 次, 得 $2 \cdot O(\dfrac{n}{2}) \cdot n$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-3：（不會也沒差-會前兩種方法就足夠了）"><a href="#Solution-3：（不會也沒差-會前兩種方法就足夠了）" class="headerlink" title="Solution 3：（不會也沒差, 會前兩種方法就足夠了）"></a><strong>Solution 3：（不會也沒差, 會前兩種方法就足夠了）</strong></h2><blockquote><p><strong>想法：利用 Manacher 演算法, 可參考 <a href="https://zako945.github.io/post/longest-palindromic-substring/">5. Longest Palindromic Substring</a>, <code>res += (p[i] + 1) / 2</code> 的原因為以下兩種：</strong></p><ul><li><strong>若 <code>p[i] = 1</code>：<code>&quot;abc&quot;</code> 擴充後 a, b, c 之 <code>p[i]</code> 皆為 1, 擴充半徑為 1, 代表回文只有自己, 但這也算一種回文</strong></li><li><strong>若 <code>p[i] &gt; 1</code>：<code>&quot;aba&quot;</code> 擴充後 b 之 <code>p[i] = 3</code>, 從 b 為中心得到的回文 substring 有：<code>&quot;b&quot;</code>（擴充半徑 &#x3D; 0）和 <code>&quot;aba&quot;</code>（擴充半徑 &#x3D; 1）, 也就是擴充半徑 <code>[0, (p[i] / 2)]</code>, 共 <code>(p[i] / 2) + 1</code> 種, 也可寫作 <code>(p[i] + 1) / 2</code> 種（奇偶都符合）</strong></li></ul><p>➔ <strong>公式：<code>(p[i] + 1) / 2</code> 滿足上述兩種情況</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string tmp = <span class="built_in">preProcess</span>(s);</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = tmp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n - <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 最後一個 $ 不用算</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>, center = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idxMirror = <span class="number">2</span> * center - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 防止超出 right</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; right) &#123;</span><br><span class="line">                p[i] = <span class="built_in">min</span>(p[idxMirror], right - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// i &gt;= right 的時候</span></span><br><span class="line">                p[i] = <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 有三種情況, 需使用中心擴散法</span></span><br><span class="line"><span class="comment">             * 1. i + p[idxMirror] &gt; right</span></span><br><span class="line"><span class="comment">             * 2. i &gt;= right 的時候</span></span><br><span class="line"><span class="comment">             * 3. p[idxMirror] 遇到左邊界</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (tmp.<span class="built_in">at</span>(i - <span class="number">1</span> - p[i]) == tmp.<span class="built_in">at</span>(i + <span class="number">1</span> + p[i])) &#123;</span><br><span class="line">                ++p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判斷是否超出右邊界, 是的話要更新右邊界和中心</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; right) &#123;</span><br><span class="line">                center = i;</span><br><span class="line">                right = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res += (p[i] + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">string <span class="title">preProcess</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        string tmp = <span class="string">&quot;^&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            tmp += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            tmp += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 透過不斷拓展 <code>right</code>, 且 <code>right</code> 只增不減, 故只看 for loop, 因為 while loop 拜訪過的 char 不會再進 while loop（可透過 DP 快速得到）</li><li><strong>space：</strong>$O(n)$ ➔ <code>tmp</code>, <code>p</code> 的長度 &#x3D; <code>2 * s.size() + 3</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>416. Partition Equal Subset Sum</title>
      <link href="/post/partition-equal-subset-sum/"/>
      <url>/post/partition-equal-subset-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></strong></p><p><strong>題意：</strong>給一<strong>只含正整數</strong>的非空 array <code>nums</code>, 返回是否能將 <code>nums</code> 切割成兩個 subset, 使得兩個 subset 的元素和相等。</p></blockquote><p><img src="https://i.imgur.com/MpRRg9c.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 因為此題可看作是 0-1 背包問題, 從前 <code>i</code> 個數中取出一些數, 使這些數之和為 <code>target</code>, 其中 <code>dp[i][j]</code> 代表前 <code>i</code> 個數是否能取出一些數, 使得這些數和為 <code>j</code>, 可得以下公式：</strong></p><ul><li><strong>不選擇 <code>nums[i]</code>：<code>dp[i][j] = dp[i - 1][j]</code></strong></li><li><strong>選擇 <code>nums[i]</code>：<code>dp[i][j] = dp[i - 1][j - nums[i]]</code>, 其中 <code>j &gt;= nums[i]</code></strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(target + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][0] 皆為 true, 因為前 i 個數都不取, 必滿足 sum = 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= target; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot sum)$ ➔ for loop, 因為 target &#x3D; $\dfrac{sum}{2}$</li><li><strong>space：</strong>$O(n \cdot sum)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>dp[i][j]</code> 只會用到上一列的元素, 故不需要開到</strong> $O(n \cdot sum)$ <strong>空間, 只需記住上一列的狀態即可, 這樣只需要 $O(2 \cdot sum)$ space</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// dp[0] 為 true, 因為前 i 個數都不取, 必滿足 sum = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="type">bool</span>&gt; nextRow = dp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= target; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    nextRow[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextRow[j] = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot sum)$ ➔ for loop, 因為 target &#x3D; $\dfrac{sum}{2}$</li><li><strong>space：</strong>$O(sum)$ ➔ <code>dp</code> 和 <code>nextRow</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, 將空間從 2 * sum 降到 sum, 其中 <code>j</code> 的 for loop 必須從後面來, 這樣才不會在同一次 loop 中用到剛賦值的</strong></p><p>e.g. <code>nums = [2, 2, 3, 5]</code>, <code>target = 6</code>, 沒解</p><ul><li>順著來：<code>i = 1</code><ul><li><p><code>j = 2</code> 時, <code>dp[i][2] = true</code></p></li><li><p><code>j = 4</code> 時, <code>dp[i][4] = dp[i][2] = true</code></p></li><li><p><code>j = 6</code> 時, <code>dp[i][6] = dp[i][4] = true</code>, 不符答案</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>T</td><td>F</td><td>T</td><td>F</td><td>T</td><td>F</td><td>T</td></tr></tbody></table></li></ul></li><li>倒著來：<code>i = 1</code><ul><li><p><code>j = 6</code> 時, <code>dp[i][6] = dp[i][4] = false</code></p></li><li><p><code>j = 4</code> 時, <code>dp[i][4] = dp[i][2] = false</code></p></li><li><p><code>j = 2</code> 時, <code>dp[i][2] = dp[i][0] = true</code></p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>T</td><td>F</td><td>T</td><td>F</td><td>F</td><td>F</td><td>F</td></tr></tbody></table></li><li><p>最終輸出為：下表, 得到答案為 false</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>T</td><td>F</td><td>T</td><td>T(i&#x3D;3)</td><td>T(i&#x3D;2)</td><td>T(i&#x3D;4)</td><td>F</td></tr></tbody></table></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 倒著才不會用到在同一個 j loop 中剛賦值完的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot sum)$ ➔ for loop, 因為 target &#x3D; $\dfrac{sum}{2}$</li><li><strong>space：</strong>$O(sum)$ ➔ <code>dp</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>763. Partition Labels</title>
      <link href="/post/partition-labels/"/>
      <url>/post/partition-labels/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/partition-labels/">https://leetcode.cn/problems/partition-labels/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code> 由<strong>小寫</strong>字母所組成。我們要把 <code>s</code> 劃分為盡可能多的 partition, 同一字母只能出現在同一個 partition 中。返回一個表示每個 partition 的長度之 array。</p></blockquote><p><img src="https://i.imgur.com/VsVJiwl.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 首先遍歷 <code>s</code>, 並用 <code>lastIdx</code> 紀錄每個字母的最後一個 index, 然後從頭開始遍歷 <code>s</code>, 並不斷更新當前 partition 的結尾。若 <code>i == idx</code> 代表已走到 partition 結尾, 即可確定當前 partition 的 size, 因為該 partition 中的 char 都沒有出現在更後面的位置</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; lastIdx; <span class="comment">// &#123;char, last index&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            lastIdx[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> curSize = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++curSize;</span><br><span class="line">            end = <span class="built_in">max</span>(end, lastIdx[s[i]]); <span class="comment">// 更新當前 partition 的結尾</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 抵達該 partition 的結尾</span></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(curSize);</span><br><span class="line">                curSize = <span class="number">0</span>; <span class="comment">// 下一個 partition 的長度從 0 開始算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ <code>lastIdx</code> 中的元素不超過 26 個</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>494. Target Sum</title>
      <link href="/post/target-sum/"/>
      <url>/post/target-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/target-sum/">https://leetcode.cn/problems/target-sum/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和整數 <code>target</code>, 在 <code>nums</code> 中每個整前添加 <code>+</code> 或 <code>-</code>, 然後串聯整個 <code>nums</code> 形成一個表達式：</p><ul><li>e.g. <code>nums = [2, 1]</code> 可以在 <code>2</code> 前添加 <code>+</code>, 在 <code>1</code> 前添加 <code>-</code>, 形成表達式 <code>+2-1</code></li></ul><p>求運算結果等於 <code>target</code> 的不同表達式數目。</p></blockquote><p><img src="https://i.imgur.com/vfEoALs.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用暴力法, 遞迴下去做（速度極慢）</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &gt; <span class="built_in">abs</span>(sum) || target &lt; -<span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>(), target, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> target, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n, target + nums[i], res);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n, target - nums[i], res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(2^n)$ ➔ <code>nums</code> 中每個數有兩種選擇</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴的深度, 遞迴最大深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 可把這題看做是背包問題, 每一個 <code>nums[i]</code> 都有取正 or 取負兩種選擇</strong></p><p><strong>1. 定義狀態：</strong></p><ul><li><code>dp[i][j]</code>：<code>nums[1:i]</code> 湊出 <code>j</code> 的方法數</li></ul><p><strong>2. 得到狀態轉移方程：</strong></p><ul><li><code>dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]</code></li></ul><p><strong>3. 初始化：</strong></p><ul><li>首先, 會在 <code>nums</code> 前先加上一個 <code>0</code>, 代表什麼元素都沒有的狀態</li><li><code>dp[0][0] = 1</code>：代表沒有元素時, 湊出 <code>0</code> 的方案為 <code>1</code> 種</li></ul><p><strong>4. 注意事項：</strong></p><ul><li><p>本題 <code>dp[i][j]</code> 的 <code>j</code> 之範圍為 <code>[-abs(sum), abs(sum)]</code>, 但 index 不允許<strong>負數</strong>, 因此統一加上 <code>offset = abs(sum)</code>, 將其 mapping 到範圍 <code>[0, 2 * abs(sum)]</code></p><p>  <img src="https://i.imgur.com/Mzxqnbm.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &gt; <span class="built_in">abs</span>(sum) || target &lt; -<span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">// nums 前面補 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// range：[-abs(sum), abs(sum)], 要 mapping 到 idx：[0, abs(sum)], 要加 offset</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * <span class="built_in">abs</span>(sum) + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> offset = <span class="built_in">abs</span>(sum), n = nums.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span> + offset] = <span class="number">1</span>; <span class="comment">// j = 0 被 mapping 到 0 + offset</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = -<span class="built_in">abs</span>(sum); j &lt;= <span class="built_in">abs</span>(sum); ++j) &#123;</span><br><span class="line">                <span class="comment">// 避免越界</span></span><br><span class="line">                <span class="keyword">if</span> (j - nums[i] &gt;= -<span class="built_in">abs</span>(sum) &amp;&amp; j - nums[i] &lt;= <span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">                    dp[i][j + offset] += dp[i - <span class="number">1</span>][j - nums[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(j + nums[i] &gt;= -<span class="built_in">abs</span>(sum) &amp;&amp; j + nums[i] &lt;= <span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">                    dp[i][j + offset] += dp[i - <span class="number">1</span>][j + nums[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][target + offset];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(sum \cdot n)$ ➔ for loop, 其中 <code>sum</code> 為 <code>nums</code> 元素之和</li><li><strong>space：</strong>$O(sum \cdot n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：Solution 2 的改進, 實際上 <code>dp[i][j + offset]</code> 只會用到上一列 <code>dp[i - 1][X]</code>, 故不需要開到 $O(sum \cdot n)$ 的空間, 只需 $O(sum)$ 的空間即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &gt; <span class="built_in">abs</span>(sum) || target &lt; -<span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">emplace</span>(nums.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">// nums 前面補 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// range：[-abs(sum), abs(sum)], 要 mapping 到 idx [0, abs(sum)], 要加 offset</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span> * abs(sum) + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> offset = <span class="built_in">abs</span>(sum), n = nums.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span> + offset] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextRow</span><span class="params">(<span class="number">2</span> * abs(sum) + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = -<span class="built_in">abs</span>(sum); j &lt;= <span class="built_in">abs</span>(sum); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i] &gt;= -<span class="built_in">abs</span>(sum) &amp;&amp; j - nums[i] &lt;= <span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">                    nextRow[j + offset] += dp[j - nums[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j + nums[i] &gt;= -<span class="built_in">abs</span>(sum) &amp;&amp; j + nums[i] &lt;= <span class="built_in">abs</span>(sum)) &#123;</span><br><span class="line">                    nextRow[j + offset] += dp[j + nums[i] + offset];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target + offset];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(sum \cdot n)$ ➔ for loop, 其中 <code>sum</code> 為 <code>nums</code> 元素之和</li><li><strong>space：</strong>$O(sum)$ ➔ <code>dp</code>, <code>nextRow</code> 皆只需 $O(2 \cdot sum + 1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62. Unique Paths</title>
      <link href="/post/unique-paths/"/>
      <url>/post/unique-paths/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></strong></p><p><strong>題意</strong>：有一機器人位於 <code>m x n</code> 網格的<strong>左上角</strong>, 機器人每次只能往下 or 往右一步, 機器人試圖抵達網格的<strong>右下角</strong>, 求總共幾條不同的路徑。</p></blockquote><p><img src="https://i.imgur.com/ZTNi2hP.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 定義 <code>dp[i][j]</code> 為從起點到 <code>(i, j)</code> 的方法數, 其中第一列和第一行方法數皆初始化為 <code>1</code>（因為只能往下、右移動）。要避免重複計算（圖中橘色圈起來的部分）, <code>dp[i][j]  = 其左邊格子的方法數 + 上方格子的方法數</code></strong><br>➔ 得到 <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p><p><img src="https://i.imgur.com/2W7qu0D.png"></p><p><img src="https://i.imgur.com/uWIclvR.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為 <code>dp[i][j]</code> 只會用到同一列的 <code>dp[i][j - 1]</code> 和上一列 <code>dp[i - 1][j]</code>, 故不需要開到 $O(m \cdot n)$ space, 只需開到 $O(n)$</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; nextRow = dp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                nextRow[j] = nextRow[j - <span class="number">1</span>] + dp[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp = <span class="built_in">move</span>(nextRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code> 和 <code>nextRow</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：用到排列組合數學, 總共要走 <code>m - 1</code> 個 <code>⇩</code> 和 <code>n - 1</code> 個 <code>⇨</code>, 可看成不盡相異物排列</strong></p><p>$\binom{(m-1)+(n-1)}{m-1} &#x3D; \binom{m+n-2}{m-1} &#x3D; \dfrac{(m+n-2)(m+n-3) … n}{(m-1)(m-2) … 1}$</p><p>$&#x3D; \dfrac{n}{1} \cdot \dfrac{n + 1}{2} … \dfrac{m+n-3}{m-2} \cdot \dfrac{m+n-2}{m-1}$</p><p><strong>其中，$\binom{m+n-2}{m-1} &#x3D; \binom{m+n-2}{n-1}$，故可以取 <code>r = min(m, n)</code> 來簡化計算</strong></p><ul><li>若 <code>r</code> 取 <code>m</code>，則 <code>分子 - 分母 = n - 1</code></li><li>若 <code>r</code> 取 <code>n</code>，則 <code>分子 - 分母 = m - 1</code></li></ul><p>令 <code>分母 = i = [0, r - 1]</code>，<code>k = m + n - 2</code>，則 <code>分子 = k - r + i</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> k = m + n - <span class="number">2</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> r = <span class="built_in">min</span>(m, n) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> diff = k - r;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1.0</span>; <span class="comment">// 要用 float 或 double</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">            res *= ((diff + i) / i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(min(m, n))$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>678. Valid Parenthesis String</title>
      <link href="/post/valid-parenthesis-string/"/>
      <url>/post/valid-parenthesis-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-parenthesis-string/">https://leetcode.cn/problems/valid-parenthesis-string/</a></strong></p><p><strong>題意：</strong>給一只包含三種 char <code>（</code> 、<code>）</code> 和 <code>*</code> 的 string <code>s</code>, 判斷 <code>s</code> 是否為<strong>有效</strong>的 string。有效的 string 具有如下規則：</p><ul><li>任何左括號 <code>(</code> 必須有相應的右括號 <code>)</code></li><li>任何右括號 <code>)</code> 必須有相應的左括號 <code>(</code></li><li>左括號 <code>(</code> 必須在對應的右括號之前 <code>)</code></li><li><code>*</code> 可以被視為單個右括號 <code>)</code> or 單個左括號 <code>(</code> or 一個 empty string <code>&quot;&quot;</code></li></ul><p>empty string <code>&quot;&quot;</code> 也被視為有效的 string。</p></blockquote><p><img src="https://i.imgur.com/MeGfxoM.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 由於 <code>*</code> 有三種可能, 因此我們需要用 <code>leftMin</code>、<code>leftMax</code> 來記錄未匹配左括號的範圍</strong></p><ul><li><code>leftMax</code> 代表未匹配左括號的最大數量, 也就是將所有 <strong><code>*</code></strong> 都變成 <code>(</code></li><li><code>leftMin</code> 代表未匹配左括號的最小數量, 也就是將所有 <strong><code>*</code></strong> 都變成 <code>)</code></li></ul><p>一旦 <code>leftMax &lt; 0</code>, 代表 <code>s</code> 中 <code>)</code> 太多, 將所有 <code>*</code> 都變成 <code>(</code> 也無法匹配, 直接返回 <code>false</code></p><p>一旦 <code>leftMin &lt; 0</code>, 此時的 <code>leftMin</code> 為 <code>-1</code>, 代表不應把所有 <code>*</code> 都設為 <code>)</code></p><p>➔ 而是應該把其中一個 <code>*</code> 設為 <code>&quot;&quot;</code>, 以確保 <code>leftMin == 0</code></p><ul><li>將其中一個 <code> </code> 從 <code>)</code> 改為 <code>&quot;&quot;</code>, 也就是讓 <code>leftMin + 1</code></li></ul><p>e.g. <code>s = (*)</code></p><ul><li><code>leftMin = -1</code>, 因為 <code>(*)</code> ➔ <code>())</code>, 但其實可以將 <strong><code>*</code></strong> 從 <code>)</code> 改為 <code>&quot;&quot;</code>, 使得 <code>(*)</code> 變成 <code>()</code></li><li><code>leftMin = 1</code>, 因為 <code>(*)</code> ➔ <code>(()</code></li></ul><p>遍歷結束時, 所有的左括號都應和右括號匹配。因此只有當 <code>leftMin == 0</code> 時, <code>s</code> 才是有效的</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>; <span class="comment">// 未匹配左括號的最大數量, 將所有 * 都變成 (</span></span><br><span class="line">        <span class="type">int</span> leftMin = <span class="number">0</span>; <span class="comment">// 未匹配左括號的最小數量, 將所有 * 都變成 )</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++leftMax;</span><br><span class="line">                ++leftMin;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                --leftMax;</span><br><span class="line">                --leftMin;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++leftMax;</span><br><span class="line">                --leftMin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftMin &lt; <span class="number">0</span>) &#123;<span class="comment">// (*) -&gt; leftMin = -1, leftMax = 1</span></span><br><span class="line">                leftMin = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftMin == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code>, 其中 <code>n</code> 為 <code>s</code> 的長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>139. Word Break</title>
      <link href="/post/word-break/"/>
      <url>/post/word-break/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/word-break/">https://leetcode.cn/problems/word-break/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code> 和一 string list <code>wordDict</code>, 若 <code>wordDict</code> 中的單字能組出 <code>s</code> 則返回 <code>true</code>。</p><p><strong>注意：</strong><code>wordDict</code> 中的 string 互不相同, 且 <code>s.length ≤ 300</code></p></blockquote><p><img src="https://i.imgur.com/Vb1Qrdx.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i]</code> 代表 <code>s[0~(i-1)]</code> 是否能被拆分成若干個出現在 <code>wordDict</code> 中的單字, 我們要枚舉 <code>s[0~(i-1)]</code> 中的切割點 <code>j</code>, 使得 <code>s[0~(j-1)]</code> 和 <code>s[j~(i-1)]</code> 皆在 <code>wordDict</code> 中, 由於 <code>j &lt; i</code>, 所以要計算 <code>dp[i]</code> 時可透過先前計算過的 <code>d[j]</code> 知道 <code>s[0~j]</code> 是否能被拆分, 然後再判斷 <code>s[j~(i-1)]</code> 是否在 <code>wordDict</code> 中即可, 故得到以下公式：</strong></p><ul><li><strong><code>dp[i] = dp[j] &amp;&amp; check(s[j~(i-1)])</code></strong></li><li><strong><code>check(s[j~(i-1)])</code> 代表檢查 <code>s[j~(i-1)]</code> 是否在 <code>wordDict</code> 中</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 空字串一定在 wordDict 中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(j, i - j)) != wordSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2：（TLE-無法通過）"><a href="#Solution-2：（TLE-無法通過）" class="headerlink" title="Solution 2：（TLE 無法通過）"></a><strong>Solution 2：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用 DFS + Trie</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                node-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : wordDict) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> <span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TrieNode *node = trie.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idx = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx]) &#123;</span><br><span class="line">                node = node-&gt;children[idx];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// s[cur~i] 為 word, 則以 i + 1 為開頭繼續遞迴拆分</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;isEnd &amp;&amp; <span class="built_in">dfs</span>(s, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>time：</strong>$O(\sum_{i &#x3D; 0}^{m-1}{w_i} + 2^n)$, 其中 $m$ 為 <code>wordDict</code> 中單字的個數, $w_i$ 為 <code>wordDict[i]</code> 的長度, $n$ 為 <code>s</code> 的長度</p><ul><li><p>$O(\sum_{i &#x3D; 0}^{m-1}{w_i})$：將 <code>wordDict</code> 中每個單字 insert 到 trie 中</p></li><li><p>$O(2^{n})$：判斷長度為 <code>n</code> 的 <code>s</code> 能否拆分成其他單字。$T(n) &#x3D; T(n - 1) + T(n - 2) + … + T(1)$</p><p>  <img src="https://i.imgur.com/DLpKESz.png"></p></li></ul></li><li><p><strong>space：</strong>$O(\sum_{i &#x3D; 0}^{m-1}{w_i})$ ➔ $O(26 \cdot \sum_{i &#x3D; 0}^{m-1}{w_i})$, worse case：trie 中所有單字都沒有重複的 prefix</p></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 DFS + Trie + DP, 改進 Solution 2, 若 <code>s</code> 中 <code>idx = cur</code> 為開頭往後的 substring 無法由若干個 <code>wordDict[i]</code> 所組成, 則透過 <code>memo</code> 紀錄起來, 藉此來進行 pruning, 避免重複走失敗的道路</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[i]) &#123;</span><br><span class="line">                node-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : wordDict) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line">    <span class="type">bool</span> memo[<span class="number">300</span>] = &#123;<span class="literal">false</span>&#125;; <span class="comment">// 紀錄 s 中以 idx 為開頭是否能分割出 word, true 代表不行</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> <span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若已經被標記為失敗, 則直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (memo[cur] == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TrieNode *node = trie.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idx = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx]) &#123;</span><br><span class="line">                node = node-&gt;children[idx];</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;isEnd &amp;&amp; <span class="built_in">dfs</span>(s, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo[cur] = <span class="literal">true</span>; <span class="comment">// 標記為失敗</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(\sum_{i &#x3D; 0}^{m-1}{w_i} + n^2)$, 其中 $m$ 為 <code>wordDict</code> 中單字的個數, $w_i$ 為 <code>wordDict[i]</code> 的長度, $n$ 為 <code>s</code> 的長度<ul><li>$O(\sum_{i &#x3D; 0}^{m-1}{w_i})$：將 <code>wordDict</code> 中每個單字 insert 到 trie 中</li><li>$O(n^2)$：判斷長度為 <code>n</code> 的 <code>s</code> 能否拆分成其他單字<ul><li>$O(n^2)$ : $T(n) &#x3D; T(n - 1) + O(n)$, 因為有用 <code>memo</code> 記憶, 所以呼叫 $T(n-1)$ 即可, 因為 $T(n-1)$ 會再往下呼叫 $T(n-2)$, 依此類推 …, 每個 $T(n-i)$ 只要呼叫一次即可（因為會記住結果）。</li><li>$O(n)$ 是因為呼叫一次 $T(n-1)$ 後, 剩下 $T(n-2), …, T(1)$ 都會計算出來。原本 $O(n)$ 應寫作 $T(n-2) + T(n-3) + … +T(1)$, 但是除了 $T(n-1)$, 剩下的 $T(n-i)$ 都只需 $O(1)$, 故 $T(n-2) + T(n-3) + … +T(1)$ 可直接寫成 $O(n)$。</li></ul></li></ul></li><li><strong>space：</strong>$O(\sum_{i &#x3D; 0}^{m-1}{w_i})$ ➔ $O(26 \cdot \sum_{i &#x3D; 0}^{m-1}{w_i})$ + $O(1)$<ul><li>$O(26 \cdot \sum_{i &#x3D; 0}^{m-1}{w_i})$：worse case：trie 中所有單字都沒有重複的 prefix</li><li>$O(1)$：<code>memo</code> 為常數空間</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>787. Cheapest Flights Within K Stops</title>
      <link href="/post/cheapest-flights-within-k-stops/"/>
      <url>/post/cheapest-flights-within-k-stops/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/cheapest-flights-within-k-stops/">https://leetcode.cn/problems/cheapest-flights-within-k-stops/</a></strong></p><p><strong>題意：</strong>有 <code>n</code> 個城市通過一些航班連接。給一整數 array <code>flights</code>, 其中 <code>flights[i] = [from_i, to_i, price_i]</code> , 表示該航班都從城市 <code>from_i</code> 開始, 以價格 <code>price_i</code> 抵達 <code>to_i</code>。</p><p>給定所有的城市和航班, 以及起點 <code>src</code> 和終點 <code>dst</code>, 找出一條最多經過 <code>k</code> 站中轉的 path, 使得從 <code>src</code> 到 <code>dst</code> 的價格最便宜, 並返回該價格。 如果不存在這樣的 path, 則返回 <code>-1</code>。</p></blockquote><p><img src="https://i.imgur.com/0tyy3zs.png"></p><p><img src="https://i.imgur.com/0IuBr8q.png"></p><p><img src="https://i.imgur.com/Gv0b0YR.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Dijkstra 演算法</strong></p><ul><li>建立 adjacent lit</li><li>建立 min heap</li><li>執行 BFS</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii; <span class="comment">// &#123;weight, next&#125;</span></span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; t3i; <span class="comment">// &#123;cost, cur, times&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">adj</span>(n); <span class="comment">// adjacent list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : flights) &#123;</span><br><span class="line">            adj[f[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(pii&#123;f[<span class="number">2</span>], f[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">calculated</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(k + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        priority_queue&lt;t3i, vector&lt;t3i&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// max heap</span></span><br><span class="line">        pq.<span class="built_in">emplace</span>(t3i&#123;<span class="number">0</span>, src, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = pq.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [cost, cur, times] = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 抵達終點, 返回 cost</span></span><br><span class="line">                <span class="keyword">if</span> (cur == dst) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cost;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若不為終點, 且已中轉 k + 1 次, 代表 cur 不可能到終點, 故跳過</span></span><br><span class="line">                <span class="keyword">if</span> (times == k + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若中轉 times 次抵達 cur 的 cost 已計算過, 則跳過</span></span><br><span class="line">                <span class="comment">// 因為中轉 times 次抵達 cur 的 cost 為最佳解, 其延伸出去的邊已加到 pq 中</span></span><br><span class="line">                <span class="keyword">if</span> (calculated[cur][times]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 cur 還未計算中轉 times 次的 cost</span></span><br><span class="line">                calculated[cur][times] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 將 cur 所延伸出去的邊加入到 pq 中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [price, next] : adj[cur]) &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(t3i&#123;cost + price, next, times + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(E \cdot log(E))$ ➔ Dijkstra 的時間複雜度, 因為 <code>pq</code> 中最多有 <code>E</code> 條邊, 每次 push &#x2F; pop 元素需花 $O(log(E))$</li><li><strong>space：</strong>$O(V + E)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：「不超過 k 個中繼點」等價於「不超過 <code>k + 1</code> 個航班 (邊)」, 利用 Bellman-Ford 演算法, 用 <code>dist[i][j]</code> 表示飛不超過 <code>i</code> 次航班抵達 <code>j</code> 的最少價格</strong></p><ul><li>path &#x3D; 0 ➔ 2 中間沒有任何中繼點</li><li>path &#x3D; 0 ➔ 1 ➔ 2 中間有 1 個中繼點 <code>1</code></li></ul><p><img src="https://i.imgur.com/Who9QoZ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(k + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        dist[<span class="number">0</span>][src] = <span class="number">0</span>; <span class="comment">// 飛 0 次, 在起點的價格為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            dist[i][src] = <span class="number">0</span>; <span class="comment">// 每次 dist[i][src] 都初始化為 0, 因為在起點的價格為 0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : flights) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> u = f[<span class="number">0</span>], v = f[<span class="number">1</span>], price = f[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 u 目前無法直接抵達, 則跳過</span></span><br><span class="line">                <span class="comment">// 若不處理, 下面 dis[i - 1][u] + price 會 overflow</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i - <span class="number">1</span>][u] == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// u 可直接抵達, 則更新 u -&gt; v 的 shortest path</span></span><br><span class="line">                dist[i][v] = <span class="built_in">min</span>(dist[i][v], dist[i - <span class="number">1</span>][u] + price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dist[k + <span class="number">1</span>][dst] == INT_MAX) ? <span class="number">-1</span> : dist[k + <span class="number">1</span>][dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot E)$ ➔ for loop</li><li><strong>space：</strong>$O(k \cdot n)$ ➔ <code>dist</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, 因為 <code>dist[i][v]</code> 只會使用到 <code>dist[i - 1][u]</code>, 因此不需要保存每一次的狀態, 只需保存上一次的狀態即可。用 <code>prev</code> 紀錄不超過 <code>i - 1</code> 個中繼點的狀態, 而 <code>dist</code> 紀錄不超過 <code>i</code> 個中繼點的狀態</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; prev = dist; <span class="comment">// prev 初始化為不超過 (i - 1) 個中繼點的狀態</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : flights) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> u = f[<span class="number">0</span>], v = f[<span class="number">1</span>], price = f[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若 u 無法直接抵達, 則跳過</span></span><br><span class="line">                <span class="comment">// 若不處理, 下面 prev[u] + price 會 overflow</span></span><br><span class="line">                <span class="keyword">if</span> (prev[u] == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// u 可直接抵達, 則更新 u -&gt; v 的 shortest path</span></span><br><span class="line">                dist[v] = <span class="built_in">min</span>(dist[v], prev[u] + price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此時的 dist 為不超過 k 個中繼點的狀態</span></span><br><span class="line">        <span class="keyword">return</span> (dist[dst] == INT_MAX) ? <span class="number">-1</span> : dist[dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(k \cdot E)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>prev</code>, <code>dist</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Advanced Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>198. House Robber</title>
      <link href="/post/house-robber/"/>
      <url>/post/house-robber/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></strong></p><p><strong>題意：</strong>你是一名專業的強盜, 計劃搶劫沿路的房子。每棟房子都藏有一定數量的金錢, 唯一阻止你搶劫的限制是相鄰的房子都連接了安全系統, 如果闖入<strong>兩棟相鄰</strong>的房子，它會自動報警。</p><p>給一整數 array <code>nums</code>, 表示每棟房子所藏有的金額, 返回<strong>在不報警的情況下</strong>能搶劫的最大金額。</p></blockquote><p><img src="https://i.imgur.com/iWD2myc.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 其中 <code>dp[i]</code> 代表 index 位於區間 <code>[0, i]</code> 這 <code>i + 1</code> 間房子中可搶劫的最大金額。接著，我們考慮單一一間房子的情況，對於 <code>index = i</code> 的房子我們有兩種選擇，要搶 or 不搶</strong></p><ul><li>若 <code>index = i</code> 的房子<strong>不搶</strong>, 此時的最大金額 &#x3D; 區間 <code>[0, i - 1]</code> 的最大金額 &#x3D; <code>dp[i - 1]</code></li><li>若 <code>index = i</code> 的房子<strong>要搶</strong>, 此時的最大金額 &#x3D; 區間 <code>[0, i - 2]</code> 的最大金額 + <code>index = i</code> 的金額 &#x3D; <code>dp[i - 2] + nums[i]</code></li></ul><p>➔ 因此 <code>dp[i]</code> 就為這兩種可能中取較大者, <code>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</code></p><p>此外，由於我們的 index 是從 <code>0</code> 開始取的，因此要考慮 <code>dp[i - 1]</code>、<code>dp[i - 2]</code> 越界的情況, 根據 <code>dp[i]</code> 的定義, <code>dp[-1]</code> 代表在 <code>nums</code> 中的 index 區間 <code>[0, -1]</code> 可搶劫的最大金額，但 <code>nums</code> 中 index 區間 <code>[0, -1]</code> 中根本沒有任何數，所以可搶劫的最大金額可視為 <code>0</code>。所以一旦要存取的 index 越界我們就取 <code>0</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>((i &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] : <span class="number">0</span>),</span><br><span class="line">                        (i &gt; <span class="number">1</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：Solution 1 的改進, 計算 <code>dp[i]</code> 只需用到 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code>, 不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>; <span class="comment">// two, one, [n1, n2, ...]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> curMax = <span class="built_in">max</span>(one, two + num);</span><br><span class="line">            two = one;</span><br><span class="line">            one = curMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>213. House Robber II</title>
      <link href="/post/house-robber-ii/"/>
      <url>/post/house-robber-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/house-robber-ii/">https://leetcode.cn/problems/house-robber-ii/</a></strong></p><p><strong>題意：</strong>你是一名專業的強盜, 計劃搶劫沿街的房屋。每棟房子都藏有一定數量的錢。所有的房子都<strong>排成一圈</strong>。這意味著第一棟房子是最後一棟的鄰居。同時, 相鄰的房屋都連接了安全系統, 如果同一晚上有兩間相鄰的房屋被闖入，它會自動報警。</p><p>給定一個整數 array <code>nums</code>, 表示每棟房子的金額, 返回<strong>在不報警的情況下</strong>搶劫的最大金額。</p></blockquote><p><img src="https://i.imgur.com/vQM49da.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：跟 <a href="https://zako945.github.io/post/house-robber/">198. House Robber</a> 類似, 只是首尾相連, 如果搶了第一家，就不能搶最後一家, 所以第一家和最後一家只能搶其中的一家, 或者都不搶。 所以把第一家和最後一家分別去掉, 各算一遍能搶的最大值, 然後比較兩個值取其中較大的一個即為所求</strong></p><p><img src="https://i.imgur.com/uQhIUXD.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">empty</span>() ? <span class="number">0</span> : nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">helper</span>(nums, <span class="number">0</span>, n - <span class="number">2</span>), <span class="built_in">helper</span>(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> curMax = <span class="built_in">max</span>(one, two + nums[i]);</span><br><span class="line">            two = one;</span><br><span class="line">            one = curMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. Longest Palindromic Substring</title>
      <link href="/post/longest-palindromic-substring/"/>
      <url>/post/longest-palindromic-substring/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-palindromic-substring/">https://leetcode.cn/problems/longest-palindromic-substring/</a></strong></p><p><strong>題意</strong>：給一 string <code>s</code>, 找出 <code>s</code> 中最長的迴文 substring。</p><p><strong>注意：</strong></p><ul><li>substring 指的是 string 中 <strong>連續的</strong> subset</li><li>subsequence 則是 string 的 subset</li></ul></blockquote><p><img src="https://i.imgur.com/u8DdxNS.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 因為我們發現「一個迴文去掉兩頭後, 剩下的部分仍為迴文」, 我們用 <code>dp[i][j]</code> 代表 <code>substring s[i~j]</code> 是否迴文, 則可得到下列公式：</strong></p><ul><li><strong><code>dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + 1][j - 1]</code></strong></li></ul><p><code>dp[i + 1][j - 1]</code> 在 <code>dp[i][j]</code> 的<strong>左下方</strong>, 故順序為<strong>由左至右, 一行一行的填</strong>, 其中對角線為 <code>true</code></p><p><img src="https://i.imgur.com/hNq2e4T.png"></p><p>e.g. <code>&quot;abba&quot;</code> 中已知 <code>&quot;bb&quot;</code> 為迴文, 所以 <code>dp[1][2] = true</code></p><p>➔ 則 <code>dp[0][3]</code> 則因為 <code>&quot;a&quot; == &quot;a&quot;</code> 且 <code>dp[1][2] = true</code>, 故 <code>dp[0][3] = true</code>, 代表 <code>&quot;abba&quot;</code> 為迴文</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 當長度為 2 時, e.g. &quot;ac&quot;, dp[0][1] = false, 但 &quot;a&quot; 為回文, 故 maxLen 設 1</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (n, <span class="literal">true</span>)); <span class="comment">// 對角線以下皆為 true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; ++i) &#123;</span><br><span class="line">                dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop：$1+2+…+(n-1) &#x3D; \dfrac{n(n-1)}{2}$  $&#x3D; O(n^2)$</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用中心擴散法, 也就是枚舉所有 substring 的中心位置, 總共枚舉 2n 個 substring, 因為每個位置 <code>i</code> 皆要考慮以其為中心的偶數 substring 和奇數 substring</strong></p><p>更新 <code>start</code> 時, 之所以為 <code>start = i - (maxLen - 1) / 2</code>, 是因為我們的 <code>i</code> 是左中點, 而非右中點, 故 <code>maxLen</code> 要先減一再除 2</p><p><code>expand(s, left, right, n)</code> 跳出迴圈時, 有兩種可能：</p><ul><li><p><code>s[left] != s[right]</code>：代表 <code>s</code> 中的 <code>[left + 1, right - 1]</code> 區間是回文 substring, 此時的回文substring 長度為 <code>(right - 1) - (left + 1) - 1 = right - left - 1</code></p></li><li><p>第二種狀況是 <code>left</code> 或 <code>right</code> 越界, e.g. <code>left = -1</code> 且 <code>right = n</code>, 此時代表整個 <code>s</code> 為回文, 故回文長度為 <code>n</code><br>➔ 第一種狀況得到的公式 <code>right - left - 1 = n - (-1) - 1 = n</code> 仍然滿足第二種狀況</p><p>  <img src="https://i.imgur.com/5JyaT34.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> curLen = <span class="built_in">max</span>(<span class="built_in">expand</span>(s, i, i, n), <span class="comment">// odd substring</span></span><br><span class="line">                                   <span class="built_in">expand</span>(s, i, i + <span class="number">1</span>, n)); <span class="comment">// even substring</span></span><br><span class="line">            <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen = curLen;</span><br><span class="line">                start = i - (maxLen - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// i 是中心, 要倒推回起點</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">expand</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 跳出 loop 時, 第一種狀況是 s[left] != s[right]</span></span><br><span class="line"><span class="comment">         * 代表 s[(left+1)~(right-1)] 是回文substring</span></span><br><span class="line"><span class="comment">         * 此時 substring 長度為 (right-1) - (left+1) + 1 = right - left - 1</span></span><br><span class="line"><span class="comment">         * 第二種狀況是越界, left = -1 且 right = n</span></span><br><span class="line"><span class="comment">         * 此時代表整個 string 為回文, 故回文長度為 n</span></span><br><span class="line"><span class="comment">         * 第一種狀況得到的公式 right - left - 1 = n - (-1) - 1 = n 仍然滿足第二種狀況</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 遍歷每個 char, 每個 char 為中心最多往外擴散 $\dfrac{n}{2}$ 次, 得 $2 \cdot O(\dfrac{n}{2}) \cdot n$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-3：（不會也沒差-會前兩種方法就足夠了）"><a href="#Solution-3：（不會也沒差-會前兩種方法就足夠了）" class="headerlink" title="Solution 3：（不會也沒差, 會前兩種方法就足夠了）"></a><strong>Solution 3：（不會也沒差, 會前兩種方法就足夠了）</strong></h2><blockquote><p><strong>想法：利用 Manacher 演算法（可參考<a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/">這篇</a>）, 其核心思想是結合 DP（回文特性）+ 中心擴散</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string tmp = <span class="built_in">preProcess</span>(s);</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = tmp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n - <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 最後一個 $ 不用算</span></span><br><span class="line">        <span class="type">int</span> center = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 右邊界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> i_mirror = <span class="number">2</span> * center - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 防止超出 right</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; right) &#123;</span><br><span class="line">                p[i] = <span class="built_in">min</span>(p[i_mirror], right - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p[i] = <span class="number">0</span>; <span class="comment">// i &gt;= right 的時候</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 有三種情況, 需使用中心擴散法</span></span><br><span class="line"><span class="comment">             * 1. i + p[i_mirror] &gt; right</span></span><br><span class="line"><span class="comment">             * 2. i &gt;= right 的時候</span></span><br><span class="line"><span class="comment">             * 3. p[i_mirror] 遇到左邊界</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (tmp.<span class="built_in">at</span>(i - <span class="number">1</span> - p[i]) == tmp.<span class="built_in">at</span>(i + <span class="number">1</span> + p[i])) &#123;</span><br><span class="line">                ++p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判斷是否超出右邊界, 是的話要更新右邊界和中心</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; right) &#123;</span><br><span class="line">                center = i;</span><br><span class="line">                right = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 p 的最大值</span></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>, centerIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; maxLen) &#123;</span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                centerIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> start = (centerIndex - maxLen) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">string <span class="title">preProcess</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        string tmp = <span class="string">&quot;^&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            tmp += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            tmp += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 透過不斷拓展 <code>right</code>, 且 <code>right</code> 只增不減, 故只看 for loop, 因為 while loop 拜訪過的 char 不會再進 while loop（可透過 DP 快速得到）</li><li><strong>space：</strong>$O(n)$ ➔ <code>tmp</code>, <code>p</code> 的長度 &#x3D; <code>2 * s.size() + 3</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1584. Min Cost to Connect All Points</title>
      <link href="/post/min-cost-to-connect-all-points/"/>
      <url>/post/min-cost-to-connect-all-points/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">https://leetcode.cn/problems/min-cost-to-connect-all-points/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>points</code>, 表示 2D 平面上的一些點, 其中 <code>points[i] = [x_i, y_i]</code> 。</p><p>連接點 <code>[x_i, y_i]</code> 和點 <code>[x_j, y_j]</code> 的費用為它們之間的<strong>曼哈頓距離</strong>：</p><ul><li><code>|x_i - x_j| + |y_i - y_j|</code></li></ul><p>其中 <code>|val|</code> 表示 <code>val</code> 的絕對值。</p><p>返回將所有點連接的最小總費用。</p></blockquote><p><img src="https://i.imgur.com/YzINIJl.png"></p><p><img src="https://i.imgur.com/g2Ul9DI.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：本題其實就是在求 MST (Minimum Spaning Tree), 故利用 Kruskal 演算法, 每次選擇 cost 最小的邊 <code>e</code>, 若加入 <code>e</code> 會導致 graph 中有 cycle（用 Union Find 判斷）, 則跳過 <code>e</code>, 直到 graph 中有 <code>n - 1</code> 條邊</strong></p><p><img src="https://i.imgur.com/K9LvcJZ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; t3i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parents</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">ranks</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;t3i&gt; edges; <span class="comment">// &#123;dist, u, v&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 總共有 O(n^2) 條邊</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> dist = <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">                edges.<span class="built_in">emplace_back</span>(t3i&#123;dist, i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根據每條邊的 dist 由小到大做排序</span></span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dist, i, j] : edges) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(parents, i); <span class="comment">// root of i</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(parents, j); <span class="comment">// root of j</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 i, j 不為同一個 set, 代表加入 edge 後不會形成 cycle</span></span><br><span class="line">            <span class="keyword">if</span> (r1 != r2) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                res += dist;</span><br><span class="line">                <span class="built_in">union_</span>(parents, ranks, r1, r2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到 n - 1 條邊就結束</span></span><br><span class="line">            <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]]; <span class="comment">// path compression</span></span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">const</span> <span class="type">int</span> r1, <span class="type">const</span> <span class="type">int</span> r2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ranks[r2] &gt; ranks[r1]) &#123;</span><br><span class="line">            parents[r1] = r2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">            ++ranks[r1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2 \cdot log(n))$ ➔ Dijkstra 演算法的時間複雜度為 $O(E \cdot log(E))$, 因為要對所有邊做排序, 而 E &#x3D; $\binom{n}{2}$ &#x3D; $O(n^2)$</li><li><strong>space：</strong>$O(n^2)$ ➔ <code>edges</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Prim 演算法</strong></p><p><img src="https://i.imgur.com/x2PiAb2.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>; <span class="comment">// 紀錄哪些點在 MST 中</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDis</span><span class="params">(n, INT_MAX)</span></span>; <span class="comment">// 尚未加入 MST 的點距離 MST 中的點之最小距離</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 0 為起點 (任意點開始)</span></span><br><span class="line">        minDis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123; <span class="comment">// 取 n 個點便結束</span></span><br><span class="line">            <span class="type">int</span> curMinEdge = INT_MAX;</span><br><span class="line">            <span class="type">int</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 cost 最小的邊 (一開始會取 0 -&gt; 0, 因為 minDis[0] = 0 &lt; curMinEdge)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i] &amp;&amp; minDis[i] &lt; curMinEdge) &#123;</span><br><span class="line">                    curMinEdge = minDis[i];</span><br><span class="line">                    cur = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[cur] = <span class="literal">true</span>;</span><br><span class="line">            res += curMinEdge;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新距離</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> dist = <span class="built_in">abs</span>(points[cur][<span class="number">0</span>] - points[i][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[cur][<span class="number">1</span>] - points[i][<span class="number">1</span>]);</span><br><span class="line">                    minDis[i] = <span class="built_in">min</span>(minDis[i], dist);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>visited</code>, <code>minDis</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Advanced Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>743. Network Delay Time</title>
      <link href="/post/network-delay-time/"/>
      <url>/post/network-delay-time/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/network-delay-time/">https://leetcode.cn/problems/network-delay-time/</a></strong></p><p><strong>題意：</strong>有 <code>n</code> 個網路節點, 標記為 <code>1</code> 到 <code>n</code>。</p><p>給一 list <code>times</code>, 表示訊號經過<strong>有向邊</strong>的傳遞時間。<code>times[i] = (ui, vi, wi)</code>, 其中 <code>ui</code> 是起點、<code>vi</code> 是終點, 而 <code>wi</code> 是一個訊號從起點傳遞到終點的時間。</p><p>從某個節點 <code>k</code> 發出一個訊號, 返回需要多久才能使所有節點都收到訊號？如果不能使所有節點都收到訊號, 則返回 <code>-1</code> 。</p></blockquote><p><img src="https://i.imgur.com/vPEe1d5.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Dijkstra 演算法（BFS + Heap）, 而非單純 BFS, 因為 <code>weight</code> 有可能不為 <code>1</code>, 這樣會導致 BFS 所得出之答案未必為解答。步驟如下：</strong></p><ul><li>建立 adjacent lit</li><li>建立 min heap</li><li>執行 BFS</li></ul><p>➔ BFS 中得到未拜訪過的點 <code>cur</code> , 則 <code>dis</code> 必為起點 <code>k</code> 到 <code>cur</code> 的最短路徑</p><p><strong>e.g. 下圖中, 求 1 到 2 的時間</strong></p><ul><li>若用 BFS 求解, 則 path 為 1 ➔ 2, 得出 4</li><li>正確的 path 應為 1 ➔ 3 ➔ 4 ➔ 2, 得出 3</li></ul><p><img src="https://i.imgur.com/c2l1eb1.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii; <span class="comment">// &#123;weight, next&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">networkDelayTime</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; times, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>); <span class="comment">// adjacent list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; t : times) &#123;</span><br><span class="line">            adj[t[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(pii&#123;t[<span class="number">2</span>], t[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; visited;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        pq.<span class="built_in">emplace</span>(pii&#123;<span class="number">0</span>, k&#125;); <span class="comment">// 起點為 k, 則 k -&gt; k 的 weight = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = pq.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="comment">// 每次取出最小的邊</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [dis, cur] = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (visited[cur]) &#123; <span class="comment">// 已拜訪則跳過</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 設為已拜訪, 並更新時間</span></span><br><span class="line">                visited[cur] = <span class="literal">true</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dis);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 將 cur 延伸出去的所有邊加入到 pq 中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [weight, next] : adj[cur]) &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(pii&#123;dis + weight, next&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (visited.<span class="built_in">size</span>() == n) ? res : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(E \cdot log(E))$ ➔ Dijkstra 的時間複雜度, 因為 <code>pq</code> 中最多有 <code>E</code> 條邊, 每次 push &#x2F; pop 元素需花 $O(log(E))$</li><li><strong>space：</strong>$O(V + E)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Advanced Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102. Binary Tree Level Order Traversal</title>
      <link href="/post/binary-tree-level-order-traversal/"/>
      <url>/post/binary-tree-level-order-traversal/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></strong></p><p><strong>題意：</strong>給一 BT <code>root</code>, 返回 <code>node.val</code> 之 level-order（由上層往下層, 每層由左至右）。</p></blockquote><p><img src="https://i.imgur.com/RV7JAy9.png"></p><p><img src="https://i.imgur.com/f9wxlhh.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array, <code>q</code> 的元素個數不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> depth, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &lt;= depth) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[depth].<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, depth + <span class="number">1</span>, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, depth + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>199. Binary Tree Right Side View</title>
      <link href="/post/binary-tree-right-side-view/"/>
      <url>/post/binary-tree-right-side-view/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-tree-right-side-view/">https://leetcode.cn/problems/binary-tree-right-side-view/</a></strong></p><p><strong>題意：</strong>給一 BT 的 <code>root</code>, 想像你站在 BT 的右側, 按照從頂部到底部的順序, 返回你從右側所能看到的 <code>node.val</code>。</p></blockquote><p><img src="https://i.imgur.com/xxrR9lV.png"></p><p><img src="https://i.imgur.com/Z0PWxXR.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把每層最後一個 node 給 push 到 res 中</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 array, 在 while loop 迭代的過程中, <code>q</code> 的元素個數不超過 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS, 遍歷順序為 <code>root -&gt; right -&gt; left</code>, 並用 <code>depth</code> 紀錄當前 <code>root</code> 的深度, 而 <code>maxDepth</code> 紀錄當前拜訪到的最大深度。</strong></p><ul><li>若遞迴拜訪的 <code>root</code> 滿足 <code>depth &gt; maxDepth</code>, 代表這是下一層最靠右的 node, 則把該 node 加入到 res 中, 並更新 <code>maxDepth</code></li></ul><p><img src="https://i.imgur.com/nRLDwxG.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> maxDepth = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, maxDepth, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> depth, <span class="type">int</span>&amp; maxDepth, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先拜訪 right, 再拜訪 left</span></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, depth + <span class="number">1</span>, maxDepth, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, depth + <span class="number">1</span>, maxDepth, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 每個 node 皆被遍歷一次</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>133. Clone Graph</title>
      <link href="/post/clone-graph/"/>
      <url>/post/clone-graph/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/clone-graph/">https://leetcode.cn/problems/clone-graph/</a></strong></p><p><strong>題意：</strong>給一無向連通圖的 node, 請返回該圖的 copy。</p><p>圖中每個 node 都包含它的 <code>val</code> (int) 和其 <code>neighbors</code> (list[node])</p><p><img src="https://i.imgur.com/SX9Lom7.png"></p></blockquote><p><img src="https://i.imgur.com/e2OGv2r.png"></p><p><img src="https://i.imgur.com/64YLSCn.png"></p><p><img src="https://i.imgur.com/FP1rkWQ.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited; <span class="comment">// &#123;old : new&#125;, 用來記錄已生成的 node</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若 node 已經生成過, 則返回其 copy</span></span><br><span class="line">        <span class="keyword">if</span> (visited.<span class="built_in">find</span>(node) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> visited[node];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成當前 node</span></span><br><span class="line">        Node* copy = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        visited[node] = copy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加當前 node 的 neighbors</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; neighbor : node-&gt;neighbors) &#123;</span><br><span class="line">            copy-&gt;neighbors.<span class="built_in">emplace_back</span>(<span class="built_in">dfs</span>(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V+E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V)$ ➔ <code>oldToNew</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; visited; <span class="comment">// &#123;old : new&#125;, 用來記錄已生成的 node</span></span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(node);</span><br><span class="line">        visited[node] = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node* n = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; neighbor : n-&gt;neighbors) &#123;</span><br><span class="line">                <span class="comment">// 如果 neighbor 還沒被拜訪過</span></span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">find</span>(neighbor) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="keyword">new</span> <span class="built_in">Node</span>(neighbor-&gt;val); <span class="comment">// 生成該 node</span></span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor); <span class="comment">// 加到 queue 中</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 更新當前 node 的 neighbors</span></span><br><span class="line">                visited[n]-&gt;neighbors.<span class="built_in">emplace_back</span>(visited[neighbor]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V+E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V)$ ➔ <code>visited</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39. Combination Sum</title>
      <link href="/post/combination-sum/"/>
      <url>/post/combination-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></strong></p><p><strong>題意：</strong>給一無重複數的 array <code>candidates</code> 和一整數 <code>target</code>, 找出 <code>candidates</code> 中可以使數字和等於 <code>target</code> 的所有不同組合, 以<strong>任意順序</strong>返回。</p><p>其中, <code>candidates[i]</code> 皆 <code>&gt; 0</code></p><p><strong>注意：</strong><code>candidates</code> 同一個數字可以<strong>無限次重複選取</strong>, 如果至少一個數字的被選數量不同, 則兩種組合是不同的</p></blockquote><p><img src="https://i.imgur.com/R8ihvki.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking, 其中每個元素 <code>candidates[i]</code> 有兩種選擇：</strong></p><ul><li><p>選, 並從此位置 <code>i</code> 繼續選要不要重複選取</p></li><li><p>不選, 從下一個位置 <code>i + 1</code> 的元素繼續開始</p><p>  <img src="https://i.imgur.com/1te9bt9.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, candidates.<span class="built_in">size</span>(), target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> i, <span class="type">int</span> n, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span> || i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, i + <span class="number">1</span>, n, target); <span class="comment">// 不取</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取, 由於可重複取同一數, 故 idx 仍是從 i 開始取</span></span><br><span class="line">        cur.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, i, n, target - candidates[i]);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ 每個元素都有兩種選擇, 故最多有 $2^n$ 種選擇, 而每一種選擇皆需花 $O(n)$</li><li><strong>space：</strong>$O(target)$ ➔ worse case 下, <code>dfs()</code> 最大遞迴深度為 $O(target)$</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 只是透過 pruning 來做優化, 一旦當前元素超過 <code>target</code>, 則直接跳過。for loop 中之所以沒有不取元素的部分, 是因為：</strong></p><ul><li>若取, 則會遞迴執行 <code>dfs(j, target - candidates[j])</code></li><li>若不取, 則在下一輪 for loop 中 <code>dfs(j + 1, target)</code> 是不會有 <code>nums[j]</code> 的, 因為上一輪的 <code>cur</code> 有做 backtracking, 會將狀態還原回加入 <code>nums[j]</code> 前的狀態後, 才進到下一輪的 <code>j + 1</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, candidates.<span class="built_in">size</span>(), target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> i, <span class="type">int</span> n, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若要取, 則會遞迴執行；若不取, 則 for loop 迭代到 j + 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[j] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 剪枝, 一旦超過 target 則跳過</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(candidates[j]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, j, n, target - candidates[j]);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ worse case 仍為 $O(n \cdot 2^n)$, 透過使用 pruning, 實際運行情況應該是<strong>遠小於</strong> $O(n \cdot 2^n)$ 的</li><li><strong>space：</strong>$O(target)$ ➔ worse case 下, <code>dfs()</code> 最大遞迴深度為 $O(target)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40. Combination Sum II</title>
      <link href="/post/combination-sum-ii/"/>
      <url>/post/combination-sum-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a></strong></p><p><strong>題意：</strong>給一 array <code>candidates</code> 和一整數 <code>target</code>, 求 <code>candidates</code> 中所有可以使數字和為 <code>target</code> 的組合, 且 <code>candidates</code> 中的每個數字在每個組合中只能使用<strong>一次</strong>。</p><p><strong>注意：</strong>Output 不能有重複的組合</p></blockquote><p><img src="https://i.imgur.com/nDVC8BI.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先做 sorting, 再用 DFS, 類似 <a href="https://zako945.github.io/post/combination-sum/">39. Combination Sum</a>, 一旦不取 <code>nums[j]</code>, 則後面區間 <code>[j + 1, n)</code> 中若有跟 <code>candidates[j]</code> 相同的都直接跳過</strong></p><p>e.g. <code>candidates = [10,1,2,7,6,1,5]</code>, <code>target = 8</code></p><ul><li>先做 sorting</li><li>若不取 <code>idx = 0</code> 的 <code>1</code>, 則可以直接跳過 <code>idx = 1</code> 的 <code>1</code>, 讓 <code>idx = 2</code> 的元素開始取</li></ul><p><img src="https://i.imgur.com/ZL06Ywq.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, candidates.<span class="built_in">size</span>(), target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> i, <span class="type">int</span> n, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span> || i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取</span></span><br><span class="line">        cur.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, i + <span class="number">1</span>, n, target - candidates[i]);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不取, 若後面有跟 candidates[i] 值一樣的, 則都跳過</span></span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; n &amp;&amp; candidates[i] == candidates[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, i + <span class="number">1</span>, n, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ $O(n \cdot log(n)) + O(n \cdot 2^n)$<ul><li>$O(n \cdot log(n))$：sorting</li><li>$O(n \cdot 2^n)$：最多有 $2^n$ 種組合, 建構每一種組合需 $O(n)$ time</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array, 則取決於遞迴的最大深度</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 只是透過剪枝（pruning）來做優化, 一旦當前元素超過 <code>target</code>, 則直接退出（因為有排序）。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, candidates.<span class="built_in">size</span>(), target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> i, <span class="type">int</span> n, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若要取, 則會遞迴執行；若不取, 則 for loop 迭代到 j + 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="comment">// 剪枝, 因為有排序, 故 candidates[j] &gt; target, 則後面皆 &gt; target</span></span><br><span class="line">            <span class="keyword">if</span> (candidates[j] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取</span></span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(candidates[j]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, j + <span class="number">1</span>, n, target - candidates[j]);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不取, 若後面有跟 candidates[i] 值一樣的, 則都跳過</span></span><br><span class="line">            <span class="keyword">while</span> (j + <span class="number">1</span> &lt; n &amp;&amp; candidates[j] == candidates[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ worse case 仍為 $O(n \cdot 2^n)$, 透過使用 pruning, 實際運行情況應該是<strong>遠小於</strong> $O(n \cdot 2^n)$ 的</li><li><strong>space：</strong>$O(target)$ ➔ worse case 下, <code>dfs()</code> 最大遞迴深度為 $O(target)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/post/construct-binary-tree-from-preorder-and-inorder-traversal/"/>
      <url>/post/construct-binary-tree-from-preorder-and-inorder-traversal/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></strong></p><p><strong>題意：</strong>給一 BT 的 <code>preorder</code> 和 <code>inorder</code>, 構建並返回該 BT。</p><p>tree 中沒有重複的元素。</p></blockquote><p><img src="https://i.imgur.com/H1ONem7.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 跟 <a href="https://zako945.github.io/maximum-binary-tree">654. Maximum Binary Tree</a> 類似, 只是可以先遍歷 inorder, 紀錄 inorder 元素的 idx, 讓後續遍歷 preorder 元素時可快速定位, 將時間複雜度降到 $O(n)$</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 紀錄 inorder 元素的 idx, 方便 preorder 快速定位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cur; <span class="comment">// preorder 當前要拜訪的 idx</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index; <span class="comment">// &#123;inorder[i], i&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速取得 preorder 元素在 inorder 中的 idx</span></span><br><span class="line">        <span class="type">int</span> idx = index[preorder[cur]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立 root 後, cur 往下一個</span></span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[cur++]);</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(preorder, left, idx - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(preorder, idx + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>preorder</code> 和 <code>inorder</code></li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1448. Count Good Nodes in Binary Tree</title>
      <link href="/post/count-good-nodes-in-binary-tree/"/>
      <url>/post/count-good-nodes-in-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/">https://leetcode.cn/problems/count-good-nodes-in-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT 的 <code>root</code>, 返回 BT 中 <strong>Good node</strong> 的個數。</p><p><strong>Good node <code>x</code> 的定義：</strong>從 <code>root</code> 到 <code>x</code> 所經過的 node 中, 沒有任何 <code>node.val</code> 大於 <code>x.val</code>。</p></blockquote><p><img src="https://i.imgur.com/kV85ofD.png"></p><p><img src="https://i.imgur.com/D6kkvFh.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 在 DFS 過程中維護當前路徑的最大值 <code>curMax</code>。若 <code>node-&gt;val ≥ curMax</code>, 則更新 <code>maxCur</code>, 並返回 <code>1 + 左子樹的 good node 數 + 右子樹的 good node 數</code>, 那個 1 是把當前 node 視為 good node</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// dfs(root, curMax) 返回 root 到 node 的 path 上總共有幾個 good node</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">int</span> curMax)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &gt;= curMax) &#123;</span><br><span class="line">            curMax = <span class="built_in">max</span>(curMax, node-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(node-&gt;left, curMax) + <span class="built_in">dfs</span>(node-&gt;right, curMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(node-&gt;left, curMax) + <span class="built_in">dfs</span>(node-&gt;right, curMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case：skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>207. Course Schedule</title>
      <link href="/post/course-schedule/"/>
      <url>/post/course-schedule/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/</a></strong></p><p><strong>題意：</strong>你這學期必須選修 <code>numCourses</code> 門課程, 標記為 <code>0</code> 到 <code>numCourses - 1</code>。</p><p>在修習某些課程前需要一些先修課程 <code>prerequisites</code>, 其中 <code>prerequisites[i] = [a_i, b_i]</code>, 表示要修 <code>a_i</code> 前必須先修 <code>b_i</code>。</p><ul><li>e.g. <code>[0, 1]</code> 表示想要修課程 <code>0</code>, 需要先完成課程 <code>1</code>。</li></ul><p>返回是否能完成所有課程。</p></blockquote><p><img src="https://i.imgur.com/876CO4y.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + BFS, 依序取出 <code>inDegree = 0</code> 之 node</strong></p><p>在 BFS 中, <code>[0, 1]</code> 表示想要修課程 <code>0</code>, 需要先完成課程 <code>1</code>。<br>用圖表示為 <strong><code>1</code> 指向 <code>0</code><strong>（</strong>方向跟 DFS 相反</strong>）, 這樣 <code>1</code> 的 <code>inDegree = 0</code>, 才會優先被執行</p><p><img src="https://i.imgur.com/joTEmA8.png"></p><ul><li>首先將 <code>inDegree = 0</code> 的 node（不需要任何先修課程的課）加入到 queue 中</li><li>BFS<ul><li>取出 <code>queue.front()</code> 後, 將其相鄰 node 的 <code>inDegree - 1</code></li><li>若相鄰 node 之 <code>inDegree - 1</code> 後為 <code>0</code>, 則將該 node push 到 queue 中</li></ul></li><li><strong>特殊情況：若 Graph 有 cycle</strong><ul><li><p>不會有任何 node 加入到 queue 中（所有 node 之 inDegree 皆不為 0）, 故要用一變數 <code>visited</code> 紀錄 <code>inDegree = 0</code> 的個數</p></li><li><p>當 queue 取出 front 時 <code>visited + 1</code>, 因為 queue 中的 node 一定是 <code>inDegree = 0</code> 的 node</p></li><li><p>最後判斷 <code>visited</code> 是否等於 <code>numCourses</code></p><p>  <img src="https://i.imgur.com/iN4nJqM.png"></p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個 node 的 in degree</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(numCourses); <span class="comment">// adjacent list</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : prerequisites) &#123;</span><br><span class="line">            adj[p[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(p[<span class="number">0</span>]);</span><br><span class="line">            inDegree[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先將 in degree = 0 的 node 加入到 queue 中</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            ++visited;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將其 adjacent node 的 in degree - 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n + m)$ ➔ <code>n</code> 為課程數(vertex), <code>m</code> 為先修課程數(edge)。其實就是對圖進行 BFS 所需之時間複雜度 $O(V+E)$</li><li><strong>space：</strong>$O(n + m)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + DFS, 其實本題就是在問有向圖中是否有 cycle。此外也要考慮存在 isolated node 的情況（也就是 Graph 非 connected, 如下圖中的 3）</strong></p><p>e.g. 下圖中 <code>(0, 1, 5)</code> 為 cycle, 故返回 false</p><p><img src="https://i.imgur.com/Oa6kJ2h.png"></p><p>在 DFS 中, <code>[0, 1]</code> 表示想要修課程 <code>0</code>, 需要先完成課程 <code>1</code>。用圖表示為 <strong><code>0</code> 指向 <code>1</code></strong></p><p><img src="https://i.imgur.com/vFPkwm7.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(numCourses); <span class="comment">// adjacency list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pre : prerequisites) &#123;</span><br><span class="line">            adj[pre[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(pre[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0: 未搜索, 1: 搜索中, 2: 已搜索</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">states</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123; <span class="comment">// 讓 isolated node 也能被搜索</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(i, states, adj)) &#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 返回 true 代表有 cycle</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; states, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 當前 node 狀態為搜索中, 代表有 cycle</span></span><br><span class="line">        <span class="keyword">if</span> (states[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當前 node 狀態為已搜索, 代表沒 cycle</span></span><br><span class="line">        <span class="keyword">if</span> (states[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        states[i] = <span class="number">1</span>; <span class="comment">// 若為未搜索, 將其設為搜索中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// dfs 遍歷其 adjacent node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(v, states, adj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        states[i] = <span class="number">2</span>; <span class="comment">// 設為已完成</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n + m)$ ➔ <code>n</code> 為課程數(vertex), <code>m</code> 為先修課程數(edge)。其實就是對圖進行 DFS 所需之時間複雜度 $O(V+E)$</li><li><strong>space：</strong>$O(n + m)$ ➔ 因為 <code>adj</code> 為 $O(V+E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>210. Course Schedule II</title>
      <link href="/post/course-schedule-ii/"/>
      <url>/post/course-schedule-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/course-schedule-ii/">https://leetcode.cn/problems/course-schedule-ii/</a></strong></p><p><strong>題意：</strong>你這學期必須選修 <code>numCourses</code> 門課程, 標記為 <code>0</code> 到 <code>numCourses - 1</code>。</p><p>在修習某些課程前需要一些先修課程 <code>prerequisites</code>, 其中 <code>prerequisites[i] = [a_i, b_i]</code>, 表示要修 <code>a_i</code> 前必須先修 <code>b_i</code>。</p><ul><li>e.g. <code>[0, 1]</code> 表示想要修課程 <code>0</code>, 需要先完成課程 <code>1</code>。</li></ul><p>返回能夠學習完所有可成的學習順序。可能會有很多種正確的順序, 只要返回其中一種就行。若不可能完成所有課程, 則返回空 list。</p></blockquote><p><img src="https://i.imgur.com/5yuYO2q.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Topological Sort + BFS, 同 <a href="https://zako945.github.io/post/course-schedule/">207. Course Schedule</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個 node 的 in degree</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(numCourses); <span class="comment">// adjacent list</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pre : prerequisites) &#123;</span><br><span class="line">            adj[pre[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(pre[<span class="number">0</span>]);</span><br><span class="line">            ++inDegree[pre[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先將 in degree = 0 的 node 加入到 queue 中</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123; </span><br><span class="line">                q.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將其 adjacent node 的 in degree - 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res.<span class="built_in">size</span>() == numCourses) ? res : <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n + m)$ ➔ <code>n</code> 為課程數(vertex), <code>m</code> 為先修課程數(edge)。其實就是對圖進行 BFS 所需之時間複雜度 $O(V+E)$</li><li><strong>space：</strong>$O(n + m)$ ➔ 因為 <code>adj</code> 為 $O(V+E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用  Topological Sort + DFS, 同</strong> <a href="https://zako945.github.io/post/course-schedule/">207. Course Schedule</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(numCourses); <span class="comment">// adjacency list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pre : prerequisites) &#123;</span><br><span class="line">            adj[pre[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(pre[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0: 未搜索, 1: 搜索中, 2: 已搜索</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">states</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(i, states, adj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 true 代表有 cycle</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; states, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 當前 node 狀態為搜索中, 代表有 cycle</span></span><br><span class="line">        <span class="keyword">if</span> (states[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當前 node 狀態為已搜索, 代表沒 cycle</span></span><br><span class="line">        <span class="keyword">if</span> (states[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        states[i] = <span class="number">1</span>; <span class="comment">// 若為未搜索, 將其設為搜索中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// dfs 遍歷其 adjacent node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(v, states, adj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        states[i] = <span class="number">2</span>; <span class="comment">// 設為已完成</span></span><br><span class="line">        res.<span class="built_in">emplace_back</span>(i); <span class="comment">// push 到 order list 中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n + m)$ ➔ <code>n</code> 為課程數(vertex), <code>m</code> 為先修課程數(edge)。其實就是對圖進行 DFS 所需之時間複雜度 $O(V+E)$</li><li><strong>space：</strong>$O(n + m)$ ➔ 因為 <code>adj</code> 為 $O(V+E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>211. Design Add and Search Words Data Structure</title>
      <link href="/post/design-add-and-search-words-data-structure/"/>
      <url>/post/design-add-and-search-words-data-structure/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">https://leetcode.cn/problems/design-add-and-search-words-data-structure/</a></strong></p><p><strong>題意：</strong>請設計一資料結構, 支持新增單字、搜尋 string 是否和先前新增的單字匹配。</p><p><strong>實作 <code>WordDictionary</code> class：</strong></p><ul><li><code>WordDictionary()</code>：初始化 instance</li><li><code>void addWord(word)</code>：將 <code>word</code> 新增到資料結構中, 之後可以對它進行匹配</li><li><code>bool search(word)</code>：如果資料結構中存在 string 和 <code>word</code> 匹配, 則返回 <code>true</code> ; 否則, 返回 <code>false</code>。<code>word</code> 中可能包含一些 <code>.</code>, 每個 <code>.</code> 都可表示成任何一個 char</li></ul><p><strong>注意：</strong></p><ul><li><code>addWord</code> 中的 <code>word</code> 只由<strong>小寫</strong>字母所組成</li><li><code>search</code> 中的 <code>word</code> 由 <code>.</code> or <strong>小寫</strong>字母所組成</li></ul></blockquote><p><img src="https://i.imgur.com/K0RzE7t.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Trie + DFS, 一旦遇到 <code>.</code>, 就對當前 node 中所有的 child 進行 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> idx = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;children[idx]) &#123;</span><br><span class="line">                cur-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        trie.<span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(trie.root, word, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie trie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TrieNode* node, string&amp; word, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        TrieNode *cur = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; child : cur-&gt;children)&#123;</span><br><span class="line">                    <span class="comment">// 要先判斷 child 是否為 nullptr, i + 1 是因為跳過當前 char</span></span><br><span class="line">                    <span class="keyword">if</span> (child &amp;&amp; <span class="built_in">dfs</span>(child, word, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> idx = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;children[idx]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;children[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>WordDictionary()</code>：$O(1)$</li><li><code>addWord(word)</code>：$O(n)$ ➔ 其中 <code>n</code> 為 <code>word.size()</code></li><li><code>search(word)</code>：$O(26^n)$ ➔ worse case : <code>word</code> 中每個 char 皆為 <code>.</code>, 這樣每個 char 都有 26 種可能</li></ul></li><li><strong>space：</strong>$O(T)$ ➔ $O(26 \cdot T)$, 其中 <code>T</code> 為 <code>trie</code> 中所有的 node 數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>355. Design Twitter</title>
      <link href="/post/design-twitter/"/>
      <url>/post/design-twitter/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/design-twitter/">https://leetcode.cn/problems/design-twitter/</a></strong></p><p><strong>題意：</strong>設計一個簡化版的 Twitter, 可以讓用戶實現發送推文、關注 &#x2F; 取消關注 其他用戶, 以及能夠看見關注人（包括自己）的最近 <code>10</code> 條推文。</p><ul><li><code>Twitter()</code>：初始化 twitter instance。</li><li><code>void postTweet(int userId, int tweetId)</code>：根據給定的 <code>tweetId</code> 和 <code>userId</code> 創建一條新推文。每次調用此函數都會使用一個不同的 <code>tweetId</code>。</li><li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code>：檢索當前用戶新聞推送中最近 <code>10</code> 條推文的 ID。<ul><li>新聞推送中的每一項都必須是由用戶關注的人 or 用戶自己發布的推文。</li><li>推文必須按照時間順序由<strong>最近到最遠排序</strong>。</li></ul></li><li><code>void follow(int followerId, int followeeId)</code>：ID 為 <code>followerId</code> 的用戶開始關注 ID 為 <code>followeeId</code> 的用戶。</li><li><code>void unfollow(int followerId, int followeeId)</code>：ID 為 <code>followerId</code> 的用戶取消關注 ID 為 <code>followeeId</code> 的用戶。</li></ul></blockquote><p><img src="https://i.imgur.com/sSGB6Yx.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1</strong>：</h2><blockquote><p><strong>想法：利用 hash table, 利用兩個 hash table <code>friends</code>、<code>tweets</code> 來分別記錄每一位用戶的好友、每一位用戶發的推文。<code>getNewsFeed()</code> 獲取自己和好友的最近 10 條推文, 首先要將自己添增到自己的好友列表中, 然後依序遍歷每個好友的所有推文, 並維護一個大小為 10 的 min heap</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Twitter</span>() &#123;</span><br><span class="line">        ts = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        tweets[userId].<span class="built_in">emplace_back</span>(pii&#123;++ts, tweetId&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">follow</span>(userId, userId); <span class="comment">// 先 follow 自己</span></span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> i : friends[userId]) &#123;</span><br><span class="line">            <span class="comment">// 遍歷該好友「最新 -&gt; 最舊」的推文</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tweets[i].<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(tweets[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">10</span>) &#123; <span class="comment">// 若大於 10 則, 則 pop 掉 ts 最小的, 以維持 10 則</span></span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出 的 tweetId 是根據 ts 由小到大排序, 故取出後要 reverse</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        friends[followerId].<span class="built_in">emplace</span>(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (friends[followerId].<span class="built_in">find</span>(followeeId) != friends[followerId].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            friends[followerId].<span class="built_in">erase</span>(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ts; <span class="comment">// timestamp, ts 越大代表該推文越新</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;pii&gt;&gt; tweets; <span class="comment">// userId -&gt; &#123;ts, tweetId&#125;</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; friends; <span class="comment">// &#123;follower, set of followee&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>Twitter()</code>：$O(1)$</li><li><code>postTweet()</code>：$O(1)$</li><li><code>getNewsFeed()</code>：$O(f \cdot t)$ ➔ $O(f \cdot t \cdot log(10))$, 遍歷該用戶每個好友的所有推文<ul><li><code>f</code> 為該用戶的好友數</li><li><code>t</code> 為每位好友的平均推文數</li><li>$O(log(10))$ 為 heap 中 insert &#x2F; erase 一個元素所需的時間</li></ul></li><li><code>follow()</code>：$O(1)$</li><li><code>unfollow()</code>：$O(1)$</li></ul></li><li><strong>space：</strong>$O(u \cdot t)$ ➔ <code>tweets</code>, 其中 <code>u</code> 為所有用戶數, <code>t</code> 為所有用戶的平均推文數</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 Solution 1, 只是 <code>getNewsFeed()</code> 改成維護一個大小為 10 的 set, 並做 pruning 來優化。每個好友的推文是根據 <code>ts</code> 「大(新) -&gt; 小(舊)」來遍歷, 一旦當前好友 <code>f1</code> 的推文比 <code>news</code> 中最舊推文的 <code>ts</code> 還要小, 則 <code>f1</code> 剩餘的推文都不必遍歷（因為 <code>ts</code> 只會更小）, 可直接跳到下一個好友</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Twitter</span>() &#123;</span><br><span class="line">        ts = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        tweets[userId].<span class="built_in">emplace_back</span>(pii&#123;++ts, tweetId&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">follow</span>(userId, userId); <span class="comment">// 先 follow 自己</span></span><br><span class="line"></span><br><span class="line">        set&lt;pii&gt; news;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> i : friends[userId]) &#123;</span><br><span class="line">            <span class="comment">// 遍歷該好友「最新 -&gt; 最舊」的推文</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = tweets[i].<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="comment">// 不足 10 則, 直接加入到 news 中</span></span><br><span class="line">                <span class="keyword">if</span> (news.<span class="built_in">size</span>() &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                    news.<span class="built_in">emplace</span>(tweets[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tweets[i][j].first &gt; news.<span class="built_in">begin</span>()-&gt;first) &#123; <span class="comment">// 若該推文比 news 中最舊的推文還新, 則加入該推文, 並移除最舊的推文</span></span><br><span class="line">                    news.<span class="built_in">erase</span>(news.<span class="built_in">begin</span>());</span><br><span class="line">                    news.<span class="built_in">emplace</span>(tweets[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 該推文比 news 中最舊的推文還舊, 則該好友不必再繼續往下遍歷</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出 news 中的 tweetId, 由於 news 是根據 ts 由小到大排序, 故取出後要 reverse</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ts, tweetId] : news) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(tweetId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        friends[followerId].<span class="built_in">emplace</span>(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (friends[followerId].<span class="built_in">find</span>(followeeId) != friends[followeeId].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            friends[followerId].<span class="built_in">erase</span>(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ts; <span class="comment">// timestamp, ts 越大代表該推文越新</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;pii&gt;&gt; tweets; <span class="comment">// userId -&gt; &#123;ts, tweetId&#125;</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; friends; <span class="comment">// &#123;follower, set of followee&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>Twitter()</code>：$O(1)$</li><li><code>postTweet()</code>：$O(1)$</li><li><code>getNewsFeed()</code>：$O(f \cdot t)$ ➔ $O(f \cdot t \cdot log(10))$, 遍歷該用戶每個好友的所有推文<ul><li><code>f</code> 為該用戶的好友數</li><li><code>t</code> 為每位好友的平均推文數</li><li>$O(log(10))$ 為 set 中 insert &#x2F; erase 一個元素所需的時間</li></ul></li><li><code>follow()</code> : $O(1)$</li><li><code>unfollow()</code> : $O(1)$</li></ul></li><li><strong>space：</strong>$O(u \cdot t)$ ➔ <code>tweets</code>, 其中 <code>u</code> 為所有用戶數, <code>t</code> 為所有用戶的平均推文數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>261. Graph Valid Tree</title>
      <link href="/post/graph-valid-tree/"/>
      <url>/post/graph-valid-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/graph-valid-tree/">https://leetcode.cn/problems/graph-valid-tree/</a></strong></p><p><strong>題意：</strong>給定編號 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 個 node, 和一個<strong>無向邊</strong>的 list <code>edges</code>, 其中 <code>edges[i] = [a, b]</code> 代表 graph 中 <code>a</code> 和 <code>b</code> 之間有一邊, 返回此 graph 是否為 tree。</p><p><strong>注意：</strong><code>edges</code> 中沒有重複的邊（e.g. <code>[1, 0]</code> 和 <code>[0, 1]</code> 不會同時出現在 <code>edges</code> 中）</p></blockquote><p><img src="https://i.imgur.com/JRd3uYU.png"></p><p><img src="https://i.imgur.com/lkjc6oP.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS, 若 graph 要為 tree, 則必須滿足以下兩點：</strong></p><ul><li><strong>graph 中不可有 cycle</strong></li><li><strong>graph 必須為 connected, 也就是圖中任兩點必定有邊相連, 不能有 isolated vertex</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n); <span class="comment">// adjacent list</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs 起始點為 0, 令 0 的前一個 node 設為 -1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(adj, visited, <span class="number">0</span>, <span class="number">-1</span>) &amp;&amp; <span class="built_in">connected</span>(visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若無 cycle, 則 dfs 會 return true; 否則 return false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, vector&lt;<span class="type">bool</span>&gt;&amp; visited, <span class="type">int</span> cur, <span class="type">int</span> prev)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若有 node 被重複拜訪, 代表有 cycle</span></span><br><span class="line">        <span class="keyword">if</span> (visited[cur]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[cur] = <span class="literal">true</span>; <span class="comment">// 將 cur 設為已拜訪</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123; <span class="comment">// dfs 拜訪 adjacent node</span></span><br><span class="line">            <span class="comment">// 若 v 為前一個 node, 則不進行 dfs</span></span><br><span class="line">            <span class="keyword">if</span> (v != prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">dfs</span>(adj, visited, v, cur)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有 cycle</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判斷圖中所有點是否都有被拜訪到</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : visited) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有點沒被拜訪到</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V + E)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(&#123;<span class="number">0</span>&#125;)</span></span>; <span class="comment">// 初始點設為 0</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(&#123;<span class="number">0</span>&#125;)</span></span>; <span class="comment">// 初始點設為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                    <span class="comment">// 若 v 已被拜訪代表有 cycle, 返回 false</span></span><br><span class="line">                    <span class="keyword">if</span> (visited.<span class="built_in">find</span>(v) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    visited.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    adj[v].<span class="built_in">erase</span>(cur); <span class="comment">// 避免等下拜訪 v 時重複拜訪 cur</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.<span class="built_in">size</span>() == n; <span class="comment">// 判斷是否所有點都被拜訪到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V + E)$ ➔ <code>adj</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Union Find + Path Compression, 用 Union Find 合併每條邊的兩個 node 時, 如果這兩個 node 已經在同一 set 中, 則存在 cycle</strong></p><p>e.g. <code>edges = [[1,2], [1, 3], [2, 3]]</code></p><p><img src="https://i.imgur.com/j0HG1wZ.png"></p><ul><li>當完成 <code>[1, 2]</code> 和 <code>[1, 3]</code> 時, <code>parents[2] = 1 = parents[3]</code></li><li>然後執行 <code>[2, 3]</code> 時, 因為 <code>parents[2] == parents[3]</code> 代表有 cycle</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parents</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個點的 parent</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ranks</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// 紀錄每個點的 rank</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每個點的 parent 都初始成自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = n; <span class="comment">// 一開始令每個 node 都自己一個 set, 然後才開始合併</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(parents, e[<span class="number">0</span>]); <span class="comment">// root of a</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(parents, e[<span class="number">1</span>]); <span class="comment">// root of b</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// a, b 已經是同個 set, 則代表加入 e 後會形成 cycle</span></span><br><span class="line">            <span class="keyword">if</span> (r1 == r2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a, b 是不同 set, 則兩個 set 合併成一個 set</span></span><br><span class="line">            <span class="built_in">union_</span>(parents, ranks, r1, r2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">1</span>; <span class="comment">// 合併到最後只剩下一個 set, 代表所有 node 皆 connected</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">const</span> <span class="type">int</span> r1, <span class="type">const</span> <span class="type">int</span> r2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ranks[r2] &gt; ranks[r1]) &#123;</span><br><span class="line">            parents[r1] = r2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">            ranks[r1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        --res; <span class="comment">// 合併後, set 數 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]]; <span class="comment">// path compression</span></span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 遍歷每個 node 初始化 <code>parents</code>, 以及遍歷每條 edge 做 union find, 其中 edge 的兩端點做 <code>find()</code> 皆只需 $O(1)$</li><li><strong>space：</strong>$O(n)$ ➔ <code>parents</code>, <code>ranks</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>208. Implement Trie (Prefix Tree)</title>
      <link href="/post/implement-trie-prefix-tree/"/>
      <url>/post/implement-trie-prefix-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">https://leetcode.cn/problems/implement-trie-prefix-tree/</a></strong></p><p><strong>題意：</strong>Trie 也稱作 prefix tree, 是一種可以高效儲存、取得 string 中的 key 的資料結構。這一資料結構有相當多的應用情境, 例如 : 自動補全和拼寫檢查。</p><p><strong>請實現 <code>Trie</code> class：</strong></p><ul><li><code>Trie()</code>：初始化 trie object</li><li><code>void insert(String word)</code>：插入 <code>word</code></li><li><code>bool search(String word)</code>：返回 <code>word</code> 是否已經存在於 trie 中</li><li><code>boolean startsWith(String prefix)</code> ：若已經插入的 <code>word</code> 的前綴之一為 <code>prefix</code>, 則 return <code>true</code></li></ul><p><strong>注意：</strong><code>word</code> 和 <code>prefix</code> 僅由<strong>小寫</strong>字母所組成。</p></blockquote><p><img src="https://i.imgur.com/JPDWBFO.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：先用一個 <code>root</code> 作為所有開頭 TrieNode 之 dummy node</strong></p><ul><li><code>Trie()</code> : 初始化 <code>root</code></li><li><code>void insert(String word)</code> : 遍歷 word 中的每個 char, 若 <code>p-&gt;children[ch - &#39;a&#39;]</code> 為 <code>null</code>, 則新增一 TrieNode 並指向它, 當走到 word 之 end, 記得將 trie 中的 end node 之 <code>isEnd</code> 設為 <code>true</code></li><li><code>bool search(String word)</code> 和 <code>boolean startsWith(String prefix)</code> : 兩者皆得遍歷傳入參數的每個 char, 因此我額外寫了一個 <code>TrieNode* find(string&amp; word)</code> 來遍歷<ul><li><code>TrieNode* find(string&amp; word)</code> : 若 word 不在 trie 中, 則返回 nullptr。否則, 返回 end node 之 ptr</li><li><code>bool search(String word)</code> : 若 end node 之 ptr <code>p</code> 存在, 且 <code>p-&gt;isEnd</code> 為 <code>true</code><br>  ➔ 代表 <code>word</code> 存在 trie 中, 因此返回 <code>true</code></li><li><code>boolean startsWith(String prefix)</code> : 若 end node 之 ptr <code>p</code> 存在<br>  ➔ 代表 <code>prefix</code> 存在 trie 中, 因此返回 <code>true</code></li></ul></li></ul><p>e.g. 下圖為插入 <code>[&quot;app&quot;, &quot;ape&quot;, &quot;at&quot;, &quot;atp&quot;, &quot;to&quot;]</code> 後的 trie, 每個 TrieNode 中的是 char 和 is_end</p><p><img src="https://i.imgur.com/G23n4gQ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>; <span class="comment">// 預設每個 char 不為 end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;children[i]) &#123;</span><br><span class="line">                cur-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;isEnd = <span class="literal">true</span>; <span class="comment">// 將最後一個 char 設為 end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不僅 word 要在 trie 中, 且 word 的最後一個 char 還必須是 end</span></span><br><span class="line">        TrieNode *p = <span class="built_in">find</span>(word);</span><br><span class="line">        <span class="keyword">return</span> (p != <span class="literal">nullptr</span>) &amp;&amp; p-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代表 prefix 為 trie 的前綴之一</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 word 不在 trie 中, 則返回 nullptr; 否則, 返回 end node 之 ptr</span></span><br><span class="line">    <span class="function">TrieNode* <span class="title">find</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : word) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li>$O(1)$ ➔ 初始化 Trie</li><li>$O(n)$ ➔ insert、search 和 startWith, <code>n</code> 為要查詢或插入的 string 長度</li></ul></li><li><strong>space：</strong>$O(26 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ worse case：每個 <code>word</code> 的 <code>prefix</code> 皆不重覆<ul><li>$\displaystyle\sum_{i&#x3D;1}^{n}w_i$：所有要插入的 string 長度之和（最大 node 數）</li><li>$O(26)$ : 每個 node 有 26 個 children</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>973. K Closest Points to Origin</title>
      <link href="/post/k-closest-points-to-origin/"/>
      <url>/post/k-closest-points-to-origin/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/k-closest-points-to-origin/">https://leetcode.cn/problems/k-closest-points-to-origin/</a></strong></p><p><strong>題意：</strong>給一 array <code>points</code> 和一整數 <code>k</code>, 其中 <code>points[i] = [x_i, y_i]</code> 表示平面上的一個點, 返回距離 <code>(0, 0)</code> 最近的 <code>k</code> 個點。</p><p>平面上兩點的距離是採用<strong>歐式距離</strong> $\sqrt{(x1 - x2)^2 + (y1 - y2)^2}$</p><p>可以按<strong>任何順序</strong>返回答案。</p></blockquote><p><img src="https://i.imgur.com/TeyvJue.png"></p><p><img src="https://i.imgur.com/YC2fgLx.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap, 用 max heap 維護前 <code>k</code> 小的元素, 類似 <a href="https://zako945.github.io/post/top-k-frequent-elements/">347. Top K Frequent Elements</a></strong></p><ul><li>先將前 <code>k</code> 個元素加入到 max heap 中</li><li>後面 <code>n - k</code> 個點, 都是先 insert 到 heap 中再 pop 掉, 來維持 heap 中 <code>k</code> 個元素</li><li>此時, heap 中為前 <code>k</code> 小的元素, 將其取出即可</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; t3i; <span class="comment">// &#123;dist, x, y&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> k) &#123;</span><br><span class="line">        priority_queue&lt;t3i&gt; pq; <span class="comment">// max heap 維護前 k 小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; point : points) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> dist = x * x + y * y;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(t3i&#123;dist, x, y&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若加入後 heap 中有 k + 1 個, 則 pop 掉 dist 最大的來維持 k 個</span></span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此時, heap 中為前 k 小元素, 將其取出即可</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [dist, x, y] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;x, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(k))$ ➔ 前面兩個 for loop 最多 insert&#x2F;delete <code>n</code> 個點, 每次操作需 $O(log(k))$, 因為 <code>pq</code> 中最多 <code>k</code> 個點</li><li><strong>space：</strong>$O(k)$ ➔ <code>pq</code> 最多有 <code>k</code> 個元素</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. Kth Largest Element in an Array</title>
      <link href="/post/kth-largest-element-in-an-array/"/>
      <url>/post/kth-largest-element-in-an-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和一整數 <code>k</code>, 返回第 <code>k</code> 大的元素。</p><p><strong>注意：</strong>你需要找的是 <code>nums</code> 排序後的第 <code>k</code> 大的元素, 而非第 <code>k</code> 個不同的元素。</p><p>設計滿足 $O(n)$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/vHep5hb.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Heap, 維護前 <code>k</code> 大的元素, 類似 <a href="https://zako945.github.io/post/top-k-frequent-elements/">347. Top K Frequent Elements</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(num);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若加入後 heap 中有 k + 1 個, 則 pop 掉最小的來維持 k 個</span></span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(k))$ ➔ for loop 最多 insert&#x2F;delete <code>n</code> 個點, 每次操作需 $O(log(k))$, 因為 <code>pq</code> 中最多 <code>k</code> 個點</li><li><strong>space：</strong>$O(k)$ ➔ <code>pq</code> 的最大長度為 <code>k</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Quick Select, 原題目就會變成求將 <code>nums</code> 由小到大排序後 <code>idx = n - k</code> 的元素, 因為排序完後 <code>idx = n - 1</code> 為第一大的元素, 故 <code>idx = n - k</code> 為第 <code>k</code> 大的元素</strong></p><ul><li>先選一元素當作 pivot<ul><li>把 <code>val ≤ pivot</code> 的元素放在 pivot 的左邊</li><li>而 <code>val &gt; pivot</code> 的元素放在 pivot 的右邊</li></ul></li><li>比較 <code>pivot_idx</code> 是否為 <code>k</code><ul><li>若 <code>k &gt; pivot_idx</code>：遞迴搜索右邊的部分 <code>quickSelect(pivot_idx + 1, right)</code></li><li>若 <code>k &lt; pivot_idx</code>：遞迴搜索左邊的部分 <code>quickSelect(left, pivot_idx - 1)</code></li><li>若 <code>k == pivot_idx</code>：返回 <code>nums[k]</code></li></ul></li></ul><p>e.g. <code>nums = [3,2,1,5,6,4]</code>, <code>k = 2</code> ➔ <code>k = n - k = 6 - 2 = 4</code></p><ul><li>首先, <code>left = 0</code>, <code>right = 5</code>, 取出 <code>pivotVal = 4</code>, <code>pivotIdx = 0</code>,</li><li>第一輪 Quick Select 做完, 得到 <code>nums = [3,2,1,4,6,5]</code>, <code>pivotIdx = 3</code></li><li>由於 <code>k = 4 &gt; pivotIdx = 3</code>, 故往右邊尋找 <code>quickSelect(nums, pivotIdx + 1, right, k)</code></li><li>第二輪 Quick Select 做完, 得到 <code>nums = [3,2,1,4,5,6]</code>, <code>pivotIdx = 4</code></li><li><code>k == pivotIdx</code>, 故返回 <code>nums[4] = 5</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k = n - k; <span class="comment">// 若由小排到大, 則 nums 中 idx = n - k 的元素為第 k 大的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = nums[right], pivotIdx = left; <span class="comment">// 取最右的元素為 pivot</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將比 pivot 小的元素從 idx = left 的位置開始放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[pivotIdx++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 pivot 放在 pivotIdx 上, 使得左邊皆 &lt;= pivot, 右邊皆 &gt; pivot</span></span><br><span class="line">        <span class="comment">// 必須寫 nums[right], 不能寫 pivot, 否則 nums[pivotIdx] 仍會是 pivot</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[pivotIdx], nums[right]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt; pivotIdx) &#123; <span class="comment">// 搜索左邊的部分</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, left, pivotIdx - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; pivotIdx) &#123; <span class="comment">// 搜索右邊的部分</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, pivotIdx + <span class="number">1</span>, right, k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[pivotIdx]; <span class="comment">// k == pivotIdx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ Quick Select 的 Avg case<ul><li>worse case 為 $O(n^2)$, 也就是每次取完 <code>pivot</code> 都只篩掉一個元素</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>230. Kth Smallest Element in a BST</title>
      <link href="/post/kth-smallest-element-in-a-bst/"/>
      <url>/post/kth-smallest-element-in-a-bst/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">https://leetcode.cn/problems/kth-smallest-element-in-a-bst/</a></strong></p><p><strong>題意：</strong>給一 BST 的 <code>root</code> 和一整數 <code>k</code>, 返回 BST 中第 <code>k</code> 小的元素（從 <code>1</code> 開始計數）。</p></blockquote><p><img src="https://i.imgur.com/FNXlEpo.png"></p><p><img src="https://i.imgur.com/qQJ4RXw.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS（inorder）, 不斷取當前 node 的 <code>left</code> 直到 <code>node-&gt;left</code> 為 <code>null</code>, 由於 <code>left child</code> 是「後進先出」, 故要使用 stack。將這些 <code>left</code> 一個一個 pop 掉, 並將 <code>k</code> 減去 <code>1</code></strong></p><ul><li>若 <code>k == 0</code>, 代表當前 <code>node</code> 為第 <code>k</code> 小的數</li><li>若 <code>k &gt; 0</code>, 代表當前的數還太小, 故要嘗試其右子樹中的 node</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 不斷加入 left child, 直到 left child 為 null</span></span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出最左邊的 node</span></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            --k; <span class="comment">// 扣除 root 本身</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// k == 0, 代表當前 root 為第 k 小的</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 嘗試最左邊的 node 之 right subtree</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ worse case：skew tree, 其中 <code>n</code> 為 node 數</li><li><strong>space：</strong>$O(n)$ ➔ 取決於 stack 長度, 最大長度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. Letter Combinations of a Phone Number</title>
      <link href="/post/letter-combinations-of-a-phone-number/"/>
      <url>/post/letter-combinations-of-a-phone-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></strong></p><p><strong>題意：</strong>給一 string 包含數字 <code>2-9</code>, 以<strong>任意順序</strong>返回所有它所能表示的英文組合。<br>數字到英文的 mapping 如下, 其中數字 1 不對應任何字母</p></blockquote><p><img src="https://i.imgur.com/ObUlOvR.png"></p><p><img src="https://i.imgur.com/gdaxaKL.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, <span class="number">0</span>, digits.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string cur;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;string&gt; mapping = &#123;</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string&amp; digits, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : mapping[digits[i] - <span class="string">&#x27;2&#x27;</span>]) &#123;</span><br><span class="line">            cur += ch;</span><br><span class="line">            <span class="built_in">dfs</span>(digits, i + <span class="number">1</span>, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 4^n)$<ul><li>一個數字最多 4 種選擇（數字 <code>7</code> 和 <code>9</code>）</li><li>總共 $4^n$ 種排列, 建構每一種需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array <code>res</code>, 則取決於遞迴深度, 最大遞迴深度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>695. Max Area of Island</title>
      <link href="/post/max-area-of-island/"/>
      <url>/post/max-area-of-island/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/max-area-of-island/">https://leetcode.cn/problems/max-area-of-island/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的矩陣 <code>grid</code>。</p><p><strong>島嶼</strong>是由一些相鄰的 <code>1</code> （代表土地）所構成的組合, 這里的「相鄰」要求兩個 <code>1</code> 必須在<strong>水平 or 垂直</strong>的四個方向上相鄰。</p><p>假設 <code>grid</code> 的邊界都被 <code>0</code>（代表水）包圍著。</p><p>返回 <code>grid</code> 中最大的島嶼面積。如果沒有島嶼, 則返回 <code>0</code>。</p></blockquote><p><img src="https://i.imgur.com/7InE5Cq.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 以每一個 <code>grid[i][j]</code> 作為起點做 DFS 計算 area, 一旦拜訪過, 就將 <code>grid[i][j]</code> 設為 <code>0</code>, 避免遞迴遍歷時 area 重複計算</strong></p><ul><li>若 <code>grid[i][j] == 1</code> : <code>area++</code>, 並遞迴遍歷四個方向</li><li>若 <code>grid[i][j] == 0</code> : 直接返回</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(grid, i, j, area);</span><br><span class="line">                res = <span class="built_in">max</span>(res, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, <span class="type">int</span>&amp; area)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">out_of_bound</span>(i, j) || grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 設為已拜訪, 避免重覆計算到 area</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        ++area;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r = i + dirY, c = j + dirX;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, r, c, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_bound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>grid</code>, 且每個 cell 最多被拜訪一次</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ 取決於遞迴深度, worse case：整個 <code>grid</code> 都是 <code>1</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>323. Number of Connected Components in an Undirected Graph</title>
      <link href="/post/number-of-connected-components-in-an-undirected-graph/"/>
      <url>/post/number-of-connected-components-in-an-undirected-graph/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/">https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/</a></strong></p><p><strong>題意：</strong>有一含 <code>n</code> 個 node 的 graph, 給你一整數 <code>n</code> 和 <code>edges</code>, 其中 <code>edges[i] = [a, b]</code> 代表 graph 中 <code>a</code> 和 <code>b</code> 之間有一邊, 返回 connected component 個數。</p></blockquote><p><img src="https://i.imgur.com/6FgGu4s.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS, 依序對所有 node 做 dfs, 每次判斷該 node 是否被拜訪過, 若還沒代表有新的 component</strong></p><p>e.g. <code>n = 5</code>, <code>edges = [[0, 1], [1, 2], [3, 4]]</code></p><ul><li><p>先對 <code>0</code> 做 dfs 得到第一個 <code>component(0,1,2)</code>, 同時 <code>visited[0,1,2]</code> 都被設為 <code>true</code></p></li><li><p>因為 <code>visited[3] = false</code>, 所以對 <code>3</code> 做 dfs 得到第二個 <code>component(3,4)</code></p><p>  <img src="https://i.imgur.com/lQHOPPC.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countComponents</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                <span class="built_in">dfs</span>(adj, visited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, vector&lt;<span class="type">bool</span>&gt;&amp; visited, <span class="type">int</span>&amp; cur)</span></span>&#123;</span><br><span class="line">        visited[cur] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(adj, visited, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V + E)$ ➔ 因為 <code>adj</code> 為 $O(V + E)$, <code>V</code> 是因為要記錄所有點, <code>E</code> 是因為會記錄所有邊</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 道理同 DFS, 依序對所有 node 做 bfs, 每次判斷該 node 是否被拜訪過, 若還沒代表有新的 component</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countComponents</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                <span class="built_in">bfs</span>(adj, visited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, vector&lt;<span class="type">int</span>&gt;&amp; visited, <span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">        <span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(&#123;i&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                visited[cur] = <span class="literal">true</span>; <span class="comment">// 將 cur 設為已拜訪</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : adj[cur]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(v); <span class="comment">// 將未拜訪的相鄰點加到 queue 中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 必須拜訪所有 node, 和其延伸出去的所有 edge<ul><li><code>V</code> 是 node 數, <code>E</code> 是 edge 數</li></ul></li><li><strong>space：</strong>$O(V + E)$ ➔ <code>adj</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Union Find + Path Compression</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countComponents</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parents</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個點的 parent</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ranks</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// 紀錄每個點的 rank</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每個點的 parent 都初始成自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = n; <span class="comment">// 一開始令每個 node 都自己一個 set, 然後才開始合併</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges)&#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(parents, e[<span class="number">0</span>]); <span class="comment">// root of a</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(parents, e[<span class="number">1</span>]); <span class="comment">// root of b</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 a, b 是同個 set, 則不做任何事</span></span><br><span class="line">            <span class="keyword">if</span> (r1 == r2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a, b 是不同 set, 則兩個 set 合併成一個 set</span></span><br><span class="line">            <span class="built_in">union_</span>(parents, ranks, r1, r2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">const</span> <span class="type">int</span> r1, <span class="type">const</span> <span class="type">int</span> r2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 深度低的 tree root 把深度高的 tree root 作為 parent</span></span><br><span class="line">        <span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ranks[r1] &lt; ranks[r2]) &#123;</span><br><span class="line">            parents[r1] = r2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若深度一樣, 可以任意選擇一個 root 作為 parent</span></span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">            ++ranks[r1]; <span class="comment">// 作為 parent 的 node 之 rank 值會加一, 因為深度變了</span></span><br><span class="line">        &#125;</span><br><span class="line">        --res; <span class="comment">// 合併後, set 數 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]]; <span class="comment">// path compression</span></span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(V + E)$ ➔ 遍歷每個 node 初始化 <code>parents</code>, 以及遍歷每條 edge 做 union find, 其中 edge 的兩端點做 <code>find()</code> 皆只需 $O(1)$</li><li><strong>space：</strong>$O(n)$ ➔ <code>parents</code> , <code>ranks</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>200. Number of Islands</title>
      <link href="/post/number-of-islands/"/>
      <url>/post/number-of-islands/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的二維矩陣 <code>grid</code>, 其中 <code>&#39;1&#39;</code> 代表陸地, 而 <code>&#39;0&#39;</code> 代表水, 返回島嶼的個數。</p><p>每座島嶼只能由水平 or 垂直方向的相鄰陸地連接而成。</p></blockquote><p><img src="https://i.imgur.com/pY28FxG.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS, 若 <code>grid[row][col] == 1</code>, 則以其為起始 node 開始進行 DFS。在 DFS 的過程中. 每個搜索到的 <code>1</code> 都會被重新標記為 <code>0</code>, 最後整個地圖都會變成水</strong></p><p><img src="https://i.imgur.com/nZbHrWq.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">out_of_bound</span>(i, j) || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 表示已拜訪過</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, i + dirY, j + dirX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_bound</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ 取決於遞迴深度, 最大遞迴深度為 $mn$（worse case：全部都是陸地）</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 概念類似 Solution 1, 拜訪後一樣要設為 <code>0</code>。若在 <code>q.pop()</code> 下面放 <code>grid[row][col] = &#39;0&#39;</code>, 而不是在將 <code>&#123;r, c&#125;</code> push 到 <code>q</code> 時將 <code>grid[r][c]</code> 設為 <code>0</code>, 這樣會使 node 被重複拜訪, 導致 TLE</strong></p><p><img src="https://i.imgur.com/6Ge76fI.png"></p><p>e.g. <code>grid = [[1, 1], [1, 1]]</code></p><ul><li><p>若是在 <code>q.pop()</code> 下面放 <code>grid[row][col] = &#39;0&#39;</code>, 則 <code>grid[1][1]</code> 會被 <code>grid[0][1]</code> 和 <code>grid[1][0]</code> 重複拜訪（因為 <code>grid[1][1]</code> 在下一輪的 <code>q.pop()</code> 後才被設為 0）</p><p>  <img src="https://i.imgur.com/nR05xdp.png"></p></li><li><p>若是在將 <code>&#123;r, c&#125;</code> push 到 <code>q</code> 時將 <code>grid[r][c]</code> 設為 <code>0</code>, 則 <code>grid[1][1]</code> 只會被 <code>grid[1][0]</code> 拜訪。因為在 <code>grid[0][1]</code> 的 for loop 中 <code>if(grid[1][1] == &#39;1&#39;)</code> 不會成立, 因為 <code>grid[1][1]</code> 已經在 <code>grid[1][0]</code> 的 for loop 中被設成 <code>0</code></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, i, j);</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    vector&lt;pii&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(pii&#123;i, j&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [row, col] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> r = row + dirY, c = col + dirX;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">out_of_bound</span>(r, c) &amp;&amp; grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(pii&#123;r, c&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_bound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(min(m, n))$ ➔ worse case：全部都是陸地, 則 <code>q</code> 的長度最多為 <code>min(m, n)</code>, 也就是圖中線的最大長度</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Union Find + Path Compression, 將所有的連在一起的 <code>1</code> 的位置歸到一個 <code>root</code>, 最後有多少個 <code>root</code> 就有多少個島嶼。值得注意的是, 與 DFS 或者 BFS 的方法不同的是, 不需要搜索四個方向, 只需要看兩個方向（右、下）即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        parents.<span class="built_in">resize</span>(m * n, <span class="number">0</span>);</span><br><span class="line">        ranks.<span class="built_in">resize</span>(m * n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 parents, 每個 node 指向自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; ++i) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> r = i + dirY, c = j + dirX;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// (i, j) 和 (r, c) 做 union</span></span><br><span class="line">                        <span class="keyword">if</span> (!<span class="built_in">out_of_bound</span>(r, c) &amp;&amp; grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            <span class="built_in">union_</span>(i * n + j, r * n + c, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parents, ranks;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n1, <span class="type">const</span> <span class="type">int</span> n2, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(n1); <span class="comment">// root of n1</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(n2); <span class="comment">// root of n2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 n1, n2 是同個 set, 則不做任何事</span></span><br><span class="line">        <span class="keyword">if</span> (r1 == r2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// n1, n2 是不同 set, 則兩個 set 合併成一個 set</span></span><br><span class="line">        <span class="comment">// 深度低的 tree root 把深度高的 tree root 作為 parent</span></span><br><span class="line">        <span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[r1] &lt; ranks[r2]) &#123;</span><br><span class="line">            parents[r1] = r2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若深度一樣, 可以任意選擇一個 root 作為 parent</span></span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">            ++ranks[r1]; <span class="comment">// 作為 parent 的 node 之 rank 值會加一, 因為深度變了</span></span><br><span class="line">        &#125;</span><br><span class="line">        --res; <span class="comment">// 合併後, set 數 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]]; <span class="comment">// path compression</span></span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_bound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ for loop</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>parent</code>, <code>ranks</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>417. Pacific Atlantic Water Flow</title>
      <link href="/post/pacific-atlantic-water-flow/"/>
      <url>/post/pacific-atlantic-water-flow/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">https://leetcode.cn/problems/pacific-atlantic-water-flow/</a></strong></p><p><strong>題意：</strong>今有一 <code>m x n</code> 矩形島嶼, 與<strong>太平洋</strong>和<strong>大西洋</strong>相鄰。</p><ul><li>太平洋位於島嶼的左邊界和上邊界</li><li>大西洋位於島嶼的右邊界和下邊界</li></ul><p>給一 <code>m x n</code> 整數 array <code>heights</code>, 其中 <code>heights[r][c]</code> 代表座標 <code>(r, c)</code> <strong>高於海平面的高度</strong></p><p>相鄰 cell 的高度 <strong>小於或等於</strong> 目前 cell 的高度, 則雨水可以直接流向相鄰 cell</p><p>求哪些位置的雨水能同時流進太平洋和大西洋？</p></blockquote><p><img src="https://i.imgur.com/MeL335x.png"></p><p><img src="https://i.imgur.com/XcJyHJQ.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS, 從邊界開始往內陸行進, 若高度越來越高則代表水可往邊界流, 藉此可找到抵達太平洋和大西洋的兩個集合, 然後取交集</strong></p><ul><li><strong>最左和最上的邊界一定能抵達太平洋（由這兩邊界向內延伸）</strong></li><li><strong>最右和最下的邊界一定能抵達大西洋（由這兩邊界向內延伸）</strong></li></ul><p><img src="https://i.imgur.com/pemKCwI.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        m = heights.<span class="built_in">size</span>(), n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">pac</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">atl</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(heights, i, <span class="number">0</span>, pac); <span class="comment">// left</span></span><br><span class="line">            <span class="built_in">bfs</span>(heights, i, n - <span class="number">1</span>, atl); <span class="comment">// right</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(heights, <span class="number">0</span>, j, pac); <span class="comment">// top</span></span><br><span class="line">            <span class="built_in">bfs</span>(heights, m - <span class="number">1</span>, j, atl); <span class="comment">// bottom</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pac[i][j] &amp;&amp; atl[i][j]) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    vector&lt;pii&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; h, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(pii&#123;i, j&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [y, x] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visited[y][x]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[y][x] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> r = y + dirY, c = x + dirX;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">out_of_bound</span>(r, c) &amp;&amp; h[y][x] &lt;= h[r][c] &amp;&amp; !visited[r][c]) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(pii&#123;r, c&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_bound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r == m || c &lt; <span class="number">0</span> || c == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 每個 node 最多被訪問四次（來自上下左右的鄰居）</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>pac</code>, <code>atl</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 想法同 Solution 1</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        m = heights.<span class="built_in">size</span>(), n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">pac</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">atl</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(heights, i, <span class="number">0</span>, pac); <span class="comment">// left</span></span><br><span class="line">            <span class="built_in">bfs</span>(heights, i, n - <span class="number">1</span>, atl); <span class="comment">// right</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(heights, <span class="number">0</span>, j, pac); <span class="comment">// top</span></span><br><span class="line">            <span class="built_in">bfs</span>(heights, m - <span class="number">1</span>, j, atl); <span class="comment">// bottom</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pac[i][j] &amp;&amp; atl[i][j]) &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    vector&lt;pii&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; h, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(pii&#123;i, j&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> [y, x] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">out_of_bound</span>(y, x) || visited[y][x]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[y][x] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> r = y + dirY, c = x + dirX;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">out_of_bound</span>(r, c) &amp;&amp; h[y][x] &lt;= h[r][c]) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(pii&#123;r, c&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_bound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r == m || c &lt; <span class="number">0</span> || c == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 每個 node 最多被訪問四次（來自上下左右的鄰居）</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>pac</code>, <code>atl</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131. Palindrome Partitioning</title>
      <link href="/post/palindrome-partitioning/"/>
      <url>/post/palindrome-partitioning/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindrome-partitioning/">https://leetcode.cn/problems/palindrome-partitioning/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 將 <code>s</code> 切割成一些 substring, 使每個 substring 皆回文, 返回 <code>s</code> 所有可能的切割方法。</p><p>其中, <code>s</code> 僅由小寫英文字母所組成。</p></blockquote><p><img src="https://i.imgur.com/IzaJUX6.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 如果切下去是回文, 則遞迴剩下的 substring</strong></p><p><img src="https://i.imgur.com/ZnBhKRI.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, i, j)) &#123;</span><br><span class="line">                cur.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>));</span><br><span class="line">                <span class="built_in">dfs</span>(s, j + <span class="number">1</span>, n);</span><br><span class="line">                cur.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left++] != s[right--]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ 最壞情況下, <code>s</code> 為 <code>n</code> 個相同的 char<ul><li>總共 $2^{n-1}$ 種切法（每個 char 之間的間隙都有切 or 不切兩種選擇）</li><li>每種耗時 $O(n)$, 判斷每個 substring 是否為回文</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, 最大遞迴深度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46. Permutations</title>
      <link href="/post/permutations/"/>
      <url>/post/permutations/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></strong></p><p><strong>題意：</strong>給一不含重複數字的 array <code>nums</code>, 求所有可能的排列, 以<strong>任意順序</strong>返回。</p></blockquote><p><img src="https://i.imgur.com/adGJ3ij.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：DFS, <code>nums[i]</code> 輪流當頭</strong></p><p>e.g. <code>nums = [1, 2, 3]</code></p><ul><li><p><code>1</code> 當頭 : <code>[1, 2, 3], [1, 3, 2]</code></p></li><li><p><code>2</code> 當頭 : <code>[2, 1, 3], [2, 3, 1]</code></p></li><li><p><code>3</code> 當頭 : <code>[3, 2, 1], [3, 1, 2]</code></p><p>  <img src="https://i.imgur.com/rC0P6Cu.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n); <span class="comment">// 跟開頭 nums[i] 做 swap, 排序 i + 1 (開頭以後)</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot n!)$ ➔ 總共 $n!$ 種排列, 建構每一種排列皆需花 $O(n)$ time</li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array, 則取決於遞迴的最大深度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>684. Redundant Connection</title>
      <link href="/post/redundant-connection/"/>
      <url>/post/redundant-connection/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/redundant-connection/">https://leetcode.cn/problems/redundant-connection/</a></strong></p><p><strong>題意：</strong>給一 <code>n</code> 個 node 的 tree（編號從 <code>1</code> 到 <code>n</code>）, 並在其中添加一條邊。添加的邊其兩個頂點包含在 <code>1</code> 到 <code>n</code> 中間, 且這條邊不屬於 tree 中已存在的邊。<code>edges[i] = [a, b]</code> 表示圖中 <code>a</code> 和 <code>b</code> 之間存在一條邊。</p><p>找出一條可以刪去的邊, 刪除後可使得剩餘部分為 tree。如果有多個答案, 則返回這些答案在 <code>edges</code> 中順序最後的那條邊。</p></blockquote><p><img src="https://i.imgur.com/SBu9b3T.png"></p><p><img src="https://i.imgur.com/6He3AY4.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：同 <a href="https://zako945.github.io/post/graph-valid-tree/">261. Graph Valid Tree</a>, 利用 DFS, 每次加入一條 edge <code>e</code>, 就檢查是否有 cycle, 一旦發現了 cycle, 就返回 <code>e</code>（最後加入形成 cycle 的 edge）</strong></p><ul><li>令 <code>e</code> 的兩端點分別為 <code>u</code>、<code>v</code>, 檢查是否已經有 path 能連接 <code>u</code>、<code>v</code>。若有, 則代表加入 <code>e</code> 後會形成 cycle</li><li>由於為<strong>無向圖</strong>, 所以遞迴遍歷時需要用 <code>visited</code> 紀錄哪些 node 已經拜訪過, 一旦拜訪過就不再遞迴遍歷。假設 edge <code>e = [u,v]</code>, 則 <code>u</code>、<code>v</code> 之間並無 cycle, 若不用 <code>visited</code> 紀錄, 則會發生 <code>u -&gt; v</code>、<code>v -&gt; u</code>, 因而得出 <code>u</code>、<code>v</code> 之間存在 cycle 的錯誤判斷。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges)&#123;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">hasPath</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], visited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加入 e</span></span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; adj; <span class="comment">// adjacent list</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 cur 能走到 goal, 則返回 true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(<span class="type">const</span> <span class="type">int</span> cur, <span class="type">const</span> <span class="type">int</span> goal, unordered_set&lt;<span class="type">int</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == goal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited.<span class="built_in">emplace</span>(cur);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其中一個點不在 adj 中, 則一定找不到 path 連接兩點</span></span><br><span class="line">        <span class="keyword">if</span> (adj.<span class="built_in">find</span>(cur) == adj.<span class="built_in">end</span>() || adj.<span class="built_in">find</span>(goal) == adj.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; next : adj[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(next) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 已經拜訪過則跳過</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">hasPath</span>(next, goal, visited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 其中 <code>n</code> 代表 edge、node 數<ul><li>$O(n^2)$：worse case 對於每次新增的 edge <code>e</code>, 必須搜索圖中之前出現的每條 edge<br>  ➔ $1 + 2 + … + n$ &#x3D; $\dfrac{(n + 1) \cdot n}{2}$</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>adj</code> 的 avg case 為 $O(V + E)$, 本題的 <code>V</code>、<code>E</code> 皆為 <code>n</code>（因為是 tree + 1 edge）</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：同 <a href="https://zako945.github.io/post/graph-valid-tree/">261. Graph Valid Tree</a>, 利用 Union Find + Path Compression, 用 Union Find 合併每條邊的兩個 node 時, 如果這兩個 node 已經在同一 set 中, 則存在 cycle</strong></p><p>e.g. <code>edges = [[1,2], [1,3], [2,3]]</code></p><p><img src="https://i.imgur.com/j0HG1wZ.png"></p><ul><li>當完成 <code>[1,2]</code> 和 <code>[1,3]</code> 時, <code>parents[2] = 1 = parent[3]</code></li><li>然後執行 <code>[2,3]</code> 時, 因為 <code>parents[2] == parents[3]</code> 代表有 cycle</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parents</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 紀錄每個點的 parent</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ranks</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 紀錄每個點的 rank</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每個點的 parent 都初始成自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r1 = <span class="built_in">find</span>(parents, e[<span class="number">0</span>]); <span class="comment">// root of a</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r2 = <span class="built_in">find</span>(parents, e[<span class="number">1</span>]); <span class="comment">// root of b</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// a, b 已經是同個 set, 則代表加入 e 後會形成 cycle</span></span><br><span class="line">            <span class="keyword">if</span> (r1 == r2) &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a, b 是不同 set, 則兩個 set 合併成一個 set</span></span><br><span class="line">            <span class="built_in">union_</span>(parents, ranks, r1, r2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != parents[i]) &#123;</span><br><span class="line">            parents[i] = parents[parents[i]];</span><br><span class="line">            i = parents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">int</span>&amp; r1, <span class="type">int</span>&amp; r2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 深度低的 tree root 把深度高的 tree root 作為 parent</span></span><br><span class="line">        <span class="keyword">if</span> (ranks[r1] &gt; ranks[r2]) &#123;</span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[r1] &lt; ranks[r2]) &#123;</span><br><span class="line">            parents[r1] = r2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若深度一樣, 可以任意選擇一個 root 作為 parent</span></span><br><span class="line">            parents[r2] = r1;</span><br><span class="line">            ++ranks[r1]; <span class="comment">// 作為 parent 的 node 之 rank 值會加一, 因為深度變了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷每個 node 初始化 <code>parents</code>, 以及遍歷每條 edge 做 union find, 而 edge 的兩端點做 <code>find()</code> 皆只需 $O(1)$, 其中 node、edge 數皆為 <code>n</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>parent</code>, <code>ranks</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>994. Rotting Oranges</title>
      <link href="/post/rotting-oranges/"/>
      <url>/post/rotting-oranges/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/rotting-oranges/">https://leetcode.cn/problems/rotting-oranges/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的網格 <code>grid</code>, 其中每個 cell 有三種可能：</p><ul><li><code>0</code> 代表沒橘子</li><li><code>1</code> 代表新鮮橘子</li><li><code>2</code> 代表腐爛的橘子</li></ul><p>每分鐘, 腐爛的橘子<strong>周圍 <code>4</code> 個方向</strong>上相鄰的新鮮橘子都會腐爛。</p><p>返回 <code>grid</code> 中沒有新鮮橘子所必須經過的最短時間。如果不可能, 則返回 <code>-1</code> 。</p></blockquote><p><img src="https://i.imgur.com/8cPRq6f.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS, 因為 <code>grid</code> 一開始可能有多顆腐爛的橘子</strong></p><p><img src="https://i.imgur.com/1PhPxVa.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, fresh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ++fresh;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(pii&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bfs</span>(grid, res, fresh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    vector&lt;pii&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span>&amp; res, <span class="type">int</span>&amp; fresh)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一旦沒有新鮮的橘子即可退出</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; fresh &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [y, x] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> r = y + dirY, c = x + dirX;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">out_of_bound</span>(r, c) &amp;&amp; grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                        --fresh;</span><br><span class="line">                        grid[r][c] = <span class="number">2</span>;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(pii&#123;r, c&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_bound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>grid</code></li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>q</code> 中的元素個數不超過 <code>m * n</code>, worse case：<code>grid</code> 元素皆為 2</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78. Subsets</title>
      <link href="/post/subsets/"/>
      <url>/post/subsets/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 當中的元素互不相同, 返回所有可能的 subset。</p></blockquote><p><img src="https://i.imgur.com/sASUAcK.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking, 每個元素都有取 or 不取兩種選擇</strong></p><p><img src="https://i.imgur.com/1JtQlEc.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n); <span class="comment">// 不取</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取</span></span><br><span class="line">        cur.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$<ul><li>有 $2^n$ 種 subset</li><li>建每一種 subset 需 $O(n)$ time, 因為 <code>i</code> 從 <code>[0, n]</code></li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array, 則只需 $O(n)$<ul><li>$O(n)$：<code>dfs()</code> 遞迴最大深度、<code>cur</code> 中的元素個數</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>90. Subsets II</title>
      <link href="/post/subsets-ii/"/>
      <url>/post/subsets-ii/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 當中的元素可能會重複, 返回所有可能的 subset <code>res</code>。</p><p><strong>注意：</strong><code>res</code> 不能包含重複的 subset, 可以按<strong>順序任意</strong>排列</p></blockquote><p><img src="https://i.imgur.com/Fp3brwo.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 先將 <code>nums</code> 排序（讓相同值的數相鄰）, 然後跟 <a href="https://zako945.github.io/post/subsets/">78. Subsets</a> 一樣</strong></p><ul><li>不一樣的是, <code>res</code> 中不能有重複的 subset</li><li>只是若不取, 則後面跟當前值一樣的數, 都要跳過, 從值不一樣的繼續</li></ul><p>e.g. <code>nums = [1, 2, 2, 3]</code><br>下圖中紅色圈起來的部分, 即是選 1 之後不選 2, 所以後面值為 2 的都要跳過, 下一個從 3 開始取</p><p><img src="https://i.imgur.com/eeaaTX2.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取</span></span><br><span class="line">        cur.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不取</span></span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; n &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot 2^n)$ ➔ $O(n \cdot log(n)) + O(n \cdot 2^n)$<ul><li>$O(n \cdot log(n))$：sorting</li><li>$O(n \cdot 2^n)$：最多 $2^n$ 種 subset, 建每一種 subset 需 $O(n)$ time</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 若不考慮要返回的 array, 則取決於遞迴的最大深度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>130. Surrounded Regions</title>
      <link href="/post/surrounded-regions/"/>
      <url>/post/surrounded-regions/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/surrounded-regions/">https://leetcode.cn/problems/surrounded-regions/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的矩陣 <code>board</code>, 由若干個 char <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>, 找到所有被 <code>&#39;X&#39;</code> 圍繞的區域, 並用 <code>&#39;X&#39;</code> 來替代這些區域裡的 <code>&#39;O&#39;</code>。</p></blockquote><p><img src="https://i.imgur.com/h78wviU.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 題目希望我們找出被 <code>X</code> 包圍的區域, 但我們可以反向思考, 從邊界出發（因為邊界上的 <code>O</code> 一定不會被 <code>X</code> 包圍）, 往內陸延伸找出那些沒有被 <code>X</code> 包圍的區域, 概念同</strong> <a href="https://zako945.github.io/post/pacific-atlantic-water-flow/">417. Pacific Atlantic Water Flow</a><strong>。因此步驟如下：</strong></p><ul><li>找出沒有被 <code>X</code> 包圍的 <code>O</code> 區域, 並把這些區域設為 <code>#</code>（區分是否被 <code>X</code> 包圍）</li><li>遍歷 <code>board</code>, 將 <code>O</code> 設為 <code>X</code>（因為沒被設為 <code>#</code> 的區域就是被 <code>X</code> 包圍的 <code>O</code> 區域）</li><li>遍歷 <code>board</code>, 將 <code>#</code> 設為 <code>O</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(board, i, <span class="number">0</span>); <span class="comment">// left</span></span><br><span class="line">            <span class="built_in">dfs</span>(board, i, n - <span class="number">1</span>); <span class="comment">// right</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(board, <span class="number">0</span>, j); <span class="comment">// top</span></span><br><span class="line">            <span class="built_in">dfs</span>(board, m - <span class="number">1</span>, j); <span class="comment">// bottom</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">replace</span>(board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">out_of_bound</span>(i, j) || board[i][j] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// 將沒有被 X 包圍的 O 設成 #</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(board, i + dirY, j + dirX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_bound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先將被包圍的 O 設成 X</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再將沒被包圍的 # 設成 O</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：$O(m \cdot n)$</strong> ➔ 遍歷 <code>board</code></li><li><strong>space：$O(m \cdot n)$</strong> ➔ 取決於遞迴深度, worse case：整個 <code>board</code> 皆為 <code>&#39;O&#39;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>621. Task Scheduler</title>
      <link href="/post/task-scheduler/"/>
      <url>/post/task-scheduler/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/task-scheduler/">https://leetcode.cn/problems/task-scheduler/</a></strong></p><p><strong>題意：</strong>給一 char array <code>tasks</code> 代表 CPU 須執行的任務 list, 其中每個字母代表一種不同種類的任務, 任務能以任意順序執行, 且每個任務皆可在 1 個單位時間內完成。在任意一個時間單位, CPU 可以選擇完成一個任務 or 處於待命狀態。</p><p>然而, 在兩個<strong>相同種類</strong>的任務之間必須有長度為 <code>n</code> 的冷卻時間。</p><p>計算並返回完成所有任務的<strong>最短時間</strong>。</p><p><strong>注意：</strong><code>tasks[i]</code> 必為<strong>大寫</strong>字母。</p></blockquote><p><img src="https://i.imgur.com/6aS60TV.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Greedy + Heap, 應該處理的出現次數最多的 task, 盡量讓每一輪都能塞滿 <code>n + 1</code> 個 task（因為題目要求最短時間）。盡量先取高頻的 task, 然後再來取低頻的 task, 理由如下：</strong></p><p>若改成優先取那些低頻的 task, 可能會讓低頻的 task 一下就被取完, 導致<strong>剩下的 task 整體的多樣性減少</strong>。當 max heap 中的 task 種類 <code>&lt; n + 1</code>, 但每一輪又要取 <code>n + 1</code>  個時, 就會需要使用 <code>idle</code> 來填補每一輪中剩餘的 task ➔ 這無法滿足題目要求的<strong>最短時間</strong></p><ul><li>每次從 max heap 中取出 <code>n + 1</code> 個不同種類的 task</li><li>若無法從 max heap 取出 <code>n + 1</code> 個 task, 分成兩種情況：<ul><li>非最後一輪, 用 <code>idle</code> 填滿剩餘的 task</li><li>為最後一輪, 則不需用 <code>idle</code> 填滿剩餘的 task（因為沒有下一輪）</li></ul></li><li>將取出的 task 之 <code>cnt -= 1</code>, 若 <code>cnt &gt; 0</code>, 則 push 回 max heap 中</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; tasks, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freqs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : tasks) &#123;</span><br><span class="line">            freqs[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// max heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [ch, num] : freqs) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; bucket; <span class="comment">// 用來暫存這一輪取出的 task 之 cnt - 1</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> num = <span class="built_in">min</span>(n + <span class="number">1</span>, <span class="built_in">int</span>(pq.<span class="built_in">size</span>())); <span class="comment">// 紀錄這一輪取出的 task 個數</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一次從 max heap 中取 num 個 task 放入桶子中, 取出記得 cnt 要減 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">                bucket.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>() - <span class="number">1</span>); <span class="comment">// 紀錄 cnt - 1</span></span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若取出的 task 之 cnt &gt; 0, 則 push 回 max heap 中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; cnt : bucket) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(cnt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 max heap 不為空, 則代表還有下一輪, 那這一輪的桶會是全填滿的狀態</span></span><br><span class="line">            <span class="comment">// 否則, 代表這一輪為最後一輪, 且桶中個數為 num 個(可能不滿 n + 1 個)</span></span><br><span class="line">            res += (pq.<span class="built_in">empty</span>() ? num : n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(len)$ ➔ $O(len) + O(len \cdot log(26))$<ul><li>$O(len)$：遍歷 <code>tasks</code> 每個 char</li><li>$O(len \cdot log(26))$：每一次從 <code>pq</code> 中取 <code>n + 1</code> 個數放入桶子中, 總共取 <code>len</code> 個, 故 <code>pq</code> 要調整 <code>len</code> 次 , 而 <code>pq</code> 中最多 26 個數</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間, 因為 <code>freqs</code> 只需 $O(26)$, 且 <code>bucket</code> 和 <code>pq</code> 最多 $O(26)$</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 假設今天只有一種任務 <code>A</code>, <code>tasks = [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]</code> 且 <code>n = 2</code>, 則最小排列方式為 <code>A _ _ A _ _ A</code>, 其中 <code>A _ _</code> 可看作是一個桶子（長度為 <code>n + 1</code>）, 總共需花費 <code>(3 - 1) x (2 + 1) + 1 = 7</code> 個時間單位, 也就是 <code>(頻率最高任務的次數 - 1) x (n + 1) + 1</code>, 但會有以下情況不適用：</strong></p><ul><li><p><strong>當頻率最高任務次數的任務數不只一個時</strong><br>e.g. <code>tasks = [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]</code>, <code>n = 2</code><br>最小排列方式為 <code>A B _ A B _ A B</code>, 總共需花費 <code>(3 - 1) x (2 + 1) + 2 = 8</code><br>➔ <strong>公式需修改為 <code>(頻率最高任務的次數 - 1) x (n + 1) + (頻率最高任務次數的任務數)</code></strong></p></li><li><p><strong>當中間的間隔不夠其他任務插入時</strong><br>e.g. <code>tasks = [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C&#39;, &#39;D&#39;, &#39;D&#39;]</code>, <code>n = 2</code><br>按照上述公式會得出需花費 <code>(3 - 1) x (2 + 1) + 1 = 7</code><br>但總共有 9 個任務, 根本不可能在 7 個時間單位內完成<br>我們可以在間隔 <code>_ _</code> 後加上其他任務, 因此最小排列方式為 <code>A B C D A B C D A</code><br>➔ <strong>如果 <code>任務個數 &gt; 公式算出的最少時間</code>, 則答案為<code>任務個數</code></strong></p><p>  <img src="https://i.imgur.com/cZ2GHF7.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; tasks, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">freqs</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : tasks) &#123;</span><br><span class="line">            freqs[ch - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出現次數最多的 char (最高任務的次數)</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> maxFreq = *<span class="built_in">max_element</span>(freqs.<span class="built_in">begin</span>(), freqs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出現次數為 maxVal 的個數</span></span><br><span class="line">        <span class="type">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : freqs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == maxFreq) &#123;</span><br><span class="line">                maxCnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>((maxFreq - <span class="number">1</span>) * (n + <span class="number">1</span>) + maxCnt, tasks.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(len)$ ➔ 遍歷 <code>tasks</code></li><li><strong>space：</strong>$O(1)$ ➔ <code>freqs</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98. Validate Binary Search Tree</title>
      <link href="/post/validate-binary-search-tree/"/>
      <url>/post/validate-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></strong></p><p><strong>題意：</strong>給一 BT 的 <code>root</code>, 返回其是否為 BST。</p></blockquote><p><img src="https://i.imgur.com/hCHWtfq.png"></p><p><img src="https://i.imgur.com/9gNOLMq.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 當前 node 必須判斷是否在目前的上、下界中, 因此要不斷維護當前的上、下界。若 node-&gt;val 滿足當前上下界：</strong></p><ul><li>遞迴遍歷 <code>node-&gt;left</code>, 並把 <code>node-&gt;val</code> 設為上界</li><li>遞迴遍歷 <code>node-&gt;right</code>, 並把 <code>node-&gt;val</code> 設為下界</li></ul><p>下圖中雖然 <code>7  &gt; 4</code>, 但它卻位於 <code>5</code> 的左子樹中（此時的 <code>lower = 4</code>, <code>upper = 5</code>）, 故要返回 <code>false</code></p><p><img src="https://i.imgur.com/3laL2XQ.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要用 long 而非 int, 因為若用 int, 當 root = [INT_MAX] 時, 會返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">long</span> lower, <span class="type">long</span> upper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 若 tree 為空樹, 也是合法的 BST</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &lt;= lower || node-&gt;val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當前 node 是合法的, 故遞迴判斷左、右子樹是否合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(node-&gt;left, lower, node-&gt;val) &amp;&amp; </span><br><span class="line">                <span class="built_in">dfs</span>(node-&gt;right, node-&gt;val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>286. Walls and Gates</title>
      <link href="/post/walls-and-gates/"/>
      <url>/post/walls-and-gates/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/walls-and-gates/">https://leetcode.cn/problems/walls-and-gates/</a></strong></p><p><strong>題意：</strong>給一 <code>m × n</code> 的網格 <code>rooms</code>, 其中每個 cell 有三種可能：</p><ul><li><code>1</code> 表示牆 or 障礙物</li><li><code>0</code> 表示門</li><li><code>INF</code> 表示空房間。用 <code>2^31 - 1 = 2147483647</code> 代表 <code>INF</code>。<br>且通往門的距離總是小於 <code>2147483647</code></li></ul><p>返回每個空房間位到<strong>最近門的距離</strong>。如果無法到達門, 則距離設為 <code>INF</code>。</p></blockquote><p><img src="https://i.imgur.com/IhxF72p.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS（因為可能不只一個門）, 以門為起點向外做 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wallsAndGates</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        m = rooms.<span class="built_in">size</span>(), n = rooms[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dist = <span class="number">1</span>; <span class="comment">// 房間離門的最小距離為 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(pii&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bfs</span>(rooms, dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    vector&lt;pii&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms, <span class="type">int</span>&amp; dist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> [y, x] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> r = y + dirY, c = x + dirX;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">out_of_bound</span>(r, c) &amp;&amp; rooms[r][c] == INT_MAX) &#123;</span><br><span class="line">                        rooms[r][c] = dist;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(pii&#123;r, c&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_bound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>space：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>rooms</code></li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>q</code> 中元素個數不超過 <code>m * n</code>, worse case：<code>rooms</code> 元素皆為 0</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79. Word Search</title>
      <link href="/post/word-search/"/>
      <url>/post/word-search/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/word-search/">https://leetcode.cn/problems/word-search/</a></strong></p><p><strong>題意：</strong>給一 <code>m x n</code> 的網格 <code>board</code> 和一 string <code>word</code>, 求 <code>word</code> 是否出現在 <code>board</code> 中。</p><p>其中, <code>board</code> 和 <code>word</code> 僅由大小寫英文字母所組成</p><p><strong>注意：</strong>必須按照 <code>word</code> 中字母的順序, 並通過相鄰的 cell 所構成, 其中相鄰是指水平相鄰 or 垂直相鄰, 且同一位置的 cell 不允許被重複使用。</p></blockquote><p><img src="https://i.imgur.com/BMKYeN9.png"></p><p><img src="https://i.imgur.com/nYhEf4S.png"></p><p><img src="https://i.imgur.com/apterok.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 要記得將已拜訪過的 node 設為已拜訪, 避免重複拜訪</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依序把 board[i][j] 作為起始點來探索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, i, j, word, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, <span class="type">const</span> string&amp; word, <span class="type">const</span> <span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">out_of_bound</span>(i, j) || board[i][j] != word[idx]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// word 的最後一個 char 有被找到(前面的也都有被找到, idx 才會執行到最後一個)</span></span><br><span class="line">        <span class="keyword">if</span> (idx == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> ch = board[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 (i, j) 標記為已拜訪, 避免重複拜訪</span></span><br><span class="line">        <span class="comment">// 本題 word 中的 char 皆為英文字母, 故這邊設為數字</span></span><br><span class="line">        <span class="comment">// 這樣下方的 dfs 若走到拜訪過的位置必和 word[idx] 不相等, 並返回 false</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dirY, dirX] : dirs) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> r = i + dirY, c = j + dirX;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, r, c, word, idx + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = ch; <span class="comment">// 還原</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_bound</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == m || j &lt; <span class="number">0</span> || j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot 4^L)$ ➔ for loop 中每個 <code>board[i][j]</code> 都要執行 dfs, 其中 $L$ 為 <code>word</code> 的長度<ul><li>$O(m \cdot n)$：<code>exist()</code> 中的 for loop</li><li>$O(4^L)$：<code>dfs()</code> 的 worse case, <code>word[idx]</code> 每次都有四個方向要探索, 故為 $4^L$</li></ul></li><li><strong>space：</strong>$O(L)$ ➔ 最大遞迴深度, 受限於 $L$, 因為 <code>if (idx == word.size() - 1)</code> 為中止條件</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/post/add-two-numbers/"/>
      <url>/post/add-two-numbers/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></strong></p><p><strong>題意</strong>：給兩個<strong>非空</strong> linked list 表示兩個非負整數, 每位數字都是按照<strong>逆序</strong>（e.g. 個位數在前, 十位數在後）儲存的, 且每一個 node 只能存一位數字。請將兩數相加, 並以相同型式返回和的 linked list。</p><p>除了數字 0 以外, 其他數字都不會以 0 作為開頭。</p></blockquote><p><img src="https://i.imgur.com/ICc2d6B.png"></p><p><img src="https://i.imgur.com/9nnmNaL.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution</strong>：</h2><blockquote><p><strong>想法：用 dummy 記住新的 linked list 開頭, tail 用來更新新的 linked list 之尾端。除此之外, 還要考慮進位(carry bit)和以下特殊情況</strong>：</p><ul><li><p><strong>兩個整數長度不一（e.g. <code>123</code> + <code>4567</code>）</strong><br>➔ 當 <code>node</code> 為 <code>NULL</code> 時, 把 <code>node-&gt;val</code> 設為 <code>0</code></p></li><li><p><strong>進位導致輸出比原本最長整數還長（e.g. <code>1</code> + <code>99</code> &#x3D; <code>100</code>）</strong><br>➔ loop 終止條件須判斷 carry bit 是否為 0</p><p>  <img src="https://i.imgur.com/atRCQf4.png"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *tail = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 ptr, 若 ptr 為 null, 則不能用 ptr-&gt;next, 而是直接設成 null</span></span><br><span class="line">            l1 = l1 ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(max(m,n))$ ➔ while loop 終止是取決最長的 linked list 長度</li><li><strong>space：</strong>$O(max(m,n))$ ➔ 新的 linked list 長度取決於最長的 linked list 長度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138. Copy List with Random Pointer</title>
      <link href="/post/copy-list-with-random-pointer/"/>
      <url>/post/copy-list-with-random-pointer/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></strong></p><p><strong>題意：</strong>給一長度為 <code>n</code> 的 linked list, 每個節點包含一個額外增加的隨機 pointer <code>random</code>, 該 pointer 可以指向 linked list 中的任何節點 or 空節點。</p><p>建構該 linked list 的 deep copy, 它由 <code>n</code> 個新節點組成, 其中每個新節點的值都設為其對應的 <code>node.val</code>。</p><p>新節點的 <code>next</code> 和 <code>random</code> 也都應指向新 linked list 中的其他節點, 使原 linked list 和新 linked list 能夠表示成相同的 linked list。</p><p>e.g. 如果原 linked list 中有 <code>X</code> 和 <code>Y</code> 兩個節點, 其中 <code>X.random --&gt; Y</code>。則新 linked list 中對應的兩個節點 <code>x</code> 和 <code>y</code>, 同樣有 <code>x.random --&gt; y</code>。</p><p>返回新 linked list 的 <code>head</code>。</p></blockquote><p><img src="https://i.imgur.com/pfPzZ9u.png"></p><p><img src="https://i.imgur.com/a0gJl5X.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table, 先遍歷原 linked list, 並在遍歷的同時不斷創建新節點, 將 <code>原節點</code> 作為 <code>key</code>、<code>新節點</code> 作為 <code>value</code> 放入 hash table 中。最後, 再遍歷一次原 linked list, 並設置新 linked list 的 <code>next</code> 和 <code>random</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        Node *cur = head;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; oldToNew; <span class="comment">// &#123;old, new&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            oldToNew[cur] = newNode;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            oldToNew[cur]-&gt;next = oldToNew[cur-&gt;next];</span><br><span class="line">            oldToNew[cur]-&gt;random = oldToNew[cur-&gt;random];</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldToNew[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list</li><li><strong>space：</strong>$O(n)$ ➔ <code>oldToNew</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：分成三個步驟</strong></p><ul><li>根據遍歷到的原節點來創建對應的新節點, 並把每個新節點放在原節點後面<br>e.g. <code>1 -&gt; 1&#39; -&gt; 2 -&gt; 2&#39; -&gt; 3 -&gt; 3&#39;</code></li><li>設置新節點的 <code>random</code><br>➔ 新節點的 <code>random</code> 為原節點的 <code>random-&gt;next</code> (原 <code>random</code> 對應的新節點)</li><li>將兩個 linked list 分開</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根據遍歷到的原節點來創建對應的新節點, 並把每個新節點放在原節點後面</span></span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            newNode-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            cur = newNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 設置新節點的 random</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="comment">// 不用判斷 cur-&gt;next 是否為 null, 是因為 cur 為原 linked list 的節點</span></span><br><span class="line">            <span class="comment">// cur-&gt;next 為對應的新節點, 在 cur != null 的前提下, cur-&gt;next 必不為 null</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;random) &#123;</span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將兩個 linked list 分開</span></span><br><span class="line">        cur = head;</span><br><span class="line">        Node *dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>), *tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            tail-&gt;next = cur-&gt;next; <span class="comment">// 將新節點加到新 linked list</span></span><br><span class="line">            tail = tail-&gt;next; <span class="comment">// 更新 tail</span></span><br><span class="line">            cur-&gt;next = tail-&gt;next; <span class="comment">// 將 cur 指向下一個原 linked list 的 node</span></span><br><span class="line">            cur = cur-&gt;next; <span class="comment">// 將 cur 更新成下一個原 linked list 的 node</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要 copy 的 node, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>287. Find the Duplicate Number</title>
      <link href="/post/find-the-duplicate-number/"/>
      <url>/post/find-the-duplicate-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-the-duplicate-number/">https://leetcode.cn/problems/find-the-duplicate-number/</a></strong></p><p><strong>題意</strong>：給一有 <code>n + 1</code> 個數的 array <code>nums</code>, 每個元素值皆在 <code>[1, n]</code>, 剛好<strong>只有一數字重複</strong>, 求重複的數字。</p><p><strong>注意</strong>：只能使用 $O(1)$ space, 且<strong>不能改變</strong> <code>nums</code></p><p><strong>進階</strong>：設計 $O(n)$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/GNc82JD.png"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1</strong>：</h2><blockquote><p><strong>想法：利用 Binary Search, 先在 <code>[1, n]</code> 中找中點 <code>mid</code>, 然後判斷整個 <code>nums</code> 中 <code>≤ mid</code> 的元素個數 <code>cnt</code>。若 <code>cnt &gt; mid</code> 代表有重複, 則往左繼續找</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不要考慮 nums, 只需要考慮數字都在 1 到 n 之間</span><br><span class="line">nums = [1,3,4,2,2] 此時數字在 1 到 4 之間</span><br><span class="line"></span><br><span class="line">mid = (1 + 4) / 2 = 2, nums 中 ≤ 2 的有3個(1,2,2), 1到2中肯定有重複, 往左搜尋 ➔ right = 2</span><br><span class="line">mid = (1 + 2) / 2 = 1, nums 中 ≤ 1 的有1個(1), 2到2中肯定有重複, 往右搜尋</span><br><span class="line">➔ left = 2, left &lt; right 不成立</span><br><span class="line">➔ 所以重複的數是 2</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; mid) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$<ul><li>$O(log(n))$：Binary Search, while loop 得做 $O(log(n))$ 次</li><li>$O(n)$：while loop 每迭代一次, for loop 都得遍歷 <code>nums</code></li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：將此問題轉換成 linked list cyle, 利用 slow &amp; fast pointers 找出 cycle 的起點, 可參考 142. Linked List Cycle II</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [1,3,4,2,2]</span><br><span class="line"></span><br><span class="line">第一個 0 代表從 idx = 0 開始</span><br><span class="line">下一個移動到 nums[0] = 1</span><br><span class="line">下一個移動到 nums[1] = 3, 依此類推</span><br><span class="line">因為有重複數, 代表會有兩個數指向同一個數 e.g. nums[3] 和 nums[4] 都指向 nums[2] = 4</span><br><span class="line">0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2, cycle: 2-&gt;4-&gt;2</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/65xJ87D.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 slow 和 fast 相遇的點</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 cycle 的起點</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>235. Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="/post/lowest-common-ancestor-of-a-binary-search-tree/"/>
      <url>/post/lowest-common-ancestor-of-a-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></strong></p><p><strong>題意：</strong>給一 BT 和兩個節點 <code>p</code>, <code>q</code>, 求兩節點之<strong>最低共同祖先(LCA)</strong></p></blockquote><p><img src="https://i.imgur.com/aMLdW4p.png"></p><p><img src="https://i.imgur.com/wS3XAZv.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS 和 BST 的性質, 找到一 node 滿足 <code>node.val</code> 介於 <code>p</code>、<code>q</code> 之間</strong></p><ul><li><code>p-&gt;val ≤ node.val ≤ q-&gt;val</code> 或</li><li><code>q-&gt;val ≤ node.val ≤ p-&gt;val</code></li></ul><p><strong>BST 性質:</strong></p><ul><li><code>root</code> 左子樹中所有 <code>node.val</code> 皆小於 <code>root.val</code></li><li><code>root</code> 右子樹中所有 <code>node.val</code> 皆大於 <code>root.val</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123; <span class="comment">// 當前 root 太小</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123; <span class="comment">// 當前 root 太大</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 當前 root-&gt;val 介於 p、q 之間, 故返回 root</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, 遞迴深度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146. LRU Cache</title>
      <link href="/post/lru-cache/"/>
      <url>/post/lru-cache/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a></strong></p><p><strong>題意：</strong>設計並實現一個滿足 <strong>LRU（Least Recently Used）</strong>的資料結構。</p><p><strong>實現 <code>LRUCache</code> class：</strong></p><ul><li><code>LRUCache(int capacity)</code>：以 <code>capacity</code> 初始化 LRU cache 的大小。</li><li><code>int get(int key)</code>：若 <code>key</code> 存在於 cache 中, 則返回其對應的 <code>val</code>, 否則返回 <code>1</code>。</li><li><code>void put(int key, int value)</code>：<ul><li>若 <code>key</code> 已經存在, 則變更其 <code>value</code></li><li>若不存在, 則將該組 <code>key-value</code> insert 到 cache 中</li><li>若 insert 操作導致 pair 數量超過 <code>capacity</code>, 則移除最久未使用的 <code>key-value</code> pair</li></ul></li></ul><p><strong>注意：</strong><code>get()</code> 和 <code>put()</code> 必須是 $O(1)$ time</p></blockquote><p><img src="https://i.imgur.com/xxJOpVQ.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution</strong>：</h2><blockquote><p><strong>想法：利用 hash table + list, 其中 <code>cache</code> 用來存放所有的 <code>key</code>, 用來記錄哪個 <code>key</code> 最近被使用、最久沒被使用。用 list 而非 forward_list 的原因是：「當 <code>get()</code> 訪問的是處於中間位置的節點時, 可以直接獲取其前一個節點和後一個節點, 從而省去了遍歷整個 linked list的時間」。若用 forward_list, 要獲取前一個節點和後一個節點必須從 linked list 的 head 開始遍歷</strong></p><ul><li><code>cache.begin()</code> : 最久未用的 key</li><li><code>--cache.end()</code> : 最近使用的 key</li></ul><p><strong>而 <code>key2val</code> 和 <code>key2iter</code> 分別存放 <code>key</code> 所對應到的 <code>val</code> 和 <code>iterator</code></strong></p><ul><li><strong><code>get(key)</code> :</strong><ul><li>若 <code>key</code> 已在 <code>cache</code> 中, 則將其放到 <code>cache</code> 尾部</li><li>若 <code>key</code> 不在 <code>cache</code> 中, 則返回 <code>1</code></li></ul></li><li><strong><code>put(key, value)</code> :</strong><ul><li>若 <code>key</code> 已在 <code>cache</code> 中, 則更新其對應的 val</li><li>若 <code>key</code> 不在 <code>cache</code> 中, 則要新增該 key。若 <code>capacity</code> 已滿, 則要移除 <code>cache.begin()</code></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        capacity_ = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若 cache 已存在該 key, 則將其放到 cache 尾部</span></span><br><span class="line">        <span class="keyword">if</span> (key2val.<span class="built_in">find</span>(key) != key2val.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = key2val[key];</span><br><span class="line">            <span class="keyword">auto</span> it = key2iter[key];</span><br><span class="line">            cache.<span class="built_in">erase</span>(it);</span><br><span class="line">            cache.<span class="built_in">push_back</span>(key);</span><br><span class="line">            key2iter[key] = --cache.<span class="built_in">end</span>();</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// key not found</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cache 已存在該 key, 則更新其對應的 val</span></span><br><span class="line">        <span class="comment">// 直接調用 get(key), 若存在 key, 則 get 會將其放到 cache 尾端, 然後更新 val 即可</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(key) != <span class="number">-1</span>) &#123;</span><br><span class="line">            key2val[key] = value;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// key 已存在, 因此 put 後 size 不變, 不會超過 cap, 所以直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache 不存在該 key, 則要新增該 key</span></span><br><span class="line">        <span class="comment">// 若 cache 已滿, 則要先移除 cache.begin()</span></span><br><span class="line">        <span class="keyword">if</span> (key2val.<span class="built_in">size</span>() == capacity_) &#123;</span><br><span class="line">            <span class="type">int</span> keyDel = *cache.<span class="built_in">begin</span>();</span><br><span class="line">            cache.<span class="built_in">erase</span>(cache.<span class="built_in">begin</span>());</span><br><span class="line">            key2val.<span class="built_in">erase</span>(keyDel);</span><br><span class="line">            key2iter.<span class="built_in">erase</span>(keyDel);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cache.<span class="built_in">push_back</span>(key);</span><br><span class="line">        key2val[key] = value;</span><br><span class="line">        key2iter[key] = --cache.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity_;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; cache; <span class="comment">// 存放 &quot;key&quot; 的 list</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; key2val; <span class="comment">// &#123;key, val&#125;</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;::iterator&gt; key2iter; <span class="comment">// &#123;key, iterator&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$</li><li><strong>space：</strong>$O(capacity)$ ➔ <code>cache</code>, <code>key2val</code>, <code>key2iter</code> 的元素個數不超過 <code>capacity</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/post/remove-nth-node-from-end-of-list/"/>
      <url>/post/remove-nth-node-from-end-of-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></strong></p><p><strong>題意：</strong>給一 linked list, 請刪除倒數第 <code>n</code> 個 node, 並返回 linked list 的 head。</p><p><strong>進階：</strong>試著用一次掃描就完成。</p></blockquote><p><img src="https://i.imgur.com/o9Lnn8T.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 slow &amp; fast pointers, 用 <code>dummy</code> 是因為有可能第一個 node 被刪, 所以需要有 ptr 指著第一個 node 的前一個 node。首先 <code>fast</code> 先從 head 走 <code>n</code> 步（讓 <code>fast</code> 領先）, 然後 <code>slow</code> 才從 <code>dummy</code> 開始往前走, 直到 <code>fast</code> 變成 <code>NULL</code></strong></p><ul><li><strong>為什麼 <code>fast</code> 是初始化為 <code>head</code>, 而 <code>slow</code> 初始化為 <code>dummy</code> ?</strong><br>因為若 <code>fast</code> 和 <code>slow</code> 都初始化為 <code>head</code>, 則當 <code>fast</code> 為 <code>NULL</code> 時, <code>slow</code> 恰好在倒數第 <code>n</code> 個 node(因為 <code>fast</code> 領先 <code>n</code> 步), 但是我們是要<strong>刪除</strong>倒數第 <code>n</code> 個 node, <strong>要取得的是倒數第 <code>n</code> 個 node 的前一個節點</strong>(倒數第 <code>n + 1</code> 的 node), 故讓 slow 在初始化時就慢 <code>fast</code> 一步, 讓 <code>fast</code> 領先 <code>n + 1</code> 步, 這樣 <code>slow</code> 最後才會是倒數第 <code>n + 1</code> 的 node</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *slow = dummy, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(L)$ ➔ 遍歷 linked list, 其中 <code>L</code> 為 linked list 的長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>143. Reorder List</title>
      <link href="/post/reorder-list/"/>
      <url>/post/reorder-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reorder-list/">https://leetcode.cn/problems/reorder-list/</a></strong></p><p><strong>題意：</strong>給一單向 linked list 的起始節點 <code>head</code>, 該 linked list 可表示為</p><p><code>L0 → L1 → … → Ln - 1 → Ln</code></p><p>將其重新排序為</p><p><code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code></p><p>不能只是單純改變節點內部的值, 必須進行實際的節點交換。</p></blockquote><p><img src="https://i.imgur.com/HgeYnkh.png"></p><p><img src="https://i.imgur.com/IblLtsI.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：分成以下步驟</strong></p><ul><li><strong>找到 linked list 的中點, 按照 <a href="https://zako945.github.io/post/linked-list-cycle/">141. Linked List Cycle</a> 的方法</strong><ul><li>奇數時, <code>mid</code> 指向中點</li><li>偶數時, <code>mid</code> 指向右中點</li><li>因此, 最一開始要先讓 <code>fast</code> 先走一步, 這樣不管是奇偶數, <code>mid</code> 都會指向左中點</li></ul></li><li><strong>重要：截斷兩個 list ➔ <code>mid-&gt;next = nullptr</code>（容易忘記這步）</strong></li><li><strong>reverse 右半部分 <code>Ln → Ln - 1 → Ln - 2 → ...</code></strong></li><li><strong>merge 左半和右半</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *mid = <span class="built_in">get_mid</span>(head); <span class="comment">// 得到第一個中點</span></span><br><span class="line">        ListNode *right = mid-&gt;next; <span class="comment">// 得到右半部分</span></span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// **重要** 截斷兩個 list</span></span><br><span class="line">        right = <span class="built_in">reverse</span>(right); <span class="comment">// reverse 右半部分</span></span><br><span class="line">        <span class="built_in">merge</span>(head, right); <span class="comment">// merge 左半和右半</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// // 找到中點; 若為偶數, 則返回第一個中點</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">get_mid</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先讓 fast 先走一步, 這樣偶數時, slow 才會是第一個中點</span></span><br><span class="line">        ListNode *slow = head, *fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *tail = head;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (tail) &#123;</span><br><span class="line">            nxt = tail-&gt;next;</span><br><span class="line">            tail-&gt;next = prev;</span><br><span class="line">            prev = tail;</span><br><span class="line">            tail = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="comment">// 先儲存各自的 next</span></span><br><span class="line">            ListNode *n1 = l1-&gt;next;</span><br><span class="line">            ListNode *n2 = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// l1 下一個指向當前的 l2, 然後 l2 下一個指向 n1</span></span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 各自前進到下一個</span></span><br><span class="line">            l1 = n1;</span><br><span class="line">            l2 = n2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33. Search in Rotated Sorted Array</title>
      <link href="/post/search-in-rotated-sorted-array/"/>
      <url>/post/search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">https://leetcode.cn/problems/search-in-rotated-sorted-array/</a></strong></p><p><strong>題意</strong>: 有一整數 array <code>nums</code> 按升序排列, 其中的值<strong>互不相同</strong>。</p><p>給一<strong>旋轉後</strong>的 array <code>nums</code> 和一整數 <code>target</code>, 如果 <code>nums</code> 中存在 <code>target</code>, 則返回其 index; 否則, 返回 <code>-1</code>。</p><p>請設計 $O(log(n))$ time 的演算法。</p></blockquote><p><img src="https://i.imgur.com/oxWfuYg.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 將 <code>nums</code> 從中間分開成左右兩部分的時候, 一定有一部分是有序的。</strong></p><p><strong>e.g. <code>nums = [4,5,6,7,0,1,2]</code>, 從 <code>6</code> 切割, 可分成 <code>[4,5,6]</code> 和 <code>[7,0,1,2]</code> 兩個部分, 其中左邊 <code>[4,5,6]</code> 是有序的</strong></p><p>因此我們可以在 Binary Search 時查看當前 <code>mid</code> 分割的兩個部分 <code>[left, mid]</code> 和 <code>[mid + 1, right]</code> 中哪個是有序的, 藉此來縮小左邊界 or 右邊界。</p><ul><li>若 <code>target == nums[mid]</code>, 則直接返回 <code>mid</code></li><li>若 <code>[left, mid]</code> 是有序的, 且 <code>target</code> 界於 <strong><code>[nums[left], nums[mid])</code></strong> 間, 則縮小搜索範圍為 <code>[left, mid - 1]</code>; 否則, 縮小搜索範圍為 <code>[mid + 1, right]</code></li><li>若 <code>[mid + 1, right]</code> 是有序的, 且 <code>target</code> 界於 <strong><code>(nums[mid], nums[right]]</code></strong> 間, 則縮小搜索範圍為 <code>[mid + 1, right]</code>; 否則, 縮小搜索範圍為 <code>[left, mid - 1]</code></li></ul><p>當 <code>[left, mid]</code> 區間恰好只有一個元素時, 也滿足左半邊已排序的定義</p><p>e.g. <code>nums = [3, 1]</code>, <code>target = 1</code></p><ul><li><code>left = 0</code>, <code>right = 1</code>, <code>mid = 0</code> ➔ <code>[left, mid]</code> 區間恰好只有一個元素, 使得 <code>nums[left] == nums[mid]</code>, 這時 <code>target</code> 應跟左半邊中的元素比較, 然後才縮小邊界</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 這種特殊的 Binary Search 建議搜到就返回</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左半邊是被排序過的, e.g. [4,5,6,7,0,1,2], mid = 7</span></span><br><span class="line">            <span class="comment">// nums[left] == nums[mid] 也滿足左半邊是排序的定義（有可能 left == mid）</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 因為 target != nums[mid], 故用 &lt; 即可</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右半邊是被排序過的, e.g. [7,0,1,2,4,5,6], mid = 2</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>981. Time Based Key-Value Store</title>
      <link href="/post/time-based-key-value-store/"/>
      <url>/post/time-based-key-value-store/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/time-based-key-value-store/">https://leetcode.cn/problems/time-based-key-value-store/</a></strong></p><p><strong>題意：</strong>設計一個基於時間的 key-value 的資料結構, 它可以在不同 timestamp 儲存對應同一個 key 的多個值, 並針對特定 timestamp 得到相對應的 key 的 value。</p><p>實作 <code>TimeMap</code> class：</p><ul><li><code>TimeMap()</code> : 初始化 instance</li><li><code>void set(String key, String value, int timestamp)</code> : 儲存 <code>key</code>、 <code>value</code>, 以及 <code>timestamp</code>。</li><li><code>String get(String key, int timestamp)</code> :<ul><li>返回 <code>timestamp_prev</code> 對應的 value, 其中 <code>timestamp_prev &lt;= timestamp</code></li><li>如果存在多個值, 則返回對應<strong>最大</strong>的 <code>timestamp_prev</code> 的 value。</li><li>如果不存在, 則返回 <code>&quot;&quot;</code>。</li></ul></li></ul><p><strong>注意:</strong> <code>set(key, value, timestamp)</code> 中的 <code>timestamp</code> 都是嚴格遞增的。</p></blockquote><p><img src="https://i.imgur.com/9V7VWMN.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：題目的意思如下圖, <code>key</code> 裡面會儲存 <code>values</code>, 而 <code>values</code> 裡面可以有多個 <code>&#123;value, timestmap&#125;</code> pair。由於 <code>values</code> 裡面的 <code>timestamp</code> 都是嚴格遞增的(已排序), 所以我們可直接使用 Binary Search</strong></p></blockquote><p><img src="https://i.imgur.com/PdkaQmt.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeMap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeMap</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(string key, string value, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        m[key].<span class="built_in">emplace_back</span>(pair&lt;string, <span class="type">int</span>&gt;&#123;value, timestamp&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(string key, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">find</span>(key) == m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = m[key].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m[key][mid].second &gt; timestamp) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left 為 &gt; timestamp 的位置, 故 left - 1 為 &lt;= timestamp 的位置</span></span><br><span class="line">        <span class="keyword">return</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span>) ? m[key][left - <span class="number">1</span>].first : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt;&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search, 其中 <code>n</code> 為 <code>m[key]</code> 的長度</li><li><strong>space：</strong>$O(n)$ ➔ 其中 <code>n</code> 為 <code>set()</code> 的次數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>853. Car Fleet</title>
      <link href="/post/car-fleet/"/>
      <url>/post/car-fleet/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/car-fleet/">https://leetcode.cn/problems/car-fleet/</a></strong></p><p><strong>題意:</strong> 在一條單行道上, 有 <code>n</code> 輛車開往同一目的地, 目的地是幾英里外的 <code>target</code>。</p><p>給兩個整數 array <code>position</code>、<code>speed</code>, 其中 <code>position[i]</code> 是第 <code>i</code> 輛車的位置, <code>speed[i]</code> 是第 <code>i</code> 輛車的時速(英里&#x2F;小時)。</p><p>一輛車永遠不會超過前面的另一輛車, 但它可以追上去, 並與前車<strong>以相同的速度</strong>緊接著行駛。此時, 我們可忽略這兩輛車之間的距離, 也就是說, 它們被假定處於相同的位置。</p><p><strong>車隊</strong>是一些由行駛在相同位置、具有相同速度的車組成的非空集合。注意, 一輛車也可以是一個車隊。</p><p>即便一輛車在目的地才趕上了一個車隊, 它們仍然會被視作是同一個車隊。</p><p>返回到達目的地的<strong>車隊數量</strong>。</p></blockquote><p><img src="https://i.imgur.com/A0EImP6.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Monotonic（遞減） Stack, 先使用 map 根據 <code>position[i]</code> 「由小到大」排序, 然後依序取出, 並計算 <code>position[i]</code> 到 <code>target</code> 所需的時間。如果當前所需的時間 <code>time ≥ stk.top()</code>, 則代表兩車會合併為一個車隊, 因為離 <code>target</code> 較遠的那輛車所需的時間 <code>stk.top()</code> 較短, 但是道路為單向且不能超車。所以最後抵達 <code>target</code> 的時間會受制於 <code>time</code>。所以一旦 <code>time ≥ stk.top()</code> 就要 <code>stk.pop()</code>, 將兩輛車合併為一個車隊（受限於當前 <code>time</code> 的車隊）, 直到 <code>stk.top() &gt; time</code>, 才能將 <code>time</code> push 到 <code>stk</code> 中。最後, <code>stk</code> 中的元素個數即為車隊數量。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">carFleet</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; position, vector&lt;<span class="type">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ps;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; position.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ps[position[i]] = speed[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">float</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [pos, spd] : ps) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">float</span> time = <span class="built_in">float</span>(target - pos) / spd;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; time &gt;= stk.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">emplace</span>(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>739. Daily Temperatures</title>
      <link href="/post/daily-temperatures/"/>
      <url>/post/daily-temperatures/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></strong></p><p><strong>題意:</strong> 給一整數 array <code>temperatures</code> 代表每天的溫度。請返回 array <code>res</code>, 其中 <code>res[i]</code> 是指對於第 <code>i</code> 天, 下一個更高溫度是出現在幾天後。如果氣溫在這之後都不會升高, 則該位置用 <code>0</code> 來代替。</p></blockquote><p><img src="https://i.imgur.com/NEFqBSZ.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack, 使用 Monotonic（遞減） Stack <code>stk</code> 紀錄 <code>&#123;temperature, idx&#125;</code>, 一旦當前溫度 <code>temperatures[i]</code> 比 <code>stk.top().first</code> 還高, 則不斷將 <code>stk.top()</code> 取出, 並計算 <code>res[idx]</code>, 直到 <code>stk.top().first &gt; temperatures[i]</code> 才把 <code>temperatures[i]</code> push 到 <code>stk</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 若最後 stk 不為空, 則剩餘元素的 res[idx] 皆為 0</span></span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; stk; <span class="comment">// &#123;temperature, idx&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 一旦當前溫度 &gt; top, 則不斷將 top 給 pop 掉, 並計算 res[idx]</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; stk.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [temperature, idx] = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                res[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">emplace</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&#123;temperatures[i], i&#125;); <span class="comment">// push 當前元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>153. Find Minimum in Rotated Sorted Array</title>
      <link href="/post/find-minimum-in-rotated-sorted-array/"/>
      <url>/post/find-minimum-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/</a></strong></p><p><strong>題意</strong>: 給一長度為 <code>n</code> 的 array, 已照升序排列, 經過 1 到 <code>n</code> 次旋轉後得到 input array。</p><p>e.g. <code>nums = [0,1,2,4,5,6,7]</code> 經過變化後可得到:</p><ul><li>若旋轉 <code>4</code> 次, 可得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋轉 <code>7</code> 次, 可得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>給一元素互不相同的 array <code>nums</code>, 已照升序排列, 並進行多次旋轉, 返回 <code>nums</code> 中最小的元素。</p><p><strong>注意</strong>: 請設計 $O(log(n))$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/gSIGk6B.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 根據比較左、中、右三個位置的值來縮小左邊界 or 右邊界, 有以下幾種情況：</strong></p><ul><li><strong>(左 &lt; 中) 且 (中 &lt; 右)</strong>, e.g. <code>[1,2,3,4,5]</code>。代表<strong>沒有旋轉</strong> ➔ min 在左半邊, 故縮小<strong>右</strong>邊界。</li><li><strong>(左 &gt; 中) 且 (中 &lt; 右)</strong>, e.g. <code>[5,1,2,3,4]</code>。代表<strong>有旋轉</strong> ➔ min 在左半邊, 故縮小<strong>右</strong>邊界</li><li><strong>(左 &lt; 中) 且 (中 &gt; 右)</strong>, e.g. <code>[2,3,4,5,1]</code>。代表<strong>有旋轉</strong> ➔ min 在右半邊, 故縮小<strong>左</strong>邊界</li><li><strong>(左 &gt; 中) 且 (中 &gt; 右)</strong>, e.g. <code>[5,4,3,2,1]</code>。單調遞減, 本題不可能出現此種情形, 因為遞增的 array 再怎麼轉也不可能變遞減的</li></ul><p>分析前面三種可能的情況, 我們選擇比較<strong>中、右</strong></p><p>➔ 因為這樣可將情況 1、2 是視作一類（中 &lt; 右, 縮小右邊界）, 而情況 3 視作另一類（中 &gt; 右, 縮小左邊界）</p><p><img src="https://i.imgur.com/uuP4Hbh.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>]; <span class="comment">// 初始值設 array 的第一個元素</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            res = <span class="built_in">min</span>(res, nums[mid]); <span class="comment">// 更新最小值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>875. Koko Eating Bananas</title>
      <link href="/post/koko-eating-bananas/"/>
      <url>/post/koko-eating-bananas/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/koko-eating-bananas/">https://leetcode.cn/problems/koko-eating-bananas/</a></strong></p><p><strong>題意:</strong> Koko 喜歡吃香蕉。這里有 <code>n</code> 堆香蕉, 第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警衛已經離開了, 並且將在 <code>h</code> 小時後回來。</p><p>Koko 可以決定她吃香蕉的速度 <code>k</code> （單位：根 &#x2F; 小時）。每個小時, 她將會選擇其中一堆的香蕉, 並從中吃掉 <code>k</code> 根。如果這堆香蕉少於 <code>k</code> 根, 她將吃掉這堆所有的香蕉, 然後這一小時內都不會再吃更多的香蕉。  </p><p>Koko 喜歡慢慢吃, 但仍然想在警衛回來前吃掉所有的香蕉。</p><p>返回她可以在 <code>h</code> 小時內吃掉所有香蕉的最小速度 <code>k</code>, 其中 <code>k</code> 為整數。</p></blockquote><p><img src="https://i.imgur.com/8vBcc5O.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 其中 <code>k</code> 的區間為 <code>[1,  max(piles)]</code>, 因為 Koko 吃掉該堆所有的香蕉後, 這一小時內都不會再吃更多的香蕉, 所以 <code>k</code> 取到 <code>max(piles)</code> 即可。此外, <code>left</code> 不能為 <code>0</code>, 否則 <code>mid</code> 有可能為 <code>0</code>, 這會導致計算 <code>time += ceil(1.0 * pile / mid)</code> 時發生錯誤</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = *<span class="built_in">max_element</span>(piles.<span class="built_in">begin</span>(), piles.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// speed</span></span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> cost = <span class="number">0</span>; <span class="comment">// 加總有可能會 overflow, 故取 long</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; pile : piles) &#123;</span><br><span class="line">                cost += <span class="built_in">ceil</span>(<span class="number">1.0</span> * pile / mid); <span class="comment">// 先轉成 float 再運算, 最後取 ceiling</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cost &lt;= h) &#123; <span class="comment">// 速度過快, 往左區間繼續搜尋</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(m))$ ➔ 其中 <code>n</code> 為 <code>piles</code> 的長度, <code>m</code> 為 <code>piles</code> 中的最大值<ul><li>$O(log(m))$ : Binary Search 的次數</li><li>$O(n \cdot log(m))$ : 每一次 Binary Search 皆須 $O(n)$, 因為計算出 mid 後, 皆須遍歷 <code>piles</code></li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>74. Search a 2D Matrix</title>
      <link href="/post/search-a-2d-matrix/"/>
      <url>/post/search-a-2d-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址: <a href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></strong></p><p><strong>題意</strong>: 設計一高效演算法來搜索 <code>m x n</code> matrix 中是否存在整數 <code>target</code>, matrix 滿足以下特性:</p><ul><li>每列的元素由左到右按升序排列</li><li>每列的第一個元素 &gt; 前一列的最後一個元素</li></ul></blockquote><p><img src="https://i.imgur.com/1iXww8t.png"></p><p><img src="https://i.imgur.com/PJveiV8.png"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, <code>matrix</code> 其實就是 1D 已排序的 array, 只是改成用 2D array 表達而已, 故將 <code>matrix</code> 看成 1D array, 然後還原回 2D array 座標來做 Binary Search</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matrix[mid / n][mid % n] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left &lt; m * n &amp;&amp; matrix[left / n][left % n] == target) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(mn))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/post/trapping-rain-water/"/>
      <url>/post/trapping-rain-water/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></strong></p><p><strong>題意：</strong>給 <code>n</code> 個非負整數, 代表每個寬度為 <code>1</code> 的柱子之高度圖, 計算按此排列的柱子, 在下雨後能接多少雨水。</p></blockquote><p><img src="https://i.imgur.com/YA2gsx4.png" alt="Untitled"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用暴力法, 我們計算每個 col 所能接住的水量, 因此對於每個 <code>i</code> 我們要在 <code>height[0 ~ i]</code> 和 <code>height[i ~ (n - 1)]</code> 中分別找出最大值 <code>leftMax</code> 和 <code>rightMax</code>, 則該 col 所能接住的水量 &#x3D; <code>min(leftMax, rightMax) - height[i]</code></strong></p><p><img src="https://i.imgur.com/uRPc5KE.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = height.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> leftMax = *<span class="built_in">max_element</span>(it, it + i + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> rightMax = *<span class="built_in">max_element</span>(it + i, it + n);</span><br><span class="line">            res += <span class="built_in">min</span>(leftMax, rightMax) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ 每計算一次需找出 <code>leftMax</code> 和 <code>rightMax</code>, 此過程需 $O(n)$, 總共要計算 <code>n</code> 次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 概念同 Solution 1, 只是我們用兩個 array <code>leftMax</code> 和 <code>rightMax</code> 來記錄, 其中 <code>leftMax[i]</code> 和 <code>rightMax[i]</code> 分別代表 <code>height[0 ~ i]</code> 和 <code>height[(n - 1) ~ i]</code> 之最大值</strong></p><ul><li>由左往右遍歷 <code>height</code> 得到每一個 <code>leftMax[i]</code></li><li>由右往左遍歷 <code>height</code> 得到每一個 <code>rightMax[i]</code></li><li>最後計算每個 col 所能接住的雨水</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(n, height.front())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(n, height.back())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            leftMax[i] = <span class="built_in">max</span>(height[i], leftMax[i - <span class="number">1</span>]);</span><br><span class="line">            rightMax[n - <span class="number">1</span> - i] = <span class="built_in">max</span>(height[n - <span class="number">1</span> - i], rightMax[n - i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res += <span class="built_in">min</span>(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>leftMax</code>, <code>rightMax</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers, 改進 Solution 2, 因為 <code>leftMax[i]</code> 和 <code>rightMax[i]</code> 只會用到一次, 然後就再也不會用到了, 因此我們用一個變數記住即可。我們定義以下變數：</strong></p><ul><li><code>leftMax</code>：左邊的最大值, 它是由左往右遍歷得到的</li><li><code>rightMax</code>：右邊的最大值, 它是由右往左遍歷得到的</li><li><code>left</code>：由左往右處理的當前 idx</li><li><code>right</code>：由右往左處理的當前 idx</li></ul><p><strong>我們有以下定理可使用：</strong></p><ul><li><p><strong>定理一</strong>：在 <code>idx = i</code> 時能接住的水量是取決於左右兩邊的最大值中<strong>較小</strong>的那一個</p></li><li><p><strong>定理二</strong>：</p><ul><li>當我們由左往右處理到 <code>left</code> 時, 左邊的最大值 <code>leftMax</code> 對它而言是可信的, 但 <code>rightMax</code> 對它而言是不可信的</li><li>當我們由右往左處理到 <code>right</code> 時, 右邊的最大值 <code>rightMax</code> 對它而言是可信的, 但 <code>leftMax</code> 對它而言是不可信的</li></ul><p>  <img src="https://i.imgur.com/qwYcmK4.png" alt="Untitled"></p></li></ul><p><strong>由上述定理, 我們可以得到：</strong></p><ul><li>對於 <code>left</code> 而言, 它左邊最大值一定是 <code>leftMax</code>, 就算 <code>右邊實際最大值 ≥ rightMax</code>, 只要 <code>leftMax &lt; rightMax</code> 成立, 就能知道 <code>left</code> 能接住多少水(<strong>定理一</strong>), 無論右邊將來是否會出現更大的 <code>rightMax</code>, 都不會影響到這個結果。反之, <code>right</code> 也是同樣道理。</li></ul><p><strong>while loop 的條件為何是 <code>left &lt;= right</code>, 而非 <code>left &lt; right</code> ?</strong></p><p>因為是先計算當前 ptr, 再移動 ptr 的</p><p>e.g. <code>height = [1, 0, 3]</code></p><ul><li>一開始 <code>leftMax(0) &lt; rightMax(0)</code> 不成立, 故處理 <code>right</code> ➔ 得 <code>rightMax = 3</code>, <code>res = 0</code>, <code>right = 1</code></li><li><code>leftMax(0) &lt; rightMax(3)</code> 成立, 故處理 <code>left</code> ➔ 得 <code>leftMax = 1</code>, <code>res = 0</code>, <code>left = 1</code></li><li>此時, <code>left = 1 = right</code>, 若 while loop 條件為 <code>left &lt; right</code>, 則無法計算到 <code>idx = 1</code> 位置的水量</li><li><code>leftMax(1) &lt; rightMax(3)</code>成立, 故處理 <code>left</code> ➔ 得 <code>leftMax = 1</code>, <code>res = 1</code>, <code>left = 2</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                leftMax = <span class="built_in">max</span>(leftMax, height[left]); <span class="comment">// 得到左邊最大值(含自身)</span></span><br><span class="line">                res += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightMax = <span class="built_in">max</span>(rightMax, height[right]); <span class="comment">// 得到右邊最大值(含自身)</span></span><br><span class="line">                res += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>height</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/post/3sum/"/>
      <url>/post/3sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 返回 <code>nums</code> 是否存在 <code>[nums[i], nums[j], nums[k]]</code>, 使得 <code>nums[i] + nums[j] + nums[k] == 0</code>, 其中 <code>i != j</code>, <code>i != k</code> 且 <code>j != k</code>。</p><p><strong>注意：</strong>答案中不可包含重複的 tuple。</p></blockquote><p><img src="https://i.imgur.com/yeEmHb3.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers</strong></p><ul><li><p>首先, 將 <code>nums</code> 由小到大做<strong>排序</strong></p><ul><li>用來避免取重複的 tuple, 並可使用 two pointer 來移動 ptr</li></ul></li><li><p>用 <code>i</code> 遍歷 <code>index = [0, n - 3]</code>, 得到 <code>nums[i]</code></p><ul><li>為了避免第一次取到與上一輪相同的元素，我們需要在這裡進行一次判斷並跳過</li><li>使用 Two pointer <code>left = i + 1</code>, <code>right = n - 1</code> 尋找滿足條件的 pair</li><li>若 <code>sum &lt; 0</code> : 則 <code>left + 1</code></li><li>若 <code>sum &gt; 0</code> : 則 <code>right - 1</code></li><li>若 <code>sum == 0</code> : 則將 tuple 加入到 <code>res</code> 中，由於還要檢查剩餘的元素中是否有滿足條件的。因此在加入 tuple 後，<code>left</code> 和 <code>right</code> 都需要跳過與當前元素相同的值</li></ul></li><li><p>注意：答案中不可包含重複的 tuple</p><ul><li>對於第一個元素，我們在判斷時已經確保不會與上一輪相同</li><li>對於第二和第三個元素，在加入 <code>res</code> 後，我們繼續遍歷剩餘元素時，需要判斷是否與上一個元素相同，如果相同則跳過</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// skip duplicates for the second element</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// skip duplicates for the third element</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// move pointers to the next elements with different values</span></span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ $O(n \cdot log(n))$ + $O(n^2)$<ul><li>$O(n \cdot log(n))$ : 排序 <code>nums</code></li><li>$O(n^2)$ : for loop 需 $O(n)$, 其中每一個元素用 two ptr 遍歷剩餘元素需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮 output array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>637. Average of Levels in Binary Tree</title>
      <link href="/post/average-of-levels-in-binary-tree/"/>
      <url>/post/average-of-levels-in-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 Binary Tree(BT), 計算每一層的平均值。</p></blockquote><p><img src="https://i.imgur.com/I7IRJWJ.png" alt="Untitled"></p><p><img src="https://i.imgur.com/cZP2nAa.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於樹的高度, worse case 為 skew tree, tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>844. Backspace String Compare</title>
      <link href="/post/backspace-string-compare/"/>
      <url>/post/backspace-string-compare/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/backspace-string-compare/">https://leetcode.cn/problems/backspace-string-compare/</a></strong></p><p><strong>題意：</strong>給兩個 string <code>s</code>, <code>t</code>, 其中的 <code>#</code> 代表 <code>退格(backspace)字元</code>, 求兩字串是否相等。</p></blockquote><p><img src="https://i.imgur.com/DvHelFY.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 two pointers, 其中 <code>slowindex</code> 負責 in-place 記錄新的 string, 而 <code>fastindex</code> 負責遍歷整個 string</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(s) == <span class="built_in">build</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">string <span class="title">build</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> slowindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fastindex = <span class="number">0</span>; fastindex &lt; s.<span class="built_in">size</span>(); ++fastindex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[fastindex] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                slowindex = <span class="built_in">max</span>(<span class="number">0</span>, --slowindex);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s[slowindex++] = s[fastindex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(<span class="number">0</span>, slowindex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code>, 其中 m 為 <code>s</code> 之長度, <code>n</code> 為 <code>t</code> 之長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110. Balanced Binary Tree</title>
      <link href="/post/balanced-binary-tree/"/>
      <url>/post/balanced-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 判斷它是否 <strong>height-balanced</strong>。</p><p><strong>height-balanced 的定義：</strong>BT 中每個 node 的左、右子樹的高度差不超過 1。</p></blockquote><p><img src="https://i.imgur.com/iNX9uVN.png" alt="Untitled"></p><p><img src="https://i.imgur.com/jCJucay.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 如果當前 node 的左、右子樹的高度差不超過 1, 且左、右子樹皆為 height-balanced, 則返回 true</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span></span><br><span class="line">            &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 BT 中所有 node</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case : BT 為 skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link href="/post/best-time-to-buy-and-sell-stock/"/>
      <url>/post/best-time-to-buy-and-sell-stock/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></strong></p><p><strong>題意：</strong>給一 array <code>prices</code>, 從左到右分別是每天的股票價格, 求如何買賣可以獲得最大的利潤。</p><p><strong>注意：</strong>買入的天數必須在賣出的天數之前。</p></blockquote><p><img src="https://i.imgur.com/oGeonr9.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 紀錄前 <code>i - 1</code> 天的最大利潤、最小價格, 然後計算第 <code>i</code> 天的利潤並比較</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 紀錄前 (i - 1) 天的最大利潤</span></span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>];<span class="comment">// 紀錄前 (i - 1) 天的最小價格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - minPrice);</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>prices</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>704. Binary Search</title>
      <link href="/post/binary-search/"/>
      <url>/post/binary-search/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></strong></p><p><strong>題意：</strong>給一已排序的整數 array <code>nums</code>, 用 binary search 找出 <code>nums</code> 中是否存在 <code>target</code>。若存在, 則返回該元素的 idx；否則, 返回 <code>-1</code>。</p></blockquote><p><img src="https://i.imgur.com/ZzNPVSo.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 找到 left 為第一個 <code>≥ target</code> 的數。若 <code>left</code> 越界 or <code>nums[left] != target</code>, 則代表 <code>target</code> 不存在於 <code>nums</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 當 nums 中所有的元素都比 target 小 (target 不存在), left 會越界 (left = n)</span></span><br><span class="line">        <span class="comment">// 所以在存取 nums[left] 前, 要先判斷 left 是否越界, 否則存取會出錯</span></span><br><span class="line">        <span class="keyword">return</span> (left &lt; n &amp;&amp; nums[left] == target) ? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70. Climbing Stairs</title>
      <link href="/post/climbing-stairs/"/>
      <url>/post/climbing-stairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></strong></p><p><strong>題意：</strong>今天有 <code>n</code> 階樓梯要爬, 每一次你可以選擇要爬 1階 or 2階, 求總共有幾種不同的爬法。</p></blockquote><p><img src="https://i.imgur.com/345Jp3i.png" alt="Untitled"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用遞迴求解</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>time complexity 證明：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(n) = <span class="built_in">T</span>(n - <span class="number">1</span>) + <span class="built_in">T</span>(n - <span class="number">2</span>) + c</span><br><span class="line">     &lt;= <span class="number">2</span>T(n - <span class="number">1</span>) + c, 取 upper bound <span class="built_in">T</span>(n - <span class="number">2</span>) &lt;= <span class="built_in">T</span>(n - <span class="number">1</span>)</span><br><span class="line">      = <span class="number">2</span>*(<span class="number">2</span>T(n - <span class="number">2</span>) + <span class="number">1</span>) + (<span class="number">1</span> * c)</span><br><span class="line">      = <span class="number">4</span>T(n - <span class="number">2</span>) + (<span class="number">2</span> * c)</span><br><span class="line">      = <span class="number">8</span>T(n - <span class="number">3</span>) + (<span class="number">3</span> * c)</span><br><span class="line">      = <span class="number">2</span>^k * <span class="built_in">T</span>(n - k) + (<span class="number">2</span>^k * c)</span><br><span class="line"></span><br><span class="line">令 k = n , <span class="built_in">T</span>(<span class="number">0</span>) = <span class="number">1</span></span><br><span class="line"><span class="built_in">T</span>(n) &lt;= <span class="number">2</span>^n * <span class="built_in">T</span>(<span class="number">0</span>) + (<span class="number">2</span>^n * c)</span><br><span class="line">      = <span class="number">2</span>^n * (<span class="number">1</span> + c)</span><br></pre></td></tr></table></figure><ul><li><p><strong>time：</strong>$O(2^n)$</p></li><li><p><strong>space：</strong>$O(n)$ ➔ 受限於 tree 的深度, 下圖中可以看到 F(6) 的深度 &#x3D; 6 - 1 &#x3D; n - 1</p><p>  <img src="https://i.imgur.com/vaRiYvD.png" alt="Untitled"></p><p>  <strong>遞迴缺點：重複計算</strong>, e.g. 上圖中可看到 F(3) 被重複呼叫好幾次</p></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 紀錄 0, 1, 2, …, n 階的方法數, 用空間換取時間, 避免重複計算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, <code>dp[i] = dp[i - 1] + dp[i - 2]</code> 中 <code>dp[i]</code> 只會用到前兩步的方法數, 也就是說只需紀錄 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> 就好, 根本不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">1</span>; <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="type">int</span> two = <span class="number">1</span>; <span class="comment">// dp[i - 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> cur = one + two; <span class="comment">// dp[i]</span></span><br><span class="line">            two = one;</span><br><span class="line">            one = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/post/container-with-most-water/"/>
      <url>/post/container-with-most-water/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/container-with-most-water/">https://leetcode.cn/problems/container-with-most-water/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>height</code> 和一整數 <code>n</code>。有 <code>n</code> 條線其高度為 <code>height[i]</code>, 找出其中的兩條線，使得它們與 x 軸組成的容器可以容納最多的水。</p></blockquote><p><img src="https://i.imgur.com/9XQIlRp.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers</strong></p><ul><li>當前 area &#x3D; 兩條線中<strong>較短</strong>的高度 * 彼此間的距離</li><li><strong>移動較短</strong>那端的 ptr, 盡量保留較長的線</li></ul><p><strong>為何是移動較短那端的 ptr？</strong> 因為 area 是用<strong>下限</strong>計算的, 我們希望下限越高越好, 但是下限會受限於上限 ➔ 因此我們採取的策略為<strong>「維持上限、提升下限」</strong></p><p>e.g. <code>height = [1, 3, 5, 7]</code></p><ul><li><p>最一開始 <code>left = 0</code>, <code>right = 3</code> ➔ <code>nums[left] = 1</code>, <code>nums[right] = 7</code><br>此時 <code>area = min(1, 7) * (3 - 0) = 1 * 3 = 3</code></p><ul><li><p><strong>若移動 right</strong> : <code>left = 0</code>, <code>right = 2</code> ➔ <code>nums[left] = 1</code>, <code>nums[right] = 5</code><br>  此時 <code>area = min(1, 5) * (2 - 0) = 1 * 2 = 2</code> 反而更小了</p></li><li><p><strong>若移動 left</strong> : <code>left = 1</code>, <code>right = 3</code> ➔ <code>nums[left] = 3</code>, <code>nums[right] = 7</code><br>  此時 <code>area = min(3, 7) * (3 - 1) = 3 * 2 = 6</code></p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)  &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> area = <span class="built_in">min</span>(height[left], height[right]) * (right - left);</span><br><span class="line">            res = <span class="built_in">max</span>(res, area);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>height</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>217. Contains Duplicate</title>
      <link href="/post/contains-duplicate/"/>
      <url>/post/contains-duplicate/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/contains-duplicate/">https://leetcode.cn/problems/contains-duplicate/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 判斷當中是否有重複數字。</p></blockquote><p><img src="https://i.imgur.com/Er5lLKp.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先排序, 再用 loop 兩兩比較 <code>nums[i - 1]</code> 和 <code>nums[i]</code> 是否相等</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ sorting 後 data 仍儲存在 <code>nums</code> 中, 不需要額外空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 hash table 紀錄出現過的元素</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(num) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>s</code> 長度不超過 <code>n</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：比較 <code>nums</code> 和 <code>set(nums)</code> 長度是否相等, 若不相等代表有重複</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() != <span class="built_in">set</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()).<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 將 <code>nums</code> 轉成 <code>set(nums)</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>set(nums)</code> 長度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022. Convert 1D Array Into 2D Array</title>
      <link href="/post/convert-1d-array-into-2d-array/"/>
      <url>/post/convert-1d-array-into-2d-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/convert-1d-array-into-2d-array/">https://leetcode.cn/problems/convert-1d-array-into-2d-array/</a></strong></p><p><strong>題意：</strong>將 1d array <code>original</code> 轉成 <code>m</code> 列 <code>n</code> 行的 2d array。</p></blockquote><p><img src="https://i.imgur.com/Ys9chvQ.png" alt="Untitled"></p><p><img src="https://i.imgur.com/DMHTmAS.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：每次塞 <code>1 x n</code> 的 vector</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">construct2DArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; original, <span class="type">int</span> m, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m * n != original.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i += n)</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(original.<span class="built_in">begin</span>() + i, original.<span class="built_in">begin</span>() + i + n));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>original</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>338. Counting Bits</title>
      <link href="/post/counting-bits/"/>
      <url>/post/counting-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/counting-bits/">https://leetcode.cn/problems/counting-bits/</a></strong></p><p><strong>題意：</strong>給一整數 <code>n</code>, 對於 <code>0 ≤ i ≤ n</code> 中的每個 <code>i</code>, 計算其在二進制中 <code>1</code> 的個數, 返回一個長度為 <code>n + 1</code> 的 array 作為答案。</p></blockquote><p><img src="https://i.imgur.com/xLkiXO6.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：判斷 <code>i</code> 最靠右的 bit 是否為 <code>1</code>。若是的話, 則 <code>cnt++</code>, 每次判斷完後就將 <code>i</code> 右移一位, 直到 <code>i = 0</code>（沒有 1-bit）為止</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> val = i; val &gt; <span class="number">0</span>; val &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> rightmost = val &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(rightmost == <span class="number">1</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ $n * O(log(n))$<ul><li>$O(log(n))$ : <code>n</code> 右移 <code>1</code> 位等價 <code>n</code> 除以 <code>2</code>, 令 <code>k</code> 為右移次數, $\dfrac{n}{2^k} &#x3D; 1$ ➔ $k &#x3D; log(n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要返回的 array, 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 因為透過觀察發現：</strong></p><p><strong>1. 前一數（偶數）的 1 之個數 + 1, 因為偶數最右邊的 bit 必為 0, 奇數多的就是最右邊的 bit</strong></p><ul><li>e.g. 3 &#x3D; 011, 2 &#x3D; 010 ➔ 故 3 的 1 之個數 &#x3D; 2 的 1 之個數 + 1</li></ul><p><strong>2. 偶數的 1 之個數 &#x3D; （該數 &#x2F; 2） 的 1 之個數, 因為偶數最右邊的 bit 必為 0, 所以偶數往右移一位, 該數的 1 之個數並不會減少</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            dp[i] = (i &amp; <span class="number">1</span>) ? dp[i - <span class="number">1</span>] + <span class="number">1</span> : dp[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $n * O(1)$<ul><li><code>dp[i]</code> 都是去存取先前已計算過的 <code>dp[i-1]</code> 或 <code>dp[i &gt;&gt; 1]</code>, 故每一次計算 <code>dp[i]</code> 故只需花 $O(1)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>543. Diameter of Binary Tree</title>
      <link href="/post/diameter-of-binary-tree/"/>
      <url>/post/diameter-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求任兩點的 path 之最大長度。</p><ul><li>最大長度：最長 path 上的 <code>edge</code> 數</li></ul></blockquote><p><img src="https://i.imgur.com/NkrA6am.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, LP(node) 返回以 <code>node</code> 為 root 的 subtree 之最長路徑, 只有當前 node 可以同時使用左子樹和右子樹（由左至右分別是 1, 2, 1）, 也就是計算 <code>res</code> 時可用, 但返回時只能 return 單邊路徑。由於 path 不一定要經過 root, 因此可用 global 變數 <code>res</code> 來記錄最長 path 之長度</strong></p><p><img src="https://i.imgur.com/48fZdOl.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">LP</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LP</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">LP</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">LP</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        res = <span class="built_in">max</span>(res, left + right); <span class="comment">// 只有當前 root 可以同時使用左子樹和右子樹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right); <span class="comment">// 每個 node 都看成是轉折點, 只能返回單邊路徑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case：skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>271. Encode and Decode Strings</title>
      <link href="/post/encode-and-decode-strings/"/>
      <url>/post/encode-and-decode-strings/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/encode-and-decode-strings/">https://leetcode.cn/problems/encode-and-decode-strings/</a></strong></p><p><strong>題意：</strong>給一 string list <code>strs</code>, 請設計一演算法, 讓 encode 後的 string 可以透過網路高效傳輸, 並透過 decode 還原回原本的 string list。</p><p><strong>注意：</strong></p><ul><li>string 可能會包含所有的 ASCII char, 所以你設計的演算法要能處理任何可能出現的 char</li><li>請勿使用 <code>class member</code>、<code>global variable</code>、<code>static variable</code> 來儲存額外的狀態</li></ul></blockquote><p><img src="https://i.imgur.com/ftVLgXk.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：不能只在兩個 string 間只用一個分隔符 (delimiter) 隔開, 因為也有可能 input 中恰好有該分隔符組成的 string</strong></p><p>e.g. <code>delimiter = &#39;#&#39;</code>, <code>strs = [&#39;1&#39;, &#39;2#3&#39;]</code></p><p>這樣會得到錯誤的答案 <code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</code>, 而非 <code>[&#39;1&#39;, &#39;2#3&#39;]</code></p><p><strong>因此, 要額外紀錄每個 string 的長度：</strong></p><ul><li>Encode 時, 在每個 string <code>s</code> 前面加上長度 <code>s.size()</code> 和分割符 <code>#</code></li><li>Decode 時, 首先找出 idx <code>i</code> 往後的第一個 <code>#</code>, 假設其 idx 為 <code>j</code>, 則 <code>s[i, j)</code> 轉成 int 後即為 <code>s</code> 的長度。從 <code>j + 1</code> 往後(含)取 <code>s[i, j)</code> 個 char 即可得到當前的 <code>s</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a list of strings to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : strs) &#123;</span><br><span class="line">            ss &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;#&#x27;</span> &lt;&lt; s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a single string to a list of strings.</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">decode</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (s[j] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> len = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(i, j - i));</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(j + <span class="number">1</span>, len)); <span class="comment">// push 當前的 string</span></span><br><span class="line">            i = j + <span class="number">1</span> + len; <span class="comment">// 更新下一次開始的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><strong>encode：</strong>$O(n)$ ➔ <code>n</code> 為 <code>strs</code> 中所有 string 的總長度</li><li><strong>decode：</strong>$O(n)$ ➔ <code>n</code> 為 <code>s</code> 的長度</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 皆需要 $O(n)$ 來儲存原先所有的 string</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link href="/post/evaluate-reverse-polish-notation/"/>
      <url>/post/evaluate-reverse-polish-notation/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></strong></p><p><strong>題意：</strong>給一 postorder, 返回 inorder 的運算結果。</p><p>保證 postorder 運算式皆為有效的, 不會有除數為 <code>0</code> 的情況。</p></blockquote><p><img src="https://i.imgur.com/Fib7hlW.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack, 一旦當前 <code>token</code> 為數字, 則 push 到 stack 中; 否則, 取出 stack 中最上面的兩個 top 元素出來做運算, 並把運算結果 push 到 stack 中。重複以上步驟, 最後 stack 會剩下一個元素, 也就是最終的運算結果</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; token : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(token))</span><br><span class="line">                stk.<span class="built_in">emplace</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 注意順序</span></span><br><span class="line">                <span class="type">int</span> n2 = <span class="built_in">get_topNum</span>();</span><br><span class="line">                <span class="type">int</span> n1 = <span class="built_in">get_topNum</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span>(token[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 + n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 - n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(<span class="built_in">long</span>(n1) * <span class="built_in">long</span>(n2));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 / n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isdigit</span><span class="params">(string&amp; token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_topNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop, 其中 <code>n</code> 為 <code>token</code> 的個數</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>448. Find All Numbers Disappeared in an Array</title>
      <link href="/post/find-all-numbers-disappeared-in-an-array/"/>
      <url>/post/find-all-numbers-disappeared-in-an-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/</a></strong></p><p><strong>題意：</strong>原本有一包含 <code>[1, n]</code> 總共 <code>n</code> 個數的 array, 今給一個 <code>n</code> 個數的 array (含重複數) <code>nums</code>, 找出所有缺失的數。</p></blockquote><p><img src="https://i.imgur.com/uWoILtq.png" alt="Untitled"></p><hr><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將數字設為 負數 來標記我們看到的數字的 index, 然後遍歷 <code>nums</code> 元素, 若 <code>nums[i] &gt; 0</code>, 代表數字 <code>i + 1</code> 沒出現過</strong></p><p>e.g. <code>[1, 2, 2]</code> ➔ <code>[-1, -2, 2]</code>, 其中 <code>nums[0]</code> 紀錄數字 1 是否出現</p><p>因為數字 1 有出現, 所以 <code>nums[0]</code> 被設為負數, 依此類推</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 將數字設為負數來標記我們看到的數字的index</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除返回的 array, 且缺失 idx 都儲存在 <code>nums</code> 中, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>744. Find Smallest Letter Greater Than Target</title>
      <link href="/post/find-smallest-letter-greater-than-target/"/>
      <url>/post/find-smallest-letter-greater-than-target/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/">https://leetcode.cn/problems/find-smallest-letter-greater-than-target/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> char array <code>letters</code>, 在其中找到比 <code>target</code> 大的最小 char。</p><p><strong>注意：</strong><code>letters</code> 是循環的</p><ul><li>e.g. <code>target == &#39;z&#39;</code> 且 <code>letters == [&#39;a&#39;, &#39;b&#39;]</code>, 則返回 <code>&#39;a&#39;</code></li></ul></blockquote><p><img src="https://i.imgur.com/8BY6pKe.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 binary search</strong></p><ul><li><code>letters[mid] &gt; target</code> 時, 往左查找, 看是否有比 <code>mid</code> 更小的</li><li><code>letters[mid] &lt;= target</code> 時, 往右查找</li></ul><p>最後記得檢查是否 <code>&gt; target</code>, 如果不滿足(代表 <code>letters</code> 中沒有 <code>&gt; target</code> 的 char), 則返回 <code>letters[0]</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; letters, <span class="type">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = letters.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 避免 overflow</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &gt; target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[left] &gt; target ? letters[left] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. Generate Parentheses</title>
      <link href="/post/generate-parentheses/"/>
      <url>/post/generate-parentheses/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/generate-parentheses/">https://leetcode.cn/problems/generate-parentheses/</a></strong></p><p><strong>題意：</strong>數字 <code>n</code> 代表生成括號的對數, 生成所有可能的且<strong>有效的</strong>括號組合。</p></blockquote><p><img src="https://i.imgur.com/3fkGh4I.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p><ul><li><p>當 <code>左括號個數 &lt; n</code> 時, 可以加入左括號</p></li><li><p>當 <code>右括號個數 &lt; 左括號個數</code> 時, 可以加入右括號</p><p>  <img src="https://i.imgur.com/TmAGVht.png" alt="Untitled"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string cur;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>&amp; n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == n &amp;&amp; right == n)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)&#123;</span><br><span class="line">            cur += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(left + <span class="number">1</span>, right, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)&#123;</span><br><span class="line">            cur += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(left, right + <span class="number">1</span>, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(\dfrac{4^n}{n \sqrt n})$ ➔ 取決於第 <code>n</code> 個 Catalan number $\dfrac{1}{n+1} \left(\begin{array}{ccc} 2n \\ n \ \end{array} \right)$, 近似於 $O(\dfrac{4^n}{n \sqrt n})$<br><a href="https://math.stackexchange.com/questions/1986247/asymptotic-approximation-of-catalan-numbers">證明網址(不重要)</a></li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 array <code>res</code>, 取決於遞迴深度, 遞迴最大深度為 <code>2n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/post/group-anagrams/"/>
      <url>/post/group-anagrams/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a></strong></p><p><strong>題意：</strong>給一 string list <code>strs</code>, 其中 <code>strs[i]</code> 僅由小寫字母所組成, 將 <code>strs</code> 中的<strong>字母異位詞 (Anagram)</strong> 進行分組, 可按任意順序返回。</p><p><strong>字母異位詞 (Anagram) 定義 ：</strong>若 <code>s</code> 和 <code>t</code> 中每個字母的出現次數都相同, 則 <code>s</code> 和 <code>t</code> 互為字母異位詞。</p></blockquote><p><img src="https://i.imgur.com/EGOaFHh.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Sorting + hash table, 遍歷每個 string <code>s</code>, 並對其進行排序得到 string key, 將 <code>key</code> 和對應的 <code>s</code> 加入到 hash table 中。最後再根據 <code>key</code> 取出整個 group 即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : strs) &#123;</span><br><span class="line">            string key = s;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            groups[key].<span class="built_in">emplace_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, group] : groups) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(group);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot log(n))$ ➔ 其中 <code>m</code> 為 string 的個數, <code>n</code> 為 string 的平均長度。<ul><li>$O(n \cdot log(n))$：<code>s</code> 進行 sorting 的時間</li></ul></li><li><strong>space：</strong>$O(m \cdot n)$ ➔ hash table 中儲存所有的 string</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 hash table, 紀錄每個 string <code>s</code> 中每種 char 出現的頻率, 並把每種 char 的頻率當作是 key, 連同 <code>s</code> 一起加入到 hash table 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line">            <span class="function">string <span class="title">freqs</span><span class="params">(<span class="number">26</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>; <span class="comment">// 用 string 代替 vector 紀錄出現頻率</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : str) &#123;</span><br><span class="line">                freqs[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            groups[freqs].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [freq, group] : groups) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(group);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 所有 string 中每種 char 的出現頻率, 其中 <code>m</code> 為 <code>strs</code> 的元素個數, <code>n</code> 為 <code>strs[i]</code> 的平均長度</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>groups</code> 儲存所有的 string</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202. Happy Number</title>
      <link href="/post/happy-number/"/>
      <url>/post/happy-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></strong></p><p><strong>題意：</strong>判斷整數 <code>n</code> 是否為<strong>快樂數</strong>。</p><p><strong>快樂數</strong>的定義為：</p><ul><li>對於一正整數, 每次將該數轉換為它每一位數的平方和</li><li>重複此步驟直到該數為 <code>1</code>, 也有可能進入無窮迴圈（始終無法變成 <code>1</code> ）</li><li>如果該數能變成 <code>1</code>, 則它就是快樂數</li></ul><p>若 <code>n</code> 為快樂數, 則返回 <code>true</code>; 否則, 返回 <code>false</code>。</p></blockquote><p><img src="https://i.imgur.com/1nDigjm.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table 來記錄出現過的數, 一旦重複出現, 代表會無限循環</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s&#123;n&#125;;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">            n = <span class="built_in">squareSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(n) != s.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.<span class="built_in">emplace</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ 令 <code>k</code> 為 <code>n</code> 除以 <code>10</code> 的次數, $\dfrac{n}{10^k} &#x3D; 1 ➔ k &#x3D; log(n)$</li><li><strong>space：</strong>$O(log(n))$ ➔ <code>s</code> 中儲存 $log(n)$ 次轉換後的元素</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：概念同 Solution 1, 只是改成利用 Two Pointers 來判斷是否出現重複的數, 可參考 <a href="https://zako945.github.io/post/linked-list-cycle/">141. Linked List Cycle</a>, <code>slow</code> 每次只轉換一次, 而 <code>fast</code> 每次轉換兩次</strong></p><ul><li>若存在循環（重複數）, 則 <code>slow</code> 和 <code>fast</code> 必相遇（<code>fast</code> 倒追 <code>slow</code>） ➔ <code>n</code> 不為快樂數</li><li>若不存在循環, 經過 <code>x</code> 步後 <code>fast</code> 必先變成 1, 然後再經過 <code>x</code> 步後 <code>slow</code> 才會接著變成 1</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="built_in">squareSum</span>(n);</span><br><span class="line">        <span class="type">int</span> fast = <span class="built_in">squareSum</span>(<span class="built_in">squareSum</span>(n));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = <span class="built_in">squareSum</span>(slow);</span><br><span class="line">            fast = <span class="built_in">squareSum</span>(<span class="built_in">squareSum</span>(fast));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ 令 <code>k</code> 為 <code>n</code> 除以 <code>10</code> 的次數, $\dfrac{n}{10^k} &#x3D; 1 ➔ k &#x3D; log(n)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1065. Index Pairs of a String</title>
      <link href="/post/index-pairs-of-a-string/"/>
      <url>/post/index-pairs-of-a-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/index-pairs-of-a-string/">https://leetcode.cn/problems/index-pairs-of-a-string/</a></strong></p><p><strong>題意：</strong>給一 string <code>text</code> 和 string list <code>words</code>, 求所有 <code>index pair</code> 使得 <code>text[i~j]</code> 出現在 <code>words</code> 中。</p></blockquote><p><img src="https://i.imgur.com/ITZF5on.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：暴力搜尋法</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">indexPairs</span>(string text, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="type">int</span> m = text.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordset</span><span class="params">(words.begin(), words.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>; start &lt; m; ++start) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> end = start; end &lt; m; ++end) &#123;</span><br><span class="line">                string cur = text.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(wordset.<span class="built_in">count</span>(cur))</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;start, end&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令總共有 <code>n</code> 個 word, 其中 $w_i$ 代表 <code>words[i]</code> 的長度, 且 text 之長度為 <code>m</code></p><ul><li><strong>time：</strong>$O(m^2 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ 因為 c++ 的 <strong><code>find()</code></strong> 不是用 <strong>KMP</strong> 實作的<ul><li>$O(m^2)$：每次以 <code>start</code> 為起點往後遍歷, 取 <code>text[start:end]</code> 然後去判斷是否在 <code>wordset</code> 中<ul><li>$m + (m-1) + (m-2) + … + 1$ &#x3D; $\dfrac{(m+1)\cdot m}{2}$</li></ul></li><li>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$：每次判斷 <code>text[start:end]</code> 是否在 <code>wordset</code> 中</li></ul></li><li><strong>space：</strong>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ <code>wordset</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Trie(prefix tree), 可參考 <a href="https://zako945.github.io/post/implement-trie-prefix-tree/">208. Implement Trie (Prefix Tree)</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> is_end = <span class="literal">false</span>; <span class="comment">// 預設每個 char 不為 end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : word)&#123;</span><br><span class="line">            <span class="type">int</span> i = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;children[i])</span><br><span class="line">                p-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            p = p-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;is_end = <span class="literal">true</span>; <span class="comment">// 將最後一個 char 設為 end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">search</span>(string text, vector&lt;string&gt;&amp; words)&#123;</span><br><span class="line">        <span class="type">int</span> m = text.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>; start &lt; m; ++start)&#123;</span><br><span class="line">            TrieNode *p = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> end = start; end &lt; m &amp;&amp; p != <span class="literal">nullptr</span>; ++end)&#123;</span><br><span class="line">                p = p-&gt;children[text[end] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(p &amp;&amp; p-&gt;is_end)</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;start, end&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">indexPairs</span>(string text, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        Trie trie;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; word : words)</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        <span class="keyword">return</span> trie.<span class="built_in">search</span>(text, words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令總共有 <code>n</code> 個 word, 其中 $w_i$ 代表 <code>words[i]</code> 的長度, 且 text 之長度為 <code>m</code></p><ul><li><strong>time：</strong>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i + m^2)$<ul><li>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$ : insert 所有 word 到 Trie 中</li><li>$O(m^2)$ : 每次以 <code>start</code> 為起點往後遍歷, 判斷 <code>text[start:end]</code> 是否在 Trie 中<ul><li>$m + (m-1) + (m-2) + … + 1 &#x3D;$ $\dfrac{(m+1)\cdot m}{2}$</li></ul></li></ul></li><li><strong>space：</strong>$O(26 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ worse case : 每個 word 的 <code>prefix</code> 皆不重覆<ul><li>總共 <code>n</code> 個 word, 每一個 word 有 $w_i$ 個 node, 而每個 node 又有 26 個 children</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>226. Invert Binary Tree</title>
      <link href="/post/invert-binary-tree/"/>
      <url>/post/invert-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 反轉其左右子樹。</p></blockquote><p><img src="https://i.imgur.com/0KPB1wQ.png" alt="Untitled"></p><p><img src="https://i.imgur.com/UQcx1Lg.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ worse case : skew tree, 遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(cur-&gt;left, cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>703. Kth Largest Element in a Stream</title>
      <link href="/post/kth-largest-element-in-a-stream/"/>
      <url>/post/kth-largest-element-in-a-stream/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">https://leetcode.cn/problems/kth-largest-element-in-a-stream/</a></strong></p><p><strong>題意：</strong>設計一個找到 stream 中第 <code>k</code> 大的元素。注意是排序後的第 <code>k</code> 大元素, 而非第 <code>k</code> 個不同的元素。</p><p><strong>實現 <code>KthLargest</code> class：</strong></p><ul><li><code>KthLargest(int k, int[] nums)</code>：使用 <code>k</code> 和 <code>nums</code> 來初始化 instance</li><li><code>int add(int val)</code>：將 <code>val</code> 加入倒 <code>nums</code> 中, 並返回第 <code>k</code> 大的元素</li></ul></blockquote><p><img src="https://i.imgur.com/wRrfh84.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution</strong>：</h2><blockquote><p><strong>想法：利用 Heap, 使用 min heap <code>pq</code> 來記錄前 <code>k</code> 大的元素, 其中 <code>pq.top()</code> 代表當前第 <code>k</code> 大的元素</strong></p><ul><li><code>KthLargest(k, nums)</code>：先 push <code>nums[i]</code>, 然後確認 <code>pq.size()</code> 是否 &gt; k。若是的話, 則把 <code>pq.top()</code> 給 pop 掉, 讓 <code>pq</code> 的元素個數維持在 <code>k</code> 個</li><li><code>add(val)</code>：先 push <code>val</code>, 然後確認 <code>pq.size()</code> 是否 <code>&gt; k</code>。若是的話, 則把 <code>pq.top()</code> 給 pop 掉, 讓 <code>pq</code> 的元素個數維持在 <code>k</code> 個</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        k_ = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            <span class="built_in">add</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k_)</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> k_;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>KthLargest(k, nums)</code>：$O(n \cdot log(k))$, 其中 <code>n</code> 為 <code>nums</code> 中的元素個數, 因為 heap 要 add &#x2F; delete 元素皆需花 $O(log(k))$ 來調整 heap</li><li><code>add(val)</code>：$O(log(k))$ ➔ heap 要 add &#x2F; delete 元素皆需花 $O(log(k))$ 來調整 heap</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ <code>pq</code> 中的元素不超過 <code>k + 1</code> 個</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1046. Last Stone Weight</title>
      <link href="/post/last-stone-weight/"/>
      <url>/post/last-stone-weight/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/last-stone-weight/">https://leetcode.cn/problems/last-stone-weight/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>stones</code>, 其中 <code>stones[i]</code> 代表第 <code>i</code> 塊石頭的重量。</p><p>每一回合取出最重的兩塊石頭, 並將其互相撞擊。假設石頭的重量分別為 <code>x</code>、<code>y</code>, 且 <code>x ≤ y</code>。則撞擊後的可能結果如下：</p><ul><li>若 <code>x == y</code>, 則兩塊石頭都將完全粉碎</li><li>若 <code>x != y</code>, 則重量為 <code>x</code> 的石頭將完全粉碎, 而重量為 <code>y</code> 的石頭之新重量為 <code>y - x</code></li></ul><p>最後, 頂多剩下一塊石頭。若沒有石頭剩下, 則返回 <code>0</code>; 否則, 返回該石頭的重量。</p></blockquote><p><img src="https://i.imgur.com/tUYixRb.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap, 先將所有的元素 push 到 max heap <code>pq</code> 中, 再從 <code>pq</code> 中兩兩取出元素做運算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// max heap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; stone : stones)</span><br><span class="line">            pq.<span class="built_in">emplace</span>(stone);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> y = <span class="built_in">getTop</span>(pq);</span><br><span class="line">            <span class="keyword">auto</span> x = <span class="built_in">getTop</span>(pq);</span><br><span class="line">            pq.<span class="built_in">emplace</span>(y - x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">getTop</span><span class="params">(priority_queue&lt;T&gt;&amp; pq)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ 將所有的 stone push 到 <code>pq</code> 中、將所有 stone 取出來做運算, 其中 <code>n</code> 為 stone 的個數</li><li><strong>space：</strong>$O(n)$ ➔ <code>pq</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle</title>
      <link href="/post/linked-list-cycle/"/>
      <url>/post/linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></strong></p><p><strong>題意：</strong>判斷 linked list 中是否有 cycle。</p></blockquote><p><img src="https://i.imgur.com/Ylw08jF.png" alt="Untitled"></p><p><img src="https://i.imgur.com/m3WoSHi.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用兩個不同步長的 ptr, <code>slow</code> 每次只走一步, 而 <code>fast</code> 每次走兩步</strong></p><ul><li>若存在循環, 則 <code>slow</code> 和 <code>fast</code> 必相遇（<code>fast</code> 倒追 <code>slow</code>）</li><li>若不存在循環, <code>fast</code> 必先抵達 <code>nullptr</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷 fast, 因為若沒有 cycle, fast 會比較快抵達 nullptr</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 一次走一步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 一次走兩步</span></span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中的元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128. Longest Consecutive Sequence</title>
      <link href="/post/longest-consecutive-sequence/"/>
      <url>/post/longest-consecutive-sequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></strong></p><p><strong>題意：</strong>給一<strong>未排序的</strong> array <code>nums</code>, 找出數字連續的最長 sequence（sequence 元素不需在 <code>nums</code> 中位置連續）。</p><p><strong>注意：</strong>請設計 $O(n)$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/JkHCMuK.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將 <code>nums</code> 視覺化發現, 每個 sequence 形成的首要條件就是開頭的數左邊沒有數, 結尾的數右邊沒有數</strong></p><p><img src="https://i.imgur.com/RZNbX7F.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="comment">// 判斷左邊的數有無在 hash table 中</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(num - <span class="number">1</span>) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> end = num + <span class="number">1</span>; <span class="comment">// 則 num 可當作 sequence 的開頭</span></span><br><span class="line">                <span class="keyword">while</span> (s.<span class="built_in">find</span>(end) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, end - num); <span class="comment">// 檢查是否為最長 sequence</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 雖然有 for loop 和 while loop, 但是每一個數<strong>最多</strong>被訪問 &#96;2&#96;&#96; 次<ul><li>一次是 <code>for (const auto&amp; num : nums)</code></li><li>一次是 <code>if (s.find(num - 1) == s.end())</code>, 也就是剛好是某數的左邊</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>s</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>424. Longest Repeating Character Replacement</title>
      <link href="/post/longest-repeating-character-replacement/"/>
      <url>/post/longest-repeating-character-replacement/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">https://leetcode.cn/problems/longest-repeating-character-replacement/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code> 和一整數 <code>k</code>, 你可以選擇將 <code>s</code> 中的任意字元變成其他大寫英文字母, 該操作最多執行 <code>k</code> 次。</p><p>經上述操作後, 返回<strong>僅包含相同字元</strong>的最大 substring 長度。</p><p>s 由大寫英文字母所組成。</p></blockquote><p><img src="https://i.imgur.com/xPxWZv5.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 將 <code>window</code> 中的元素分成兩部分</strong></p><ul><li>出現頻率最多的元素</li><li>扣掉出現頻率最多的元素後，所剩餘的元素</li></ul><p><strong>若剩餘的元素個數 <code>≤ k</code>, 代表剩餘的元素可全部替換為頻率最多的元素。反之, 則不行。做完後, 更新 <code>res</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">window</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            ++window[c - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若剩餘元素個數 &gt; k，則縮小窗口</span></span><br><span class="line">            <span class="keyword">while</span>(right - left - *<span class="built_in">max_element</span>(window.<span class="built_in">begin</span>(), window.<span class="built_in">end</span>()) &gt; k)&#123;</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                --window[d - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(26 \cdot n)$, <code>s</code> 中的每個元素最多被遍歷 2 次（<code>left</code>、<code>right</code>）<ul><li>$O(26 \cdot n)$：while loop 中每次取 <code>max_element()</code> 需 $O(26)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code></li></ul><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a><strong>Solution 2:</strong></h2><blockquote><p><strong>想法: 改善 Solution 1, 將 <code>max_element()</code> 提出, 變成在 while loop 外部維護, 而非在 while loop 中維護</strong></p><ul><li>能這樣做是因為在內層 while loop 中移除 <code>window[s[left]]</code> 後, <code>maxf</code> 只會<strong>越來越小</strong></li><li>也就是說 <code>right - left - maxf(移除前) ≥ right - left - maxf(移除後)</code> 始終是成立的, 因為 <code>maxf(移除後) ≤ maxf(移除前)</code></li><li>若 <code>right - left - maxf(移除前) &gt; k</code> 成立, 則 <code>right - left - maxf(移除後) &gt; k</code> 也必定成立, 因此根本不必在 while loop 中更新 <code>maxf</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            ++window[c];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 widnow 中出現頻率最高的 char 的個數</span></span><br><span class="line">            <span class="type">int</span> maxf = <span class="built_in">max_element</span>(window.<span class="built_in">begin</span>(), window.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; p1, <span class="keyword">auto</span>&amp; p2)&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">            &#125;)-&gt;second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(right - left - maxf &gt; k)&#123;</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                --window[d];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>s</code> 中的每個元素最多被遍歷 2 次（<code>left</code>、<code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code> 長度為 $O(26)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/post/longest-substring-without-repeating-characters/"/>
      <url>/post/longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 返回一沒有重複 char 的<strong>最長 substring</strong> 的長度。</p></blockquote><p><img src="https://i.imgur.com/jg9qqTK.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 類似 <a href="https://zako945.github.io/post/longest-repeating-character-replacement/">424. Longest Repeating Character Replacement</a>, 每次檢查 <code>s[right]</code> 是否已經在 <code>visited</code> 中</strong></p><ul><li>若是, 則移除 <code>s[left]</code>, 且 <code>left + 1</code>, 直到 <code>visited</code> 中不存在 <code>s[right]</code></li><li>將 <code>s[right]</code> 加入到 <code>visited</code> 中</li><li>更新 <code>res</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); ++right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(visited.<span class="built_in">find</span>(s[right]) != visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">emplace</span>(s[right]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>s</code> 中的每個元素最多被拜訪 <code>2</code> 次（<code>left</code>, <code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>cnt</code> 長度最多為 <code>26</code>, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169. Majority Element</title>
      <link href="/post/majority-element/"/>
      <url>/post/majority-element/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/majority-element/">https://leetcode.cn/problems/majority-element/</a></strong></p><p><strong>題意：</strong>給一大小為 <code>n</code> 的 array <code>nums</code>, 找出當中個數<strong>大於</strong> $⌊ \dfrac{n}{2} ⌋$ 的數字(保證存在一個數滿足此條件)。</p><p><strong>進階：</strong>試著用 $O(n)$ time, $O(1)$ space 的演算法解決此問題</p></blockquote><p><img src="https://i.imgur.com/jvwdXOf.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table 紀錄 <code>&#123;num: count&#125;</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, maxCount = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n : nums)&#123;</span><br><span class="line">            ++umap[n];</span><br><span class="line">            <span class="keyword">if</span>(umap[n] &gt; maxCount)&#123;</span><br><span class="line">                res = n;</span><br><span class="line">                maxCount = umap[n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>umap</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p>想法：利用 Boyer – Moore 投票法</p><ul><li>當 <code>res = 0</code> 時, 將 <code>res</code> 設為 <code>nums[i]</code></li><li>否則, 檢查 <code>nums[i]</code> 是否為 <code>res</code>。若是的話 <code>res + 1</code>, 否則 <code>res - 1</code></li></ul><p><img src="https://i.imgur.com/ySun2rW.png" alt="Untitled"></p><p><strong>考慮特殊 case</strong>:</p><ol><li><p><code>nums = [2,2,1,1,3]</code>, 得出 <code>res</code> &#x3D; 3</p><table><thead><tr><th>nums[i]</th><th>2</th><th>2</th><th>1</th><th>1</th><th>3</th></tr></thead><tbody><tr><td>cnt</td><td>1</td><td>2</td><td>1</td><td>0</td><td>1</td></tr><tr><td>res</td><td>2</td><td>2</td><td>2</td><td>2</td><td>3</td></tr></tbody></table></li><li><p><code>nums = [2,2,3,4,5]</code>, 得出 <code>res</code> &#x3D; 5</p><table><thead><tr><th>nums[i]</th><th>2</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>cnt</td><td>1</td><td>2</td><td>1</td><td>0</td><td>1</td></tr><tr><td>res</td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td></tr></tbody></table></li></ol><p>➔ 以上情況皆不會在本題出現, 因為 2 的個數並沒有 &gt; $⌊ \dfrac{5}{2} ⌋$<br>➔ <strong>而本題的先決條件就是必有一數的個數 &gt; $⌊ \dfrac{n}{2} ⌋$, 因此 Boyer – Moore 投票法在本題必成立</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">                res = n;</span><br><span class="line">            cnt += (n == res) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104. Maximum Depth of Binary Tree</title>
      <link href="/post/maximum-depth-of-binary-tree/"/>
      <url>/post/maximum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求 <strong>root-to-leaf</strong> 的 path 之最大長度(tree 的最大深度)。</p><ul><li>最大長度：path 上的 <code>node</code> 數</li></ul></blockquote><p><img src="https://i.imgur.com/HasniTr.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ worse case : skew tree, 遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left) q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>252. Meeting Rooms</title>
      <link href="/post/meeting-rooms/"/>
      <url>/post/meeting-rooms/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/meeting-rooms/">https://leetcode.cn/problems/meeting-rooms/</a></strong></p><p><strong>題意：</strong>給定一包含開始時間和結束時間的 <code>intervals</code>, 其中<code>intervals[i] = [starti, endi]</code>, 返回一個人是否可以參加所有會議。</p><p><strong>注意：</strong><code>(0,8)</code>、<code>(8,10)</code> 並不衝突</p></blockquote><p><img src="https://i.imgur.com/3p0FW4o.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：先將 <code>intervals</code> 根據 <code>interval.start</code> 進行排序, 然後判斷當前 <code>interval[i - 1].end</code> 是否大於 <code>interval[i].start</code>。若是的話, 代表會衝突到</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canAttendMeetings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 不需要額外空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>617. Merge Two Binary Trees</title>
      <link href="/post/merge-two-binary-trees/"/>
      <url>/post/merge-two-binary-trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></strong></p><p><strong>題意：</strong>給兩棵 BT, 請合併它們。</p><ul><li>如果兩個節點重疊, 則將節點值相加作為合併節點的新值。</li><li>否則, 不為 NULL 的節點將作為新樹的節點。</li></ul></blockquote><p><img src="https://i.imgur.com/ggMDIUx.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// root1, root2 皆存在</span></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ stack 最大長度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. Merge Two Sorted Lists</title>
      <link href="/post/merge-two-sorted-lists/"/>
      <url>/post/merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></strong></p><p><strong>題意：</strong>給兩個 <code>sorted</code> linked list: <code>list1</code> 和 <code>list2</code>, 將兩個合併成一個 <code>sorted</code> linked list。</p></blockquote><p><img src="https://i.imgur.com/CuDl9AB.png" alt="Untitled"></p><p><img src="https://i.imgur.com/uAf35hh.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 dummy node, 其中 <code>tail</code> 指向當前 <code>val</code> 較小的 list node</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *tail = dummy;</span><br><span class="line">        <span class="keyword">while</span>(list1 &amp;&amp; list2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">                tail-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next; <span class="comment">// 指向下一個</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 某中一個 list 結束跳出迴圈, 要處理另一個 list 剩下的元素</span></span><br><span class="line">        <span class="keyword">if</span>(list1)</span><br><span class="line">            tail-&gt;next = list1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2)</span><br><span class="line">            tail-&gt;next = list2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 其中 <code>m</code> 為 <code>list1</code> 的長度, <code>n</code> 為 <code>list2</code> 的長度, worse case：每個點都恰拜訪一次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>876. Middle of the Linked List</title>
      <link href="/post/middle-of-the-linked-list/"/>
      <url>/post/middle-of-the-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/middle-of-the-linked-list/">https://leetcode.cn/problems/middle-of-the-linked-list/</a></strong></p><p><strong>題意：</strong>返回 linked list 的中點, 若 linked list 的 node 數為偶數, 則返回<strong>第二個中點</strong>。</p></blockquote><p><img src="https://i.imgur.com/8nZD1k4.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers<br><code>slow</code> 一次走一步, <code>fast</code> 一次走兩步, 當 <code>fast</code> 走到 <code>NULL</code> 時, <code>slow</code> 剛好走到中點</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當 n 為偶數時, 跳出迴圈是因為 fast == NULL</span></span><br><span class="line">        <span class="comment">// 當 n 為奇數時, 跳出迴圈是因為 fast-&gt;nxt = NULL</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>746. Min Cost Climbing Stairs</title>
      <link href="/post/min-cost-climbing-stairs/"/>
      <url>/post/min-cost-climbing-stairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>cost</code>, 其中 <code>cost[i]</code> 代表從第 <code>i</code> 皆樓梯往上爬所需支付的費用。一旦支付該費用, 可以選擇往上爬一個 or 二個台階。</p><p>可以選擇從 index 為 <code>0</code> or <code>1</code> 的位置開始往上爬。</p><p>請計算到達樓梯頂部 <code>index = cost.size()</code> 所需的最小費用。</p></blockquote><p><img src="https://i.imgur.com/SQZ2B6d.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 定義 <code>dp[i]</code> 為抵達 <code>index = i</code> 所需的最小費用, 因此 <code>dp[i]</code> 為 <code>抵達前一階的最小費用 + 該階的費用</code>、<code>抵達前兩階的最小費用 + 該階的費用</code> 中取較小者</strong></p><ul><li><code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="comment">// index = 0 和 1 的費用都為 0</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為發現計算 <code>dp[i]</code> 只需用到 <code>dp[i - 1]</code>、<code>dp[i - 2]</code> 即可, 也就是說只需紀錄 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> 就好, 根本不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>; <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="type">int</span> two = <span class="number">0</span>; <span class="comment">// dp[i - 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">min</span>(one + cost[i - <span class="number">1</span>], two + cost[i - <span class="number">2</span>]);</span><br><span class="line">            two = one;</span><br><span class="line">            one = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155. Min Stack</title>
      <link href="/post/min-stack/"/>
      <url>/post/min-stack/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/min-stack/">https://leetcode.cn/problems/min-stack/</a></strong></p><p><strong>題意：</strong>設計一個支持 <code>push</code>、<code>pop</code>、<code>top</code> 操作, 並且能在 $O(1)$ time 得到最小元素的 stack。</p><p><strong>實作 <code>MinStack</code> class：</strong></p><ul><li><code>MinStack()</code>：初始化 instance</li><li><code>void push(int val)</code>：將 <code>val</code> push 到 stack 中</li><li><code>void pop()</code>：移除 stack 頂端元素</li><li><code>void top()</code>：得到 stack 頂端元素</li><li><code>int getMin()</code>：得到 stack 中的最小元素</li></ul></blockquote><p><img src="https://i.imgur.com/8x7sde8.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用兩個 Stack, 其中 stack <code>stk</code> 紀錄元素 push &#x2F; pop 的過程, 另一個 stack <code>minStk.top()</code> 紀錄每一次 push 元素到 <code>stk</code> 後, 當前 <code>stk</code> 中的的最小值</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        <span class="comment">// 讓 minStk 初始有一個最大值, 這樣後續 push 時 minStk 一定有 top 元素可比較</span></span><br><span class="line">        minStk.<span class="built_in">emplace</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">emplace</span>(val);</span><br><span class="line">        minStk.<span class="built_in">emplace</span>(<span class="built_in">min</span>(minStk.<span class="built_in">top</span>(), val)); <span class="comment">// 新增元素後, 紀錄當前的最小元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        minStk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minStk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>皆為 $O(1)$</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 的元素個數最多為 <code>n</code>, <code>minStk</code> 的元素個數最多為 <code>n + 1</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111. Minimum Depth of Binary Tree</title>
      <link href="/post/minimum-depth-of-binary-tree/"/>
      <url>/post/minimum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求 <strong>root-to-leaf</strong> 的 path 之最小長度(tree 的最小深度)。</p><ul><li>最小長度: path 上的 <code>node</code> 數</li></ul><p><strong>注意：</strong>若今給一 skew tree, 則 <code>min_depth = n</code></p></blockquote><p><img src="https://i.imgur.com/tbUhkxE.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 需遍歷所有 node</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, stack 長度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 需遍歷所有 node</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, stack 長度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268. Missing Number</title>
      <link href="/post/missing-number/"/>
      <url>/post/missing-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/missing-number/">https://leetcode.cn/problems/missing-number/</a></strong></p><p><strong>題意：</strong>原本有一包含 <code>[0, n]</code> 總共 <code>n + 1</code> 個數的 array, 今給一只有 <code>n</code> 個數的 array <code>nums</code>, 找出缺失的數。</p></blockquote><p><img src="https://i.imgur.com/qAxMn9S.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先將 <code>nums</code> 排序, 然後用 loop 檢查第 <code>i</code> 個數是否在 <code>nums</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>(); <span class="comment">// Example 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ sorting 後 data 仍儲存在 <code>nums</code> 中, 不需要額外空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：先計算 <code>[0, n]</code> 這 <code>n + 1</code> 個數之和, 然後扣掉 <code>nums</code> 中 data 之和, 即可得到缺失的數</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// 取得 nums 總和</span></span><br><span class="line">        <span class="type">int</span> total = nums.<span class="built_in">size</span>() * (nums.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 計算 0 ~ n 之和</span></span><br><span class="line">        <span class="keyword">return</span> total - sum; <span class="comment">// 相減即為缺值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍例 <code>nums</code> 計算所有 data 之和</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 XOR 中 <code>a ^ a = 0</code> 且 <code>0 ^ a = a</code> 的特性（還有交換性）</strong></p><p>e.g. <code>[0, 1, 2, 3] ^ [0, 1, 3] = 2</code></p><p><strong>XOR：</strong></p><ul><li><code>0 ^ 0 = 0</code></li><li><code>b ^ b = b</code></li><li><code>0 ^ a = a</code></li><li><code>a ^ b ^ b = a ^ (b ^ b) = a ^ 0 = a</code></li><li><strong>交換性：</strong><code>b ^ a ^ b = a ^ (b ^ b) = a ^ 0 = a</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            res = res ^ i ^ nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191. Number of 1 Bits</title>
      <link href="/post/number-of-1-bits/"/>
      <url>/post/number-of-1-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></strong></p><p><strong>題意：</strong>給一無號整數 <code>n</code>, 返回其二進制表示中 <code>1</code> 的個數。</p><p><strong>進階：</strong>如果多次呼叫此 function, 要如何優化？</p></blockquote><p><img src="https://i.imgur.com/hvYGLCW.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：每次判斷 <code>n</code> 的最右 bit 是否為 <code>1</code>, 若是的話, 則 <code>cnt++</code>, 判斷完最右 bit 後將 <code>n</code> 右移一位, 重複以上步驟直到 <code>n == 0</code> （沒有 1-bit）為止</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> rightmost = n &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(rightmost == <span class="number">1</span>) cnt++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 因為 <code>n</code> 只有 <code>32</code> bit, 所以最多右移 <code>32</code> 次, 故為 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：<code>n &amp; (n-1)</code> 會讓 <code>n</code> 最右邊的 <code>1</code> 變為 <code>0</code>（重要）, 每做一次 <code>cnt++</code>, 直到 <code>n == 0</code> 為止</strong></p><p>e.g. <code>n = 100</code></p><p><img src="https://i.imgur.com/zB7GfKf.png" alt="Untitled"></p><p>e.g. <code>n = 101</code></p><p><img src="https://i.imgur.com/RyZlDKQ.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 因為 <code>n</code> 只有 <code>32</code> bit, 所以最多右移 <code>32</code> 次, 故為 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/post/palindrome-linked-list/"/>
      <url>/post/palindrome-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></strong></p><p><strong>題意：</strong>判斷 linked list 是否迴文。</p></blockquote><p><img src="https://i.imgur.com/dCswt4N.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 <a href="https://zako945.github.io/post/middle-of-the-linked-list/">876. Middle of the Linked List</a> 的方法取得 linked list 的中點<br>然後 reverse 以 <code>slow</code> 為 head 的 linked list, 最後比較兩個 linked list 是否相等<br>(reverse linked list 可參考 <a href="https://zako945.github.io/post/reverse-linked-list/">206. Reverse Linked List</a>)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast != NULL 代表 linked list 之 node 個數為奇數</span></span><br><span class="line">        <span class="keyword">if</span>(fast)</span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 若為奇數, 則中點往後一位</span></span><br><span class="line">        slow = <span class="built_in">reverse</span>(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(slow)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val != head-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112. Path Sum</title>
      <link href="/post/path-sum/"/>
      <url>/post/path-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></strong></p><p><strong>題意：</strong>給一 BT 和一整數 <code>targetSum</code>, 返回是否存在 <strong>root-to-leaf</strong> 之路徑總和為 <code>targetSum</code> 的 path。</p></blockquote><p><img src="https://i.imgur.com/i0rjjOX.png" alt="Untitled"></p><p><img src="https://i.imgur.com/8XRgIUG.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val)</span><br><span class="line">            || <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度最大長度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;); <span class="comment">// sum 初始設 0, 而非 root-&gt;val, 因為等等會加上 root-&gt;val</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">            TreeNode *curNode = front.first;</span><br><span class="line">            <span class="type">int</span> curSum = front.second + curNode-&gt;val;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若為 leaf</span></span><br><span class="line">            <span class="keyword">if</span>(!curNode-&gt;left &amp;&amp; !curNode-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curSum == targetSum)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(curNode-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;curNode-&gt;left, curSum&#125;);</span><br><span class="line">                <span class="keyword">if</span>(curNode-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;curNode-&gt;right, curSum&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>567. Permutation in String</title>
      <link href="/post/permutation-in-string/"/>
      <url>/post/permutation-in-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/permutation-in-string/">https://leetcode.cn/problems/permutation-in-string/</a></strong></p><p><strong>題意：</strong>給兩 string <code>s1</code> 和 <code>s2</code>, 若 <code>s2</code> 包含 <code>s1</code> 的<strong>排列</strong>, 則返回 <code>true</code>。否則, 返回 <code>false</code>。</p><p><code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>substring</strong>。</p><p><strong>注意：</strong>substring 為連續的, subsequence 為非連續的</p></blockquote><p><img src="https://i.imgur.com/XbTG8Fb.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 類似 <a href="https://zako945.github.io/post/minimum-window-substring/">76. Minimum Window Substring</a></strong></p><ul><li>先不斷地增加 <code>right</code> 來擴大窗口</li><li>縮小窗口的時機是窗口大小 <code>≥ s1.size()</code> 時</li><li>當 <code>valid == need.size()</code> 時, 代表窗口中的 substring 為合法的排列</li></ul><p><strong>注意：這題是「固定長度」的窗口, 因為窗口每次向前滑動時只會移出一個字元, 故可以把內層的 while 改成 if, 其效果是一樣的</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right= <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window, need;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s1)</span><br><span class="line">            ++need[ch];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s2[right];</span><br><span class="line">            window[c]++;</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">find</span>(c) != need.<span class="built_in">end</span>() &amp;&amp; window[c] == need[c])</span><br><span class="line">                ++valid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(right - left &gt;= s1.<span class="built_in">size</span>())&#123; <span class="comment">// 固定窗口，可以改成 if 判斷</span></span><br><span class="line">                <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 存在排列 substring</span></span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> d = s2[left];</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(d) != need.<span class="built_in">end</span>() &amp;&amp; window[d] == need[d]) <span class="comment">// 移出前相等</span></span><br><span class="line">                    --valid;</span><br><span class="line">                --window[d];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n1 + n2)$ ➔ 其中 <code>n1</code>、<code>n2</code> 分別為 <code>s1</code>、<code>s2</code> 的長度<ul><li>$O(n1)$：遍歷 <code>s1</code> 計算 <code>need</code></li><li>$O(n2)$：<code>s2</code> 中的每個元素最多被遍歷 <code>2</code> 次（<code>left</code>、<code>right</code>）</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code>、<code>need</code> 長度皆為 $O(26)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66. Plus One</title>
      <link href="/post/plus-one/"/>
      <url>/post/plus-one/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/plus-one/">https://leetcode.cn/problems/plus-one/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>digits</code> 用來表示一非負整數。返回該非負整數 + 1 後所表示的 <code>digits</code>。</p><p>非負整數的最高為儲存在 <code>digits</code> 的首位, 其中 <code>digits[i]</code> 只儲存單個數字。</p><p>除了 <code>0</code> 之外, 其他整數都不會以 <code>0</code> 作為開頭。</p></blockquote><p><img src="https://i.imgur.com/AGxIfBP.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：遍歷 <code>digits</code>, 並紀錄進位 <code>carry</code>。若最後 <code>carry</code> 為 <code>1</code>, 則在 <code>digits</code> 最前面補上 <code>1</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">1</span>; <span class="comment">// 因為最後一位要加 1, 所以把 carry 設成 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            digits[i] = carry + digits[i];</span><br><span class="line">            carry = digits[i] / <span class="number">10</span>;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">            digits.<span class="built_in">emplace</span>(digits.<span class="built_in">begin</span>(), carry);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 改成一旦不用進位, 則終止循環（循環裡會不斷將 <code>digits[i] + 1</code>）, 並返回 digits</strong></p><ul><li><code>digits[i] &lt; 9</code>：代表不用進位, 將 <code>digits[i] + 1</code> 後, 終止循環並返回 <code>digits</code></li><li><code>digits[i] == 9</code>：代表要進位, 將 <code>digits[i]</code> 設為 <code>0</code>, 並繼續循環</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>)&#123;</span><br><span class="line">                ++digits[i];</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 執行到這裡, 代表原先 digits 裡的元素全為 9, 現在全變為 0 了</span></span><br><span class="line">        <span class="comment">// 因此在最前面加入 1 即可, e.g. 999 ➔ 000 ➔ 1000</span></span><br><span class="line">        digits.<span class="built_in">emplace</span>(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>238. Product of Array Except Self</title>
      <link href="/post/product-of-array-except-self/"/>
      <url>/post/product-of-array-except-self/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/product-of-array-except-self/">https://leetcode.cn/problems/product-of-array-except-self/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 返回一 array <code>answer</code>, 其中 <code>answer[i]</code> 為 <code>nums</code> 中除了 <code>nums[i]</code> 以外其餘元素的乘積, 乘積保證在 32-bit 整數的範圍內（不用考慮 overflow）。</p><p><strong>注意：請不要使用除法</strong>, 並在 $O(n)$ time 內解決此問題</p><p><strong>進階：</strong>請設計 $O(1)$ space 的演算法, 其中 output array 不算額外空間</p></blockquote><p><img src="https://i.imgur.com/CDIeTxS.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 prefix 和 postfix, 以 <code>index = i</code> 為分界, <code>prefix[i]</code> 記錄區間 <code>[0, i - 1]</code> 之乘積, <code>postfix[i]</code> 記錄區間 <code>[i + 1, n - 1]</code> 之乘積, 最後 <code>nums[i] = prefix[i] * postfix[i]</code> 即為題目所求</strong></p><ul><li><strong>prefix：</strong><code>prefix[i]</code> 紀錄 <code>num[0] ~ nums[i - 1]</code> 的乘積（由前往後填）</li><li><strong>postfix：</strong><code>postfix[n - i - 1]</code> 紀錄 <code>nums[n - 1] ~ nums[n - i]</code> 的乘積（由後往前填）</li><li><strong>nums：</strong><code>nums[i]</code> 紀錄 <code>prefix[i] * postfix[i]</code>, 也就是除了位置 <code>i</code> 剩餘其他數的乘積</li></ul><p>e.g. <code>nums = [1,2,3,4]</code></p><table><thead><tr><th>nums</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>prefix</td><td>1</td><td>1</td><td>2</td><td>6</td></tr><tr><td>postfix</td><td>24</td><td>12</td><td>4</td><td>1</td></tr><tr><td>nums</td><td>24</td><td>12</td><td>8</td><td>6</td></tr></tbody></table></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">postfix</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            prefix[i] = prefix[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">            postfix[n - i - <span class="number">1</span>] = nums[n - i] * postfix[n - i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = prefix[i] * postfix[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>prefix</code>, <code>postfix</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 將 <code>postfix</code> 直接儲存在 <code>res</code> 中, 然後計算出 <code>prefix</code> 後乘上對應的 <code>postfix</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nums:   [ <span class="number">1</span>,  <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">➔ res: [<span class="number">24</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>] <span class="comment">// postfix 做完</span></span><br><span class="line">➔ res: [<span class="number">24</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">6</span>] <span class="comment">// prefix 做完</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 計算 postfix</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[n - i - <span class="number">1</span>] = res[n - i] * nums[n - i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> prefix = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] *= prefix;</span><br><span class="line">            prefix *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 撇除要返回的 output array <code>res</code>, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>303. Range Sum Query - Immutable</title>
      <link href="/post/range-sum-query-immutable/"/>
      <url>/post/range-sum-query-immutable/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a></strong></p><p><strong>題意：</strong>給一 array, 多次輸入不同的 <code>left</code> 和 <code>right</code>, 求 array 中從 <code>idx = left</code> 到 <code>idx = right</code> 之和。</p></blockquote><p><img src="https://i.imgur.com/JfAhPC1.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法: 每一次 query 都去計算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        nums_ = <span class="built_in">move</span>(nums); <span class="comment">// 複製 nums</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">            sum += nums_[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令 <code>query</code> 次數：<code>m</code> 次, <code>nums</code> 中元素個數：<code>n</code></p><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ <code>m</code> 次 query，每次 query 需 $O(n)$ 時間</li><li><strong>space：</strong>$O(n)$ ➔ <code>nums_</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Prefix Sum, 事先計算前 <code>i</code> 個數之和</strong></p></blockquote><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sums</span> 紀錄前 i 個數之和</span><br><span class="line"><span class="attribute">nums</span>:<span class="meta"> [-2,  0, 3, -5,  2, -1]</span></span><br><span class="line"><span class="attribute">sums</span>:<span class="meta"> [-2, -2, 1, -4, -2, -3]</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">range</span>(left, right):</span><br><span class="line">    <span class="attribute">if</span>(left == <span class="number">0</span>) sum = sums[right] // e.g. range(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="attribute">else</span> sum = sums[right] - sums[left-<span class="number">1</span>] // e.g. range(<span class="number">2</span>, <span class="number">5</span>) -&gt; -<span class="number">3</span> - (-<span class="number">2</span>) = <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sums = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            sums[i] = sums[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span>) <span class="keyword">return</span> sums[right];</span><br><span class="line">        <span class="keyword">return</span> sums[right] - sums[left<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令 <code>query</code> 次數：<code>m</code> 次, <code>nums</code> 中元素個數：<code>n</code></p><ul><li><strong>time：</strong>$O(m+n)$ ➔ $O(n)$ + $m * O(1)$<ul><li>$O(n)$ : 計算 prefix sum 的時間</li><li>$m * O(1)$ : <code>m</code> 次 query, 每次 query 只需 $O(1)$ 時間</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>sums</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>83. Remove Duplicates from Sorted List</title>
      <link href="/post/remove-duplicates-from-sorted-list/"/>
      <url>/post/remove-duplicates-from-sorted-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> linked list, 刪除 linked list 所有重複的元素, 讓每種元素恰好出現一次。</p></blockquote><p><img src="https://i.imgur.com/06GrNA5.png" alt="Untitled"></p><p><img src="https://i.imgur.com/51OBB5i.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：比較當前 node 和 下一個 node 的 val, 若相同則刪除下一個, 直到下一個的值不同, <code>cur</code> 才前進</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr &amp;&amp; curr-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;val == curr-&gt;next-&gt;val)</span><br><span class="line">                curr-&gt;next = curr-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203. Remove Linked List Elements</title>
      <link href="/post/remove-linked-list-elements/"/>
      <url>/post/remove-linked-list-elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-linked-list-elements">https://leetcode.cn/problems/remove-linked-list-elements</a></strong></p><p><strong>題意：</strong>給一整數 <code>val</code>, 刪除 linked list 中所有 <code>node.val == val</code> 的 node。</p></blockquote><p><img src="https://i.imgur.com/zEGcTRx.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：用 <code>dummy</code> 來指向 head, <code>pre</code> 則記住當前 node 的前一個 node<br>初始化 <code>pre</code> 為 <code>dummy</code>(head 的前一個 node)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dummy 指向 link-list 之 head</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *curr = head, *prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;val == val) <span class="comment">// 當前 node 要刪除</span></span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 不刪除, 往下一個 node 前進, current node 變成前一個 node</span></span><br><span class="line">                prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>190. Reverse Bits</title>
      <link href="/post/reverse-bits/"/>
      <url>/post/reverse-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-bits/">https://leetcode.cn/problems/reverse-bits/</a></strong></p><p><strong>題意：</strong>給一無號整數 <code>n</code>, 請將其二進制進行反轉。</p></blockquote><p><img src="https://i.imgur.com/00zH6zZ.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：每次先把 <code>res</code> 的最右 bit 設為 <code>0</code>（左移一位, 最右 bit 補 0）, 然後取得 <code>n</code> 的最右 bit（對 <code>n</code> 的最右 bit 取 OR）, 做完後將 <code>n</code> 右移一位（捨棄最右 bit）</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">           res &lt;&lt;= <span class="number">1</span>; <span class="comment">// 最右 bit 設 0</span></span><br><span class="line">           res |= (n &amp; <span class="number">1</span>); <span class="comment">// 得到 n 的最右 bit</span></span><br><span class="line">           n &gt;&gt;= <span class="number">1</span>; <span class="comment">// 捨棄最右 bit</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ for loop 只需 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="/post/reverse-linked-list/"/>
      <url>/post/reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></strong></p><p><strong>題意：</strong>反轉 linked-list。</p></blockquote><p><img src="https://i.imgur.com/JN4Kd2M.png" alt="Untitled"></p><p><img src="https://i.imgur.com/l7LB6ZU.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：必須要有 <code>prev</code>, <code>nxt</code> 來記住前一個 node 和 下一個 node</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            nxt = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100. Same Tree</title>
      <link href="/post/same-tree/"/>
      <url>/post/same-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/same-tree/">https://leetcode.cn/problems/same-tree/</a></strong></p><p><strong>題意：</strong>給兩 BT, 求兩者是否相等。</p></blockquote><p><img src="https://i.imgur.com/0OPiUyV.png" alt="Untitled"></p><p><img src="https://i.imgur.com/tWUqJkw.png" alt="Untitled"></p><p><img src="https://i.imgur.com/7UBxdM2.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少其中一個為 null, 兩個都為 null 時, return true; 其他情況皆為 false</span></span><br><span class="line">        <span class="keyword">if</span>(!(p &amp;&amp; q)) <span class="keyword">return</span> p == q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兩個皆不為 null</span></span><br><span class="line">        <span class="keyword">return</span> (p-&gt;val == q-&gt;val)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(min(m, n))$ ➔ 其中 <code>m</code>、<code>n</code> 分別是兩個 BT 的 node 個數, 被訪問到的 node 個數不超過較小的 BT 之節點個數</li><li><strong>space：</strong>$O(min(m, n))$ ➔ 遞迴深度不超過較小的 BT 之節點個數</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 要注意 <code>nullptr</code> 也要 insert 到 queue 中, 否則下方範例會出錯</strong></p><p>e.g. <code>左邊 = [1, null, 2]</code>, <code>右邊 = [1, 2]</code></p><p><img src="https://i.imgur.com/ALYOTs3.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少其中一個為 null, 兩個都為 null 時, return true; 其他情況皆為 false</span></span><br><span class="line">        <span class="keyword">if</span>(!(p &amp;&amp; q)) <span class="keyword">return</span> p == q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兩個皆不為 null</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        queue&lt;TreeNode*&gt; q2;</span><br><span class="line">        q1.<span class="built_in">emplace</span>(p);</span><br><span class="line">        q2.<span class="built_in">emplace</span>(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n1 = q1.<span class="built_in">size</span>(), n2 = q2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(n1 != n2)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; ++i)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur1 = q1.<span class="built_in">front</span>(); q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">auto</span> cur2 = q2.<span class="built_in">front</span>(); q2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 這邊做判斷是為了避免下面出錯</span></span><br><span class="line">                <span class="keyword">if</span>(!(cur1 &amp;&amp; cur2))&#123; <span class="comment">// 其中一個為 null</span></span><br><span class="line">                    <span class="keyword">if</span>(cur1 != cur2) <span class="comment">// 一個是 null, 一個不是</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">// 兩個皆為 null</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur1-&gt;val != cur2-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">add_child</span>(q1, cur1);</span><br><span class="line">                <span class="built_in">add_child</span>(q2, cur2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>() &amp;&amp; q2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// nullptr 也要 insert 到 queue 中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_child</span><span class="params">(queue&lt;TreeNode*&gt;&amp; q, TreeNode* node)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">        q.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(min(m, n))$ ➔ 其中 <code>m</code>、<code>n</code> 分別是兩個 BT 的 node 個數, 被訪問到的 node 個數不超過較小的 BT 之節點個數</li><li><strong>space：</strong>$O(min(m, n))$ ➔ <code>q</code> 的元素個數不超過較小的 BT 之節點個數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136. Single Number</title>
      <link href="/post/single-number/"/>
      <url>/post/single-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></strong></p><p><strong>題意：</strong>給一非空的 array <code>nums</code>, 當中只有一個數 <code>n1</code> 只出現一次, 找出 <code>n1</code>。</p></blockquote><p><img src="https://i.imgur.com/jhihJCU.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 XOR 的特性, <code>a ^ a = 0</code> 且 <code>0 ^ b = b</code>, 還有交換性<br>e.g. <code>b ^ a ^ b = a ^ (b ^ b) = a ^ 0 = a</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>977. Squares of a Sorted Array</title>
      <link href="/post/squares-of-a-sorted-array/"/>
      <url>/post/squares-of-a-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> array <code>nums</code>, 求每個數字平方所組成的 <code>sorted</code> array。</p></blockquote><p><img src="https://i.imgur.com/pOCljbp.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 two pointers</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123; <span class="comment">// res 從後面往前填(先填大的)</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[left]) &gt; <span class="built_in">abs</span>(nums[right]))&#123;</span><br><span class="line">                res[i] = nums[left] * nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i] = nums[right] * nums[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ 扣除返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>572. Subtree of Another Tree</title>
      <link href="/post/subtree-of-another-tree/"/>
      <url>/post/subtree-of-another-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/subtree-of-another-tree/">https://leetcode.cn/problems/subtree-of-another-tree/</a></strong></p><p><strong>題意：</strong>給兩棵 BT <code>root</code> 和 <code>subRoot</code>, 求 <code>subRoot</code> 是否為 <code>root</code> 之 subtree。</p></blockquote><p><img src="https://i.imgur.com/dnJkv2i.png" alt="Untitled"></p><p><img src="https://i.imgur.com/8JvUpJg.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 先判斷是否為 Same Tree（可參考 <a href="https://zako945.github.io/post/same-tree/">100. Same Tree</a>）<br>若不是的話, 則遞迴判斷 <code>subRoot</code> 是否為 <code>root</code> 之左子樹 or <code>root</code> 之右子樹</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!subRoot) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// subRoot == null, 則一定為 root 之 subtree</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// root == null &amp;&amp; subRoot != null</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isSameTree</span>(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubtree</span>(root-&gt;left, subRoot)</span><br><span class="line">            || <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(p &amp;&amp; q)) <span class="keyword">return</span> p == q;</span><br><span class="line">        <span class="keyword">return</span> (p-&gt;val == q-&gt;val)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>令 <code>root</code> 的 node 個數為 <code>m</code>, <code>subRoot</code> 的 node 個數為 <code>n</code><br>令 <code>root</code> 的深度為 <code>s</code>, <code>subRoot</code> 的深度為 <code>t</code></strong></p><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 對於 root 中的每個 node <code>s</code>, 都以 <code>s</code> 為 root 檢查 n 個 node</li><li><strong>space：</strong>$O(max(s, t))$ ➔ 遞迴最大深度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. Top K Frequent Elements</title>
      <link href="/post/top-k-frequent-elements/"/>
      <url>/post/top-k-frequent-elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和一整數 <code>k</code>, 返回出現頻率前 <code>k</code> 高的元素。可以按任何順序返回答案。</p><p><strong>進階：</strong>請設計 $O(n \cdot log(n))$ time 的演算法, 其中 <code>n</code> 為 <code>nums.size()</code>。</p></blockquote><p><img src="https://i.imgur.com/Niq9pgv.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap</strong></p><ul><li>計算每種元素的出現次數</li><li>直接將元素 push 到 min heap <code>pq</code> 中</li><li>若 <code>pq.size() &gt; k</code>, 代表現在 <code>pq</code> 中有 <code>k + 1</code> 個元素, 故把最小的元素給 pop 掉, 讓 <code>pq</code> 元素個數始終保持在 <code>k</code> 個</li><li>此時, <code>pq</code> 中的元素為前 <code>k</code> 大的元素, 將其取出即可</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freqs; <span class="comment">// &#123;num, freq&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            ++freqs[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [num, freq] : freqs) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(pii&#123;freq, num&#125;);</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) &#123; <span class="comment">// 讓 pq 始終儲存前 k 大的元素</span></span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>time: $O(n \cdot log(k))$ ➔ <code>pq</code> 最多 insert &#x2F; delete <code>n</code> 個點, 每次操作需 $O(log(k))$, 因為 <code>pq</code> 中最多 <code>k + 1</code> 個點, 其中 <code>n</code> 為 <code>nums</code> 的元素個數</li><li>space: $O(n)$ ➔ <code>freqs</code> 最大長度為 <code>n</code>, 而 <code>pq</code> 的最大長度為 <code>k + 1</code>, 其中 <code>n ≥ k</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/post/two-sum/"/>
      <url>/post/two-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和一整數 <code>target</code>, 求 <code>nums</code> 中兩數和剛好為 <code>target</code> 之 index, 假設每一種 <code>target</code> 只會對應到一組解。</p><p><strong>注意：</strong>同一個元素不可重複使用, 可按照任意順序返回。</p></blockquote><p><img src="https://i.imgur.com/zKI5XRV.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 hash table, 由於題目保證一定有解, 因此對 <code>nums[i]</code> 而言, 先去 hash table 中找 <code>target - nums[i]</code> 是否存在</strong></p><ul><li>若存在, 則直接返回</li><li>否則, 將 <code>nums[i]</code> 還有其 <code>index</code> 加入到 hash table 中</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;  <span class="comment">// &#123;value, index&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> search = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (umap.<span class="built_in">find</span>(search) != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, umap[search]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            umap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：$O(n)$</strong> ➔ <code>umap</code> 的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167. Two Sum II - Input Array Is Sorted</title>
      <link href="/post/two-sum-ii-input-array-is-sorted/"/>
      <url>/post/two-sum-ii-input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/</a></strong></p><p><strong>題意：</strong>給一 index 從 <code>1</code> 開始的整數 array <code>numbers</code>, 該 array 已按照非遞減順序排列, 請從 <code>numbers</code> 中找出相加等於 <code>target</code> 的兩數之 index <code>index1</code>、<code>index2</code>, 其中 <code>1 ≤ index1 ≤ index2 ≤ numbers.length</code>。</p><p>假設每一種 <code>target</code> 只會對應到一組解, 且同一個元素不可重複使用。</p><p>請設計 $O(1)$ space 的演算法。</p></blockquote><p><img src="https://i.imgur.com/DVvXBxC.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：概念同 <a href="https://zako945.github.io/post/3sum/">15. 3Sum</a>, 由於 array 已排序, 故直接使用 Two Pointers 即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>numbers</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242. Valid Anagram</title>
      <link href="/post/valid-anagram/"/>
      <url>/post/valid-anagram/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a></strong></p><p><strong>題意：</strong>給兩 string <code>s</code> 和 <code>t</code>, 返回 <code>t</code> 是否為 <code>s</code> 的字母異位詞(Anagram) 則返回 <code>true</code>, 其中 <code>s</code> 和 <code>t</code> 僅由<strong>小寫</strong>字母所組成。</p><p><strong>字母異位詞 (Anagram) 定義：</strong>若 <code>s</code> 和 <code>t</code> 中每個字母的出現次數都相同, 則 <code>s</code> 和 <code>t</code> 互為字母異位詞。</p><p><strong>進階：</strong>若 input string 包含 Unicode char, 你要如何調整你的解法？</p></blockquote><p><img src="https://i.imgur.com/x5ZFFwG.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：將 <code>s</code>、<code>t</code> 進行排序, 若排序後 <code>s</code>、<code>t</code> 相等, 就代表為 anagram</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Array 來記錄每個字母的出現次數, 若 <code>s</code> 和 <code>t</code> 為 anagram, 則 <code>s 中每個字母的出現頻率 - t 中每個字母的出現頻率</code> 後, 每個字母的出現頻率應皆為 0</strong></p><p>e.g. <code>s = &quot;abc&quot;</code>, <code>t = &quot;cba&quot;</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">freqs</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freqs[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 s 和 t 長度相等的情況下, 若不為 anagram, 則必存在一 char 相減後的 freq &lt; 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(--freqs[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code></li><li><strong>space：</strong>$O(1)$ ➔ $O(26)$, 只需常數空間</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 hash table, 概念同 Solution 1, 但是 Solution 1 只能解決 <code>s</code> 和 <code>t</code> 為小寫字母的問題, Solution 2 可解決 input string 包含 Unicode char 的問題</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freqs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            ++freqs[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--freqs[ch] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code></li><li><strong>space：</strong>$O(S)$ ➔ $S$ 為 <code>s</code> 和 <code>t</code> union 後的 char set 之元素個數, 本題的 <code>S = 26</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="/post/valid-palindrome/"/>
      <url>/post/valid-palindrome/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-palindrome/">https://leetcode.cn/problems/valid-palindrome/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 將其大寫轉換成小寫、並移除非字母和數字的 char, 返回轉換後是否為迴文。</p></blockquote><p><img src="https://i.imgur.com/9LPedjt.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two pointers, 若當前的 char 不為數字 or 字母則跳過, 直到 <code>left</code>、<code>right</code> 相會。判斷式為 <code>left &lt; right</code> 即可, 因為 <code>left == right</code> 時 <code>s[left]</code>、<code>s[right]</code> 必相等, 因此不用判斷</strong></p><p><strong>注意：</strong>判斷完後記得要更新 <code>left</code>、<code>right</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 注意：這裡更新時還是要保持 left &lt; right</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update ptr</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>s</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. Valid Parentheses</title>
      <link href="/post/valid-parentheses/"/>
      <url>/post/valid-parentheses/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></strong></p><p><strong>題意：</strong>給一只包含 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、<code>&#39;&#123;&#39;</code>、<code>&#39;&#125;&#39;</code>、<code>&#39;[&#39;</code>、<code>&#39;]&#39;</code> 的 string <code>s</code>, 判斷 <code>s</code> 是否有效。</p><p>有效的定義如下：</p><ul><li>左括號必須有相同類型的右括號閉合</li><li>左括號必須以正確的順序閉合</li><li>每個右括號都有一個對應的相同類型之左括號</li></ul></blockquote><p><img src="https://i.imgur.com/1vJ8lkJ.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stk.<span class="built_in">emplace</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>(); <span class="comment">// 若 stack 為空, 則代表有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; pairs = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code>, 其中 <code>n</code> 為 <code>s</code> 的長度</li><li><strong>space：</strong>$O(n)$ ➔ stack 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku</title>
      <link href="/post/valid-sudoku/"/>
      <url>/post/valid-sudoku/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-sudoku/">https://leetcode.cn/problems/valid-sudoku/</a></strong></p><p><strong>題意：</strong>判斷 <code>9 x 9</code> 數獨是否有效, 根據以下規則, 判斷已填入的數字是否有效即可。</p><ul><li>數字 <code>1 - 9</code> 在每一行只能出現一次</li><li>數字 <code>1 - 9</code> 在每一列只能出現一次</li><li>數字 <code>1 - 9</code> 在每一個 <code>3 x 3</code> 九宮格中只能出現一次</li></ul><p>空白格以 <code>&#39;.&#39;</code> 表示。</p></blockquote><p><img src="https://i.imgur.com/CZidDFe.png" alt="Untitled"></p><p><img src="https://i.imgur.com/TiCSPjx.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：一旦 <code>board[r][c]</code> 不為 <code>&#39;.&#39;</code>, 就去判斷該 row、col、block 是否有重複的 char</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> target = board[r][c];</span><br><span class="line">                <span class="keyword">if</span> (target == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isValidRow</span>(board, r, target)</span><br><span class="line">                    || !<span class="built_in">isValidCol</span>(board, c, target)</span><br><span class="line">                    || !<span class="built_in">isValidBlock</span>(board, r, c, target)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidRow</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span>&amp; row, <span class="type">const</span> <span class="type">char</span>&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> seen[<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidCol</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span>&amp; col, <span class="type">const</span> <span class="type">char</span>&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> seen[<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen[board[row][col] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBlock</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> <span class="type">int</span>&amp; row, <span class="type">const</span> <span class="type">int</span>&amp; col, <span class="type">const</span> <span class="type">char</span>&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> blockR = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> blockC = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">bool</span> seen[<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = blockR; r &lt; blockR + <span class="number">3</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = blockC; c &lt; blockC + <span class="number">3</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (seen[board[r][c] - <span class="string">&#x27;1&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                seen[board[r][c] - <span class="string">&#x27;1&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 每個 <code>board[r][c]</code> 判斷該 row、col、block 是否重複皆需 $O(9)$, 故總共需 $O((9 * 9) \cdot (3 * 9))$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
