<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/post/3sum/"/>
      <url>/post/3sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 返回 <code>nums</code> 是否存在 <code>[nums[i], nums[j], nums[k]]</code>, 使得 <code>nums[i] + nums[j] + nums[k] == 0</code>, 其中 <code>i != j</code>, <code>i != k</code> 且 <code>j != k</code>。</p><p><strong>注意：</strong>答案中不可包含重複的 tuple。</p></blockquote><p><img src="https://i.imgur.com/yeEmHb3.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers</strong></p><ul><li>首先, 將 <code>nums</code> 由小到大做<strong>排序</strong><ul><li>用來避免取重複的 tuple, 並可使用 two pointer 來移動 ptr</li></ul></li><li>用 <code>i</code> 遍歷 <code>[0, n-3]</code>, 得到 <code>nums[i]</code> —- (1)<ul><li>使用 Two pointer 尋找: <code>left = i + 1</code>, <code>right = n - 1</code> —- (2)</li><li>若 <code>sum &lt; 0</code> : 則 <code>left + 1</code> —- (3)</li><li>若 <code>sum &gt; 0</code> : 則 <code>right - 1</code> —- (4)</li><li>若 <code>sum == 0</code> : 則加入到 <code>res</code> 中, 且 <code>left + 1</code> —- (5)</li></ul></li><li>注意答案中不可包含重複的 tuple, 因此在 (1) 跟 (5) 的地方更新後要判斷是否跟上一個元素相同。若相同則要不斷更新, 直到新元素跟前一個元素不相同</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 若最小的 nums[i] &gt; 0, 則 sum 不可能等於 0</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>; <span class="comment">// 避免重複</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 避免重複</span></span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n^2)$ ➔ $O(n \cdot log(n))$ + $O(n^2)$<ul><li>$O(n \cdot log(n))$ : 排序 <code>nums</code></li><li>$O(n^2)$ : for loop 需 $O(n)$, 其中每一個元素用 two ptr 遍歷剩餘元素需 $O(n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮 output array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>637. Average of Levels in Binary Tree</title>
      <link href="/post/average-of-levels-in-binary-tree/"/>
      <url>/post/average-of-levels-in-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 Binary Tree(BT), 計算每一層的平均值。</p></blockquote><p><img src="https://i.imgur.com/I7IRJWJ.png" alt="Untitled"></p><p><img src="https://i.imgur.com/cZP2nAa.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於樹的高度, worse case 為 skew tree, tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>844. Backspace String Compare</title>
      <link href="/post/backspace-string-compare/"/>
      <url>/post/backspace-string-compare/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/backspace-string-compare/">https://leetcode.cn/problems/backspace-string-compare/</a></strong></p><p><strong>題意：</strong>給兩個 string <code>s</code>, <code>t</code>, 其中的 <code>#</code> 代表 <code>退格(backspace)字元</code>, 求兩字串是否相等。</p></blockquote><p><img src="https://i.imgur.com/DvHelFY.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 two pointers, 其中 <code>slowindex</code> 負責 in-place 記錄新的 string, 而 <code>fastindex</code> 負責遍歷整個 string</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(s) == <span class="built_in">build</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">string <span class="title">build</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> slowindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fastindex = <span class="number">0</span>; fastindex &lt; s.<span class="built_in">size</span>(); ++fastindex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[fastindex] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                slowindex = <span class="built_in">max</span>(<span class="number">0</span>, --slowindex);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s[slowindex++] = s[fastindex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(<span class="number">0</span>, slowindex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code>, 其中 m 為 <code>s</code> 之長度, <code>n</code> 為 <code>t</code> 之長度</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110. Balanced Binary Tree</title>
      <link href="/post/balanced-binary-tree/"/>
      <url>/post/balanced-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 判斷它是否 <strong>height-balanced</strong>。</p><p><strong>height-balanced 的定義：</strong>BT 中每個 node 的左、右子樹的高度差不超過 1。</p></blockquote><p><img src="https://i.imgur.com/iNX9uVN.png" alt="Untitled"></p><p><img src="https://i.imgur.com/jCJucay.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 如果當前 node 的左、右子樹的高度差不超過 1, 且左、右子樹皆為 height-balanced, 則返回 true</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span></span><br><span class="line">            &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 BT 中所有 node</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case : BT 為 skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link href="/post/best-time-to-buy-and-sell-stock/"/>
      <url>/post/best-time-to-buy-and-sell-stock/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></strong></p><p><strong>題意：</strong>給一 array <code>prices</code>, 從左到右分別是每天的股票價格, 求如何買賣可以獲得最大的利潤。</p><p><strong>注意：</strong>買入的天數必須在賣出的天數之前。</p></blockquote><p><img src="https://i.imgur.com/oGeonr9.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Greedy, 紀錄前 <code>i - 1</code> 天的最大利潤、最小價格, 然後計算第 <code>i</code> 天的利潤並比較</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 紀錄前 (i - 1) 天的最大利潤</span></span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>];<span class="comment">// 紀錄前 (i - 1) 天的最小價格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - minPrice);</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>prices</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>704. Binary Search</title>
      <link href="/post/binary-search/"/>
      <url>/post/binary-search/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></strong></p><p><strong>題意：</strong>給一已排序的整數 array <code>nums</code>, 用 binary search 找出 <code>nums</code> 中是否存在 <code>target</code>。若存在, 則返回該元素的 idx；否則, 返回 <code>-1</code>。</p></blockquote><p><img src="https://i.imgur.com/ZzNPVSo.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Binary Search, 找到 left 為第一個 <code>≥ target</code> 的數。若 <code>left</code> 越界 or <code>nums[left] != target</code>, 則代表 <code>target</code> 不存在於 <code>nums</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 當 nums 中所有的元素都比 target 小 (target 不存在), left 會越界 (left = n)</span></span><br><span class="line">        <span class="comment">// 所以在存取 nums[left] 前, 要先判斷 left 是否越界, 否則存取會出錯</span></span><br><span class="line">        <span class="keyword">return</span> (left &lt; n &amp;&amp; nums[left] == target) ? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70. Climbing Stairs</title>
      <link href="/post/climbing-stairs/"/>
      <url>/post/climbing-stairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></strong></p><p><strong>題意：</strong>今天有 <code>n</code> 階樓梯要爬, 每一次你可以選擇要爬 1階 or 2階, 求總共有幾種不同的爬法。</p></blockquote><p><img src="https://i.imgur.com/345Jp3i.png" alt="Untitled"></p><h2 id="Solution-1：（TLE-無法通過）"><a href="#Solution-1：（TLE-無法通過）" class="headerlink" title="Solution 1：（TLE 無法通過）"></a><strong>Solution 1：（TLE 無法通過）</strong></h2><blockquote><p><strong>想法：利用遞迴求解</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>time complexity 證明：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(n) = <span class="built_in">T</span>(n - <span class="number">1</span>) + <span class="built_in">T</span>(n - <span class="number">2</span>) + c</span><br><span class="line">     &lt;= <span class="number">2</span>T(n - <span class="number">1</span>) + c, 取 upper bound <span class="built_in">T</span>(n - <span class="number">2</span>) &lt;= <span class="built_in">T</span>(n - <span class="number">1</span>)</span><br><span class="line">      = <span class="number">2</span>*(<span class="number">2</span>T(n - <span class="number">2</span>) + <span class="number">1</span>) + (<span class="number">1</span> * c)</span><br><span class="line">      = <span class="number">4</span>T(n - <span class="number">2</span>) + (<span class="number">2</span> * c)</span><br><span class="line">      = <span class="number">8</span>T(n - <span class="number">3</span>) + (<span class="number">3</span> * c)</span><br><span class="line">      = <span class="number">2</span>^k * <span class="built_in">T</span>(n - k) + (<span class="number">2</span>^k * c)</span><br><span class="line"></span><br><span class="line">令 k = n , <span class="built_in">T</span>(<span class="number">0</span>) = <span class="number">1</span></span><br><span class="line"><span class="built_in">T</span>(n) &lt;= <span class="number">2</span>^n * <span class="built_in">T</span>(<span class="number">0</span>) + (<span class="number">2</span>^n * c)</span><br><span class="line">      = <span class="number">2</span>^n * (<span class="number">1</span> + c)</span><br></pre></td></tr></table></figure><ul><li><p><strong>time：</strong>$O(2^n)$</p></li><li><p><strong>space：</strong>$O(n)$ ➔ 受限於 tree 的深度, 下圖中可以看到 F(6) 的深度 &#x3D; 6 - 1 &#x3D; n - 1</p><p>  <img src="https://i.imgur.com/vaRiYvD.png" alt="Untitled"></p><p>  <strong>遞迴缺點：重複計算</strong>, e.g. 上圖中可看到 F(3) 被重複呼叫好幾次</p></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 紀錄 0, 1, 2, …, n 階的方法數, 用空間換取時間, 避免重複計算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：改進 Solution 2, <code>dp[i] = dp[i - 1] + dp[i - 2]</code> 中 <code>dp[i]</code> 只會用到前兩步的方法數, 也就是說只需紀錄 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> 就好, 根本不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">1</span>; <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="type">int</span> two = <span class="number">1</span>; <span class="comment">// dp[i - 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> cur = one + two; <span class="comment">// dp[i]</span></span><br><span class="line">            two = one;</span><br><span class="line">            one = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/post/container-with-most-water/"/>
      <url>/post/container-with-most-water/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/container-with-most-water/">https://leetcode.cn/problems/container-with-most-water/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>height</code> 和一整數 <code>n</code>。有 <code>n</code> 條線其高度為 <code>height[i]</code>, 找出其中的兩條線，使得它們與 x 軸組成的容器可以容納最多的水。</p></blockquote><p><img src="https://i.imgur.com/9XQIlRp.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers</strong></p><ul><li>當前 area &#x3D; 兩條線中<strong>較短</strong>的高度 * 彼此間的距離</li><li><strong>移動較短</strong>那端的 ptr, 盡量保留較長的線</li></ul><p><strong>為何是移動較短那端的 ptr ?</strong> 因為 area 是用下限計算的, 我們希望下限越高越好, 但是下限會受限於上限 ➔ 因此我們採取的策略為<strong>「維持上限、提升下限」</strong></p><p>e.g. <code>height = [1, 3, 5, 7]</code></p><ul><li>最一開始 <code>left = 0</code>, <code>right = 3</code> ➔ <code>nums[left] = 1</code>, <code>nums[right] = 7</code><br>此時 <code>area = min(1, 7) * (3 - 0) = 1 * 3 = 3</code><ul><li><strong>若移動 right</strong> : <code>left = 0</code>, <code>right = 2</code> ➔ <code>nums[left] = 1</code>, <code>nums[right] = 5</code><br>  此時 <code>area = min(1, 5) * (2 - 0) = 1 * 2 = 2</code> 反而更小了</li><li><strong>若移動 left</strong> : <code>left = 1</code>, <code>right = 3</code> ➔ <code>nums[left] = 3</code>, <code>nums[right] = 7</code><br>  此時 <code>area = min(3, 7) * (3 - 1) = 3 * 2 = 6</code></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> area = <span class="built_in">min</span>(height[left], height[right]) * (right - left);</span><br><span class="line">            res = <span class="built_in">max</span>(res, area);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>height</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>217. Contains Duplicate</title>
      <link href="/post/contains-duplicate/"/>
      <url>/post/contains-duplicate/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/contains-duplicate/">https://leetcode.cn/problems/contains-duplicate/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>nums</code>, 判斷當中是否有重複數字。</p></blockquote><p><img src="https://i.imgur.com/Er5lLKp.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先排序, 再用 loop 兩兩比較 <code>nums[i - 1]</code> 和 <code>nums[i]</code> 是否相等</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ sorting 後 data 仍儲存在 <code>nums</code> 中, 不需要額外空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 hash table 紀錄出現過的元素</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(num) != s.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>s</code> 長度不超過 <code>n</code></li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：比較 <code>nums</code> 和 <code>set(nums)</code> 長度是否相等, 若不相等代表有重複</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() != <span class="built_in">set</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()).<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 將 <code>nums</code> 轉成 <code>set(nums)</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>set(nums)</code> 長度不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022. Convert 1D Array Into 2D Array</title>
      <link href="/post/convert-1d-array-into-2d-array/"/>
      <url>/post/convert-1d-array-into-2d-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/convert-1d-array-into-2d-array/">https://leetcode.cn/problems/convert-1d-array-into-2d-array/</a></strong></p><p><strong>題意：</strong>將 1d array <code>original</code> 轉成 <code>m</code> 列 <code>n</code> 行的 2d array。</p></blockquote><p><img src="https://i.imgur.com/Ys9chvQ.png" alt="Untitled"></p><p><img src="https://i.imgur.com/DMHTmAS.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：每次塞 <code>1 x n</code> 的 vector</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">construct2DArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; original, <span class="type">int</span> m, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m * n != original.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i += n)</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(original.<span class="built_in">begin</span>() + i, original.<span class="built_in">begin</span>() + i + n));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 遍歷 <code>original</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>338. Counting Bits</title>
      <link href="/post/counting-bits/"/>
      <url>/post/counting-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/counting-bits/">https://leetcode.cn/problems/counting-bits/</a></strong></p><p><strong>題意：</strong>給一整數 <code>n</code>, 對於 <code>0 ≤ i ≤ n</code> 中的每個 <code>i</code>, 計算其在二進制中 <code>1</code> 的個數, 返回一個長度為 <code>n + 1</code> 的 array 作為答案。</p></blockquote><p><img src="https://i.imgur.com/xLkiXO6.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：判斷 <code>i</code> 最靠右的 bit 是否為 <code>1</code>。若是的話, 則 <code>cnt++</code>, 每次判斷完後就將 <code>i</code> 右移一位, 直到 <code>i = 0</code>（沒有 1-bit）為止</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> val = i; val &gt; <span class="number">0</span>; val &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> rightmost = val &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(rightmost == <span class="number">1</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ $n * O(log(n))$<ul><li>$O(log(n))$ : <code>n</code> 右移 <code>1</code> 位等價 <code>n</code> 除以 <code>2</code>, 令 <code>k</code> 為右移次數, $\dfrac{n}{2^k} &#x3D; 1$ ➔ $k &#x3D; log(n)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要返回的 array, 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DP, 因為透過觀察發現：</strong></p><p><strong>1. 前一數（偶數）的 1 之個數 + 1, 因為偶數最右邊的 bit 必為 0, 奇數多的就是最右邊的 bit</strong></p><ul><li>e.g. 3 &#x3D; 011, 2 &#x3D; 010 ➔ 故 3 的 1 之個數 &#x3D; 2 的 1 之個數 + 1</li></ul><p><strong>2. 偶數的 1 之個數 &#x3D; （該數 &#x2F; 2） 的 1 之個數, 因為偶數最右邊的 bit 必為 0, 所以偶數往右移一位, 該數的 1 之個數並不會減少</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            dp[i] = (i &amp; <span class="number">1</span>) ? dp[i - <span class="number">1</span>] + <span class="number">1</span> : dp[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $n * O(1)$<ul><li><code>dp[i]</code> 都是去存取先前已計算過的 <code>dp[i-1]</code> 或 <code>dp[i &gt;&gt; 1]</code>, 故每一次計算 <code>dp[i]</code> 故只需花 $O(1)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ 若不考慮要返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>543. Diameter of Binary Tree</title>
      <link href="/post/diameter-of-binary-tree/"/>
      <url>/post/diameter-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求任兩點的 path 之最大長度。</p><ul><li>最大長度<strong>：</strong>最長 path 上的 <code>edge</code> 數</li></ul></blockquote><p><img src="https://i.imgur.com/NkrA6am.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, LP(node) 返回以 <code>node</code> 為 root 的 subtree 之最長路徑, 只有當前 node 可以同時使用左子樹和右子樹（由左至右分別是 1, 2, 1）, 也就是計算 <code>res</code> 時可用, 但返回時只能 return 單邊路徑。由於 path 不一定要經過 root, 因此可用 global 變數 <code>res</code> 來記錄最長 path 之長度</strong></p><p><img src="https://i.imgur.com/48fZdOl.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">LP</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LP</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">LP</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">LP</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        res = <span class="built_in">max</span>(res, left + right); <span class="comment">// 只有當前 root 可以同時使用左子樹和右子樹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right); <span class="comment">// 每個 node 都看成是轉折點, 只能返回單邊路徑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 取決於遞迴深度, worse case：skew tree</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>271. Encode and Decode Strings</title>
      <link href="/post/encode-and-decode-strings/"/>
      <url>/post/encode-and-decode-strings/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/encode-and-decode-strings/">https://leetcode.cn/problems/encode-and-decode-strings/</a></strong></p><p><strong>題意：</strong>給一 string list <code>strs</code>, 請設計一演算法, 讓 encode 後的 string 可以透過網路高效傳輸, 並透過 decode 還原回原本的 string list。</p><p><strong>注意：</strong></p><ul><li>string 可能會包含所有的 ASCII char, 所以你設計的演算法要能處理任何可能出現的 char</li><li>請勿使用 <code>class member</code>、<code>global variable</code>、<code>static variable</code> 來儲存額外的狀態</li></ul></blockquote><p><img src="https://i.imgur.com/ftVLgXk.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：不能只在兩個 string 間只用一個分隔符 (delimiter) 隔開, 因為也有可能 input 中恰好有該分隔符組成的 string</strong></p><p>e.g. <code>delimiter = &#39;#&#39;</code>, <code>strs = [&#39;1&#39;, &#39;2#3&#39;]</code></p><p>這樣會得到錯誤的答案 <code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</code>, 而非 <code>[&#39;1&#39;, &#39;2#3&#39;]</code></p><p><strong>因此, 要額外紀錄每個 string 的長度：</strong></p><ul><li>Encode 時, 在每個 string <code>s</code> 前面加上長度 <code>s.size()</code> 和分割符 <code>#</code></li><li>Decode 時, 首先找出 idx <code>i</code> 往後的第一個 <code>#</code>, 假設其 idx 為 <code>j</code>, 則 <code>s[i, j)</code> 轉成 int 後即為 <code>s</code> 的長度。從 <code>j + 1</code> 往後(含)取 <code>s[i, j)</code> 個 char 即可得到當前的 <code>s</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a list of strings to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : strs)</span><br><span class="line">            res += <span class="built_in">to_string</span>(s.<span class="built_in">size</span>()) + <span class="string">&#x27;#&#x27;</span> + s;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a single string to a list of strings.</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">decode</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(s[j] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                ++j;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(i, j - i)); <span class="comment">// s[i, j) 為長度, 可能不為個位數</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(j + <span class="number">1</span>, len)); <span class="comment">// push 當前的 string</span></span><br><span class="line">            i = j + <span class="number">1</span> + len; <span class="comment">// 更新下一次開始的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><strong>encode：</strong>$O(n)$ ➔ <code>n</code> 為 <code>strs</code> 中所有 string 的總長度</li><li><strong>decode：</strong>$O(n)$ ➔ <code>n</code> 為 <code>s</code> 的長度</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ 皆需要 $O(n)$ 來儲存原先所有的 string</li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link href="/post/evaluate-reverse-polish-notation/"/>
      <url>/post/evaluate-reverse-polish-notation/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></strong></p><p><strong>題意：</strong>給一 postorder, 返回 inorder 的運算結果。</p><p>保證 postorder 運算式皆為有效的, 不會有除數為 <code>0</code> 的情況。</p></blockquote><p><img src="https://i.imgur.com/Fib7hlW.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack, 一旦當前 <code>token</code> 為數字, 則 push 到 stack 中; 否則, 取出 stack 中最上面的兩個 top 元素出來做運算, 並把運算結果 push 到 stack 中。重複以上步驟, 最後 stack 會剩下一個元素, 也就是最終的運算結果</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; token : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(token))</span><br><span class="line">                stk.<span class="built_in">emplace</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 注意順序</span></span><br><span class="line">                <span class="type">int</span> n2 = <span class="built_in">get_topNum</span>();</span><br><span class="line">                <span class="type">int</span> n1 = <span class="built_in">get_topNum</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span>(token[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 + n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 - n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(<span class="built_in">long</span>(n1) * <span class="built_in">long</span>(n2));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">emplace</span>(n1 / n2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isdigit</span><span class="params">(string&amp; token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_topNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop, 其中 <code>n</code> 為 <code>token</code> 的個數</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>448. Find All Numbers Disappeared in an Array</title>
      <link href="/post/find-all-numbers-disappeared-in-an-array/"/>
      <url>/post/find-all-numbers-disappeared-in-an-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/</a></strong></p><p><strong>題意：</strong>原本有一包含 <code>[1, n]</code> 總共 <code>n</code> 個數的 array, 今給一個 <code>n</code> 個數的 array (含重複數) <code>nums</code>, 找出所有缺失的數。</p></blockquote><p><img src="https://i.imgur.com/uWoILtq.png" alt="Untitled"></p><hr><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將數字設為 負數 來標記我們看到的數字的 index, 然後遍歷 <code>nums</code> 元素, 若 <code>nums[i] &gt; 0</code>, 代表數字 <code>i + 1</code> 沒出現過</strong></p><p>e.g. <code>[1, 2, 2]</code> ➔ <code>[-1, -2, 2]</code>, 其中 <code>nums[0]</code> 紀錄數字 1 是否出現</p><p>因為數字 1 有出現, 所以 <code>nums[0]</code> 被設為負數, 依此類推</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 將數字設為負數來標記我們看到的數字的index</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 扣除返回的 array, 且缺失 idx 都儲存在 <code>nums</code> 中, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>744. Find Smallest Letter Greater Than Target</title>
      <link href="/post/find-smallest-letter-greater-than-target/"/>
      <url>/post/find-smallest-letter-greater-than-target/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/">https://leetcode.cn/problems/find-smallest-letter-greater-than-target/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> char array <code>letters</code>, 在其中找到比 <code>target</code> 大的最小 char。</p><p><strong>注意：</strong><code>letters</code> 是循環的</p><ul><li>e.g. <code>target == &#39;z&#39;</code> 且 <code>letters == [&#39;a&#39;, &#39;b&#39;]</code>, 則返回 <code>&#39;a&#39;</code></li></ul></blockquote><p><img src="https://i.imgur.com/8BY6pKe.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 binary search</strong></p><ul><li><code>letters[mid] &gt; target</code> 時, 往左查找, 看是否有比 <code>mid</code> 更小的</li><li><code>letters[mid] &lt;= target</code> 時, 往右查找</li></ul><p>最後記得檢查是否 <code>&gt; target</code>, 如果不滿足(代表 <code>letters</code> 中沒有 <code>&gt; target</code> 的 char), 則返回 <code>letters[0]</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; letters, <span class="type">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = letters.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 避免 overflow</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &gt; target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[left] &gt; target ? letters[left] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ Binary Search</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Binary Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. Generate Parentheses</title>
      <link href="/post/generate-parentheses/"/>
      <url>/post/generate-parentheses/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/generate-parentheses/">https://leetcode.cn/problems/generate-parentheses/</a></strong></p><p><strong>題意：</strong>數字 <code>n</code> 代表生成括號的對數, 生成所有可能的且<strong>有效的</strong>括號組合。</p></blockquote><p><img src="https://i.imgur.com/3fkGh4I.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS + Backtracking</strong></p><ul><li><p>當 <code>左括號個數 &lt; n</code> 時, 可以加入左括號</p></li><li><p>當 <code>右括號個數 &lt; 左括號個數</code> 時, 可以加入右括號</p><p>  <img src="https://i.imgur.com/TmAGVht.png" alt="Untitled"></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string cur;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>&amp; n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == n &amp;&amp; right == n)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)&#123;</span><br><span class="line">            cur += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(left + <span class="number">1</span>, right, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)&#123;</span><br><span class="line">            cur += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(left, right + <span class="number">1</span>, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(\dfrac{4^n}{n \sqrt n})$ ➔ 取決於第 <code>n</code> 個 Catalan number $\dfrac{1}{n+1} \left(\begin{array}{ccc} 2n \\ n \ \end{array} \right)$, 近似於 $O(\dfrac{4^n}{n \sqrt n})$<br><a href="https://math.stackexchange.com/questions/1986247/asymptotic-approximation-of-catalan-numbers">證明網址(不重要)</a></li><li><strong>space：</strong>$O(n)$ ➔ 撇除要返回的 array <code>res</code>, 取決於遞迴深度, 遞迴最大深度為 <code>2n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/post/group-anagrams/"/>
      <url>/post/group-anagrams/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a></strong></p><p><strong>題意：</strong>給一 string list <code>strs</code>, 其中 <code>strs[i]</code> 僅由小寫字母所組成, 將 <code>strs</code> 中的<strong>字母異位詞 (Anagram)</strong> 進行分組, 可按任意順序返回。</p><p><strong>字母異位詞 (Anagram) 定義 ：</strong>若 <code>s</code> 和 <code>t</code> 中每個字母的出現次數都相同, 則 <code>s</code> 和 <code>t</code> 互為字母異位詞。</p></blockquote><p><img src="https://i.imgur.com/EGOaFHh.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Sorting + hash table, 遍歷每個 string <code>s</code>, 並對其進行排序得到 string key, 將 <code>key</code> 和對應的 <code>s</code> 加入到 hash table 中。最後再根據 <code>key</code> 取出整個 group 即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : strs)&#123;</span><br><span class="line">            string key = s;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            groups[key].<span class="built_in">emplace_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [key, group] : groups)</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(group);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n \cdot log(n))$ ➔ 其中 <code>m</code> 為 string 的個數, <code>n</code> 為 string 的平均長度。<ul><li>$O(n \cdot log(n))$：<code>s</code> 進行 sorting 的時間</li></ul></li><li><strong>space：</strong>$O(m \cdot n)$ ➔ hash table 中儲存所有的 string</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 hash table, 紀錄每個 string <code>s</code> 中每種 char 出現的頻率, 並把每種 char 的頻率當作是 key, 連同 <code>s</code> 一起加入到 hash table 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : strs)&#123;</span><br><span class="line">            <span class="function">string <span class="title">freqs</span><span class="params">(<span class="number">26</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>; <span class="comment">// 用 string 代替 vector 紀錄出現頻率</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : str)</span><br><span class="line">                freqs[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            groups[freqs].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [freq, group] : groups)</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(group);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 所有 string 中每種 char 的出現頻率, 其中 <code>m</code> 為 <code>strs</code> 的元素個數, <code>n</code> 為 <code>strs[i]</code> 的平均長度</li><li><strong>space：</strong>$O(m \cdot n)$ ➔ <code>groups</code> 儲存所有的 string</li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202. Happy Number</title>
      <link href="/post/happy-number/"/>
      <url>/post/happy-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></strong></p><p><strong>題意：</strong>判斷整數 <code>n</code> 是否為<strong>快樂數</strong>。</p><p><strong>快樂數</strong>的定義為<strong>：</strong></p><ul><li>對於一正整數, 每次將該數轉換為它每一位數的平方和</li><li>重複此步驟直到該數為 <code>1</code>, 也有可能進入無窮迴圈（始終無法變成 <code>1</code> ）</li><li>如果該數能變成 <code>1</code>, 則它就是快樂數</li></ul><p>若 <code>n</code> 為快樂數, 則返回 <code>true</code>; 否則, 返回 <code>false</code>。</p></blockquote><p><img src="https://i.imgur.com/1nDigjm.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table 來記錄出現過的數, 一旦重複出現, 代表會無限循環</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s&#123;n&#125;;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">            n = <span class="built_in">squareSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(n) != s.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.<span class="built_in">emplace</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ 令 <code>k</code> 為 <code>n</code> 除以 <code>10</code> 的次數, $\dfrac{n}{10^k} &#x3D; 1 ➔ k &#x3D; log(n)$</li><li><strong>space：</strong>$O(log(n))$ ➔ <code>s</code> 中儲存 $log(n)$ 次轉換後的元素</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：概念同 Solution 1, 只是改成利用 Two Pointers 來判斷是否出現重複的數, 可參考 <a href="https://zako945.github.io/post/linked-list-cycle/">141. Linked List Cycle</a>, <code>slow</code> 每次只轉換一次, 而 <code>fast</code> 每次轉換兩次</strong></p><ul><li>若存在循環（重複數）, 則 <code>slow</code> 和 <code>fast</code> 必相遇（<code>fast</code> 倒追 <code>slow</code>） ➔ <code>n</code> 不為快樂數</li><li>若不存在循環, 經過 <code>x</code> 步後 <code>fast</code> 必先變成 1, 然後再經過 <code>x</code> 步後 <code>slow</code> 才會接著變成 1</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="built_in">squareSum</span>(n);</span><br><span class="line">        <span class="type">int</span> fast = <span class="built_in">squareSum</span>(<span class="built_in">squareSum</span>(n));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = <span class="built_in">squareSum</span>(slow);</span><br><span class="line">            fast = <span class="built_in">squareSum</span>(<span class="built_in">squareSum</span>(fast));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(log(n))$ ➔ 令 <code>k</code> 為 <code>n</code> 除以 <code>10</code> 的次數, $\dfrac{n}{10^k} &#x3D; 1 ➔ k &#x3D; log(n)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1065. Index Pairs of a String</title>
      <link href="/post/index-pairs-of-a-string/"/>
      <url>/post/index-pairs-of-a-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/index-pairs-of-a-string/">https://leetcode.cn/problems/index-pairs-of-a-string/</a></strong></p><p><strong>題意：</strong>給一 string <code>text</code> 和 string list <code>words</code>, 求所有 <code>index pair</code> 使得 <code>text[i~j]</code> 出現在 <code>words</code> 中。</p></blockquote><p><img src="https://i.imgur.com/ITZF5on.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：暴力搜尋法</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">indexPairs</span>(string text, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="type">int</span> m = text.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordset</span><span class="params">(words.begin(), words.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>; start &lt; m; ++start) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> end = start; end &lt; m; ++end) &#123;</span><br><span class="line">                string cur = text.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(wordset.<span class="built_in">count</span>(cur))</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;start, end&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令總共有 <code>n</code> 個 word, 其中 $w_i$ 代表 <code>words[i]</code> 的長度, 且 text 之長度為 <code>m</code></p><ul><li><strong>time：</strong>$O(m^2 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ 因為 c++ 的 <strong><code>find()</code></strong> 不是用 <strong>KMP</strong> 實作的<ul><li>$O(m^2)$<strong>：</strong>每次以 <code>start</code> 為起點往後遍歷, 取 <code>text[start:end]</code> 然後去判斷是否在 <code>wordset</code> 中<ul><li>$m + (m-1) + (m-2) + … + 1$ &#x3D; $\dfrac{(m+1)\cdot m}{2}$</li></ul></li><li>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$<strong>：</strong>每次判斷 <code>text[start:end]</code> 是否在 <code>wordset</code> 中</li></ul></li><li><strong>space：</strong>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ <code>wordset</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Trie(prefix tree), 可參考 <a href="https://zako945.github.io/post/implement-trie-prefix-tree/">208. Implement Trie (Prefix Tree)</a></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> is_end = <span class="literal">false</span>; <span class="comment">// 預設每個 char 不為 end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : word)&#123;</span><br><span class="line">            <span class="type">int</span> i = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;children[i])</span><br><span class="line">                p-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            p = p-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;is_end = <span class="literal">true</span>; <span class="comment">// 將最後一個 char 設為 end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">search</span>(string text, vector&lt;string&gt;&amp; words)&#123;</span><br><span class="line">        <span class="type">int</span> m = text.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>; start &lt; m; ++start)&#123;</span><br><span class="line">            TrieNode *p = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> end = start; end &lt; m &amp;&amp; p != <span class="literal">nullptr</span>; ++end)&#123;</span><br><span class="line">                p = p-&gt;children[text[end] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(p &amp;&amp; p-&gt;is_end)</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;start, end&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">indexPairs</span>(string text, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        Trie trie;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; word : words)</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        <span class="keyword">return</span> trie.<span class="built_in">search</span>(text, words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令總共有 <code>n</code> 個 word, 其中 $w_i$ 代表 <code>words[i]</code> 的長度, 且 text 之長度為 <code>m</code></p><ul><li><strong>time：</strong>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i + m^2)$<ul><li>$O(\displaystyle\sum_{i&#x3D;1}^{n}w_i)$ : insert 所有 word 到 Trie 中</li><li>$O(m^2)$ : 每次以 <code>start</code> 為起點往後遍歷, 判斷 <code>text[start:end]</code> 是否在 Trie 中<ul><li>$m + (m-1) + (m-2) + … + 1 &#x3D;$ $\dfrac{(m+1)\cdot m}{2}$</li></ul></li></ul></li><li><strong>space：</strong>$O(26 \cdot \displaystyle\sum_{i&#x3D;1}^{n}w_i)$ ➔ worse case : 每個 word 的 <code>prefix</code> 皆不重覆<ul><li>總共 <code>n</code> 個 word, 每一個 word 有 $w_i$ 個 node, 而每個 node 又有 26 個 children</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>226. Invert Binary Tree</title>
      <link href="/post/invert-binary-tree/"/>
      <url>/post/invert-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 反轉其左右子樹。</p></blockquote><p><img src="https://i.imgur.com/0KPB1wQ.png" alt="Untitled"></p><p><img src="https://i.imgur.com/UQcx1Lg.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ worse case : skew tree, 遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(cur-&gt;left, cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>703. Kth Largest Element in a Stream</title>
      <link href="/post/kth-largest-element-in-a-stream/"/>
      <url>/post/kth-largest-element-in-a-stream/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">https://leetcode.cn/problems/kth-largest-element-in-a-stream/</a></strong></p><p><strong>題意：</strong>設計一個找到 stream 中第 <code>k</code> 大的元素。注意是排序後的第 <code>k</code> 大元素, 而非第 <code>k</code> 個不同的元素。</p><p><strong>實現 <code>KthLargest</code> class：</strong></p><ul><li><code>KthLargest(int k, int[] nums)</code>：使用 <code>k</code> 和 <code>nums</code> 來初始化 instance</li><li><code>int add(int val)</code>：將 <code>val</code> 加入倒 <code>nums</code> 中, 並返回第 <code>k</code> 大的元素</li></ul></blockquote><p><img src="https://i.imgur.com/wRrfh84.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution</strong>：</h2><blockquote><p><strong>想法：利用 Heap, 使用 min heap <code>pq</code> 來記錄前 <code>k</code> 大的元素, 其中 <code>pq.top()</code> 代表當前第 <code>k</code> 大的元素</strong></p><ul><li><code>KthLargest(k, nums)</code>：先 push <code>nums[i]</code>, 然後確認 <code>pq.size()</code> 是否 &gt; k。若是的話, 則把 <code>pq.top()</code> 給 pop 掉, 讓 <code>pq</code> 的元素個數維持在 <code>k</code> 個</li><li><code>add(val)</code>：先 push <code>val</code>, 然後確認 <code>pq.size()</code> 是否 <code>&gt; k</code>。若是的話, 則把 <code>pq.top()</code> 給 pop 掉, 讓 <code>pq</code> 的元素個數維持在 <code>k</code> 個</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        k_ = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            <span class="built_in">add</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k_)</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> k_;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong><ul><li><code>KthLargest(k, nums)</code>：$O(n \cdot log(k))$, 其中 <code>n</code> 為 <code>nums</code> 中的元素個數, 因為 heap 要 add &#x2F; delete 元素皆需花 $O(log(k))$ 來調整 heap</li><li><code>add(val)</code>：$O(log(k))$ ➔ heap 要 add &#x2F; delete 元素皆需花 $O(log(k))$ 來調整 heap</li></ul></li><li><strong>space：</strong>$O(k)$ ➔ <code>pq</code> 中的元素不超過 <code>k + 1</code> 個</li></ul>]]></content>
      
      
      <categories>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1046. Last Stone Weight</title>
      <link href="/post/last-stone-weight/"/>
      <url>/post/last-stone-weight/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/last-stone-weight/">https://leetcode.cn/problems/last-stone-weight/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>stones</code>, 其中 <code>stones[i]</code> 代表第 <code>i</code> 塊石頭的重量。</p><p>每一回合取出最重的兩塊石頭, 並將其互相撞擊。假設石頭的重量分別為 <code>x</code>、<code>y</code>, 且 <code>x ≤ y</code>。則撞擊後的可能結果如下<strong>：</strong></p><ul><li>若 <code>x == y</code>, 則兩塊石頭都將完全粉碎</li><li>若 <code>x != y</code>, 則重量為 <code>x</code> 的石頭將完全粉碎, 而重量為 <code>y</code> 的石頭之新重量為 <code>y - x</code></li></ul><p>最後, 頂多剩下一塊石頭。若沒有石頭剩下, 則返回 <code>0</code>; 否則, 返回該石頭的重量。</p></blockquote><p><img src="https://i.imgur.com/tUYixRb.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap, 先將所有的元素 push 到 max heap <code>pq</code> 中, 再從 <code>pq</code> 中兩兩取出元素做運算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// max heap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; stone : stones)</span><br><span class="line">            pq.<span class="built_in">emplace</span>(stone);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> y = <span class="built_in">getTop</span>(pq);</span><br><span class="line">            <span class="keyword">auto</span> x = <span class="built_in">getTop</span>(pq);</span><br><span class="line">            pq.<span class="built_in">emplace</span>(y - x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">getTop</span><span class="params">(priority_queue&lt;T&gt;&amp; pq)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ 將所有的 stone push 到 <code>pq</code> 中、將所有 stone 取出來做運算, 其中 <code>n</code> 為 stone 的個數</li><li><strong>space：</strong>$O(n)$ ➔ <code>pq</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle</title>
      <link href="/post/linked-list-cycle/"/>
      <url>/post/linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></strong></p><p><strong>題意：</strong>判斷 linked list 中是否有 cycle。</p></blockquote><p><img src="https://i.imgur.com/Ylw08jF.png" alt="Untitled"></p><p><img src="https://i.imgur.com/m3WoSHi.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用兩個不同步長的 ptr, <code>slow</code> 每次只走一步, 而 <code>fast</code> 每次走兩步</strong></p><ul><li>若存在循環, 則 <code>slow</code> 和 <code>fast</code> 必相遇（<code>fast</code> 倒追 <code>slow</code>）</li><li>若不存在循環, <code>fast</code> 必先抵達 <code>nullptr</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判斷 fast, 因為若沒有 cycle, fast 會比較快抵達 nullptr</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 一次走一步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 一次走兩步</span></span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中的元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128. Longest Consecutive Sequence</title>
      <link href="/post/longest-consecutive-sequence/"/>
      <url>/post/longest-consecutive-sequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></strong></p><p><strong>題意：</strong>給一<strong>未排序的</strong> array <code>nums</code>, 找出數字連續的最長 sequence（不要求 sequence 元素再 <code>nums</code> 中位置連續）。</p><p><strong>注意：</strong>請設計 $O(n)$ time 的演算法</p></blockquote><p><img src="https://i.imgur.com/JkHCMuK.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：將 <code>nums</code> 視覺化發現, 每個 sequence 形成的首要條件就是開頭的數左邊沒有數, 結尾的數右邊沒有數</strong></p><p><img src="https://i.imgur.com/RZNbX7F.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : s)&#123;</span><br><span class="line">            <span class="comment">// 判斷左邊的數有無在 hash table 中</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(num - <span class="number">1</span>) == s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="type">int</span> end = num + <span class="number">1</span>; <span class="comment">// 若沒有, 則 num 可當作 sequence 的開頭</span></span><br><span class="line">                <span class="keyword">while</span>(s.<span class="built_in">find</span>(end) != s.<span class="built_in">end</span>())</span><br><span class="line">                    ++end;</span><br><span class="line">                res = <span class="built_in">max</span>(res, end - num); <span class="comment">// 檢查是否為最長 sequence</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 雖然有 for loop 和 while loop, 但是每一個數<strong>最多</strong>被訪問 2 次<ul><li>一次是 <code>for(auto&amp; num : nums)</code></li><li>一次是 <code>if(s.find(num - 1) == s.end())</code>, 也就是剛好是某數的左邊</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>s</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>424. Longest Repeating Character Replacement</title>
      <link href="/post/longest-repeating-character-replacement/"/>
      <url>/post/longest-repeating-character-replacement/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">https://leetcode.cn/problems/longest-repeating-character-replacement/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code> 和一整數 <code>k</code>, 你可以選擇將 <code>s</code> 中的任意字元變成其他大寫英文字母, 該操作最多執行 <code>k</code> 次。</p><p>經上述操作後, 返回<strong>僅包含相同字元</strong>的最大 substring 長度。</p><p>s 由大寫英文字母所組成。</p></blockquote><p><img src="https://i.imgur.com/xPxWZv5.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 將 <code>window</code> 中的元素分成兩部分</strong></p><ul><li>出現頻率最多的元素</li><li>扣掉出現頻率最多的元素後，所剩餘的元素</li></ul><p><strong>若剩餘的元素個數 <code>≤ k</code>, 代表剩餘的元素可全部替換為頻率最多的元素。反之, 則不行。做完後, 更新 <code>res</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">window</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            ++window[c - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若剩餘元素個數 &gt; k，則縮小窗口</span></span><br><span class="line">            <span class="keyword">while</span>(right - left - *<span class="built_in">max_element</span>(window.<span class="built_in">begin</span>(), window.<span class="built_in">end</span>()) &gt; k)&#123;</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                --window[d - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ $O(26 \cdot n)$, <code>s</code> 中的每個元素最多被遍歷 2 次（<code>left</code>、<code>right</code>）<ul><li>$O(26 \cdot n)$：while loop 中每次取 <code>max_element()</code> 需 $O(26)$</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code></li></ul><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a><strong>Solution 2:</strong></h2><blockquote><p><strong>想法: 改善 Solution 1, 將 <code>max_element()</code> 提出, 變成在 while loop 外部維護, 而非在 while loop 中維護</strong></p><ul><li>能這樣做是因為在內層 while loop 中移除 <code>window[s[left]]</code> 後, <code>maxf</code> 只會<strong>越來越小</strong></li><li>也就是說 <code>right - left - maxf(移除前) ≥ right - left - maxf(移除後)</code> 始終是成立的, 因為 <code>maxf(移除後) ≤ maxf(移除前)</code></li><li>若 <code>right - left - maxf(移除前) &gt; k</code> 成立, 則 <code>right - left - maxf(移除後) &gt; k</code> 也必定成立, 因此根本不必在 while loop 中更新 <code>maxf</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            ++window[c];</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 widnow 中出現頻率最高的 char 的個數</span></span><br><span class="line">            <span class="type">int</span> maxf = <span class="built_in">max_element</span>(window.<span class="built_in">begin</span>(), window.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; p1, <span class="keyword">auto</span>&amp; p2)&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">            &#125;)-&gt;second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(right - left - maxf &gt; k)&#123;</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                --window[d];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>s</code> 中的每個元素最多被遍歷 2 次（<code>left</code>、<code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code> 長度為 $O(26)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/post/longest-substring-without-repeating-characters/"/>
      <url>/post/longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 返回一沒有重複 char 的<strong>最長 substring</strong> 的長度。</p></blockquote><p><img src="https://i.imgur.com/jg9qqTK.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 類似 <a href="https://zako945.github.io/post/longest-repeating-character-replacement/">424. Longest Repeating Character Replacement</a>, 每次檢查 <code>s[right]</code> 是否已經在 <code>visited</code> 中</strong></p><ul><li>若是, 則移除 <code>s[left]</code>, 且 <code>left + 1</code>, 直到 <code>visited</code> 中不存在 <code>s[right]</code></li><li>將 <code>s[right]</code> 加入到 <code>visited</code> 中</li><li>更新 <code>res</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); ++right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(visited.<span class="built_in">find</span>(s[right]) != visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">emplace</span>(s[right]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ <code>s</code> 中的每個元素最多被拜訪 <code>2</code> 次（<code>left</code>, <code>right</code>）</li><li><strong>space：</strong>$O(1)$ ➔ <code>cnt</code> 長度最多為 <code>26</code>, 故只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169. Majority Element</title>
      <link href="/post/majority-element/"/>
      <url>/post/majority-element/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/majority-element/">https://leetcode.cn/problems/majority-element/</a></strong></p><p><strong>題意：</strong>給一大小為 <code>n</code> 的 array <code>nums</code>, 找出當中個數<strong>大於</strong> $⌊ \dfrac{n}{2} ⌋$ 的數字(保證存在一個數滿足此條件)。</p><p><strong>進階：</strong>試著用 $O(n)$ time, $O(1)$ space 的演算法解決此問題</p></blockquote><p><img src="https://i.imgur.com/jvwdXOf.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 hash table 紀錄 <code>&#123;num: count&#125;</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, maxCount = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n : nums)&#123;</span><br><span class="line">            ++umap[n];</span><br><span class="line">            <span class="keyword">if</span>(umap[n] &gt; maxCount)&#123;</span><br><span class="line">                res = n;</span><br><span class="line">                maxCount = umap[n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>umap</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p>想法<strong>：</strong>利用 Boyer – Moore 投票法</p><ul><li>當 <code>res = 0</code> 時, 將 <code>res</code> 設為 <code>nums[i]</code></li><li>否則, 檢查 <code>nums[i]</code> 是否為 <code>res</code>。若是的話 <code>res + 1</code>, 否則 <code>res - 1</code></li></ul><p><img src="https://i.imgur.com/ySun2rW.png" alt="Untitled"></p><p><strong>考慮特殊 case</strong>:</p><ol><li><p><code>nums = [2,2,1,1,3]</code>, 得出 <code>res</code> &#x3D; 3</p><table><thead><tr><th>nums[i]</th><th>2</th><th>2</th><th>1</th><th>1</th><th>3</th></tr></thead><tbody><tr><td>cnt</td><td>1</td><td>2</td><td>1</td><td>0</td><td>1</td></tr><tr><td>res</td><td>2</td><td>2</td><td>2</td><td>2</td><td>3</td></tr></tbody></table></li><li><p><code>nums = [2,2,3,4,5]</code>, 得出 <code>res</code> &#x3D; 5</p><table><thead><tr><th>nums[i]</th><th>2</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>cnt</td><td>1</td><td>2</td><td>1</td><td>0</td><td>1</td></tr><tr><td>res</td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td></tr></tbody></table></li></ol><p>➔ 以上情況皆不會在本題出現, 因為 2 的個數並沒有 &gt; $⌊ \dfrac{5}{2} ⌋$<br>➔ <strong>而本題的先決條件就是必有一數的個數 &gt; $⌊ \dfrac{n}{2} ⌋$, 因此 Boyer – Moore 投票法在本題必成立</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">                res = n;</span><br><span class="line">            cnt += (n == res) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104. Maximum Depth of Binary Tree</title>
      <link href="/post/maximum-depth-of-binary-tree/"/>
      <url>/post/maximum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求 <strong>root-to-leaf</strong> 的 path 之最大長度(tree 的最大深度)。</p><ul><li>最大長度<strong>：</strong>path 上的 <code>node</code> 數</li></ul></blockquote><p><img src="https://i.imgur.com/HasniTr.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ worse case : skew tree, 遞迴深度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left) q.<span class="built_in">emplace</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) q.<span class="built_in">emplace</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>252. Meeting Rooms</title>
      <link href="/post/meeting-rooms/"/>
      <url>/post/meeting-rooms/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/meeting-rooms/">https://leetcode.cn/problems/meeting-rooms/</a></strong></p><p><strong>題意：</strong>給定一包含開始時間和結束時間的 <code>intervals</code>, 其中<code>intervals[i] = [starti, endi]</code>, 返回一個人是否可以參加所有會議。</p><p><strong>注意：</strong><code>(0,8)</code>、<code>(8,10)</code> 並不衝突</p></blockquote><p><img src="https://i.imgur.com/3p0FW4o.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：先將 <code>intervals</code> 根據 <code>interval.start</code> 進行排序, 然後判斷當前 <code>interval[i - 1].end</code> 是否大於 <code>interval[i].start</code>。若是的話, 代表會衝突到</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canAttendMeetings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 不需要額外空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Intervals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>617. Merge Two Binary Trees</title>
      <link href="/post/merge-two-binary-trees/"/>
      <url>/post/merge-two-binary-trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></strong></p><p><strong>題意：</strong>給兩棵 BT, 請合併它們。</p><ul><li>如果兩個節點重疊, 則將節點值相加作為合併節點的新值。</li><li>否則, 不為 NULL 的節點將作為新樹的節點。</li></ul></blockquote><p><img src="https://i.imgur.com/ggMDIUx.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// root1, root2 皆存在</span></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ stack 最大長度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. Merge Two Sorted Lists</title>
      <link href="/post/merge-two-sorted-lists/"/>
      <url>/post/merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></strong></p><p><strong>題意：</strong>給兩個 <code>sorted</code> linked list: <code>list1</code> 和 <code>list2</code>, 將兩個合併成一個 <code>sorted</code> linked list。</p></blockquote><p><img src="https://i.imgur.com/CuDl9AB.png" alt="Untitled"></p><p><img src="https://i.imgur.com/uAf35hh.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 dummy node, 其中 <code>tail</code> 指向當前 <code>val</code> 較小的 list node</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *tail = dummy;</span><br><span class="line">        <span class="keyword">while</span>(list1 &amp;&amp; list2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">                tail-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next; <span class="comment">// 指向下一個</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 某中一個 list 結束跳出迴圈, 要處理另一個 list 剩下的元素</span></span><br><span class="line">        <span class="keyword">if</span>(list1)</span><br><span class="line">            tail-&gt;next = list1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2)</span><br><span class="line">            tail-&gt;next = list2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(m + n)$ ➔ 其中 <code>m</code> 為 <code>list1</code> 的長度, <code>n</code> 為 <code>list2</code> 的長度, worse case：每個點都恰拜訪一次</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>876. Middle of the Linked List</title>
      <link href="/post/middle-of-the-linked-list/"/>
      <url>/post/middle-of-the-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/middle-of-the-linked-list/">https://leetcode.cn/problems/middle-of-the-linked-list/</a></strong></p><p><strong>題意：</strong>返回 linked list 的中點, 若 linked list 的 node 數為偶數, 則返回<strong>第二個中點</strong>。</p></blockquote><p><img src="https://i.imgur.com/8nZD1k4.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two Pointers<br><code>slow</code> 一次走一步, <code>fast</code> 一次走兩步, 當 <code>fast</code> 走到 <code>NULL</code> 時, <code>slow</code> 剛好走到中點</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當 n 為偶數時, 跳出迴圈是因為 fast == NULL</span></span><br><span class="line">        <span class="comment">// 當 n 為奇數時, 跳出迴圈是因為 fast-&gt;nxt = NULL</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>746. Min Cost Climbing Stairs</title>
      <link href="/post/min-cost-climbing-stairs/"/>
      <url>/post/min-cost-climbing-stairs/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>cost</code>, 其中 <code>cost[i]</code> 代表從第 <code>i</code> 皆樓梯往上爬所需支付的費用。一旦支付該費用, 可以選擇往上爬一個 or 二個台階。</p><p>可以選擇從 index 為 <code>0</code> or <code>1</code> 的位置開始往上爬。</p><p>請計算到達樓梯頂部 <code>index = cost.size()</code> 所需的最小費用。</p></blockquote><p><img src="https://i.imgur.com/SQZ2B6d.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DP, 定義 <code>dp[i]</code> 為抵達 <code>index = i</code> 所需的最小費用, 因此 <code>dp[i]</code> 為 <code>抵達前一階的最小費用 + 該階的費用</code>、<code>抵達前兩階的最小費用 + 該階的費用</code> 中取較小者</strong></p><ul><li><code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="comment">// index = 0 和 1 的費用都為 0</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(n)$ ➔ <code>dp</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 因為發現計算 <code>dp[i]</code> 只需用到 <code>dp[i - 1]</code>、<code>dp[i - 2]</code> 即可, 也就是說只需紀錄 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code> 就好, 根本不需要開到 <code>n</code> 個空間</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>; <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="type">int</span> two = <span class="number">0</span>; <span class="comment">// dp[i - 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">min</span>(one + cost[i - <span class="number">1</span>], two + cost[i - <span class="number">2</span>]);</span><br><span class="line">            two = one;</span><br><span class="line">            one = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155. Min Stack</title>
      <link href="/post/min-stack/"/>
      <url>/post/min-stack/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/min-stack/">https://leetcode.cn/problems/min-stack/</a></strong></p><p><strong>題意：</strong>設計一個支持 <code>push</code>、<code>pop</code>、<code>top</code> 操作, 並且能在 $O(1)$ time 得到最小元素的 stack。</p><p><strong>實作 <code>MinStack</code> class：</strong></p><ul><li><code>MinStack()</code>：初始化 instance</li><li><code>void push(int val)</code>：將 <code>val</code> push 到 stack 中</li><li><code>void pop()</code>：移除 stack 頂端元素</li><li><code>void top()</code>：得到 stack 頂端元素</li><li><code>int getMin()</code>：得到 stack 中的最小元素</li></ul></blockquote><p><img src="https://i.imgur.com/8x7sde8.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用兩個 Stack, 其中 stack <code>stk</code> 紀錄元素 push &#x2F; pop 的過程, 另一個 stack <code>minStk.top()</code> 紀錄每一次 push 元素到 <code>stk</code> 後, 當前 <code>stk</code> 中的的最小值</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        <span class="comment">// 讓 minStk 初始有一個最大值, 這樣後續 push 時 minStk 一定有 top 元素可比較</span></span><br><span class="line">        minStk.<span class="built_in">emplace</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">emplace</span>(val);</span><br><span class="line">        minStk.<span class="built_in">emplace</span>(<span class="built_in">min</span>(minStk.<span class="built_in">top</span>(), val)); <span class="comment">// 新增元素後, 紀錄當前的最小元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        minStk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minStk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>皆為 $O(1)$</li><li><strong>space：</strong>$O(n)$ ➔ <code>stk</code> 的元素個數最多為 <code>n</code>, <code>minStk</code> 的元素個數最多為 <code>n + 1</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111. Minimum Depth of Binary Tree</title>
      <link href="/post/minimum-depth-of-binary-tree/"/>
      <url>/post/minimum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></strong></p><p><strong>題意：</strong>給一 BT, 求 <strong>root-to-leaf</strong> 的 path 之最小長度(tree 的最小深度)。</p><ul><li>最小長度: path 上的 <code>node</code> 數</li></ul><p><strong>注意：</strong>若今給一 skew tree, 則 <code>min_depth = n</code></p></blockquote><p><img src="https://i.imgur.com/tbUhkxE.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 需遍歷所有 node</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, stack 長度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ skew tree, 需遍歷所有 node</li><li><strong>space：</strong>$O(n)$ ➔ skew tree, stack 長度為 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268. Missing Number</title>
      <link href="/post/missing-number/"/>
      <url>/post/missing-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/missing-number/">https://leetcode.cn/problems/missing-number/</a></strong></p><p><strong>題意：</strong>原本有一包含 <code>[0, n]</code> 總共 <code>n + 1</code> 個數的 array, 今給一只有 <code>n</code> 個數的 array <code>nums</code>, 找出缺失的數。</p></blockquote><p><img src="https://i.imgur.com/qAxMn9S.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：先將 <code>nums</code> 排序, 然後用 loop 檢查第 <code>i</code> 個數是否在 <code>nums</code> 中</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>(); <span class="comment">// Example 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ sorting 後 data 仍儲存在 <code>nums</code> 中, 不需要額外空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：先計算 <code>[0, n]</code> 這 <code>n + 1</code> 個數之和, 然後扣掉 <code>nums</code> 中 data 之和, 即可得到缺失的數</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// 取得 nums 總和</span></span><br><span class="line">        <span class="type">int</span> total = nums.<span class="built_in">size</span>() * (nums.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 計算 0 ~ n 之和</span></span><br><span class="line">        <span class="keyword">return</span> total - sum; <span class="comment">// 相減即為缺值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍例 <code>nums</code> 計算所有 data 之和</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 XOR 中 <code>a ^ a = 0</code> 且 <code>0 ^ a = a</code> 的特性（還有交換性）</strong></p><p>e.g. <code>[0, 1, 2, 3] ^ [0, 1, 3] = 2</code></p><p><strong>XOR：</strong></p><ul><li><code>0 ^ 0 = 0</code></li><li><code>b ^ b = b</code></li><li><code>0 ^ a = a</code></li><li><code>a ^ b ^ b = a ^ (b ^ b) = a ^ 0 = a</code></li><li><strong>交換性：</strong><code>b ^ a ^ b = a ^ (b ^ b) = a ^ 0 = a</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            res = res ^ i ^ nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191. Number of 1 Bits</title>
      <link href="/post/number-of-1-bits/"/>
      <url>/post/number-of-1-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></strong></p><p><strong>題意：</strong>給一無號整數 <code>n</code>, 返回其二進制表示中 <code>1</code> 的個數。</p><p><strong>進階：</strong>如果多次呼叫此 function, 要如何優化？</p></blockquote><p><img src="https://i.imgur.com/hvYGLCW.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：每次判斷 <code>n</code> 的最右 bit 是否為 <code>1</code>, 若是的話, 則 <code>cnt++</code>, 判斷完最右 bit 後將 <code>n</code> 右移一位, 重複以上步驟直到 <code>n == 0</code> （沒有 1-bit）為止</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> rightmost = n &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(rightmost == <span class="number">1</span>) cnt++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 因為 <code>n</code> 只有 <code>32</code> bit, 所以最多右移 <code>32</code> 次, 故為 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：<code>n &amp; (n-1)</code> 會讓 <code>n</code> 最右邊的 <code>1</code> 變為 <code>0</code>（重要）, 每做一次 <code>cnt++</code>, 直到 <code>n == 0</code> 為止</strong></p><p>e.g. <code>n = 100</code></p><p><img src="https://i.imgur.com/zB7GfKf.png" alt="Untitled"></p><p>e.g. <code>n = 101</code></p><p><img src="https://i.imgur.com/RyZlDKQ.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 因為 <code>n</code> 只有 <code>32</code> bit, 所以最多右移 <code>32</code> 次, 故為 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/post/palindrome-linked-list/"/>
      <url>/post/palindrome-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></strong></p><p><strong>題意：</strong>判斷 linked list 是否迴文。</p></blockquote><p><img src="https://i.imgur.com/dCswt4N.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 <a href="https://zako945.github.io/post/middle-of-the-linked-list/">876. Middle of the Linked List</a> 的方法取得 linked list 的中點<br>然後 reverse 以 <code>slow</code> 為 head 的 linked list, 最後比較兩個 linked list 是否相等<br>(reverse linked list 可參考 <a href="https://zako945.github.io/post/reverse-linked-list/">206. Reverse Linked List</a>)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast != NULL 代表 linked list 之 node 個數為奇數</span></span><br><span class="line">        <span class="keyword">if</span>(fast)</span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 若為奇數, 則中點往後一位</span></span><br><span class="line">        slow = <span class="built_in">reverse</span>(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(slow)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val != head-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>567. Permutation in String</title>
      <link href="/post/permutation-in-string/"/>
      <url>/post/permutation-in-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/permutation-in-string/">https://leetcode.cn/problems/permutation-in-string/</a></strong></p><p><strong>題意：</strong>給兩 string <code>s1</code> 和 <code>s2</code>, 若 <code>s2</code> 包含 <code>s1</code> 的<strong>排列</strong>, 則返回 <code>true</code>。否則, 返回 <code>false</code>。</p><p><code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>substring</strong>。</p><p><strong>注意：</strong>substring 為連續的, subsequence 為非連續的</p></blockquote><p><img src="https://i.imgur.com/XbTG8Fb.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Sliding Window, 類似 <a href="https://zako945.github.io/post/minimum-window-substring/">76. Minimum Window Substring</a></strong></p><ul><li>先不斷地增加 <code>right</code> 來擴大窗口</li><li>縮小窗口的時機是窗口大小 <code>≥ s1.size()</code> 時</li><li>當 <code>valid == need.size()</code> 時, 代表窗口中的 substring 為合法的排列</li></ul><p><strong>注意：這題是「固定長度」的窗口, 因為窗口每次向前滑動時只會移出一個字元, 故可以把內層的 while 改成 if, 其效果是一樣的</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right= <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window, need;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s1)</span><br><span class="line">            ++need[ch];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s2[right];</span><br><span class="line">            window[c]++;</span><br><span class="line">            ++right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">find</span>(c) != need.<span class="built_in">end</span>() &amp;&amp; window[c] == need[c])</span><br><span class="line">                ++valid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(right - left &gt;= s1.<span class="built_in">size</span>())&#123; <span class="comment">// 固定窗口，可以改成 if 判斷</span></span><br><span class="line">                <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 存在排列 substring</span></span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> d = s2[left];</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(d) != need.<span class="built_in">end</span>() &amp;&amp; window[d] == need[d]) <span class="comment">// 移出前相等</span></span><br><span class="line">                    --valid;</span><br><span class="line">                --window[d];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n1 + n2)$ ➔ 其中 <code>n1</code>、<code>n2</code> 分別為 <code>s1</code>、<code>s2</code> 的長度<ul><li>$O(n1)$：遍歷 <code>s1</code> 計算 <code>need</code></li><li>$O(n2)$：<code>s2</code> 中的每個元素最多被遍歷 <code>2</code> 次（<code>left</code>、<code>right</code>）</li></ul></li><li><strong>space：</strong>$O(1)$ ➔ <code>window</code>、<code>need</code> 長度皆為 $O(26)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112. Path Sum</title>
      <link href="/post/path-sum/"/>
      <url>/post/path-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></strong></p><p><strong>題意：</strong>給一 BT 和一整數 <code>targetSum</code>, 返回是否存在 <strong>root-to-leaf</strong> 之路徑總和為 <code>targetSum</code> 的 path。</p></blockquote><p><img src="https://i.imgur.com/i0rjjOX.png" alt="Untitled"></p><p><img src="https://i.imgur.com/8XRgIUG.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val)</span><br><span class="line">            || <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ 遞迴深度最大長度為 <code>n</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;); <span class="comment">// sum 初始設 0, 而非 root-&gt;val, 因為等等會加上 root-&gt;val</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">            TreeNode *curNode = front.first;</span><br><span class="line">            <span class="type">int</span> curSum = front.second + curNode-&gt;val;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若為 leaf</span></span><br><span class="line">            <span class="keyword">if</span>(!curNode-&gt;left &amp;&amp; !curNode-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curSum == targetSum)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(curNode-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;curNode-&gt;left, curSum&#125;);</span><br><span class="line">                <span class="keyword">if</span>(curNode-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;curNode-&gt;right, curSum&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 BT</li><li><strong>space：</strong>$O(n)$ ➔ <code>q</code> 中的元素不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66. Plus One</title>
      <link href="/post/plus-one/"/>
      <url>/post/plus-one/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/plus-one/">https://leetcode.cn/problems/plus-one/</a></strong></p><p><strong>題意：</strong>給一整數 array <code>digits</code> 用來表示一非負整數。返回該非負整數 + 1 後所表示的 <code>digits</code>。</p><p>非負整數的最高為儲存在 <code>digits</code> 的首位, 其中 <code>digits[i]</code> 只儲存單個數字。</p><p>除了 <code>0</code> 之外, 其他整數都不會以 <code>0</code> 作為開頭。</p></blockquote><p><img src="https://i.imgur.com/AGxIfBP.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：遍歷 <code>digits</code>, 並紀錄進位 <code>carry</code>。若最後 <code>carry</code> 為 <code>1</code>, 則在 <code>digits</code> 最前面補上 <code>1</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">1</span>; <span class="comment">// 因為最後一位要加 1, 所以把 carry 設成 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            digits[i] = carry + digits[i];</span><br><span class="line">            carry = digits[i] / <span class="number">10</span>;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">            digits.<span class="built_in">emplace</span>(digits.<span class="built_in">begin</span>(), carry);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 改成一旦不用進位, 則終止循環（循環裡會不斷將 <code>digits[i] + 1</code>）, 並返回 digits</strong></p><ul><li><code>digits[i] &lt; 9</code><strong>：</strong>代表不用進位, 將 <code>digits[i] + 1</code> 後, 終止循環並返回 <code>digits</code></li><li><code>digits[i] == 9</code><strong>：</strong>代表要進位, 將 <code>digits[i]</code> 設為 <code>0</code>, 並繼續循環</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>)&#123;</span><br><span class="line">                ++digits[i];</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 執行到這裡, 代表原先 digits 裡的元素全為 9, 現在全變為 0 了</span></span><br><span class="line">        <span class="comment">// 因此在最前面加入 1 即可, e.g. 999 ➔ 000 ➔ 1000</span></span><br><span class="line">        digits.<span class="built_in">emplace</span>(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ for loop</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>238. Product of Array Except Self</title>
      <link href="/post/product-of-array-except-self/"/>
      <url>/post/product-of-array-except-self/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/product-of-array-except-self/">https://leetcode.cn/problems/product-of-array-except-self/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code>, 返回一 array <code>answer</code>, 其中 <code>answer[i]</code> 為 <code>nums</code> 中除了 <code>nums[i]</code> 以外其餘元素的乘積, 乘積保證在 32-bit 整數的範圍內（不用考慮 overflow）。</p><p><strong>注意：請不要使用除法</strong>, 並在 $O(n)$ time 內解決此問題</p><p><strong>進階：</strong>請設計 $O(1)$ space 的演算法, 其中 output array 不算額外空間</p></blockquote><p><img src="https://i.imgur.com/CDIeTxS.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 prefix 和 postfix, 以 <code>index = i</code> 為分界, <code>prefix[i]</code> 記錄區間 <code>[0, i - 1]</code> 之乘積, <code>postfix[i]</code> 記錄區間 <code>[i + 1, n - 1]</code> 之乘積, 最後 <code>nums[i] = prefix[i] * postfix[i]</code> 即為題目所求</strong></p><ul><li><strong>prefix：</strong><code>prefix[i]</code> 紀錄 <code>num[0] ~ nums[i - 1]</code> 的乘積（由前往後填）</li><li><strong>postfix：</strong><code>postfix[n - i - 1]</code> 紀錄 <code>nums[n - 1] ~ nums[n - i]</code> 的乘積（由後往前填）</li><li><strong>nums：</strong><code>nums[i]</code> 紀錄 <code>prefix[i] * postfix[i]</code>, 也就是除了位置 <code>i</code> 剩餘其他數的乘積</li></ul><p>e.g. <code>nums = [1,2,3,4]</code></p><table><thead><tr><th>nums</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>prefix</td><td>1</td><td>1</td><td>2</td><td>6</td></tr><tr><td>postfix</td><td>24</td><td>12</td><td>4</td><td>1</td></tr><tr><td>nums</td><td>24</td><td>12</td><td>8</td><td>6</td></tr></tbody></table></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">postfix</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            prefix[i] = prefix[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">            postfix[n - i - <span class="number">1</span>] = nums[n - i] * postfix[n - i]; <span class="comment">// 從 n - 2 開始往前</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            nums[i] = prefix[i] * postfix[i];</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ <code>prefix</code>, <code>postfix</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：改進 Solution 1, 將 <code>prefix</code> 直接儲存在 <code>res</code> 中, 然後計算出 <code>postfix</code> 後乘上對應的 <code>prefix</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nums:   [ <span class="number">1</span>,  <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">➔ res: [ <span class="number">1</span>,  <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>] <span class="comment">// prefix 做完</span></span><br><span class="line">➔ res: [<span class="number">24</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">6</span>] <span class="comment">// postfix 做完</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 計算 prefix</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            res[i] = nums[i - <span class="number">1</span>] * res[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> postfix = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            postfix *= nums[i + <span class="number">1</span>];</span><br><span class="line">            res[i] *= postfix;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 撇除要返回的 output array <code>res</code>, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>303. Range Sum Query - Immutable</title>
      <link href="/post/range-sum-query-immutable/"/>
      <url>/post/range-sum-query-immutable/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a></strong></p><p><strong>題意：</strong>給一 array, 多次輸入不同的 <code>left</code> 和 <code>right</code>, 求 array 中從 <code>idx = left</code> 到 <code>idx = right</code> 之和。</p></blockquote><p><img src="https://i.imgur.com/JfAhPC1.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法: 每一次 query 都去計算</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        nums_ = <span class="built_in">move</span>(nums); <span class="comment">// 複製 nums</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">            sum += nums_[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令 <code>query</code> 次數<strong>：</strong><code>m</code> 次, <code>nums</code> 中元素個數<strong>：</strong><code>n</code></p><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ <code>m</code> 次 query，每次 query 需 $O(n)$ 時間</li><li><strong>space：</strong>$O(n)$ ➔ <code>nums_</code></li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Prefix Sum, 事先計算前 <code>i</code> 個數之和</strong></p></blockquote><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sums</span> 紀錄前 i 個數之和</span><br><span class="line"><span class="attribute">nums</span>:<span class="meta"> [-2,  0, 3, -5,  2, -1]</span></span><br><span class="line"><span class="attribute">sums</span>:<span class="meta"> [-2, -2, 1, -4, -2, -3]</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">range</span>(left, right):</span><br><span class="line">    <span class="attribute">if</span>(left == <span class="number">0</span>) sum = sums[right] // e.g. range(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="attribute">else</span> sum = sums[right] - sums[left-<span class="number">1</span>] // e.g. range(<span class="number">2</span>, <span class="number">5</span>) -&gt; -<span class="number">3</span> - (-<span class="number">2</span>) = <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sums = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            sums[i] = sums[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span>) <span class="keyword">return</span> sums[right];</span><br><span class="line">        <span class="keyword">return</span> sums[right] - sums[left<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>令 <code>query</code> 次數<strong>：</strong><code>m</code> 次, <code>nums</code> 中元素個數<strong>：</strong><code>n</code></p><ul><li><strong>time：</strong>$O(m+n)$ ➔ $O(n)$ + $m * O(1)$<ul><li>$O(n)$ : 計算 prefix sum 的時間</li><li>$m * O(1)$ : <code>m</code> 次 query, 每次 query 只需 $O(1)$ 時間</li></ul></li><li><strong>space：</strong>$O(n)$ ➔ <code>sums</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>83. Remove Duplicates from Sorted List</title>
      <link href="/post/remove-duplicates-from-sorted-list/"/>
      <url>/post/remove-duplicates-from-sorted-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> linked list, 刪除 linked list 所有重複的元素, 讓每種元素恰好出現一次。</p></blockquote><p><img src="https://i.imgur.com/06GrNA5.png" alt="Untitled"></p><p><img src="https://i.imgur.com/51OBB5i.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：比較當前 node 和 下一個 node 的 val, 若相同則刪除下一個, 直到下一個的值不同, <code>cur</code> 才前進</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr &amp;&amp; curr-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;val == curr-&gt;next-&gt;val)</span><br><span class="line">                curr-&gt;next = curr-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 linked list 中 $\dfrac{n}{2}$ 個元素</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203. Remove Linked List Elements</title>
      <link href="/post/remove-linked-list-elements/"/>
      <url>/post/remove-linked-list-elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/remove-linked-list-elements">https://leetcode.cn/problems/remove-linked-list-elements</a></strong></p><p><strong>題意：</strong>給一整數 <code>val</code>, 刪除 linked list 中所有 <code>node.val == val</code> 的 node。</p></blockquote><p><img src="https://i.imgur.com/zEGcTRx.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：用 <code>dummy</code> 來指向 head, <code>pre</code> 則記住當前 node 的前一個 node<br>初始化 <code>pre</code> 為 <code>dummy</code>(head 的前一個 node)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dummy 指向 link-list 之 head</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *curr = head, *prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;val == val) <span class="comment">// 當前 node 要刪除</span></span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 不刪除, 往下一個 node 前進, current node 變成前一個 node</span></span><br><span class="line">                prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>190. Reverse Bits</title>
      <link href="/post/reverse-bits/"/>
      <url>/post/reverse-bits/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-bits/">https://leetcode.cn/problems/reverse-bits/</a></strong></p><p><strong>題意：</strong>給一無號整數 <code>n</code>, 請將其二進制進行反轉。</p></blockquote><p><img src="https://i.imgur.com/00zH6zZ.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：每次先把 <code>res</code> 的最右 bit 設為 <code>0</code>（左移一位, 最右 bit 補 0）, 然後取得 <code>n</code> 的最右 bit（對 <code>n</code> 的最右 bit 取 OR）, 做完後將 <code>n</code> 右移一位（捨棄最右 bit）</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">           res &lt;&lt;= <span class="number">1</span>; <span class="comment">// 最右 bit 設 0</span></span><br><span class="line">           res |= (n &amp; <span class="number">1</span>); <span class="comment">// 得到 n 的最右 bit</span></span><br><span class="line">           n &gt;&gt;= <span class="number">1</span>; <span class="comment">// 捨棄最右 bit</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ for loop 只需 $O(32)$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="/post/reverse-linked-list/"/>
      <url>/post/reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></strong></p><p><strong>題意：</strong>反轉 linked-list。</p></blockquote><p><img src="https://i.imgur.com/JN4Kd2M.png" alt="Untitled"></p><p><img src="https://i.imgur.com/l7LB6ZU.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：必須要有 <code>prev</code>, <code>nxt</code> 來記住前一個 node 和 下一個 node</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            nxt = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷整個 linked list</li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100. Same Tree</title>
      <link href="/post/same-tree/"/>
      <url>/post/same-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/same-tree/">https://leetcode.cn/problems/same-tree/</a></strong></p><p><strong>題意：</strong>給兩 BT, 求兩者是否相等。</p></blockquote><p><img src="https://i.imgur.com/0OPiUyV.png" alt="Untitled"></p><p><img src="https://i.imgur.com/tWUqJkw.png" alt="Untitled"></p><p><img src="https://i.imgur.com/7UBxdM2.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：利用 DFS</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少其中一個為 null, 兩個都為 null 時, return true; 其他情況皆為 false</span></span><br><span class="line">        <span class="keyword">if</span>(!(p &amp;&amp; q)) <span class="keyword">return</span> p == q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兩個皆不為 null</span></span><br><span class="line">        <span class="keyword">return</span> (p-&gt;val == q-&gt;val)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(min(m, n))$ ➔ 其中 <code>m</code>、<code>n</code> 分別是兩個 BT 的 node 個數, 被訪問到的 node 個數不超過較小的 BT 之節點個數</li><li><strong>space：</strong>$O(min(m, n))$ ➔ 遞迴深度不超過較小的 BT 之節點個數</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 BFS, 要注意 <code>nullptr</code> 也要 insert 到 queue 中, 否則下方範例會出錯</strong></p><p>e.g. <code>左邊 = [1, null, 2]</code>, <code>右邊 = [1, 2]</code></p><p><img src="https://i.imgur.com/ALYOTs3.png" alt="Untitled"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 至少其中一個為 null, 兩個都為 null 時, return true; 其他情況皆為 false</span></span><br><span class="line">        <span class="keyword">if</span>(!(p &amp;&amp; q)) <span class="keyword">return</span> p == q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兩個皆不為 null</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        queue&lt;TreeNode*&gt; q2;</span><br><span class="line">        q1.<span class="built_in">emplace</span>(p);</span><br><span class="line">        q2.<span class="built_in">emplace</span>(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n1 = q1.<span class="built_in">size</span>(), n2 = q2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(n1 != n2)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; ++i)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur1 = q1.<span class="built_in">front</span>(); q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">auto</span> cur2 = q2.<span class="built_in">front</span>(); q2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 這邊做判斷是為了避免下面出錯</span></span><br><span class="line">                <span class="keyword">if</span>(!(cur1 &amp;&amp; cur2))&#123; <span class="comment">// 其中一個為 null</span></span><br><span class="line">                    <span class="keyword">if</span>(cur1 != cur2) <span class="comment">// 一個是 null, 一個不是</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">// 兩個皆為 null</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur1-&gt;val != cur2-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">add_child</span>(q1, cur1);</span><br><span class="line">                <span class="built_in">add_child</span>(q2, cur2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>() &amp;&amp; q2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// nullptr 也要 insert 到 queue 中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_child</span><span class="params">(queue&lt;TreeNode*&gt;&amp; q, TreeNode* node)</span></span>&#123;</span><br><span class="line">        q.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">        q.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(min(m, n))$ ➔ 其中 <code>m</code>、<code>n</code> 分別是兩個 BT 的 node 個數, 被訪問到的 node 個數不超過較小的 BT 之節點個數</li><li><strong>space：</strong>$O(min(m, n))$ ➔ <code>q</code> 的元素個數不超過較小的 BT 之節點個數</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136. Single Number</title>
      <link href="/post/single-number/"/>
      <url>/post/single-number/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></strong></p><p><strong>題意：</strong>給一非空的 array <code>nums</code>, 當中只有一個數 <code>n1</code> 只出現一次, 找出 <code>n1</code>。</p></blockquote><p><img src="https://i.imgur.com/jhihJCU.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 XOR 的特性, <code>a ^ a = 0</code> 且 <code>0 ^ b = b</code>, 還有交換性<br>e.g. <code>b ^ a ^ b = a ^ (b ^ b) = a ^ 0 = a</code></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需要常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>977. Squares of a Sorted Array</title>
      <link href="/post/squares-of-a-sorted-array/"/>
      <url>/post/squares-of-a-sorted-array/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></strong></p><p><strong>題意：</strong>給一 <code>sorted</code> array <code>nums</code>, 求每個數字平方所組成的 <code>sorted</code> array。</p></blockquote><p><img src="https://i.imgur.com/pOCljbp.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 two pointers</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123; <span class="comment">// res 從後面往前填(先填大的)</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[left]) &gt; <span class="built_in">abs</span>(nums[right]))&#123;</span><br><span class="line">                res[i] = nums[left] * nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i] = nums[right] * nums[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：</strong>$O(n)$ ➔ 扣除返回的 array, 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>572. Subtree of Another Tree</title>
      <link href="/post/subtree-of-another-tree/"/>
      <url>/post/subtree-of-another-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/subtree-of-another-tree/">https://leetcode.cn/problems/subtree-of-another-tree/</a></strong></p><p><strong>題意：</strong>給兩棵 BT <code>root</code> 和 <code>subRoot</code>, 求 <code>subRoot</code> 是否為 <code>root</code> 之 subtree。</p></blockquote><p><img src="https://i.imgur.com/dnJkv2i.png" alt="Untitled"></p><p><img src="https://i.imgur.com/8JvUpJg.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 DFS, 先判斷是否為 Same Tree（可參考 <a href="https://zako945.github.io/post/same-tree/">100. Same Tree</a>）<br>若不是的話, 則遞迴判斷 <code>subRoot</code> 是否為 <code>root</code> 之左子樹 or <code>root</code> 之右子樹</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!subRoot) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// subRoot == null, 則一定為 root 之 subtree</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// root == null &amp;&amp; subRoot != null</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isSameTree</span>(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubtree</span>(root-&gt;left, subRoot)</span><br><span class="line">            || <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(p &amp;&amp; q)) <span class="keyword">return</span> p == q;</span><br><span class="line">        <span class="keyword">return</span> (p-&gt;val == q-&gt;val)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>令 <code>root</code> 的 node 個數為 <code>m</code>, <code>subRoot</code> 的 node 個數為 <code>n</code><br>令 <code>root</code> 的深度為 <code>s</code>, <code>subRoot</code> 的深度為 <code>t</code></strong></p><ul><li><strong>time：</strong>$O(m \cdot n)$ ➔ 對於 root 中的每個 node <code>s</code>, 都以 <code>s</code> 為 root 檢查 n 個 node</li><li><strong>space：</strong>$O(max(s, t))$ ➔ 遞迴最大深度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. Top K Frequent Elements</title>
      <link href="/post/top-k-frequent-elements/"/>
      <url>/post/top-k-frequent-elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和一整數 <code>k</code>, 返回出現頻率前 <code>k</code> 高的元素。可以按任何順序返回答案。</p><p><strong>進階：</strong>請設計 $O(n \cdot log(n))$ time 的演算法, 其中 <code>n</code> 為 <code>nums.size()</code>。</p></blockquote><p><img src="https://i.imgur.com/Niq9pgv.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Heap</strong></p><ul><li>計算每種元素的出現次數</li><li>直接將元素 push 到 min heap <code>pq</code> 中</li><li>若 <code>pq.size() &gt; k</code>, 代表現在 <code>pq</code> 中有 <code>k + 1</code> 個元素, 故把最小的元素給 pop 掉, 讓 <code>pq</code> 元素個數始終保持在 <code>k</code> 個</li><li>此時, <code>pq</code> 中的元素為前 <code>k</code> 大的元素, 將其取出即可</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freqs; <span class="comment">// &#123;num, freq&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 計算每種元素的出現次數</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            ++freqs[num];</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [num, freq] : freqs)&#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(pii&#123;freq, num&#125;);</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k) <span class="comment">// 讓 pq 始終儲存前 k 大的元素</span></span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>time: $O(n \cdot log(k))$ ➔ <code>pq</code> 最多 insert &#x2F; delete <code>n</code> 個點, 每次操作需 $O(log(k))$, 因為 <code>pq</code> 中最多 <code>k + 1</code> 個點, 其中 <code>n</code> 為 <code>nums</code> 的元素個數</li><li>space: $O(n)$ ➔ <code>freqs</code> 最大長度為 <code>n</code>, 而 <code>pq</code> 的最大長度為 <code>k + 1</code>, 其中 <code>n ≥ k</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/post/two-sum/"/>
      <url>/post/two-sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></strong></p><p><strong>題意：</strong>給一 array <code>nums</code> 和一整數 <code>target</code>, 求 <code>nums</code> 中兩數和剛好為 <code>target</code> 之 index, 假設每一種 <code>target</code> 只會對應到一組解。</p><p><strong>注意：</strong>同一個元素不可重複使用, 可按照任意順序返回。</p></blockquote><p><img src="https://i.imgur.com/zKI5XRV.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 hash table, 由於題目保證一定有解, 因此對 <code>nums[i]</code> 而言, 先去 hash table 中找 <code>target - nums[i]</code> 是否存在</strong></p><ul><li>若存在, 則直接返回</li><li>否則, 將 <code>nums[i]</code> 還有其 <code>index</code> 加入到 hash table 中</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap; <span class="comment">// 紀錄 &#123;val, idx&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="type">int</span> search = target - nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// umap 中有找到 remain, 則直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(umap.<span class="built_in">find</span>(search) != umap.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> &#123;umap[search], i&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// umap 中沒找到 remain, 則新增 nums[i] 到 umap 中</span></span><br><span class="line">            umap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>nums</code></li><li><strong>space：$O(n)$</strong> ➔ <code>umap</code> 的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167. Two Sum II - Input Array Is Sorted</title>
      <link href="/post/two-sum-ii-input-array-is-sorted/"/>
      <url>/post/two-sum-ii-input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/</a></strong></p><p><strong>題意：</strong>給一 index 從 <code>1</code> 開始的整數 array <code>numbers</code>, 該 array 已按照非遞減順序排列, 請從 <code>numbers</code> 中找出相加等於 <code>target</code> 的兩數之 index <code>index1</code>、<code>index2</code>, 其中 <code>1 ≤ index1 ≤ index2 ≤ numbers.length</code>。</p><p>假設每一種 <code>target</code> 只會對應到一組解, 且同一個元素不可重複使用。</p><p>請設計 $O(1)$ space 的演算法。</p></blockquote><p><img src="https://i.imgur.com/DVvXBxC.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：概念同 <a href="https://zako945.github.io/post/3sum/">15. 3Sum</a>, 由於 array 已排序, 故直接使用 Two Pointers 即可</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                --right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>numbers</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242. Valid Anagram</title>
      <link href="/post/valid-anagram/"/>
      <url>/post/valid-anagram/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a></strong></p><p><strong>題意：</strong>給兩 string <code>s</code> 和 <code>t</code>, 返回 <code>t</code> 是否為 <code>s</code> 的字母異位詞(Anagram) 則返回 <code>true</code>, 其中 <code>s</code> 和 <code>t</code> 僅由<strong>小寫</strong>字母所組成。</p><p><strong>字母異位詞 (Anagram) 定義：</strong>若 <code>s</code> 和 <code>t</code> 中每個字母的出現次數都相同, 則 <code>s</code> 和 <code>t</code> 互為字母異位詞。</p><p><strong>進階：</strong>若 input string 包含 Unicode char, 你要如何調整你的解法？</p></blockquote><p><img src="https://i.imgur.com/x5ZFFwG.png" alt="Untitled"></p><h2 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1：</strong></h2><blockquote><p><strong>想法：將 <code>s</code>、<code>t</code> 進行排序, 若排序後 <code>s</code>、<code>t</code> 相等, 就代表為 anagram</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n \cdot log(n))$ ➔ sorting</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul><h2 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2：</strong></h2><blockquote><p><strong>想法：利用 Array 來記錄每個字母的出現次數, 若 <code>s</code> 和 <code>t</code> 為 anagram, 則 <code>s 中每個字母的出現頻率 - t 中每個字母的出現頻率</code> 後, 每個字母的出現頻率應皆為 0</strong></p><p>e.g. <code>s = &quot;abc&quot;</code>, <code>t = &quot;cba&quot;</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判斷 s、t 的長度是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">freqs</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">            ++freqs[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 s 和 t 長度相等的情況下, 若不為 anagram, 則必存在一 char 相減後的 freq &lt; 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : t)</span><br><span class="line">            <span class="keyword">if</span>(--freqs[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code></li><li><strong>space：</strong>$O(1)$ ➔ $O(26)$, 只需常數空間</li></ul><h2 id="Solution-3："><a href="#Solution-3：" class="headerlink" title="Solution 3："></a><strong>Solution 3：</strong></h2><blockquote><p><strong>想法：利用 hash table, 概念同 Solution 1, 但是 Solution 1 只能解決 <code>s</code> 和 <code>t</code> 為小寫字母的問題, Solution 2 可解決 input string 包含 Unicode char 的問題</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freqs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">            ++freqs[ch];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 s 和 t 長度相等的情況下, 若不為 anagram, 則必存在一 char 相減後的 freq &lt; 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : t)</span><br><span class="line">            <span class="keyword">if</span>(--freqs[ch] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code> 和 <code>t</code></li><li><strong>space：</strong>$O(S)$ ➔ $S$ 為 <code>s</code> 和 <code>t</code> union 後的 char set 之元素個數, 本題的 <code>S = 26</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="/post/valid-palindrome/"/>
      <url>/post/valid-palindrome/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-palindrome/">https://leetcode.cn/problems/valid-palindrome/</a></strong></p><p><strong>題意：</strong>給一 string <code>s</code>, 將其大寫轉換成小寫、並移除非字母和數字的 char, 返回轉換後是否為迴文。</p></blockquote><p><img src="https://i.imgur.com/9LPedjt.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Two pointers, 若當前的 char 不為數字 or 字母則跳過, 直到 <code>left</code>、<code>right</code> 相會。判斷式為 <code>left &lt; right</code> 即可, 因為 <code>left == right</code> 時 <code>s[left]</code>、<code>s[right]</code> 必相等, 因此不用判斷</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left]))</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right]))</span><br><span class="line">                --right;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 ptr</span></span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ while loop 遍歷 <code>s</code></li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. Valid Parentheses</title>
      <link href="/post/valid-parentheses/"/>
      <url>/post/valid-parentheses/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></strong></p><p><strong>題意：</strong>給一只包含 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、<code>&#39;&#123;&#39;</code>、<code>&#39;&#125;&#39;</code>、<code>&#39;[&#39;</code>、<code>&#39;]&#39;</code> 的 string <code>s</code>, 判斷 <code>s</code> 是否有效。</p><p>有效的定義如下：</p><ul><li>左括號必須有相同類型的右括號閉合</li><li>左括號必須以正確的順序閉合</li><li>每個右括號都有一個對應的相同類型之左括號</li></ul></blockquote><p><img src="https://i.imgur.com/1vJ8lkJ.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：利用 Stack</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stk.<span class="built_in">emplace</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>(); <span class="comment">// 若 stack 為空, 則代表有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; pairs = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(n)$ ➔ 遍歷 <code>s</code>, 其中 <code>n</code> 為 <code>s</code> 的長度</li><li><strong>space：</strong>$O(n)$ ➔ stack 中的元素個數不超過 <code>n</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Google </tag>
            
            <tag> Microsoft </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku</title>
      <link href="/post/valid-sudoku/"/>
      <url>/post/valid-sudoku/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>題目網址：<a href="https://leetcode.cn/problems/valid-sudoku/">https://leetcode.cn/problems/valid-sudoku/</a></strong></p><p><strong>題意：</strong>判斷 <code>9 x 9</code> 數獨是否有效, 根據以下規則, 判斷已填入的數字是否有效即可。</p><ul><li>數字 <code>1 - 9</code> 在每一行只能出現一次</li><li>數字 <code>1 - 9</code> 在每一列只能出現一次</li><li>數字 <code>1 - 9</code> 在每一個 <code>3 x 3</code> 九宮格中只能出現一次</li></ul><p>空白格以 <code>&#39;.&#39;</code> 表示。</p></blockquote><p><img src="https://i.imgur.com/CZidDFe.png" alt="Untitled"></p><p><img src="https://i.imgur.com/TiCSPjx.png" alt="Untitled"></p><h2 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a><strong>Solution：</strong></h2><blockquote><p><strong>想法：一旦 <code>board[r][c]</code> 不為 <code>&#39;.&#39;</code>, 就去判斷該 row、col、block 是否有重複的 char</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[r][c] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// 跳過 &#x27;.&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isValidRow</span>(board, r, c)</span><br><span class="line">                || !<span class="built_in">isValidCol</span>(board, r, c)</span><br><span class="line">                || !<span class="built_in">isValidBlock</span>(board, r, c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidRow</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span>&amp; r, <span class="type">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">        <span class="type">char</span> ch = board[r][c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == col) <span class="keyword">continue</span>; <span class="comment">// 跳過自己</span></span><br><span class="line">            <span class="keyword">if</span>(ch == board[r][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidCol</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span>&amp; r, <span class="type">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">        <span class="type">char</span> ch = board[r][c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r == row) <span class="keyword">continue</span>; <span class="comment">// 跳過自己</span></span><br><span class="line">            <span class="keyword">if</span>(ch == board[row][c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBlock</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span>&amp; r, <span class="type">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">        <span class="type">char</span> ch = board[r][c];</span><br><span class="line">        <span class="type">int</span> blockR = (r / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> blockC = (c / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k)&#123;</span><br><span class="line">            <span class="type">int</span> row = blockR + (k / <span class="number">3</span>);</span><br><span class="line">            <span class="type">int</span> col = blockC + (k % <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span>(r == row &amp;&amp; c == col) <span class="keyword">continue</span>; <span class="comment">// 跳過自己</span></span><br><span class="line">            <span class="keyword">if</span>(ch == board[row][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>time：</strong>$O(1)$ ➔ 每個 <code>board[r][c]</code> 判斷該 row、col、block 是否重複皆需 $O(9)$, 故總共需 $O((9 * 9) \cdot (3 * 9))$</li><li><strong>space：</strong>$O(1)$ ➔ 只需常數空間</li></ul>]]></content>
      
      
      <categories>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
